{"version":3,"sources":["/home/subham/Documents/Projects/NodeJS/Angular9/SlickGrid/node_modules/angular-slickgrid/fesm2015/angular-slickgrid.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sHA2QE;iCAC+B,AAE9B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mHA4LD;gCAC8B,AAE7B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mHAmkCD;gCAC8B,AAE7B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sHAycD;iCAC+B,AAE9B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uGAoTD;4BAC0B,AAEzB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uGAsEF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gHA+JC;+BAC6B,AAE5B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4HA4BD;mCACiC,AAEhC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gKA4JD;+CAC6C,AAE5C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mHAsID;gCAC8B,AAE7B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2IA+DD;wCACsC,AAErC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+HAgFD;oCACkC,AAEjC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4HAmTD;mCACiC,AAEhC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8IA6DD;yCACuC,AAEtC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sHAqiBD;iCAC+B,AAE9B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6GAg5EF;;;;;;;;;;;;;;;;;;;;;;;uGAqBC;4BAC0B,AAEzB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uGAkjBD;4BAC0B,AAEzB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iGAiRF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mHAsVC;gCAC8B,AAE7B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0JAgCD;6CAC2C,AAE1C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+HA6CD;oCACkC,AAEjC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yHAwUD;kCACgC,AAE/B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kIAkTD;qCACmC,AAElC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qIA2DD;sCACoC,AAEnC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+HA2BD;oCACkC,AAEjC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gHAwXD;+BAC6B,AAE5B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0GA+oBF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gHAsoBC;+BAC6B,AAE5B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gHAkEF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gHA+ZC;+BAC6B,AAE5B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iGAqlBD;0BACwB,AAEvB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0GAwNF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2IA4GC;wCACsC,AAErC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mHA4UD;gCAC8B,AAE7B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wFAghGD;;;;;uCAKqC,AAKpC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4HA4wBD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wCAiFsC,AAuCrC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAoCD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiByB","file":"angular-slickgrid.js","sourcesContent":["import { __decorate, __metadata, __param, __awaiter } from 'tslib';\nimport { Injectable, ComponentFactoryResolver, ApplicationRef, Injector, Optional, Input, Component, EventEmitter, Output, Inject, ChangeDetectorRef, ElementRef, NgModule } from '@angular/core';\nimport { isObservable, iif, EMPTY, Observable, Subject } from 'rxjs';\nimport { takeUntil, first } from 'rxjs/operators';\nimport { TranslateService, TranslateModule } from '@ngx-translate/core';\nimport * as moment_ from 'moment-mini';\nimport { Workbook, Worksheet, Builder } from 'excel-builder-webpacker';\nimport { TextEncoder } from 'text-encoding-utf-8';\nimport 'slickgrid/plugins/slick.cellrangedecorator';\nimport 'slickgrid/plugins/slick.cellrangeselector';\nimport 'slickgrid/plugins/slick.cellselectionmodel';\nimport * as isequal_ from 'lodash.isequal';\nimport Flatpickr from 'flatpickr';\nimport * as DOMPurify_ from 'dompurify';\nimport 'jquery-ui-dist/jquery-ui';\nimport 'slickgrid/lib/jquery.event.drag-2.3.0';\nimport 'slickgrid/slick.core';\nimport 'slickgrid/slick.grid';\nimport 'slickgrid/slick.dataview';\nimport { CommonModule } from '@angular/common';\n\nvar CaseType;\r\n(function (CaseType) {\r\n    /** For example: camelCase */\r\n    CaseType[CaseType[\"camelCase\"] = 0] = \"camelCase\";\r\n    /** For example: PascalCase */\r\n    CaseType[CaseType[\"pascalCase\"] = 1] = \"pascalCase\";\r\n    /** For example: snake_case */\r\n    CaseType[CaseType[\"snakeCase\"] = 2] = \"snakeCase\";\r\n    /** For example: kebab-case */\r\n    CaseType[CaseType[\"kebabCase\"] = 3] = \"kebabCase\";\r\n})(CaseType || (CaseType = {}));\n\nvar DelimiterType;\r\n(function (DelimiterType) {\r\n    DelimiterType[\"colon\"] = \":\";\r\n    DelimiterType[\"comma\"] = \",\";\r\n    DelimiterType[\"equalSign\"] = \"=\";\r\n    DelimiterType[\"pipe\"] = \"|\";\r\n    DelimiterType[\"semicolon\"] = \";\";\r\n    DelimiterType[\"space\"] = \" \";\r\n    DelimiterType[\"tab\"] = \"\\t\";\r\n    DelimiterType[\"doubleColon\"] = \"::\";\r\n    DelimiterType[\"doublePipe\"] = \"||\";\r\n    DelimiterType[\"doubleSemicolon\"] = \";;\";\r\n})(DelimiterType || (DelimiterType = {}));\n\nvar EmitterType;\r\n(function (EmitterType) {\r\n    EmitterType[\"local\"] = \"local\";\r\n    EmitterType[\"remote\"] = \"remote\";\r\n})(EmitterType || (EmitterType = {}));\n\n/** List of available SlickGrid Extensions (Controls & Plugins) */\r\nvar ExtensionName;\r\n(function (ExtensionName) {\r\n    ExtensionName[\"autoTooltip\"] = \"autoTooltip\";\r\n    ExtensionName[\"cellExternalCopyManager\"] = \"cellExternalCopyManager\";\r\n    ExtensionName[\"cellMenu\"] = \"cellMenu\";\r\n    ExtensionName[\"checkboxSelector\"] = \"checkboxSelector\";\r\n    ExtensionName[\"columnPicker\"] = \"columnPicker\";\r\n    ExtensionName[\"contextMenu\"] = \"contextMenu\";\r\n    ExtensionName[\"draggableGrouping\"] = \"draggableGrouping\";\r\n    ExtensionName[\"groupItemMetaProvider\"] = \"groupItemMetaProvider\";\r\n    ExtensionName[\"gridMenu\"] = \"gridMenu\";\r\n    ExtensionName[\"headerButton\"] = \"headerButton\";\r\n    ExtensionName[\"headerMenu\"] = \"headerMenu\";\r\n    ExtensionName[\"noname\"] = \"noname\";\r\n    ExtensionName[\"rowDetailView\"] = \"rowDetailView\";\r\n    ExtensionName[\"rowMoveManager\"] = \"rowMoveManager\";\r\n    ExtensionName[\"rowSelection\"] = \"rowSelection\";\r\n})(ExtensionName || (ExtensionName = {}));\n\nvar FieldType;\r\n(function (FieldType) {\r\n    /** unknown type */\r\n    FieldType[FieldType[\"unknown\"] = 0] = \"unknown\";\r\n    /** string type */\r\n    FieldType[FieldType[\"string\"] = 1] = \"string\";\r\n    /** boolean type (true/false) */\r\n    FieldType[FieldType[\"boolean\"] = 2] = \"boolean\";\r\n    /** integer number type (1,2,99) */\r\n    FieldType[FieldType[\"integer\"] = 3] = \"integer\";\r\n    /** float number (with decimal) type */\r\n    FieldType[FieldType[\"float\"] = 4] = \"float\";\r\n    /** number includes Integer and Float */\r\n    FieldType[FieldType[\"number\"] = 5] = \"number\";\r\n    /** new Date(), javascript Date object */\r\n    FieldType[FieldType[\"date\"] = 6] = \"date\";\r\n    /** Format: 'YYYY-MM-DD' => 2001-02-28 */\r\n    FieldType[FieldType[\"dateIso\"] = 7] = \"dateIso\";\r\n    /** Format: 'YYYY-MM-DDTHH:mm:ss.SSSZ' => 2001-02-28T14:00:00.123Z */\r\n    FieldType[FieldType[\"dateUtc\"] = 8] = \"dateUtc\";\r\n    /** new Date(), javacript Date Object with Time */\r\n    FieldType[FieldType[\"dateTime\"] = 9] = \"dateTime\";\r\n    /** Format: 'YYYY-MM-DD HH:mm:ss' => 2001-02-28 14:01:01 */\r\n    FieldType[FieldType[\"dateTimeIso\"] = 10] = \"dateTimeIso\";\r\n    /** Format: 'YYYY-MM-DD h:mm:ss a' => 2001-02-28 11:01:01 pm */\r\n    FieldType[FieldType[\"dateTimeIsoAmPm\"] = 11] = \"dateTimeIsoAmPm\";\r\n    /** Format: 'YYYY-MM-DD h:mm:ss A' => 2001-02-28 11:01:01 PM */\r\n    FieldType[FieldType[\"dateTimeIsoAM_PM\"] = 12] = \"dateTimeIsoAM_PM\";\r\n    /** Format: 'YYYY-MM-DD HH:mm' => 2001-02-28 14:01 */\r\n    FieldType[FieldType[\"dateTimeShortIso\"] = 13] = \"dateTimeShortIso\";\r\n    /** Format (Euro): 'DD/MM/YYYY' => 28/02/2001 */\r\n    FieldType[FieldType[\"dateEuro\"] = 14] = \"dateEuro\";\r\n    /** Format (Euro): 'D/M/YY' => 28/2/12 */\r\n    FieldType[FieldType[\"dateEuroShort\"] = 15] = \"dateEuroShort\";\r\n    /** Format (Euro): 'DD/MM/YYYY HH:mm' => 28/02/2001 13:01 */\r\n    FieldType[FieldType[\"dateTimeShortEuro\"] = 16] = \"dateTimeShortEuro\";\r\n    /** Format (Euro): 'DD/MM/YYYY HH:mm:ss' => 02/28/2001 13:01:01 */\r\n    FieldType[FieldType[\"dateTimeEuro\"] = 17] = \"dateTimeEuro\";\r\n    /** Format (Euro): 'DD/MM/YYYY hh:mm:ss a' => 28/02/2001 11:01:01 pm */\r\n    FieldType[FieldType[\"dateTimeEuroAmPm\"] = 18] = \"dateTimeEuroAmPm\";\r\n    /** Format (Euro): 'DD/MM/YYYY hh:mm:ss A' => 28/02/2001 11:01:01 PM */\r\n    FieldType[FieldType[\"dateTimeEuroAM_PM\"] = 19] = \"dateTimeEuroAM_PM\";\r\n    /** Format (Euro): 'D/M/YY H:m:s' => 28/2/14 14:1:2 */\r\n    FieldType[FieldType[\"dateTimeEuroShort\"] = 20] = \"dateTimeEuroShort\";\r\n    /** Format (Euro): 'D/M/YY h:m:s a' => 28/2/14 1:2:10 pm */\r\n    FieldType[FieldType[\"dateTimeEuroShortAmPm\"] = 21] = \"dateTimeEuroShortAmPm\";\r\n    /** Format (Euro): 'D/M/YY h:m:s A' => 28/2/14 14:1:1 PM */\r\n    FieldType[FieldType[\"dateTimeEuroShortAM_PM\"] = 22] = \"dateTimeEuroShortAM_PM\";\r\n    /** Format: 'MM/DD/YYYY' => 02/28/2001 */\r\n    FieldType[FieldType[\"dateUs\"] = 23] = \"dateUs\";\r\n    /** Format: 'M/D/YY' => 2/28/12 */\r\n    FieldType[FieldType[\"dateUsShort\"] = 24] = \"dateUsShort\";\r\n    /** Format: 'MM/DD/YYYY HH:mm' => 02/28/2001 13:01 */\r\n    FieldType[FieldType[\"dateTimeShortUs\"] = 25] = \"dateTimeShortUs\";\r\n    /** Format: 'MM/DD/YYYY HH:mm:ss' => 02/28/2001 13:01:01 */\r\n    FieldType[FieldType[\"dateTimeUs\"] = 26] = \"dateTimeUs\";\r\n    /** Format: 'MM/DD/YYYY hh:mm:ss a' => 02/28/2001 11:01:01 pm */\r\n    FieldType[FieldType[\"dateTimeUsAmPm\"] = 27] = \"dateTimeUsAmPm\";\r\n    /** Format: 'MM/DD/YYYY hh:mm:ss A' => 02/28/2001 11:01:01 PM */\r\n    FieldType[FieldType[\"dateTimeUsAM_PM\"] = 28] = \"dateTimeUsAM_PM\";\r\n    /** Format: 'M/D/YY H:m:s' => 2/28/14 14:1:2 */\r\n    FieldType[FieldType[\"dateTimeUsShort\"] = 29] = \"dateTimeUsShort\";\r\n    /** Format: 'M/D/YY h:m:s a' => 2/28/14 1:2:10 pm */\r\n    FieldType[FieldType[\"dateTimeUsShortAmPm\"] = 30] = \"dateTimeUsShortAmPm\";\r\n    /** Format: 'M/D/YY h:m:s A' => 2/28/14 14:1:1 PM */\r\n    FieldType[FieldType[\"dateTimeUsShortAM_PM\"] = 31] = \"dateTimeUsShortAM_PM\";\r\n    /** complex object with various properties */\r\n    FieldType[FieldType[\"object\"] = 32] = \"object\";\r\n})(FieldType || (FieldType = {}));\n\nvar FileType;\r\n(function (FileType) {\r\n    FileType[\"csv\"] = \"csv\";\r\n    FileType[\"doc\"] = \"doc\";\r\n    FileType[\"docx\"] = \"docx\";\r\n    FileType[\"pdf\"] = \"pdf\";\r\n    FileType[\"txt\"] = \"txt\";\r\n    FileType[\"xls\"] = \"xls\";\r\n    FileType[\"xlsx\"] = \"xlsx\";\r\n})(FileType || (FileType = {}));\n\nvar FilterMultiplePassType;\r\n(function (FilterMultiplePassType) {\r\n    FilterMultiplePassType[\"merge\"] = \"merge\";\r\n    FilterMultiplePassType[\"chain\"] = \"chain\";\r\n})(FilterMultiplePassType || (FilterMultiplePassType = {}));\n\nvar GridStateType;\r\n(function (GridStateType) {\r\n    GridStateType[\"columns\"] = \"columns\";\r\n    GridStateType[\"filter\"] = \"filter\";\r\n    GridStateType[\"pagination\"] = \"pagination\";\r\n    GridStateType[\"sorter\"] = \"sorter\";\r\n    GridStateType[\"rowSelection\"] = \"rowSelection\";\r\n})(GridStateType || (GridStateType = {}));\n\nvar KeyCode;\r\n(function (KeyCode) {\r\n    KeyCode[KeyCode[\"BACKSPACE\"] = 8] = \"BACKSPACE\";\r\n    KeyCode[KeyCode[\"DELETE\"] = 46] = \"DELETE\";\r\n    KeyCode[KeyCode[\"DOWN\"] = 40] = \"DOWN\";\r\n    KeyCode[KeyCode[\"END\"] = 35] = \"END\";\r\n    KeyCode[KeyCode[\"ENTER\"] = 13] = \"ENTER\";\r\n    KeyCode[KeyCode[\"ESCAPE\"] = 27] = \"ESCAPE\";\r\n    KeyCode[KeyCode[\"HOME\"] = 36] = \"HOME\";\r\n    KeyCode[KeyCode[\"INSERT\"] = 45] = \"INSERT\";\r\n    KeyCode[KeyCode[\"LEFT\"] = 37] = \"LEFT\";\r\n    KeyCode[KeyCode[\"PAGE_DOWN\"] = 34] = \"PAGE_DOWN\";\r\n    KeyCode[KeyCode[\"PAGE_UP\"] = 33] = \"PAGE_UP\";\r\n    KeyCode[KeyCode[\"RIGHT\"] = 39] = \"RIGHT\";\r\n    KeyCode[KeyCode[\"TAB\"] = 9] = \"TAB\";\r\n    KeyCode[KeyCode[\"UP\"] = 38] = \"UP\";\r\n    KeyCode[KeyCode[\"SPACE\"] = 32] = \"SPACE\";\r\n})(KeyCode || (KeyCode = {}));\n\nvar OperatorType;\r\n(function (OperatorType) {\r\n    /** value is empty */\r\n    OperatorType[\"empty\"] = \"\";\r\n    /** value contains x */\r\n    OperatorType[\"contains\"] = \"Contains\";\r\n    /** value not contains x (inversed of contains) */\r\n    OperatorType[\"notContains\"] = \"Not_Contains\";\r\n    /** value less than x */\r\n    OperatorType[\"lessThan\"] = \"LT\";\r\n    /** value less than or equal to x */\r\n    OperatorType[\"lessThanOrEqual\"] = \"LE\";\r\n    /** value greater than x */\r\n    OperatorType[\"greaterThan\"] = \"GT\";\r\n    /** value great than or equal to x */\r\n    OperatorType[\"greaterThanOrEqual\"] = \"GE\";\r\n    /** value not equal to x */\r\n    OperatorType[\"notEqual\"] = \"NE\";\r\n    /** value equal to x */\r\n    OperatorType[\"equal\"] = \"EQ\";\r\n    /** String ends with value */\r\n    OperatorType[\"endsWith\"] = \"EndsWith\";\r\n    /**\r\n     * Search in an inclusive range of values that is greater or equal to search value 1 and is smaller or equal to value 2\r\n     * For example the search term of \"5..10\" will return any values that are greater or equal to 5 and smaller or equal to 10\r\n     */\r\n    OperatorType[\"rangeInclusive\"] = \"RangeInclusive\";\r\n    /**\r\n     * Search in an inclusive range of values that is greater then search value 1 and is smaller then value 2\r\n     * For example the search term of \"5..10\" will return any values that is greater then 5 and smaller then 10\r\n     */\r\n    OperatorType[\"rangeExclusive\"] = \"RangeExclusive\";\r\n    /** String starts with value */\r\n    OperatorType[\"startsWith\"] = \"StartsWith\";\r\n    /** Find an equal match inside a collection */\r\n    OperatorType[\"in\"] = \"IN\";\r\n    /** Inverse (Not In) of an equal match inside a collection */\r\n    OperatorType[\"notIn\"] = \"NOT_IN\";\r\n    /**\r\n     * Find a substring contained inside a collection\r\n     * For example, this condition would return True with \"IN_CONTAINS\":: value='Task2,Task3', collection=['Task2','Task3']\r\n     * This would have returned False with \"IN\" because 'Task2' does not equal 'Task2,Task3'. However 'Task2' is contained in 'Task2,Task3'\r\n     */\r\n    OperatorType[\"inContains\"] = \"IN_CONTAINS\";\r\n    /** Inversed (Not In) of substring contained inside a collection */\r\n    OperatorType[\"notInContains\"] = \"NOT_IN_CONTAINS\";\r\n})(OperatorType || (OperatorType = {}));\n\nvar SortDirection;\r\n(function (SortDirection) {\r\n    SortDirection[\"asc\"] = \"asc\";\r\n    SortDirection[\"ASC\"] = \"ASC\";\r\n    SortDirection[\"desc\"] = \"desc\";\r\n    SortDirection[\"DESC\"] = \"DESC\";\r\n})(SortDirection || (SortDirection = {}));\n\nvar SortDirectionNumber;\r\n(function (SortDirectionNumber) {\r\n    SortDirectionNumber[SortDirectionNumber[\"asc\"] = 1] = \"asc\";\r\n    SortDirectionNumber[SortDirectionNumber[\"desc\"] = -1] = \"desc\";\r\n    SortDirectionNumber[SortDirectionNumber[\"neutral\"] = 0] = \"neutral\";\r\n})(SortDirectionNumber || (SortDirectionNumber = {}));\n\nlet AngularUtilService = class AngularUtilService {\r\n    constructor(compFactoryResolver, appRef, injector) {\r\n        this.compFactoryResolver = compFactoryResolver;\r\n        this.appRef = appRef;\r\n        this.injector = injector;\r\n    }\r\n    // ref https://hackernoon.com/angular-pro-tip-how-to-dynamically-create-components-in-body-ba200cc289e6\r\n    createAngularComponent(component) {\r\n        // Create a component reference from the component\r\n        const componentRef = this.compFactoryResolver\r\n            .resolveComponentFactory(component)\r\n            .create(this.injector);\r\n        // Attach component to the appRef so that it's inside the ng component tree\r\n        this.appRef.attachView(componentRef.hostView);\r\n        // Get DOM element from component\r\n        let domElem;\r\n        const viewRef = componentRef.hostView;\r\n        if (viewRef && Array.isArray(viewRef.rootNodes) && viewRef.rootNodes[0]) {\r\n            domElem = viewRef.rootNodes[0];\r\n        }\r\n        return { componentRef, domElement: domElem };\r\n    }\r\n    // ref https://hackernoon.com/angular-pro-tip-how-to-dynamically-create-components-in-body-ba200cc289e6\r\n    createAngularComponentAppendToDom(component, targetElement, clearTargetContent = false) {\r\n        const componentOutput = this.createAngularComponent(component);\r\n        // Append DOM element to the HTML element specified\r\n        if (targetElement && targetElement.appendChild) {\r\n            if (clearTargetContent && targetElement.innerHTML) {\r\n                targetElement.innerHTML = '';\r\n            }\r\n            targetElement.appendChild(componentOutput.domElement);\r\n        }\r\n        else {\r\n            document.body.appendChild(componentOutput.domElement); // when no target provided, we'll simply add it to the HTML Body\r\n        }\r\n        return componentOutput;\r\n    }\r\n};\r\nAngularUtilService = __decorate([\r\n    Injectable(),\r\n    __metadata(\"design:paramtypes\", [ComponentFactoryResolver,\r\n        ApplicationRef,\r\n        Injector])\r\n], AngularUtilService);\n\nconst main = {};\r\n/** Execute the Backend Processes Callback, that could come from an Observable or a Promise callback */\r\nmain.executeBackendProcessesCallback = function exeBackendProcessesCallback(startTime, processResult, backendApi, totalItems) {\r\n    const endTime = new Date();\r\n    // define what our internal Post Process callback, only available for GraphQL Service for now\r\n    // it will basically refresh the Dataset & Pagination removing the need for the user to always create his own PostProcess every time\r\n    if (processResult && backendApi && backendApi.internalPostProcess) {\r\n        backendApi.internalPostProcess(processResult);\r\n    }\r\n    // send the response process to the postProcess callback\r\n    if (backendApi.postProcess) {\r\n        if (processResult instanceof Object) {\r\n            processResult.metrics = {\r\n                startTime,\r\n                endTime,\r\n                executionTime: endTime.valueOf() - startTime.valueOf(),\r\n                itemCount: totalItems,\r\n                totalItemCount: totalItems\r\n            };\r\n            // @deprecated\r\n            processResult.statistics = processResult.metrics;\r\n        }\r\n        backendApi.postProcess(processResult);\r\n    }\r\n};\r\n/** On a backend service api error, we will run the \"onError\" if there is 1 provided or just throw back the error when nothing is provided */\r\nmain.onBackendError = function backendError(e, backendApi) {\r\n    if (backendApi && backendApi.onError) {\r\n        backendApi.onError(e);\r\n    }\r\n    else {\r\n        throw e;\r\n    }\r\n};\r\n/**\r\n * Execute the backend callback, which are mainly the \"process\" & \"postProcess\" methods.\r\n * Also note that \"preProcess\" was executed prior to this callback\r\n */\r\nmain.executeBackendCallback = function exeBackendCallback(backendServiceApi, query, args, startTime, totalItems, emitActionChangedCallback, httpCancelRequests$) {\r\n    if (backendServiceApi) {\r\n        // emit an onFilterChanged event when it's not called by a clear filter\r\n        if (args && !args.clearFilterTriggered && !args.clearSortTriggered) {\r\n            emitActionChangedCallback(EmitterType.remote);\r\n        }\r\n        // the processes can be Observables (like HttpClient) or Promises\r\n        const process = backendServiceApi.process(query);\r\n        if (process instanceof Promise && process.then) {\r\n            process.then((processResult) => main.executeBackendProcessesCallback(startTime, processResult, backendServiceApi, totalItems))\r\n                .catch((error) => main.onBackendError(error, backendServiceApi));\r\n        }\r\n        else if (isObservable(process)) {\r\n            // this will abort any previous HTTP requests, that were previously hooked in the takeUntil, before sending a new request\r\n            if (isObservable(httpCancelRequests$)) {\r\n                httpCancelRequests$.next();\r\n            }\r\n            process\r\n                // the following takeUntil, will potentially be used later to cancel any pending http request (takeUntil another rx, that would be httpCancelRequests$, completes)\r\n                // but make sure the observable is actually defined with the iif condition check before piping it to the takeUntil\r\n                .pipe(takeUntil(iif(() => isObservable(httpCancelRequests$), httpCancelRequests$, EMPTY)))\r\n                .subscribe((processResult) => main.executeBackendProcessesCallback(startTime, processResult, backendServiceApi, totalItems), (error) => main.onBackendError(error, backendServiceApi));\r\n        }\r\n    }\r\n};\r\n/** Refresh the dataset through the Backend Service */\r\nmain.refreshBackendDataset = function refreshBackend(gridOptions) {\r\n    let query = '';\r\n    const backendApi = gridOptions && gridOptions.backendServiceApi;\r\n    if (!backendApi || !backendApi.service || !backendApi.process) {\r\n        throw new Error(`BackendServiceApi requires at least a \"process\" function and a \"service\" defined`);\r\n    }\r\n    if (backendApi.service) {\r\n        query = backendApi.service.buildQuery();\r\n    }\r\n    if (query && query !== '') {\r\n        // keep start time & end timestamps & return it after process execution\r\n        const startTime = new Date();\r\n        if (backendApi.preProcess) {\r\n            backendApi.preProcess();\r\n        }\r\n        const totalItems = gridOptions && gridOptions.pagination && gridOptions.pagination.totalItems;\r\n        main.executeBackendCallback(backendApi, query, null, startTime, totalItems);\r\n    }\r\n};\r\n// export all methods & the main so that it works in all modules but also in Jest unit test\r\n// export every method as independent constant so that it still works whenever this is used in other modules\r\nconst executeBackendProcessesCallback = main.executeBackendProcessesCallback;\r\nconst onBackendError = main.onBackendError;\r\nconst executeBackendCallback = main.executeBackendCallback;\r\nconst refreshBackendDataset = main.refreshBackendDataset;\n\n// Boostrap dropdown service\r\nlet BsDropDownService = class BsDropDownService {\r\n    constructor(angularUtilService) {\r\n        this.angularUtilService = angularUtilService;\r\n    }\r\n    get domElement() {\r\n        return this._domElement;\r\n    }\r\n    get domContainerElement() {\r\n        return this._domContainerElement;\r\n    }\r\n    get gridViewport() {\r\n        return $('.slick-viewport');\r\n    }\r\n    dispose() {\r\n        if (this._domElement && this._domElement.remove) {\r\n            this._domElement.remove();\r\n        }\r\n    }\r\n    dropContainerShow() {\r\n        if (this._domContainerElement && this._domContainerElement.show) {\r\n            this._domContainerElement.show();\r\n        }\r\n    }\r\n    render(dropdownParams) {\r\n        return new Promise((resolve) => {\r\n            const { component, args, parent, offsetTop, offsetLeft, offsetDropupBottom } = dropdownParams;\r\n            const cell = args.cell;\r\n            const row = args.row;\r\n            this._domContainerElement = $(`#myDrop-r${row}-c${cell}`);\r\n            if (this._domContainerElement) {\r\n                // hide the dropdown we created as a formatter Component, we'll redisplay it later\r\n                const cellPos = this._domContainerElement.offset();\r\n                const componentOutput = this.angularUtilService.createAngularComponent(component);\r\n                const componentInstance = componentOutput && componentOutput.componentRef && componentOutput.componentRef.instance;\r\n                if (componentInstance) {\r\n                    const myDropId = componentInstance.dropdownId || 'myDrop';\r\n                    const dropDownToggleId = componentInstance.dropDownToggleId || 'dropdownMenu1';\r\n                    this._domElement = $(`#${myDropId}`);\r\n                    if (this._domElement) {\r\n                        // make sure to remove any previous Action dropdown elements, to avoid having multiple element of the same on top of each other\r\n                        this.dispose();\r\n                        // assign the row data to the dropdown component instance\r\n                        Object.assign(componentInstance, { parent, row: args.row, dataContext: args.grid.getDataItem(args.row) });\r\n                        // use a delay to make sure Angular ran at least a full cycle and make sure it finished rendering the Component before using it\r\n                        setTimeout(() => {\r\n                            // create a new dropdown element\r\n                            this._domElement = $(componentOutput.domElement);\r\n                            const topPos = (cellPos && cellPos.top || 0) + 30 + (offsetTop || 0);\r\n                            const leftPos = (cellPos && cellPos.left || 0) + (offsetLeft || 0);\r\n                            this._domElement.appendTo('body');\r\n                            this._domElement.css('position', 'absolute');\r\n                            this._domElement.css('top', topPos);\r\n                            this._domElement.css('left', leftPos);\r\n                            $(`#${myDropId}`).addClass('open');\r\n                            $(`#${dropDownToggleId}`).hide();\r\n                            // check if it should drop Up or Down\r\n                            const offset = 35;\r\n                            const iElement = $('.dropdown-menu');\r\n                            const iElementWrapper = iElement.parent();\r\n                            const iElementWrapperOffset = iElementWrapper.offset() || {};\r\n                            const iElementWrapperOffsetTop = iElementWrapperOffset.top || iElementWrapper && iElementWrapper.length > 0 && iElementWrapper[0].offsetTop;\r\n                            const iElementHeight = iElement.height();\r\n                            const windowHeight = window.innerHeight;\r\n                            const shouldDropUp = (windowHeight - iElementHeight - offset) < iElementWrapperOffsetTop;\r\n                            let menuMarginTop = '0px';\r\n                            if (shouldDropUp) {\r\n                                const offsetBottom = offsetDropupBottom || 0;\r\n                                menuMarginTop = '-'.concat(`${iElementHeight + offset + offsetBottom + 5}`, 'px');\r\n                            }\r\n                            this._domElement.css({ 'margin-top': menuMarginTop });\r\n                            // set dropdown margin left according to the document width\r\n                            const parentOffset = iElementWrapperOffset.left;\r\n                            const leftMargin = parentOffset - $(document).width();\r\n                            this._domElement.css({ 'margin-left': (this._domElement.width() + leftMargin + 60) + 'px' });\r\n                            try {\r\n                                this._domElement.dropdown('show'); // required for Bootstrap 4 only\r\n                            }\r\n                            catch (e) {\r\n                                // Bootstrap 3 wil throw an error since that method doesn't exist, we can safely disregard it\r\n                            }\r\n                            this._domElement.on('hidden.bs.dropdown', () => this.dropContainerShow());\r\n                            // hide dropdown menu on grid scroll\r\n                            this.gridViewport.on('scroll', () => this.dispose());\r\n                            // hide on dropdown click\r\n                            this._domElement.on('click', () => this.dispose());\r\n                            resolve(true);\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n};\r\nBsDropDownService = __decorate([\r\n    Injectable(),\r\n    __metadata(\"design:paramtypes\", [AngularUtilService])\r\n], BsDropDownService);\n\nconst numericSorter = (value1, value2, sortDirection) => {\r\n    const x = (isNaN(value1) || value1 === '' || value1 === null) ? -99e+10 : parseFloat(value1);\r\n    const y = (isNaN(value2) || value2 === '' || value2 === null) ? -99e+10 : parseFloat(value2);\r\n    return sortDirection * (x === y ? 0 : (x > y ? 1 : -1));\r\n};\n\nconst objectStringSorter = (value1, value2, sortDirection, sortColumn) => {\r\n    if (!sortColumn || !sortColumn.dataKey) {\r\n        throw new Error('Sorting a \"FieldType.object\" requires you to provide the \"dataKey\" (object property name) of the object so that we can use it to sort correctly');\r\n    }\r\n    const stringValue1 = value1.hasOwnProperty(sortColumn.dataKey) ? value1[sortColumn.dataKey] : value1;\r\n    const stringValue2 = value2.hasOwnProperty(sortColumn.dataKey) ? value2[sortColumn.dataKey] : value2;\r\n    if (sortDirection === undefined || sortDirection === null) {\r\n        sortDirection = SortDirectionNumber.neutral;\r\n    }\r\n    let position = 0;\r\n    if (typeof value1 !== 'object') {\r\n        position = -99e+10;\r\n    }\r\n    else if (typeof value2 !== 'object') {\r\n        position = 99e+10;\r\n    }\r\n    else if (!stringValue1) {\r\n        position = -1;\r\n    }\r\n    else if (!stringValue2) {\r\n        position = 1;\r\n    }\r\n    else if (stringValue1 === stringValue2) {\r\n        position = 0;\r\n    }\r\n    else if (sortDirection) {\r\n        position = stringValue1 < stringValue2 ? -1 : 1;\r\n    }\r\n    else {\r\n        position = stringValue1 < stringValue2 ? 1 : -1;\r\n    }\r\n    return sortDirection * position;\r\n};\n\nconst stringSorter = (value1, value2, sortDirection) => {\r\n    if (sortDirection === undefined || sortDirection === null) {\r\n        sortDirection = SortDirectionNumber.neutral;\r\n    }\r\n    let position = 0;\r\n    if (value1 === null) {\r\n        position = -1;\r\n    }\r\n    else if (value2 === null) {\r\n        position = 1;\r\n    }\r\n    else if (value1 === value2) {\r\n        position = 0;\r\n    }\r\n    else if (sortDirection) {\r\n        position = value1 < value2 ? -1 : 1;\r\n    }\r\n    else {\r\n        position = value1 < value2 ? 1 : -1;\r\n    }\r\n    return sortDirection * position;\r\n};\n\nconst moment = moment_; // patch to fix rollup \"moment has no default export\" issue, document here https://github.com/rollup/rollup/issues/670\r\n/**\r\n * Add an item to an array only when the item does not exists, when the item is an object we will be using their \"id\" to compare\r\n * @param inputArray\r\n * @param inputItem\r\n */\r\nfunction addToArrayWhenNotExists(inputArray, inputItem) {\r\n    let arrayRowIndex = -1;\r\n    if (typeof inputItem === 'object' && inputItem.hasOwnProperty('id')) {\r\n        arrayRowIndex = inputArray.findIndex((item) => item.id === inputItem.id);\r\n    }\r\n    else {\r\n        arrayRowIndex = inputArray.findIndex((item) => item === inputItem);\r\n    }\r\n    if (arrayRowIndex < 0) {\r\n        inputArray.push(inputItem);\r\n    }\r\n}\r\n/**\r\n * Simple function to which will loop and create as demanded the number of white spaces,\r\n * this is used in the CSV export\r\n * @param int nbSpaces: number of white spaces to create\r\n */\r\nfunction addWhiteSpaces(nbSpaces) {\r\n    let result = '';\r\n    for (let i = 0; i < nbSpaces; i++) {\r\n        result += ' ';\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * HTML decode using jQuery with a <div>\r\n * Create a in-memory div, set it's inner text(which jQuery automatically encodes)\r\n * then grab the encoded contents back out.  The div never exists on the page.\r\n*/\r\nfunction htmlDecode(encodedStr) {\r\n    const parser = DOMParser && new DOMParser;\r\n    if (parser && parser.parseFromString) {\r\n        const dom = parser.parseFromString('<!doctype html><body>' + encodedStr, 'text/html');\r\n        return dom && dom.body && dom.body.textContent;\r\n    }\r\n    else {\r\n        // for some browsers that might not support DOMParser, use jQuery instead\r\n        return $('<div/>').html(encodedStr).text();\r\n    }\r\n}\r\n/**\r\n * HTML encode using jQuery with a <div>\r\n * Create a in-memory div, set it's inner text(which jQuery automatically encodes)\r\n * then grab the encoded contents back out.  The div never exists on the page.\r\n*/\r\nfunction htmlEncode(inputValue) {\r\n    const entityMap = {\r\n        '&': '&amp;',\r\n        '<': '&lt;',\r\n        '>': '&gt;',\r\n        '\"': '&quot;',\r\n        '\\'': '&#39;'\r\n    };\r\n    // all symbols::  /[&<>\"'`=\\/]/g\r\n    return (inputValue || '').toString().replace(/[&<>\"']/g, (s) => entityMap[s]);\r\n}\r\n/**\r\n * Decode text into html entity\r\n * @param string text: input text\r\n * @param string text: output text\r\n */\r\nfunction htmlEntityDecode(input) {\r\n    return input.replace(/&#(\\d+);/g, function (match, dec) {\r\n        return String.fromCharCode(dec);\r\n    });\r\n}\r\n/**\r\n * Decode text into html entity\r\n * @param string text: input text\r\n * @param string text: output text\r\n */\r\nfunction htmlEntityEncode(input) {\r\n    const buf = [];\r\n    for (let i = input.length - 1; i >= 0; i--) {\r\n        buf.unshift(['&#', input[i].charCodeAt(), ';'].join(''));\r\n    }\r\n    return buf.join('');\r\n}\r\n/**\r\n * Compares two arrays of characters to determine if all the items are equal\r\n * @param a first array\r\n * @param b second array to compare with a\r\n * @param [orderMatters=false] flag if the order matters, if not arrays will be sorted before comparison\r\n * @return boolean true if equal, else false\r\n */\r\nfunction charArraysEqual(a, b, orderMatters = false) {\r\n    if (!a || !b || !Array.isArray(a) || !Array.isArray(a)) {\r\n        return false;\r\n    }\r\n    if (a.length !== b.length) {\r\n        return false;\r\n    }\r\n    if (!orderMatters) {\r\n        a.sort();\r\n        b.sort();\r\n    }\r\n    for (let i = 0; i < a.length; ++i) {\r\n        if (a[i] !== b[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Try casting an input of type Promise | Observable into a Promise type.\r\n * @param object which could be of type Promise or Observable\r\n * @param fromServiceName string representing the caller service name and will be used if we throw a casting problem error\r\n */\r\nfunction castToPromise(input, fromServiceName = '') {\r\n    let promise = input;\r\n    if (input instanceof Promise) {\r\n        // if it's already a Promise then return it\r\n        return input;\r\n    }\r\n    else if (input instanceof Observable) {\r\n        promise = input.pipe(first()).toPromise();\r\n    }\r\n    if (!(promise instanceof Promise)) {\r\n        throw new Error(`Something went wrong, Angular-Slickgrid ${fromServiceName} is not able to convert the Observable into a Promise.\n      If you are using Angular HttpClient, you could try converting your http call to a Promise with \".toPromise()\"\n      for example::  this.http.post('graphql', { query: graphqlQuery }).toPromise()\n      `);\r\n    }\r\n    return promise;\r\n}\r\n/**\r\n * Uses the logic function to find an item in an array or returns the default\r\n * value provided (empty object by default)\r\n * @param any[] array the array to filter\r\n * @param function logic the logic to find the item\r\n * @param any [defaultVal={}] the default value to return\r\n * @return object the found object or default value\r\n */\r\nfunction findOrDefault(array, logic, defaultVal = {}) {\r\n    return array.find(logic) || defaultVal;\r\n}\r\n/**\r\n  * Take a number (or a string) and display it as a formatted decimal string with defined minimum and maximum decimals\r\n  * @param input\r\n  * @param minDecimal\r\n  * @param maxDecimal\r\n  */\r\nfunction decimalFormatted(input, minDecimal, maxDecimal, decimalSeparator = '.', thousandSeparator = '') {\r\n    if (isNaN(+input)) {\r\n        return input;\r\n    }\r\n    const minDec = (minDecimal === undefined) ? 2 : minDecimal;\r\n    const maxDec = (maxDecimal === undefined) ? 2 : maxDecimal;\r\n    let amount = String(Math.round(+input * Math.pow(10, maxDec)) / Math.pow(10, maxDec));\r\n    if ((amount.indexOf('.') < 0) && (minDec > 0)) {\r\n        amount += '.';\r\n    }\r\n    while ((amount.length - amount.indexOf('.')) <= minDec) {\r\n        amount += '0';\r\n    }\r\n    // do we want to display our number with a custom separator in each thousand position\r\n    if (thousandSeparator) {\r\n        amount = thousandSeparatorFormatted(amount, thousandSeparator);\r\n    }\r\n    // when using a separator that is not a dot, replace it with the new separator\r\n    if (decimalSeparator !== '.') {\r\n        amount = amount.replace('.', decimalSeparator);\r\n    }\r\n    return amount;\r\n}\r\n/**\r\n * Format a number following options passed as arguments (decimals, separator, ...)\r\n * @param input\r\n * @param minDecimal\r\n * @param maxDecimal\r\n * @param displayNegativeNumberWithParentheses\r\n * @param symbolPrefix\r\n * @param symbolSuffix\r\n * @param decimalSeparator\r\n * @param thousandSeparator\r\n */\r\nfunction formatNumber(input, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, symbolPrefix = '', symbolSuffix = '', decimalSeparator = '.', thousandSeparator = '') {\r\n    if (isNaN(+input)) {\r\n        return input;\r\n    }\r\n    const calculatedValue = ((Math.round(parseFloat(input) * 1000000) / 1000000));\r\n    if (calculatedValue < 0) {\r\n        const absValue = Math.abs(calculatedValue);\r\n        if (displayNegativeNumberWithParentheses) {\r\n            if (!isNaN(minDecimal) || !isNaN(maxDecimal)) {\r\n                return `(${symbolPrefix}${decimalFormatted(absValue, minDecimal, maxDecimal, decimalSeparator, thousandSeparator)}${symbolSuffix})`;\r\n            }\r\n            const formattedValue = thousandSeparatorFormatted(`${absValue}`, thousandSeparator);\r\n            return `(${symbolPrefix}${formattedValue}${symbolSuffix})`;\r\n        }\r\n        else {\r\n            if (!isNaN(minDecimal) || !isNaN(maxDecimal)) {\r\n                return `-${symbolPrefix}${decimalFormatted(absValue, minDecimal, maxDecimal, decimalSeparator, thousandSeparator)}${symbolSuffix}`;\r\n            }\r\n            const formattedValue = thousandSeparatorFormatted(`${absValue}`, thousandSeparator);\r\n            return `-${symbolPrefix}${formattedValue}${symbolSuffix}`;\r\n        }\r\n    }\r\n    else {\r\n        if (!isNaN(minDecimal) || !isNaN(maxDecimal)) {\r\n            return `${symbolPrefix}${decimalFormatted(input, minDecimal, maxDecimal, decimalSeparator, thousandSeparator)}${symbolSuffix}`;\r\n        }\r\n        const formattedValue = thousandSeparatorFormatted(`${input}`, thousandSeparator);\r\n        return `${symbolPrefix}${formattedValue}${symbolSuffix}`;\r\n    }\r\n}\r\n/** From a dot (.) notation path, find and return a property within an object given a path */\r\nfunction getDescendantProperty(obj, path) {\r\n    return path.split('.').reduce((acc, part) => acc && acc[part], obj);\r\n}\r\n/** Get the browser's scrollbar width, this is different to each browser */\r\nfunction getScrollBarWidth() {\r\n    const $outer = $('<div>').css({ visibility: 'hidden', width: 100, overflow: 'scroll' }).appendTo('body');\r\n    const widthWithScroll = $('<div>').css({ width: '100%' }).appendTo($outer).outerWidth();\r\n    $outer.remove();\r\n    return Math.ceil(100 - widthWithScroll);\r\n}\r\n/**\r\n * From a Date FieldType, return it's equivalent moment.js format\r\n * refer to moment.js for the format standard used: https://momentjs.com/docs/#/parsing/string-format/\r\n * @param fieldType\r\n */\r\nfunction mapMomentDateFormatWithFieldType(fieldType) {\r\n    let map;\r\n    switch (fieldType) {\r\n        case FieldType.dateTime:\r\n        case FieldType.dateTimeIso:\r\n            map = 'YYYY-MM-DD HH:mm:ss';\r\n            break;\r\n        case FieldType.dateTimeShortIso:\r\n            map = 'YYYY-MM-DD HH:mm';\r\n            break;\r\n        case FieldType.dateTimeIsoAmPm:\r\n            map = 'YYYY-MM-DD hh:mm:ss a';\r\n            break;\r\n        case FieldType.dateTimeIsoAM_PM:\r\n            map = 'YYYY-MM-DD hh:mm:ss A';\r\n            break;\r\n        // all Euro Formats (date/month/year)\r\n        case FieldType.dateEuro:\r\n            map = 'DD/MM/YYYY';\r\n            break;\r\n        case FieldType.dateEuroShort:\r\n            map = 'D/M/YY';\r\n            break;\r\n        case FieldType.dateTimeEuro:\r\n            map = 'DD/MM/YYYY HH:mm:ss';\r\n            break;\r\n        case FieldType.dateTimeShortEuro:\r\n            map = 'DD/MM/YYYY HH:mm';\r\n            break;\r\n        case FieldType.dateTimeEuroAmPm:\r\n            map = 'DD/MM/YYYY hh:mm:ss a';\r\n            break;\r\n        case FieldType.dateTimeEuroAM_PM:\r\n            map = 'DD/MM/YYYY hh:mm:ss A';\r\n            break;\r\n        case FieldType.dateTimeEuroShort:\r\n            map = 'D/M/YY H:m:s';\r\n            break;\r\n        case FieldType.dateTimeEuroShortAmPm:\r\n            map = 'D/M/YY h:m:s a';\r\n            break;\r\n        // all US Formats (month/date/year)\r\n        case FieldType.dateUs:\r\n            map = 'MM/DD/YYYY';\r\n            break;\r\n        case FieldType.dateUsShort:\r\n            map = 'M/D/YY';\r\n            break;\r\n        case FieldType.dateTimeUs:\r\n            map = 'MM/DD/YYYY HH:mm:ss';\r\n            break;\r\n        case FieldType.dateTimeShortUs:\r\n            map = 'MM/DD/YYYY HH:mm';\r\n            break;\r\n        case FieldType.dateTimeUsAmPm:\r\n            map = 'MM/DD/YYYY hh:mm:ss a';\r\n            break;\r\n        case FieldType.dateTimeUsAM_PM:\r\n            map = 'MM/DD/YYYY hh:mm:ss A';\r\n            break;\r\n        case FieldType.dateTimeUsShort:\r\n            map = 'M/D/YY H:m:s';\r\n            break;\r\n        case FieldType.dateTimeUsShortAmPm:\r\n            map = 'M/D/YY h:m:s a';\r\n            break;\r\n        case FieldType.dateUtc:\r\n            map = 'YYYY-MM-DDTHH:mm:ss.SSSZ';\r\n            break;\r\n        case FieldType.date:\r\n        case FieldType.dateIso:\r\n        default:\r\n            map = 'YYYY-MM-DD';\r\n            break;\r\n    }\r\n    return map;\r\n}\r\n/**\r\n * From a Date FieldType, return it's equivalent Flatpickr format\r\n * refer to Flatpickr for the format standard used: https://chmln.github.io/flatpickr/formatting/#date-formatting-tokens\r\n * also note that they seem very similar to PHP format (except for am/pm): http://php.net/manual/en/function.date.php\r\n * @param fieldType\r\n */\r\nfunction mapFlatpickrDateFormatWithFieldType(fieldType) {\r\n    /*\r\n      d: Day of the month, 2 digits with leading zeros\t01 to 31\r\n      D: A textual representation of a day\tMon through Sun\r\n      l: (lowercase 'L')\tA full textual representation of the day of the week\tSunday through Saturday\r\n      j: Day of the month without leading zeros\t1 to 31\r\n      J: Day of the month without leading zeros and ordinal suffix\t1st, 2nd, to 31st\r\n      w: Numeric representation of the day of the week\t0 (for Sunday) through 6 (for Saturday)\r\n      F: A full textual representation of a month\tJanuary through December\r\n      m: Numeric representation of a month, with leading zero\t01 through 12\r\n      n: Numeric representation of a month, without leading zeros\t1 through 12\r\n      M: A short textual representation of a month\tJan through Dec\r\n      U: The number of seconds since the Unix Epoch\t1413704993\r\n      y: A two digit representation of a year\t99 or 03\r\n      Y: A full numeric representation of a year, 4 digits\t1999 or 2003\r\n      H: Hours (24 hours)\t00 to 23\r\n      h: Hours\t1 to 12\r\n      i: Minutes\t00 to 59\r\n      S: Seconds, 2 digits\t00 to 59\r\n      s: Seconds\t0, 1 to 59\r\n      K: AM/PM\tAM or PM\r\n    */\r\n    let map;\r\n    switch (fieldType) {\r\n        case FieldType.dateTime:\r\n        case FieldType.dateTimeIso:\r\n            map = 'Y-m-d H:i:S';\r\n            break;\r\n        case FieldType.dateTimeShortIso:\r\n            map = 'Y-m-d H:i';\r\n            break;\r\n        case FieldType.dateTimeIsoAmPm:\r\n        case FieldType.dateTimeIsoAM_PM:\r\n            map = 'Y-m-d h:i:S K'; // there is no lowercase in Flatpickr :(\r\n            break;\r\n        // all Euro Formats (date/month/year)\r\n        case FieldType.dateEuro:\r\n            map = 'd/m/Y';\r\n            break;\r\n        case FieldType.dateEuroShort:\r\n            map = 'd/m/y';\r\n            break;\r\n        case FieldType.dateTimeEuro:\r\n            map = 'd/m/Y H:i:S';\r\n            break;\r\n        case FieldType.dateTimeShortEuro:\r\n            map = 'd/m/y H:i';\r\n            break;\r\n        case FieldType.dateTimeEuroAmPm:\r\n            map = 'd/m/Y h:i:S K'; // there is no lowercase in Flatpickr :(\r\n            break;\r\n        case FieldType.dateTimeEuroAM_PM:\r\n            map = 'd/m/Y h:i:s K';\r\n            break;\r\n        case FieldType.dateTimeEuroShort:\r\n            map = 'd/m/y H:i:s';\r\n            break;\r\n        case FieldType.dateTimeEuroShortAmPm:\r\n            map = 'd/m/y h:i:s K'; // there is no lowercase in Flatpickr :(\r\n            break;\r\n        // all US Formats (month/date/year)\r\n        case FieldType.dateUs:\r\n            map = 'm/d/Y';\r\n            break;\r\n        case FieldType.dateUsShort:\r\n            map = 'm/d/y';\r\n            break;\r\n        case FieldType.dateTimeUs:\r\n            map = 'm/d/Y H:i:S';\r\n            break;\r\n        case FieldType.dateTimeShortUs:\r\n            map = 'm/d/y H:i';\r\n            break;\r\n        case FieldType.dateTimeUsAmPm:\r\n            map = 'm/d/Y h:i:S K'; // there is no lowercase in Flatpickr :(\r\n            break;\r\n        case FieldType.dateTimeUsAM_PM:\r\n            map = 'm/d/Y h:i:s K';\r\n            break;\r\n        case FieldType.dateTimeUsShort:\r\n            map = 'm/d/y H:i:s';\r\n            break;\r\n        case FieldType.dateTimeUsShortAmPm:\r\n            map = 'm/d/y h:i:s K'; // there is no lowercase in Flatpickr :(\r\n            break;\r\n        case FieldType.dateUtc:\r\n            map = 'Z';\r\n            break;\r\n        case FieldType.date:\r\n        case FieldType.dateIso:\r\n        default:\r\n            map = 'Y-m-d';\r\n            break;\r\n    }\r\n    return map;\r\n}\r\n/**\r\n * Mapper for query operators (ex.: <= is \"le\", > is \"gt\")\r\n * @param string operator\r\n * @returns string map\r\n */\r\nfunction mapOperatorType(operator) {\r\n    let map;\r\n    switch (operator) {\r\n        case '<':\r\n        case 'LT':\r\n            map = OperatorType.lessThan;\r\n            break;\r\n        case '<=':\r\n        case 'LE':\r\n            map = OperatorType.lessThanOrEqual;\r\n            break;\r\n        case '>':\r\n        case 'GT':\r\n            map = OperatorType.greaterThan;\r\n            break;\r\n        case '>=':\r\n        case 'GE':\r\n            map = OperatorType.greaterThanOrEqual;\r\n            break;\r\n        case '<>':\r\n        case '!=':\r\n        case 'NE':\r\n            map = OperatorType.notEqual;\r\n            break;\r\n        case '*':\r\n        case 'a*':\r\n        case 'StartsWith':\r\n            map = OperatorType.startsWith;\r\n            break;\r\n        case '*z':\r\n        case 'EndsWith':\r\n            map = OperatorType.endsWith;\r\n            break;\r\n        case '=':\r\n        case '==':\r\n        case 'EQ':\r\n            map = OperatorType.equal;\r\n            break;\r\n        case 'IN':\r\n            map = OperatorType.in;\r\n            break;\r\n        case 'NIN':\r\n        case 'NOT_IN':\r\n            map = OperatorType.notIn;\r\n            break;\r\n        case 'Not_Contains':\r\n        case 'NOT_CONTAINS':\r\n            map = OperatorType.notContains;\r\n            break;\r\n        case 'Contains':\r\n        case 'CONTAINS':\r\n        default:\r\n            map = OperatorType.contains;\r\n            break;\r\n    }\r\n    return map;\r\n}\r\n/**\r\n * Find equivalent short designation of an Operator Type or Operator String.\r\n * When using a Compound Filter, we use the short designation and so we need the mapped value.\r\n * For example OperatorType.startsWith short designation is \"a*\", while OperatorType.greaterThanOrEqual is \">=\"\r\n */\r\nfunction mapOperatorToShorthandDesignation(operator) {\r\n    let shortOperator = '';\r\n    switch (operator) {\r\n        case OperatorType.greaterThan:\r\n        case '>':\r\n            shortOperator = '>';\r\n            break;\r\n        case OperatorType.greaterThanOrEqual:\r\n        case '>=':\r\n            shortOperator = '>=';\r\n            break;\r\n        case OperatorType.lessThan:\r\n        case '<':\r\n            shortOperator = '<';\r\n            break;\r\n        case OperatorType.lessThanOrEqual:\r\n        case '<=':\r\n            shortOperator = '<=';\r\n            break;\r\n        case OperatorType.notEqual:\r\n        case '<>':\r\n            shortOperator = '<>';\r\n            break;\r\n        case OperatorType.equal:\r\n        case '=':\r\n        case '==':\r\n        case 'EQ':\r\n            shortOperator = '=';\r\n            break;\r\n        case OperatorType.startsWith:\r\n        case 'a*':\r\n        case '*':\r\n            shortOperator = 'a*';\r\n            break;\r\n        case OperatorType.endsWith:\r\n        case '*z':\r\n            shortOperator = '*z';\r\n            break;\r\n        default:\r\n            // any other operator will be considered as already a short expression, so we can return same input operator\r\n            shortOperator = operator;\r\n            break;\r\n    }\r\n    return shortOperator;\r\n}\r\n/**\r\n * Mapper for query operator by a Filter Type\r\n * For example a multiple-select typically uses 'IN' operator\r\n * @param operator\r\n * @returns string map\r\n */\r\nfunction mapOperatorByFieldType(fieldType) {\r\n    let map;\r\n    switch (fieldType) {\r\n        case FieldType.string:\r\n        case FieldType.unknown:\r\n            map = OperatorType.contains;\r\n            break;\r\n        case FieldType.float:\r\n        case FieldType.number:\r\n        case FieldType.date:\r\n        case FieldType.dateIso:\r\n        case FieldType.dateUtc:\r\n        case FieldType.dateTime:\r\n        case FieldType.dateTimeIso:\r\n        case FieldType.dateTimeIsoAmPm:\r\n        case FieldType.dateTimeIsoAM_PM:\r\n        case FieldType.dateEuro:\r\n        case FieldType.dateEuroShort:\r\n        case FieldType.dateTimeEuro:\r\n        case FieldType.dateTimeEuroAmPm:\r\n        case FieldType.dateTimeEuroAM_PM:\r\n        case FieldType.dateTimeEuroShort:\r\n        case FieldType.dateTimeEuroShortAmPm:\r\n        case FieldType.dateTimeEuroShortAM_PM:\r\n        case FieldType.dateUs:\r\n        case FieldType.dateUsShort:\r\n        case FieldType.dateTimeUs:\r\n        case FieldType.dateTimeUsAmPm:\r\n        case FieldType.dateTimeUsAM_PM:\r\n        case FieldType.dateTimeUsShort:\r\n        case FieldType.dateTimeUsShortAmPm:\r\n        case FieldType.dateTimeUsShortAM_PM:\r\n        default:\r\n            map = OperatorType.equal;\r\n            break;\r\n    }\r\n    return map;\r\n}\r\n/** Parse any input (bool, number, string) and return a boolean or False when not possible */\r\nfunction parseBoolean(input) {\r\n    return /(true|1)/i.test(input + '');\r\n}\r\n/**\r\n * Parse a date passed as a string (Date only, without time) and return a Date object (if valid)\r\n * @param inputDateString\r\n * @returns string date formatted\r\n */\r\nfunction parseUtcDate(inputDateString, useUtc) {\r\n    let date = null;\r\n    if (/^[0-9\\-\\/]*$/.test(inputDateString)) {\r\n        // get the UTC datetime with moment.js but we need to decode the value so that it's valid text\r\n        const dateString = decodeURIComponent(inputDateString);\r\n        const dateMoment = moment(new Date(dateString));\r\n        if (dateMoment.isValid() && dateMoment.year().toString().length === 4) {\r\n            date = (useUtc) ? dateMoment.utc().format() : dateMoment.format();\r\n        }\r\n    }\r\n    return date;\r\n}\r\n/**\r\n * Sanitize, return only the text without HTML tags\r\n * @input htmlString\r\n * @return text\r\n */\r\nfunction sanitizeHtmlToText(htmlString) {\r\n    const temp = document.createElement('div');\r\n    temp.innerHTML = htmlString;\r\n    return temp.textContent || temp.innerText || '';\r\n}\r\n/** Set the object value of deeper node from a given dot (.) notation path (e.g.: \"user.firstName\") */\r\nfunction setDeepValue(obj, path, value) {\r\n    if (typeof path === 'string') {\r\n        path = path.split('.');\r\n    }\r\n    if (path.length > 1) {\r\n        const e = path.shift();\r\n        setDeepValue(obj[e] = Object.prototype.toString.call(obj[e]) === '[object Object]' ? obj[e] : {}, path, value);\r\n    }\r\n    else {\r\n        obj[path[0]] = value;\r\n    }\r\n}\r\n/**\r\n * Format a number or a string into a string that is separated every thousand,\r\n * the default separator is a comma but user can optionally pass a different one\r\n * @param inputValue\r\n * @param separator default to comma \",\"\r\n * @returns string\r\n */\r\nfunction thousandSeparatorFormatted(inputValue, separator = ',') {\r\n    if (inputValue !== null && inputValue !== undefined) {\r\n        const stringValue = `${inputValue}`;\r\n        const decimalSplit = stringValue.split('.');\r\n        if (decimalSplit.length === 2) {\r\n            return `${decimalSplit[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, separator)}.${decimalSplit[1]}`;\r\n        }\r\n        return stringValue.replace(/\\B(?=(\\d{3})+(?!\\d))/g, separator);\r\n    }\r\n    return inputValue;\r\n}\r\n/**\r\n * Title case (or capitalize) first char of a string\r\n * Optionall title case the complete sentence (upper case first char of each word while changing everything else to lower case)\r\n * @param inputStr\r\n * @returns string\r\n */\r\nfunction titleCase(inputStr, caseEveryWords = false) {\r\n    if (typeof inputStr === 'string') {\r\n        if (caseEveryWords) {\r\n            return inputStr.replace(/\\w\\S*/g, (outputStr) => {\r\n                return outputStr.charAt(0).toUpperCase() + outputStr.substr(1).toLowerCase();\r\n            });\r\n        }\r\n        return inputStr.charAt(0).toUpperCase() + inputStr.slice(1);\r\n    }\r\n    return inputStr;\r\n}\r\n/**\r\n * Converts a string to camel case (camelCase)\r\n * @param inputStr the string to convert\r\n * @return the string in camel case\r\n */\r\nfunction toCamelCase(inputStr) {\r\n    if (typeof inputStr === 'string') {\r\n        return inputStr.replace(/(?:^\\w|[A-Z]|\\b\\w|[\\s+\\-_\\/])/g, (match, offset) => {\r\n            // remove white space or hypens or underscores\r\n            if (/[\\s+\\-_\\/]/.test(match)) {\r\n                return '';\r\n            }\r\n            return offset === 0 ? match.toLowerCase() : match.toUpperCase();\r\n        });\r\n    }\r\n    return inputStr;\r\n}\r\n/**\r\n * Converts a string to kebab (hypen) case\r\n * @param str the string to convert\r\n * @return the string in kebab case\r\n */\r\nfunction toKebabCase(inputStr) {\r\n    if (typeof inputStr === 'string') {\r\n        return toCamelCase(inputStr).replace(/([A-Z])/g, '-$1').toLowerCase();\r\n    }\r\n    return inputStr;\r\n}\r\n/**\r\n * Converts a string from camelCase to snake_case (underscore) case\r\n * @param str the string to convert\r\n * @return the string in kebab case\r\n */\r\nfunction toSnakeCase(inputStr) {\r\n    if (typeof inputStr === 'string') {\r\n        return toCamelCase(inputStr).replace(/([A-Z])/g, '_$1').toLowerCase();\r\n    }\r\n    return inputStr;\r\n}\r\n/**\r\n * Takes an input array and makes sure the array has unique values by removing duplicates\r\n * @param array input with possible duplicates\r\n * @param objectProperty optionally provide an object property to compare (example: 'id')\r\n * @return array output without duplicates\r\n */\r\nfunction uniqueArray(arr) {\r\n    if (Array.isArray(arr) && arr.length > 0) {\r\n        return arr.filter((item, index) => {\r\n            return arr.indexOf(item) >= index;\r\n        });\r\n    }\r\n    return arr;\r\n}\r\n/**\r\n * Takes an input array of objects and makes sure the array has unique object values by removing duplicates\r\n * it will loop through the array using a property name (or \"id\" when is not provided) to compare uniqueness\r\n * @param array input with possible duplicates\r\n * @param propertyName defaults to \"id\"\r\n * @return array output without duplicates\r\n */\r\nfunction uniqueObjectArray(arr, propertyName = 'id') {\r\n    if (Array.isArray(arr) && arr.length > 0) {\r\n        const result = [];\r\n        const map = new Map();\r\n        for (const item of arr) {\r\n            if (!map.has(item[propertyName])) {\r\n                map.set(item[propertyName], true); // set any value to Map\r\n                result.push({\r\n                    id: item[propertyName],\r\n                    name: item.name\r\n                });\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    return arr;\r\n}\r\n/**\r\n * Unsubscribe all Observables Subscriptions\r\n * It will return an empty array if it all went well\r\n * @param subscriptions\r\n */\r\nfunction unsubscribeAllObservables(subscriptions) {\r\n    if (Array.isArray(subscriptions)) {\r\n        subscriptions.forEach((subscription) => {\r\n            if (subscription && subscription.unsubscribe) {\r\n                subscription.unsubscribe();\r\n            }\r\n        });\r\n        subscriptions = [];\r\n    }\r\n    return subscriptions;\r\n}\n\nconst moment$1 = moment_; // patch to fix rollup \"moment has no default export\" issue, document here https://github.com/rollup/rollup/issues/670\r\nfunction compareDates(value1, value2, sortDirection, format, strict) {\r\n    let diff = 0;\r\n    if (value1 === null || value1 === '' || !moment$1(value1, format, strict).isValid()) {\r\n        diff = -1;\r\n    }\r\n    else if (value2 === null || value2 === '' || !moment$1(value2, format, strict).isValid()) {\r\n        diff = 1;\r\n    }\r\n    else {\r\n        const date1 = moment$1(value1, format, strict);\r\n        const date2 = moment$1(value2, format, strict);\r\n        diff = parseInt(date1.format('X'), 10) - parseInt(date2.format('X'), 10);\r\n    }\r\n    return sortDirection * (diff === 0 ? 0 : (diff > 0 ? 1 : -1));\r\n}\r\n/** From a FieldType, return the associated date Sorter */\r\nfunction getAssociatedDateSorter(fieldType) {\r\n    const FORMAT = (fieldType === FieldType.date) ? moment$1.ISO_8601 : mapMomentDateFormatWithFieldType(fieldType);\r\n    return (value1, value2, sortDirection) => {\r\n        if (FORMAT === moment$1.ISO_8601) {\r\n            return compareDates(value1, value2, sortDirection, FORMAT, false);\r\n        }\r\n        return compareDates(value1, value2, sortDirection, FORMAT, true);\r\n    };\r\n}\n\nconst Sorters = {\r\n    /** Sorter method to sort values by Date object type (uses Moment.js ISO_8601 standard format, optionally include time) */\r\n    date: getAssociatedDateSorter(FieldType.date),\r\n    /**\r\n     * Sorter method to sort values by Date formatted as ISO date (excluding time),\r\n     * If you wish to optionally include time simply use the \"Sorters.date\" which work with/without time\r\n     */\r\n    dateIso: getAssociatedDateSorter(FieldType.dateIso),\r\n    /** Sorter method to sort values by Date formatted as (YYYY-MM-DDTHH:mm:ss.SSSZ) */\r\n    dateUtc: getAssociatedDateSorter(FieldType.dateUtc),\r\n    /** Sorter method to sort values by Date and Time (native Date object) */\r\n    dateTime: getAssociatedDateSorter(FieldType.dateTime),\r\n    /** Sorter method to sort values by Date formatted as (YYYY-MM-DD HH:mm:ss) */\r\n    dateTimeIso: getAssociatedDateSorter(FieldType.dateTimeIso),\r\n    /** Sorter method to sort values by Date formatted as (YYYY-MM-DD h:mm:ss a) */\r\n    dateTimeIsoAmPm: getAssociatedDateSorter(FieldType.dateTimeIsoAmPm),\r\n    /** Sorter method to sort values by Date formatted as (YYYY-MM-DD h:mm:ss A) */\r\n    dateTimeIsoAM_PM: getAssociatedDateSorter(FieldType.dateTimeIsoAM_PM),\r\n    /** Sorter method to sort values by Date formatted as (YYYY-MM-DD HH:mm) */\r\n    dateTimeShortIso: getAssociatedDateSorter(FieldType.dateTimeShortIso),\r\n    /** Sorter method to sort values by Date formatted as Euro date (DD/MM/YYYY) */\r\n    dateEuro: getAssociatedDateSorter(FieldType.dateEuro),\r\n    /** Sorter method to sort values by Date formatted as Euro short date (D/M/YY) */\r\n    dateEuroShort: getAssociatedDateSorter(FieldType.dateEuroShort),\r\n    /** Sorter method to sort values by Date formatted as (DD/MM/YYYY HH:mm) */\r\n    dateTimeShortEuro: getAssociatedDateSorter(FieldType.dateTimeShortEuro),\r\n    /** Sorter method to sort values by Date formatted as (DD/MM/YYYY HH:mm:ss) */\r\n    dateTimeEuro: getAssociatedDateSorter(FieldType.dateTimeEuro),\r\n    /** Sorter method to sort values by Date formatted as (DD/MM/YYYY hh:mm:ss a) */\r\n    dateTimeEuroAmPm: getAssociatedDateSorter(FieldType.dateTimeEuroAmPm),\r\n    /** Sorter method to sort values by Date formatted as (DD/MM/YYYY hh:mm:ss A) */\r\n    dateTimeEuroAM_PM: getAssociatedDateSorter(FieldType.dateTimeEuroAM_PM),\r\n    /** Sorter method to sort values by Date formatted as (D/M/YY H:m:s) */\r\n    dateTimeEuroShort: getAssociatedDateSorter(FieldType.dateTimeEuroShort),\r\n    /** Sorter method to sort values by Date formatted as (D/M/YY h:m:s a) */\r\n    dateTimeEuroShortAmPm: getAssociatedDateSorter(FieldType.dateTimeEuroShortAmPm),\r\n    /** Sorter method to sort values by Date formatted as (D/M/YY h:m:s A) */\r\n    dateTimeEuroShortAM_PM: getAssociatedDateSorter(FieldType.dateTimeEuroShortAM_PM),\r\n    /** Sorter method to sort values by Date formatted as US date (MM/DD/YYYY) */\r\n    dateUs: getAssociatedDateSorter(FieldType.dateUs),\r\n    /** Sorter method to sort values by Date formatted as US short date (M/D/YY) */\r\n    dateUsShort: getAssociatedDateSorter(FieldType.dateUsShort),\r\n    /** Sorter method to sort values by Date formatted as (MM/DD/YYYY HH:mm) */\r\n    dateTimeShortUs: getAssociatedDateSorter(FieldType.dateTimeShortUs),\r\n    /** Sorter method to sort values by Date formatted as (MM/DD/YYYY HH:mm:s) */\r\n    dateTimeUs: getAssociatedDateSorter(FieldType.dateTimeUs),\r\n    /** Sorter method to sort values by Date formatted as (MM/DD/YYYY hh:mm:ss a) */\r\n    dateTimeUsAmPm: getAssociatedDateSorter(FieldType.dateTimeUsAmPm),\r\n    /** Sorter method to sort values by Date formatted as (MM/DD/YYYY hh:mm:ss A) */\r\n    dateTimeUsAM_PM: getAssociatedDateSorter(FieldType.dateTimeUsAM_PM),\r\n    /** Sorter method to sort values by Date formatted as (M/D/YY H:m:s) */\r\n    dateTimeUsShort: getAssociatedDateSorter(FieldType.dateTimeUsShort),\r\n    /** Sorter method to sort values by Date formatted as (M/D/YY h:m:s a) */\r\n    dateTimeUsShortAmPm: getAssociatedDateSorter(FieldType.dateTimeUsShortAmPm),\r\n    /** Sorter method to sort values by Date formatted as (M/D/YY h:m:s A) */\r\n    dateTimeUsShortAM_PM: getAssociatedDateSorter(FieldType.dateTimeUsShortAM_PM),\r\n    /** Sorter method to sort values as numeric fields */\r\n    numeric: numericSorter,\r\n    /**\r\n     * Sorter method to sort object values with a \"dataKey\" provided in your column definition, it's data content must be of type string\r\n     * Example:\r\n     * columnDef = { id='user', field: 'user', ..., dataKey: 'firstName', sorter: Sorters.objectString }\r\n     * collection = [{ firstName: 'John', lastName: 'Doe' }, { firstName: 'Bob', lastName: 'Cash' }]\r\n     */\r\n    objectString: objectStringSorter,\r\n    /** Sorter method to sort values as regular strings */\r\n    string: stringSorter\r\n};\n\nfunction sortByFieldType(fieldType, value1, value2, sortDirection, sortColumn) {\r\n    let sortResult = 0;\r\n    switch (fieldType) {\r\n        case FieldType.float:\r\n        case FieldType.integer:\r\n        case FieldType.number:\r\n            sortResult = Sorters.numeric(value1, value2, sortDirection);\r\n            break;\r\n        case FieldType.date:\r\n        case FieldType.dateIso:\r\n        case FieldType.dateUtc:\r\n        case FieldType.dateTime:\r\n        case FieldType.dateTimeIso:\r\n        case FieldType.dateTimeIsoAmPm:\r\n        case FieldType.dateTimeIsoAM_PM:\r\n        case FieldType.dateTimeShortIso:\r\n        case FieldType.dateEuro:\r\n        case FieldType.dateEuroShort:\r\n        case FieldType.dateTimeShortEuro:\r\n        case FieldType.dateTimeEuro:\r\n        case FieldType.dateTimeEuroAmPm:\r\n        case FieldType.dateTimeEuroAM_PM:\r\n        case FieldType.dateTimeEuroShort:\r\n        case FieldType.dateTimeEuroShortAmPm:\r\n        case FieldType.dateTimeEuroShortAM_PM:\r\n        case FieldType.dateUs:\r\n        case FieldType.dateUsShort:\r\n        case FieldType.dateTimeShortUs:\r\n        case FieldType.dateTimeUs:\r\n        case FieldType.dateTimeUsAmPm:\r\n        case FieldType.dateTimeUsAM_PM:\r\n        case FieldType.dateTimeUsShort:\r\n        case FieldType.dateTimeUsShortAmPm:\r\n        case FieldType.dateTimeUsShortAM_PM:\r\n            sortResult = getAssociatedDateSorter(fieldType).call(this, value1, value2, sortDirection);\r\n            break;\r\n        case FieldType.object:\r\n            sortResult = Sorters.objectString(value1, value2, sortDirection, sortColumn);\r\n            break;\r\n        default:\r\n            sortResult = Sorters.string(value1, value2, sortDirection);\r\n            break;\r\n    }\r\n    return sortResult;\r\n}\n\nlet CollectionService = class CollectionService {\r\n    constructor(translate) {\r\n        this.translate = translate;\r\n    }\r\n    /**\r\n     * Filter 1 or more items from a collection\r\n     * @param collection\r\n     * @param filterByOptions\r\n     */\r\n    filterCollection(collection, filterByOptions, filterResultBy = FilterMultiplePassType.chain) {\r\n        let filteredCollection = [];\r\n        // when it's array, we will use the new filtered collection after every pass\r\n        // basically if input collection has 10 items on 1st pass and 1 item is filtered out, then on 2nd pass the input collection will be 9 items\r\n        if (Array.isArray(filterByOptions)) {\r\n            filteredCollection = (filterResultBy === FilterMultiplePassType.merge) ? [] : collection;\r\n            for (const filter of filterByOptions) {\r\n                if (filterResultBy === FilterMultiplePassType.merge) {\r\n                    const filteredPass = this.singleFilterCollection(collection, filter);\r\n                    filteredCollection = uniqueArray([...filteredCollection, ...filteredPass]);\r\n                }\r\n                else {\r\n                    filteredCollection = this.singleFilterCollection(filteredCollection, filter);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            filteredCollection = this.singleFilterCollection(collection, filterByOptions);\r\n        }\r\n        return filteredCollection;\r\n    }\r\n    /**\r\n     * Filter an item from a collection\r\n     * @param collection\r\n     * @param filterBy\r\n     */\r\n    singleFilterCollection(collection, filterBy) {\r\n        let filteredCollection = [];\r\n        if (filterBy) {\r\n            const objectProperty = filterBy.property;\r\n            const operator = filterBy.operator || OperatorType.equal;\r\n            // just check for undefined since the filter value could be null, 0, '', false etc\r\n            const value = typeof filterBy.value === 'undefined' ? '' : filterBy.value;\r\n            switch (operator) {\r\n                case OperatorType.equal:\r\n                    if (objectProperty) {\r\n                        filteredCollection = collection.filter((item) => item[objectProperty] === value);\r\n                    }\r\n                    else {\r\n                        filteredCollection = collection.filter((item) => item === value);\r\n                    }\r\n                    break;\r\n                case OperatorType.contains:\r\n                    if (objectProperty) {\r\n                        filteredCollection = collection.filter((item) => item[objectProperty].toString().indexOf(value.toString()) !== -1);\r\n                    }\r\n                    else {\r\n                        filteredCollection = collection.filter((item) => (item !== null && item !== undefined) && item.toString().indexOf(value.toString()) !== -1);\r\n                    }\r\n                    break;\r\n                case OperatorType.notContains:\r\n                    if (objectProperty) {\r\n                        filteredCollection = collection.filter((item) => item[objectProperty].toString().indexOf(value.toString()) === -1);\r\n                    }\r\n                    else {\r\n                        filteredCollection = collection.filter((item) => (item !== null && item !== undefined) && item.toString().indexOf(value.toString()) === -1);\r\n                    }\r\n                    break;\r\n                case OperatorType.notEqual:\r\n                default:\r\n                    if (objectProperty) {\r\n                        filteredCollection = collection.filter((item) => item[objectProperty] !== value);\r\n                    }\r\n                    else {\r\n                        filteredCollection = collection.filter((item) => item !== value);\r\n                    }\r\n            }\r\n        }\r\n        return filteredCollection;\r\n    }\r\n    /**\r\n     * Sort 1 or more items in a collection\r\n     * @param column definition\r\n     * @param collection\r\n     * @param sortByOptions\r\n     * @param enableTranslateLabel\r\n     */\r\n    sortCollection(columnDef, collection, sortByOptions, enableTranslateLabel) {\r\n        if (enableTranslateLabel && (!this.translate || !this.translate.instant)) {\r\n            throw new Error('[Angular-Slickgrid] requires \"ngx-translate\" to be installed and configured when the grid option \"enableTranslate\" is enabled.');\r\n        }\r\n        let sortedCollection = [];\r\n        if (sortByOptions) {\r\n            if (Array.isArray(sortByOptions)) {\r\n                // multi-sort\r\n                sortedCollection = collection.sort((dataRow1, dataRow2) => {\r\n                    for (let i = 0, l = sortByOptions.length; i < l; i++) {\r\n                        const sortBy = sortByOptions[i];\r\n                        if (sortBy && sortBy.property) {\r\n                            // collection of objects with a property name provided\r\n                            const sortDirection = sortBy.sortDesc ? SortDirectionNumber.desc : SortDirectionNumber.asc;\r\n                            const objectProperty = sortBy.property;\r\n                            const fieldType = sortBy.fieldType || FieldType.string;\r\n                            const value1 = (enableTranslateLabel) ? this.translate && this.translate.currentLang && this.translate.instant(dataRow1[objectProperty] || ' ') : dataRow1[objectProperty];\r\n                            const value2 = (enableTranslateLabel) ? this.translate && this.translate.currentLang && this.translate.instant(dataRow2[objectProperty] || ' ') : dataRow2[objectProperty];\r\n                            const sortResult = sortByFieldType(fieldType, value1, value2, sortDirection, columnDef);\r\n                            if (sortResult !== SortDirectionNumber.neutral) {\r\n                                return sortResult;\r\n                            }\r\n                        }\r\n                    }\r\n                    return SortDirectionNumber.neutral;\r\n                });\r\n            }\r\n            else if (sortByOptions && sortByOptions.property) {\r\n                // single sort\r\n                // collection of objects with a property name provided\r\n                const objectProperty = sortByOptions.property;\r\n                const sortDirection = sortByOptions.sortDesc ? SortDirectionNumber.desc : SortDirectionNumber.asc;\r\n                const fieldType = sortByOptions.fieldType || FieldType.string;\r\n                if (objectProperty) {\r\n                    sortedCollection = collection.sort((dataRow1, dataRow2) => {\r\n                        const value1 = (enableTranslateLabel) ? this.translate && this.translate.currentLang && this.translate.instant(dataRow1[objectProperty] || ' ') : dataRow1[objectProperty];\r\n                        const value2 = (enableTranslateLabel) ? this.translate && this.translate.currentLang && this.translate.instant(dataRow2[objectProperty] || ' ') : dataRow2[objectProperty];\r\n                        const sortResult = sortByFieldType(fieldType, value1, value2, sortDirection, columnDef);\r\n                        if (sortResult !== SortDirectionNumber.neutral) {\r\n                            return sortResult;\r\n                        }\r\n                        return SortDirectionNumber.neutral;\r\n                    });\r\n                }\r\n            }\r\n            else if (sortByOptions && !sortByOptions.property) {\r\n                const sortDirection = sortByOptions.sortDesc ? SortDirectionNumber.desc : SortDirectionNumber.asc;\r\n                const fieldType = sortByOptions.fieldType || FieldType.string;\r\n                sortedCollection = collection.sort((dataRow1, dataRow2) => {\r\n                    const value1 = (enableTranslateLabel) ? this.translate && this.translate.currentLang && this.translate.instant(dataRow1 || ' ') : dataRow1;\r\n                    const value2 = (enableTranslateLabel) ? this.translate && this.translate.currentLang && this.translate.instant(dataRow2 || ' ') : dataRow2;\r\n                    const sortResult = sortByFieldType(fieldType, value1, value2, sortDirection, columnDef);\r\n                    if (sortResult !== SortDirectionNumber.neutral) {\r\n                        return sortResult;\r\n                    }\r\n                    return SortDirectionNumber.neutral;\r\n                });\r\n            }\r\n        }\r\n        return sortedCollection;\r\n    }\r\n};\r\nCollectionService = __decorate([\r\n    Injectable(),\r\n    __param(0, Optional()),\r\n    __metadata(\"design:paramtypes\", [TranslateService])\r\n], CollectionService);\n\nclass Constants {\r\n}\r\nConstants.locales = {\r\n    TEXT_ALL_SELECTED: 'All Selected',\r\n    TEXT_CANCEL: 'Cancel',\r\n    TEXT_CLEAR_ALL_FILTERS: 'Clear all Filters',\r\n    TEXT_CLEAR_ALL_GROUPING: 'Clear all Grouping',\r\n    TEXT_CLEAR_ALL_SORTING: 'Clear all Sorting',\r\n    TEXT_COLLAPSE_ALL_GROUPS: 'Collapse all Groups',\r\n    TEXT_CONTAINS: 'Contains',\r\n    TEXT_COLUMNS: 'Columns',\r\n    TEXT_COMMANDS: 'Commands',\r\n    TEXT_COPY: 'Copy',\r\n    TEXT_EQUALS: 'Equals',\r\n    TEXT_ENDS_WITH: 'Ends With',\r\n    TEXT_EXPAND_ALL_GROUPS: 'Expand all Groups',\r\n    TEXT_EXPORT_TO_CSV: 'Export in CSV format',\r\n    TEXT_EXPORT_TO_TEXT_FORMAT: 'Export in Text format (Tab delimited)',\r\n    TEXT_EXPORT_TO_EXCEL: 'Export to Excel',\r\n    TEXT_FORCE_FIT_COLUMNS: 'Force fit columns',\r\n    TEXT_GROUP_BY: 'Group By',\r\n    TEXT_HIDE_COLUMN: 'Hide Column',\r\n    TEXT_ITEMS: 'items',\r\n    TEXT_ITEMS_PER_PAGE: 'items per page',\r\n    TEXT_OF: 'of',\r\n    TEXT_OK: 'OK',\r\n    TEXT_LAST_UPDATE: 'Last Update',\r\n    TEXT_PAGE: 'Page',\r\n    TEXT_REFRESH_DATASET: 'Refresh Dataset',\r\n    TEXT_REMOVE_FILTER: 'Remove Filter',\r\n    TEXT_REMOVE_SORT: 'Remove Sort',\r\n    TEXT_SAVE: 'Save',\r\n    TEXT_SELECT_ALL: 'Select All',\r\n    TEXT_SYNCHRONOUS_RESIZE: 'Synchronous resize',\r\n    TEXT_SORT_ASCENDING: 'Sort Ascending',\r\n    TEXT_SORT_DESCENDING: 'Sort Descending',\r\n    TEXT_STARTS_WITH: 'Starts With',\r\n    TEXT_TOGGLE_FILTER_ROW: 'Toggle Filter Row',\r\n    TEXT_TOGGLE_PRE_HEADER_ROW: 'Toggle Pre-Header Row',\r\n    TEXT_X_OF_Y_SELECTED: '# of % selected',\r\n};\r\nConstants.VALIDATION_REQUIRED_FIELD = 'Field is required';\r\nConstants.VALIDATION_EDITOR_VALID_NUMBER = 'Please enter a valid number';\r\nConstants.VALIDATION_EDITOR_VALID_INTEGER = 'Please enter a valid integer number';\r\nConstants.VALIDATION_EDITOR_INTEGER_BETWEEN = 'Please enter a valid integer number between {{minValue}} and {{maxValue}}';\r\nConstants.VALIDATION_EDITOR_INTEGER_MAX = 'Please enter a valid integer number that is lower than {{maxValue}}';\r\nConstants.VALIDATION_EDITOR_INTEGER_MIN = 'Please enter a valid integer number that is greater than {{minValue}}';\r\nConstants.VALIDATION_EDITOR_NUMBER_BETWEEN = 'Please enter a valid number between {{minValue}} and {{maxValue}}';\r\nConstants.VALIDATION_EDITOR_NUMBER_MAX = 'Please enter a valid number that is lower than {{maxValue}}';\r\nConstants.VALIDATION_EDITOR_NUMBER_MIN = 'Please enter a valid number that is greater than {{minValue}}';\r\nConstants.VALIDATION_EDITOR_DECIMAL_BETWEEN = 'Please enter a valid number with a maximum of {{maxDecimal}} decimals';\n\nfunction exportWithFormatterWhenDefined(row, col, dataContext, columnDef, grid, exportOptions) {\r\n    let output = '';\r\n    let isEvaluatingFormatter = false;\r\n    // first check if there are any export options provided (as Grid Options)\r\n    if (exportOptions && exportOptions.hasOwnProperty('exportWithFormatter')) {\r\n        isEvaluatingFormatter = !!exportOptions.exportWithFormatter;\r\n    }\r\n    // second check if \"exportWithFormatter\" is provided in the column definition, if so it will have precendence over the Grid Options exportOptions\r\n    if (columnDef && columnDef.hasOwnProperty('exportWithFormatter')) {\r\n        isEvaluatingFormatter = !!columnDef.exportWithFormatter;\r\n    }\r\n    // did the user provide a Custom Formatter for the export\r\n    const exportCustomFormatter = (columnDef.exportCustomFormatter !== undefined) ? columnDef.exportCustomFormatter : undefined;\r\n    // does the field have the dot (.) notation and is a complex object? if so pull the first property name\r\n    const fieldId = columnDef.field || columnDef.id || '';\r\n    let fieldProperty = fieldId;\r\n    if (typeof columnDef.field === 'string' && columnDef.field.indexOf('.') > 0) {\r\n        const props = columnDef.field.split('.');\r\n        fieldProperty = (props.length > 0) ? props[0] : columnDef.field;\r\n    }\r\n    if (dataContext && dataContext.hasOwnProperty(fieldProperty) && exportCustomFormatter !== undefined) {\r\n        const formattedData = exportCustomFormatter(row, col, dataContext[fieldProperty], columnDef, dataContext, grid);\r\n        output = formattedData;\r\n        if (formattedData && typeof formattedData === 'object' && formattedData.hasOwnProperty('text')) {\r\n            output = formattedData.text;\r\n        }\r\n        if (output === null || output === undefined) {\r\n            output = '';\r\n        }\r\n    }\r\n    else if (isEvaluatingFormatter && dataContext.hasOwnProperty(fieldProperty) && columnDef.formatter) {\r\n        const formattedData = columnDef.formatter(row, col, dataContext[fieldProperty], columnDef, dataContext, grid);\r\n        output = formattedData;\r\n        if (formattedData && typeof formattedData === 'object' && formattedData.hasOwnProperty('text')) {\r\n            output = formattedData.text;\r\n        }\r\n        if (output === null || output === undefined) {\r\n            output = '';\r\n        }\r\n    }\r\n    else {\r\n        output = (!dataContext.hasOwnProperty(fieldProperty)) ? '' : dataContext[fieldProperty];\r\n        if (output === null || output === undefined) {\r\n            output = '';\r\n        }\r\n    }\r\n    return output;\r\n}\n\nconst moment$2 = moment_; // patch to fix rollup \"moment has no default export\" issue, document here https://github.com/rollup/rollup/issues/670\r\nlet ExcelExportService = class ExcelExportService {\r\n    constructor(translate) {\r\n        this.translate = translate;\r\n        this._fileFormat = FileType.xlsx;\r\n        this._hasGroupedItems = false;\r\n        this.onGridBeforeExportToExcel = new Subject();\r\n        this.onGridAfterExportToExcel = new Subject();\r\n    }\r\n    get datasetIdName() {\r\n        return this._gridOptions && this._gridOptions.datasetIdPropertyName || 'id';\r\n    }\r\n    /** Getter for the Grid Options pulled through the Grid Object */\r\n    get _gridOptions() {\r\n        return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};\r\n    }\r\n    /**\r\n     * Initialize the Export Service\r\n     * @param grid\r\n     * @param gridOptions\r\n     * @param dataView\r\n     */\r\n    init(grid, dataView) {\r\n        this._grid = grid;\r\n        this._dataView = dataView;\r\n        // get locales provided by user in forRoot or else use default English locales via the Constants\r\n        this._locales = this._gridOptions && this._gridOptions.locales || Constants.locales;\r\n        if (this._gridOptions.enableTranslate && (!this.translate || !this.translate.instant)) {\r\n            throw new Error('[Angular-Slickgrid] requires \"ngx-translate\" to be installed and configured when the grid option \"enableTranslate\" is enabled.');\r\n        }\r\n    }\r\n    /**\r\n     * Function to export the Grid result to an Excel CSV format using javascript for it to produce the CSV file.\r\n     * This is a WYSIWYG export to file output (What You See is What You Get)\r\n     *\r\n     * NOTES: The column position needs to match perfectly the JSON Object position because of the way we are pulling the data,\r\n     * which means that if any column(s) got moved in the UI, it has to be reflected in the JSON array output as well\r\n     *\r\n     * Example: exportToExcel({ format: FileType.csv, delimiter: DelimiterType.comma })\r\n     */\r\n    exportToExcel(options) {\r\n        if (!this._grid || !this._dataView) {\r\n            throw new Error('[Angular-Slickgrid] it seems that the SlickGrid & DataView objects are not initialized did you forget to enable the grid option flag \"enableExcelExport\"?');\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            this.onGridBeforeExportToExcel.next(true);\r\n            this._excelExportOptions = $.extend(true, {}, this._gridOptions.excelExportOptions, options);\r\n            this._fileFormat = this._excelExportOptions.format || FileType.xlsx;\r\n            // prepare the Excel Workbook & Sheet\r\n            this._workbook = new Workbook();\r\n            this._sheet = new Worksheet({ name: this._excelExportOptions.sheetName || 'Sheet1' });\r\n            // add any Excel Format/Stylesheet to current Workbook\r\n            this._stylesheet = this._workbook.getStyleSheet();\r\n            const boldFormatter = this._stylesheet.createFormat({ font: { bold: true } });\r\n            const stringFormatter = this._stylesheet.createFormat({ format: '@' });\r\n            const numberFormatter = this._stylesheet.createFormat({ format: '0' });\r\n            const usdFormatter = this._stylesheet.createFormat({ format: '$#,##0.00' });\r\n            this._stylesheetFormats = {\r\n                boldFormatter,\r\n                dollarFormatter: usdFormatter,\r\n                numberFormatter,\r\n                stringFormatter,\r\n            };\r\n            // get the CSV output from the grid data\r\n            const dataOutput = this.getDataOutput();\r\n            // trigger a download file\r\n            // wrap it into a setTimeout so that the EventAggregator has enough time to start a pre-process like showing a spinner\r\n            setTimeout(() => __awaiter(this, void 0, void 0, function* () {\r\n                try {\r\n                    if (this._gridOptions && this._gridOptions.excelExportOptions && this._gridOptions.excelExportOptions.customExcelHeader) {\r\n                        this._gridOptions.excelExportOptions.customExcelHeader(this._workbook, this._sheet);\r\n                    }\r\n                    const currentSheetData = this._sheet.data;\r\n                    let finalOutput = currentSheetData;\r\n                    if (Array.isArray(currentSheetData) && Array.isArray(dataOutput)) {\r\n                        finalOutput = this._sheet.data.concat(dataOutput);\r\n                    }\r\n                    this._sheet.setData(finalOutput);\r\n                    this._workbook.addWorksheet(this._sheet);\r\n                    const excelBlob = yield Builder.createFile(this._workbook, { type: 'blob' });\r\n                    const downloadOptions = {\r\n                        filename: `${this._excelExportOptions.filename}.${this._fileFormat}`,\r\n                        format: this._fileFormat\r\n                    };\r\n                    // start downloading but add the Blob property only on the start download not on the event itself\r\n                    this.startDownloadFile(Object.assign({}, downloadOptions, { blob: excelBlob, data: this._sheet.data }));\r\n                    this.onGridAfterExportToExcel.next(downloadOptions);\r\n                    resolve(true);\r\n                }\r\n                catch (error) {\r\n                    reject(error);\r\n                }\r\n            }));\r\n        });\r\n    }\r\n    /**\r\n     * Triggers download file with file format.\r\n     * IE(6-10) are not supported\r\n     * All other browsers will use plain javascript on client side to produce a file download.\r\n     * @param options\r\n     */\r\n    startDownloadFile(options) {\r\n        // IE(6-10) don't support javascript download and our service doesn't support either so throw an error, we have to make a round trip to the Web Server for exporting\r\n        if (navigator.appName === 'Microsoft Internet Explorer') {\r\n            throw new Error('Microsoft Internet Explorer 6 to 10 do not support javascript export to Excel. Please upgrade your browser.');\r\n        }\r\n        // when using IE/Edge, then use different download call\r\n        if (typeof navigator.msSaveOrOpenBlob === 'function') {\r\n            navigator.msSaveOrOpenBlob(options.blob, options.filename);\r\n        }\r\n        else {\r\n            // this trick will generate a temp <a /> tag\r\n            // the code will then trigger a hidden click for it to start downloading\r\n            const link = document && document.createElement('a');\r\n            const url = URL.createObjectURL(options.blob);\r\n            if (link && document) {\r\n                link.textContent = 'download';\r\n                link.href = url;\r\n                link.setAttribute('download', options.filename);\r\n                // set the visibility to hidden so there is no effect on your web-layout\r\n                link.style.visibility = 'hidden';\r\n                // this part will append the anchor tag, trigger a click (for download to start) and finally remove the tag once completed\r\n                document.body.appendChild(link);\r\n                link.click();\r\n                document.body.removeChild(link);\r\n            }\r\n        }\r\n    }\r\n    /** use different Excel Stylesheet Format as per the Field Type */\r\n    useCellFormatByFieldType(data, fieldType) {\r\n        let outputData = data;\r\n        switch (fieldType) {\r\n            case FieldType.dateTime:\r\n            case FieldType.dateTimeIso:\r\n            case FieldType.dateTimeShortIso:\r\n            case FieldType.dateTimeIsoAmPm:\r\n            case FieldType.dateTimeIsoAM_PM:\r\n            case FieldType.dateEuro:\r\n            case FieldType.dateEuroShort:\r\n            case FieldType.dateTimeEuro:\r\n            case FieldType.dateTimeShortEuro:\r\n            case FieldType.dateTimeEuroAmPm:\r\n            case FieldType.dateTimeEuroAM_PM:\r\n            case FieldType.dateTimeEuroShort:\r\n            case FieldType.dateTimeEuroShortAmPm:\r\n            case FieldType.dateUs:\r\n            case FieldType.dateUsShort:\r\n            case FieldType.dateTimeUs:\r\n            case FieldType.dateTimeShortUs:\r\n            case FieldType.dateTimeUsAmPm:\r\n            case FieldType.dateTimeUsAM_PM:\r\n            case FieldType.dateTimeUsShort:\r\n            case FieldType.dateTimeUsShortAmPm:\r\n            case FieldType.dateUtc:\r\n            case FieldType.date:\r\n            case FieldType.dateIso:\r\n                outputData = data;\r\n                if (data) {\r\n                    const defaultDateFormat = mapMomentDateFormatWithFieldType(fieldType);\r\n                    const isDateValid = moment$2(data, defaultDateFormat, false).isValid();\r\n                    const outputDate = (data && isDateValid) ? moment$2(data).format(defaultDateFormat) : data;\r\n                    const dateFormatter = this._stylesheet.createFormat({ format: defaultDateFormat });\r\n                    outputData = { value: outputDate, metadata: { style: dateFormatter.id } };\r\n                }\r\n                break;\r\n            case FieldType.number:\r\n                const val = isNaN(+data) ? null : data;\r\n                outputData = { value: val, metadata: { style: this._stylesheetFormats.numberFormatter.id } };\r\n                break;\r\n            default:\r\n                outputData = data;\r\n        }\r\n        return outputData;\r\n    }\r\n    // -----------------------\r\n    // Private functions\r\n    // -----------------------\r\n    getDataOutput() {\r\n        const columns = this._grid && this._grid.getColumns && this._grid.getColumns() || [];\r\n        // data variable which will hold all the fields data of a row\r\n        const outputData = [];\r\n        // get all column headers (it might include a \"Group by\" title at A1 cell)\r\n        outputData.push(this.getColumnHeaderData(columns, { style: this._stylesheetFormats.boldFormatter.id }));\r\n        // Populate the rest of the Grid Data\r\n        this.pushAllGridRowDataToArray(outputData, columns);\r\n        return outputData;\r\n    }\r\n    /** Get all column headers and format them in Bold */\r\n    getColumnHeaderData(columns, metadata) {\r\n        let outputHeaderTitles = [];\r\n        this._columnHeaders = this.getColumnHeaders(columns) || [];\r\n        if (this._columnHeaders && Array.isArray(this._columnHeaders) && this._columnHeaders.length > 0) {\r\n            // add the header row + add a new line at the end of the row\r\n            outputHeaderTitles = this._columnHeaders.map((header) => ({ value: header.title, metadata }));\r\n        }\r\n        // do we have a Group by title?\r\n        const groupTitle = this.getGroupColumnTitle();\r\n        if (groupTitle) {\r\n            outputHeaderTitles.unshift({ value: groupTitle, metadata });\r\n        }\r\n        return outputHeaderTitles;\r\n    }\r\n    getGroupColumnTitle() {\r\n        // Group By text, it could be set in the export options or from translation or if nothing is found then use the English constant text\r\n        let groupByColumnHeader = this._excelExportOptions.groupingColumnHeaderTitle;\r\n        if (!groupByColumnHeader && this._gridOptions.enableTranslate && this.translate && this.translate.currentLang && this.translate.instant) {\r\n            groupByColumnHeader = this.translate.instant('GROUP_BY');\r\n        }\r\n        else if (!groupByColumnHeader) {\r\n            groupByColumnHeader = this._locales && this._locales.TEXT_GROUP_BY;\r\n        }\r\n        // get grouped column titles and if found, we will add a \"Group by\" column at the first column index\r\n        // if it's a CSV format, we'll escape the text in double quotes\r\n        const grouping = this._dataView && this._dataView.getGrouping && this._dataView.getGrouping();\r\n        if (grouping && Array.isArray(grouping) && grouping.length > 0) {\r\n            this._hasGroupedItems = true;\r\n            return groupByColumnHeader;\r\n        }\r\n        else {\r\n            this._hasGroupedItems = false;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Get all header titles and their keys, translate the title when required.\r\n     * @param columns of the grid\r\n     */\r\n    getColumnHeaders(columns) {\r\n        if (!columns || !Array.isArray(columns) || columns.length === 0) {\r\n            return null;\r\n        }\r\n        const columnHeaders = [];\r\n        // Populate the Column Header, pull the name defined\r\n        columns.forEach((columnDef) => {\r\n            let headerTitle = '';\r\n            if ((columnDef.headerKey || columnDef.nameKey) && this._gridOptions.enableTranslate && this.translate && this.translate.currentLang && this.translate.instant) {\r\n                headerTitle = this.translate.instant((columnDef.headerKey || columnDef.nameKey));\r\n            }\r\n            else {\r\n                headerTitle = columnDef.name || titleCase(columnDef.field);\r\n            }\r\n            const skippedField = columnDef.excludeFromExport || false;\r\n            // if column width is 0, then we consider that field as a hidden field and should not be part of the export\r\n            if ((columnDef.width === undefined || columnDef.width > 0) && !skippedField) {\r\n                columnHeaders.push({\r\n                    key: columnDef.field || columnDef.id,\r\n                    title: headerTitle\r\n                });\r\n            }\r\n        });\r\n        return columnHeaders;\r\n    }\r\n    /**\r\n     * Get all the grid row data and return that as an output string\r\n     */\r\n    pushAllGridRowDataToArray(originalDaraArray, columns) {\r\n        const lineCount = this._dataView && this._dataView.getLength && this._dataView.getLength();\r\n        // loop through all the grid rows of data\r\n        for (let rowNumber = 0; rowNumber < lineCount; rowNumber++) {\r\n            const itemObj = this._dataView.getItem(rowNumber);\r\n            if (itemObj != null) {\r\n                // Normal row (not grouped by anything) would have an ID which was predefined in the Grid Columns definition\r\n                if (itemObj[this.datasetIdName] != null) {\r\n                    // get regular row item data\r\n                    originalDaraArray.push(this.readRegularRowData(columns, rowNumber, itemObj));\r\n                }\r\n                else if (this._hasGroupedItems && itemObj.__groupTotals === undefined) {\r\n                    // get the group row\r\n                    originalDaraArray.push([this.readGroupedTitleRow(itemObj)]);\r\n                }\r\n                else if (itemObj.__groupTotals) {\r\n                    // else if the row is a Group By and we have agreggators, then a property of '__groupTotals' would exist under that object\r\n                    originalDaraArray.push(this.readGroupedTotalRow(columns, itemObj));\r\n                }\r\n            }\r\n        }\r\n        return originalDaraArray;\r\n    }\r\n    /**\r\n     * Get the data of a regular row (a row without grouping)\r\n     * @param row\r\n     * @param itemObj\r\n     */\r\n    readRegularRowData(columns, row, itemObj) {\r\n        let idx = 0;\r\n        const rowOutputStrings = [];\r\n        for (let col = 0, ln = columns.length; col < ln; col++) {\r\n            const columnDef = columns[col];\r\n            const fieldType = columnDef.outputType || columnDef.type || FieldType.string;\r\n            // skip excluded column\r\n            if (columnDef.excludeFromExport) {\r\n                continue;\r\n            }\r\n            // if we are grouping and are on 1st column index, we need to skip this column since it will be used later by the grouping text:: Group by [columnX]\r\n            if (this._hasGroupedItems && idx === 0) {\r\n                rowOutputStrings.push('');\r\n            }\r\n            // get the output by analyzing if we'll pull the value from the cell or from a formatter\r\n            let itemData = exportWithFormatterWhenDefined(row, col, itemObj, columnDef, this._grid, this._excelExportOptions);\r\n            // does the user want to sanitize the output data (remove HTML tags)?\r\n            if (columnDef.sanitizeDataExport || this._excelExportOptions.sanitizeDataExport) {\r\n                itemData = sanitizeHtmlToText(itemData);\r\n            }\r\n            // use different Excel Stylesheet Format as per the Field Type\r\n            if (!columnDef.exportWithFormatter) {\r\n                itemData = this.useCellFormatByFieldType(itemData, fieldType);\r\n            }\r\n            rowOutputStrings.push(itemData);\r\n            idx++;\r\n        }\r\n        return rowOutputStrings;\r\n    }\r\n    /**\r\n     * Get the grouped title(s) and its group title formatter, for example if we grouped by salesRep, the returned result would be:: 'Sales Rep: John Dow (2 items)'\r\n     * @param itemObj\r\n     */\r\n    readGroupedTitleRow(itemObj) {\r\n        const groupName = sanitizeHtmlToText(itemObj.title);\r\n        if (this._excelExportOptions && this._excelExportOptions.addGroupIndentation) {\r\n            const collapsedSymbol = this._excelExportOptions && this._excelExportOptions.groupCollapsedSymbol || '\\u25B9';\r\n            const expandedSymbol = this._excelExportOptions && this._excelExportOptions.groupExpandedSymbol || '\\u25BF';\r\n            const chevron = itemObj.collapsed ? collapsedSymbol : expandedSymbol;\r\n            return chevron + ' ' + addWhiteSpaces(5 * itemObj.level) + groupName;\r\n        }\r\n        return groupName;\r\n    }\r\n    /**\r\n     * Get the grouped totals (below the regular rows), these are set by Slick Aggregators.\r\n     * For example if we grouped by \"salesRep\" and we have a Sum Aggregator on \"sales\", then the returned output would be:: [\"Sum 123$\"]\r\n     * @param itemObj\r\n     */\r\n    readGroupedTotalRow(columns, itemObj) {\r\n        const groupingAggregatorRowText = this._excelExportOptions.groupingAggregatorRowText || '';\r\n        const outputStrings = [groupingAggregatorRowText];\r\n        columns.forEach((columnDef) => {\r\n            let itemData = '';\r\n            const skippedField = columnDef.excludeFromExport || false;\r\n            // if there's a groupTotalsFormatter, we will re-run it to get the exact same output as what is shown in UI\r\n            if (columnDef.groupTotalsFormatter) {\r\n                itemData = columnDef.groupTotalsFormatter(itemObj, columnDef);\r\n            }\r\n            // does the user want to sanitize the output data (remove HTML tags)?\r\n            if (columnDef.sanitizeDataExport || this._excelExportOptions.sanitizeDataExport) {\r\n                itemData = sanitizeHtmlToText(itemData);\r\n            }\r\n            // add the column (unless user wants to skip it)\r\n            if ((columnDef.width === undefined || columnDef.width > 0) && !skippedField) {\r\n                outputStrings.push(itemData);\r\n            }\r\n        });\r\n        return outputStrings;\r\n    }\r\n};\r\nExcelExportService = __decorate([\r\n    Injectable(),\r\n    __param(0, Optional()),\r\n    __metadata(\"design:paramtypes\", [TranslateService])\r\n], ExcelExportService);\n\nlet ExportService = class ExportService {\r\n    constructor(translate) {\r\n        this.translate = translate;\r\n        this._delimiter = ',';\r\n        this._fileFormat = FileType.csv;\r\n        this._lineCarriageReturn = '\\n';\r\n        this._exportQuoteWrapper = '';\r\n        this._hasGroupedItems = false;\r\n        this.onGridBeforeExportToFile = new Subject();\r\n        this.onGridAfterExportToFile = new Subject();\r\n    }\r\n    get datasetIdName() {\r\n        return this._gridOptions && this._gridOptions.datasetIdPropertyName || 'id';\r\n    }\r\n    /** Getter for the Grid Options pulled through the Grid Object */\r\n    get _gridOptions() {\r\n        return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};\r\n    }\r\n    /**\r\n     * Initialize the Export Service\r\n     * @param grid\r\n     * @param gridOptions\r\n     * @param dataView\r\n     */\r\n    init(grid, dataView) {\r\n        this._grid = grid;\r\n        this._dataView = dataView;\r\n        // get locales provided by user in forRoot or else use default English locales via the Constants\r\n        this._locales = this._gridOptions && this._gridOptions.locales || Constants.locales;\r\n        if (this._gridOptions.enableTranslate && (!this.translate || !this.translate.instant)) {\r\n            throw new Error('[Angular-Slickgrid] requires \"ngx-translate\" to be installed and configured when the grid option \"enableTranslate\" is enabled.');\r\n        }\r\n    }\r\n    /**\r\n     * Function to export the Grid result to an Excel CSV format using javascript for it to produce the CSV file.\r\n     * This is a WYSIWYG export to file output (What You See is What You Get)\r\n     *\r\n     * NOTES: The column position needs to match perfectly the JSON Object position because of the way we are pulling the data,\r\n     * which means that if any column(s) got moved in the UI, it has to be reflected in the JSON array output as well\r\n     *\r\n     * Example: exportToFile({ format: FileType.csv, delimiter: DelimiterType.comma })\r\n     */\r\n    exportToFile(options) {\r\n        if (!this._grid || !this._dataView) {\r\n            throw new Error('[Angular-Slickgrid] it seems that the SlickGrid & DataView objects are not initialized did you forget to enable the grid option flag \"enableExcelExport\"?');\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            this.onGridBeforeExportToFile.next(true);\r\n            this._exportOptions = $.extend(true, {}, this._gridOptions.exportOptions, options);\r\n            this._delimiter = this._exportOptions.delimiterOverride || this._exportOptions.delimiter || '';\r\n            this._fileFormat = this._exportOptions.format || FileType.csv;\r\n            // get the CSV output from the grid data\r\n            const dataOutput = this.getDataOutput();\r\n            // trigger a download file\r\n            // wrap it into a setTimeout so that the EventAggregator has enough time to start a pre-process like showing a spinner\r\n            setTimeout(() => {\r\n                try {\r\n                    const downloadOptions = {\r\n                        filename: `${this._exportOptions.filename}.${this._fileFormat}`,\r\n                        format: this._fileFormat,\r\n                        useUtf8WithBom: this._exportOptions.hasOwnProperty('useUtf8WithBom') ? this._exportOptions.useUtf8WithBom : true\r\n                    };\r\n                    // start downloading but add the content property only on the start download not on the event itself\r\n                    this.startDownloadFile(Object.assign({}, downloadOptions, { content: dataOutput })); // add content property\r\n                    this.onGridAfterExportToFile.next(downloadOptions);\r\n                    resolve(true);\r\n                }\r\n                catch (error) {\r\n                    reject(error);\r\n                }\r\n            }, 0);\r\n        });\r\n    }\r\n    /**\r\n     * Triggers download file with file format.\r\n     * IE(6-10) are not supported\r\n     * All other browsers will use plain javascript on client side to produce a file download.\r\n     * @param options\r\n     */\r\n    startDownloadFile(options) {\r\n        // IE(6-10) don't support javascript download and our service doesn't support either so throw an error, we have to make a round trip to the Web Server for exporting\r\n        if (navigator.appName === 'Microsoft Internet Explorer') {\r\n            throw new Error('Microsoft Internet Explorer 6 to 10 do not support javascript export to CSV. Please upgrade your browser.');\r\n        }\r\n        // set the correct MIME type\r\n        const mimeType = (options.format === FileType.csv) ? 'text/csv' : 'text/plain';\r\n        // make sure no html entities exist in the data\r\n        const dataContent = htmlEntityDecode(options.content);\r\n        // dealing with Excel CSV export and UTF-8 is a little tricky.. We will use Option #2 to cover older Excel versions\r\n        // Option #1: we need to make Excel knowing that it's dealing with an UTF-8, A correctly formatted UTF8 file can have a Byte Order Mark as its first three octets\r\n        // reference: http://stackoverflow.com/questions/155097/microsoft-excel-mangles-diacritics-in-csv-files\r\n        // Option#2: use a 3rd party extension to javascript encode into UTF-16\r\n        let outputData;\r\n        if (options.format === FileType.csv) {\r\n            outputData = new TextEncoder('utf-8').encode(dataContent);\r\n        }\r\n        else {\r\n            outputData = dataContent;\r\n        }\r\n        // create a Blob object for the download\r\n        const blob = new Blob([options.useUtf8WithBom ? '\\uFEFF' : '', outputData], {\r\n            type: `${mimeType};charset=utf-8;`\r\n        });\r\n        // when using IE/Edge, then use different download call\r\n        if (typeof navigator.msSaveOrOpenBlob === 'function') {\r\n            navigator.msSaveOrOpenBlob(blob, options.filename);\r\n        }\r\n        else {\r\n            // this trick will generate a temp <a /> tag\r\n            // the code will then trigger a hidden click for it to start downloading\r\n            const link = document.createElement('a');\r\n            const csvUrl = URL.createObjectURL(blob);\r\n            link.textContent = 'download';\r\n            link.href = csvUrl;\r\n            link.setAttribute('download', options.filename);\r\n            // set the visibility to hidden so there is no effect on your web-layout\r\n            link.style.visibility = 'hidden';\r\n            // this part will append the anchor tag, trigger a click (for download to start) and finally remove the tag once completed\r\n            document.body.appendChild(link);\r\n            link.click();\r\n            document.body.removeChild(link);\r\n        }\r\n    }\r\n    // -----------------------\r\n    // Private functions\r\n    // -----------------------\r\n    getDataOutput() {\r\n        const columns = this._grid.getColumns() || [];\r\n        // Group By text, it could be set in the export options or from translation or if nothing is found then use the English constant text\r\n        let groupByColumnHeader = this._exportOptions.groupingColumnHeaderTitle;\r\n        if (!groupByColumnHeader && this._gridOptions.enableTranslate && this.translate && this.translate.currentLang && this.translate.instant) {\r\n            groupByColumnHeader = this.translate.instant('GROUP_BY');\r\n        }\r\n        else if (!groupByColumnHeader) {\r\n            groupByColumnHeader = this._locales && this._locales.TEXT_GROUP_BY;\r\n        }\r\n        // a CSV needs double quotes wrapper, the other types do not need any wrapper\r\n        this._exportQuoteWrapper = (this._fileFormat === FileType.csv) ? '\"' : '';\r\n        // data variable which will hold all the fields data of a row\r\n        let outputDataString = '';\r\n        // get grouped column titles and if found, we will add a \"Group by\" column at the first column index\r\n        // if it's a CSV format, we'll escape the text in double quotes\r\n        const grouping = this._dataView.getGrouping();\r\n        if (grouping && Array.isArray(grouping) && grouping.length > 0) {\r\n            this._hasGroupedItems = true;\r\n            outputDataString += (this._fileFormat === FileType.csv) ? `\"${groupByColumnHeader}\"${this._delimiter}` : `${groupByColumnHeader}${this._delimiter}`;\r\n        }\r\n        else {\r\n            this._hasGroupedItems = false;\r\n        }\r\n        // get all column headers\r\n        this._columnHeaders = this.getColumnHeaders(columns) || [];\r\n        if (this._columnHeaders && Array.isArray(this._columnHeaders) && this._columnHeaders.length > 0) {\r\n            // add the header row + add a new line at the end of the row\r\n            const outputHeaderTitles = this._columnHeaders.map((header) => {\r\n                return this._exportQuoteWrapper + header.title + this._exportQuoteWrapper;\r\n            });\r\n            outputDataString += (outputHeaderTitles.join(this._delimiter) + this._lineCarriageReturn);\r\n        }\r\n        // Populate the rest of the Grid Data\r\n        outputDataString += this.getAllGridRowData(columns, this._lineCarriageReturn);\r\n        return outputDataString;\r\n    }\r\n    /**\r\n     * Get all the grid row data and return that as an output string\r\n     */\r\n    getAllGridRowData(columns, lineCarriageReturn) {\r\n        const outputDataStrings = [];\r\n        const lineCount = this._dataView.getLength();\r\n        // loop through all the grid rows of data\r\n        for (let rowNumber = 0; rowNumber < lineCount; rowNumber++) {\r\n            const itemObj = this._dataView.getItem(rowNumber);\r\n            if (itemObj != null) {\r\n                // Normal row (not grouped by anything) would have an ID which was predefined in the Grid Columns definition\r\n                if (itemObj[this.datasetIdName] != null) {\r\n                    // get regular row item data\r\n                    outputDataStrings.push(this.readRegularRowData(columns, rowNumber, itemObj));\r\n                }\r\n                else if (this._hasGroupedItems && itemObj.__groupTotals === undefined) {\r\n                    // get the group row\r\n                    outputDataStrings.push(this.readGroupedTitleRow(itemObj));\r\n                }\r\n                else if (itemObj.__groupTotals) {\r\n                    // else if the row is a Group By and we have agreggators, then a property of '__groupTotals' would exist under that object\r\n                    outputDataStrings.push(this.readGroupedTotalRow(columns, itemObj));\r\n                }\r\n            }\r\n        }\r\n        return outputDataStrings.join(lineCarriageReturn);\r\n    }\r\n    /**\r\n     * Get all header titles and their keys, translate the title when required.\r\n     * @param columns of the grid\r\n     */\r\n    getColumnHeaders(columns) {\r\n        if (!columns || !Array.isArray(columns) || columns.length === 0) {\r\n            return null;\r\n        }\r\n        const columnHeaders = [];\r\n        // Populate the Column Header, pull the name defined\r\n        columns.forEach((columnDef) => {\r\n            let headerTitle = '';\r\n            if ((columnDef.headerKey || columnDef.nameKey) && this._gridOptions.enableTranslate && this.translate && this.translate.currentLang && this.translate.instant) {\r\n                headerTitle = this.translate.instant((columnDef.headerKey || columnDef.nameKey));\r\n            }\r\n            else {\r\n                headerTitle = columnDef.name || titleCase(columnDef.field);\r\n            }\r\n            const skippedField = columnDef.excludeFromExport || false;\r\n            // if column width is 0, then we consider that field as a hidden field and should not be part of the export\r\n            if ((columnDef.width === undefined || columnDef.width > 0) && !skippedField) {\r\n                columnHeaders.push({\r\n                    key: columnDef.field || columnDef.id,\r\n                    title: headerTitle\r\n                });\r\n            }\r\n        });\r\n        return columnHeaders;\r\n    }\r\n    /**\r\n     * Get the data of a regular row (a row without grouping)\r\n     * @param row\r\n     * @param itemObj\r\n     */\r\n    readRegularRowData(columns, row, itemObj) {\r\n        let idx = 0;\r\n        const rowOutputStrings = [];\r\n        const exportQuoteWrapper = this._exportQuoteWrapper;\r\n        for (let col = 0, ln = columns.length; col < ln; col++) {\r\n            const columnDef = columns[col];\r\n            // skip excluded column\r\n            if (columnDef.excludeFromExport) {\r\n                continue;\r\n            }\r\n            // if we are grouping and are on 1st column index, we need to skip this column since it will be used later by the grouping text:: Group by [columnX]\r\n            if (this._hasGroupedItems && idx === 0) {\r\n                const emptyValue = this._fileFormat === FileType.csv ? `\"\"` : '';\r\n                rowOutputStrings.push(emptyValue);\r\n            }\r\n            // get the output by analyzing if we'll pull the value from the cell or from a formatter\r\n            let itemData = exportWithFormatterWhenDefined(row, col, itemObj, columnDef, this._grid, this._exportOptions);\r\n            // does the user want to sanitize the output data (remove HTML tags)?\r\n            if (columnDef.sanitizeDataExport || this._exportOptions.sanitizeDataExport) {\r\n                itemData = sanitizeHtmlToText(itemData);\r\n            }\r\n            // when CSV we also need to escape double quotes twice, so \" becomes \"\"\r\n            if (this._fileFormat === FileType.csv && itemData) {\r\n                itemData = itemData.toString().replace(/\"/gi, `\"\"`);\r\n            }\r\n            // do we have a wrapper to keep as a string? in certain cases like \"1E06\", we don't want excel to transform it into exponential (1.0E06)\r\n            // to cancel that effect we can had = in front, ex: =\"1E06\"\r\n            const keepAsStringWrapper = (columnDef && columnDef.exportCsvForceToKeepAsString) ? '=' : '';\r\n            rowOutputStrings.push(keepAsStringWrapper + exportQuoteWrapper + itemData + exportQuoteWrapper);\r\n            idx++;\r\n        }\r\n        return rowOutputStrings.join(this._delimiter);\r\n    }\r\n    /**\r\n     * Get the grouped title(s) and its group title formatter, for example if we grouped by salesRep, the returned result would be:: 'Sales Rep: John Dow (2 items)'\r\n     * @param itemObj\r\n     */\r\n    readGroupedTitleRow(itemObj) {\r\n        let groupName = sanitizeHtmlToText(itemObj.title);\r\n        const exportQuoteWrapper = this._exportQuoteWrapper;\r\n        groupName = addWhiteSpaces(5 * itemObj.level) + groupName;\r\n        if (this._fileFormat === FileType.csv) {\r\n            // when CSV we also need to escape double quotes twice, so \" becomes \"\"\r\n            groupName = groupName.toString().replace(/\"/gi, `\"\"`);\r\n        }\r\n        return exportQuoteWrapper + groupName + exportQuoteWrapper;\r\n    }\r\n    /**\r\n     * Get the grouped totals (below the regular rows), these are set by Slick Aggregators.\r\n     * For example if we grouped by \"salesRep\" and we have a Sum Aggregator on \"sales\", then the returned output would be:: [\"Sum 123$\"]\r\n     * @param itemObj\r\n     */\r\n    readGroupedTotalRow(columns, itemObj) {\r\n        const delimiter = this._exportOptions.delimiter;\r\n        const format = this._exportOptions.format;\r\n        const groupingAggregatorRowText = this._exportOptions.groupingAggregatorRowText || '';\r\n        const exportQuoteWrapper = this._exportQuoteWrapper;\r\n        const outputStrings = [`${exportQuoteWrapper}${groupingAggregatorRowText}${exportQuoteWrapper}`];\r\n        columns.forEach((columnDef) => {\r\n            let itemData = '';\r\n            const skippedField = columnDef.excludeFromExport || false;\r\n            // if there's a groupTotalsFormatter, we will re-run it to get the exact same output as what is shown in UI\r\n            if (columnDef.groupTotalsFormatter) {\r\n                itemData = columnDef.groupTotalsFormatter(itemObj, columnDef);\r\n            }\r\n            // does the user want to sanitize the output data (remove HTML tags)?\r\n            if (columnDef.sanitizeDataExport || this._exportOptions.sanitizeDataExport) {\r\n                itemData = sanitizeHtmlToText(itemData);\r\n            }\r\n            if (format === FileType.csv) {\r\n                // when CSV we also need to escape double quotes twice, so a double quote \" becomes 2x double quotes \"\"\r\n                itemData = itemData.toString().replace(/\"/gi, `\"\"`);\r\n            }\r\n            // add the column (unless user wants to skip it)\r\n            if ((columnDef.width === undefined || columnDef.width > 0) && !skippedField) {\r\n                outputStrings.push(exportQuoteWrapper + itemData + exportQuoteWrapper);\r\n            }\r\n        });\r\n        return outputStrings.join(delimiter);\r\n    }\r\n};\r\nExportService = __decorate([\r\n    Injectable(),\r\n    __param(0, Optional()),\r\n    __metadata(\"design:paramtypes\", [TranslateService])\r\n], ExportService);\n\nclass SharedService {\r\n    constructor() {\r\n        this.onColumnsChanged = new Subject();\r\n    }\r\n    // --\r\n    // public\r\n    /** Getter for All Columns  in the grid (hidden/visible) */\r\n    get allColumns() {\r\n        return this._allColumns;\r\n    }\r\n    /** Setter for All Columns  in the grid (hidden/visible) */\r\n    set allColumns(allColumns) {\r\n        this._allColumns = allColumns;\r\n    }\r\n    /** Getter for the Column Definitions pulled through the Grid Object */\r\n    get columnDefinitions() {\r\n        return (this._grid && this._grid.getColumns) ? this._grid.getColumns() : [];\r\n    }\r\n    /** Getter for the Current Pagination (when Pagination is enabled) */\r\n    get currentPagination() {\r\n        return this._currentPagination;\r\n    }\r\n    /** Setter for the Current Pagination (when Pagination is enabled) */\r\n    set currentPagination(currentPagination) {\r\n        this._currentPagination = currentPagination;\r\n    }\r\n    /** Getter for SlickGrid DataView object */\r\n    get dataView() {\r\n        return this._dataView;\r\n    }\r\n    /** Setter for SlickGrid DataView object */\r\n    set dataView(dataView) {\r\n        this._dataView = dataView;\r\n    }\r\n    /** Getter for SlickGrid Grid object */\r\n    get grid() {\r\n        return this._grid;\r\n    }\r\n    /** Setter for SlickGrid Grid object */\r\n    set grid(grid) {\r\n        this._grid = grid;\r\n    }\r\n    /** Getter for the Grid Options pulled through the Grid Object */\r\n    get gridOptions() {\r\n        return this._gridOptions || this._grid && this._grid.getOptions && this._grid.getOptions() || {};\r\n    }\r\n    /** Setter for the Grid Options pulled through the Grid Object */\r\n    set gridOptions(gridOptions) {\r\n        this._gridOptions = gridOptions;\r\n    }\r\n    /** Getter for the Grid Options */\r\n    get groupItemMetadataProvider() {\r\n        return this._groupItemMetadataProvider;\r\n    }\r\n    /** Setter for the Grid Options */\r\n    set groupItemMetadataProvider(groupItemMetadataProvider) {\r\n        this._groupItemMetadataProvider = groupItemMetadataProvider;\r\n    }\r\n    /** Getter for the Visible Columns in the grid */\r\n    get visibleColumns() {\r\n        return this._visibleColumns;\r\n    }\r\n    /** Setter for the Visible Columns in the grid */\r\n    set visibleColumns(visibleColumns) {\r\n        this._visibleColumns = visibleColumns;\r\n    }\r\n}\n\nlet ExtensionUtility = class ExtensionUtility {\r\n    constructor(sharedService, translate) {\r\n        this.sharedService = sharedService;\r\n        this.translate = translate;\r\n    }\r\n    /**\r\n     * Remove a column from the grid by it's index in the grid\r\n     * @param array input\r\n     * @param index\r\n     */\r\n    arrayRemoveItemByIndex(array, index) {\r\n        return array.filter((el, i) => index !== i);\r\n    }\r\n    /**\r\n     * Load SlickGrid Extension (Control/Plugin) dynamically (on demand)\r\n     * This will basically only load the extension when user enables the feature\r\n     * @param extensionName\r\n     */\r\n    loadExtensionDynamically(extensionName) {\r\n        try {\r\n            switch (extensionName) {\r\n                case ExtensionName.autoTooltip:\r\n                    require('slickgrid/plugins/slick.autotooltips');\r\n                    break;\r\n                case ExtensionName.cellExternalCopyManager:\r\n                    require('slickgrid/plugins/slick.cellexternalcopymanager');\r\n                    break;\r\n                case ExtensionName.checkboxSelector:\r\n                    require('slickgrid/plugins/slick.checkboxselectcolumn');\r\n                    break;\r\n                case ExtensionName.cellMenu:\r\n                    require('slickgrid/plugins/slick.cellmenu');\r\n                    break;\r\n                case ExtensionName.columnPicker:\r\n                    require('slickgrid/controls/slick.columnpicker');\r\n                    break;\r\n                case ExtensionName.contextMenu:\r\n                    require('slickgrid/plugins/slick.contextmenu');\r\n                    break;\r\n                case ExtensionName.draggableGrouping:\r\n                    require('slickgrid/plugins/slick.draggablegrouping');\r\n                    break;\r\n                case ExtensionName.gridMenu:\r\n                    require('slickgrid/controls/slick.gridmenu');\r\n                    break;\r\n                case ExtensionName.groupItemMetaProvider:\r\n                    require('slickgrid/slick.groupitemmetadataprovider');\r\n                    break;\r\n                case ExtensionName.headerButton:\r\n                    require('slickgrid/plugins/slick.headerbuttons');\r\n                    break;\r\n                case ExtensionName.headerMenu:\r\n                    require('slickgrid/plugins/slick.headermenu');\r\n                    break;\r\n                case ExtensionName.rowSelection:\r\n                    require('slickgrid/plugins/slick.rowselectionmodel');\r\n                    break;\r\n                case ExtensionName.rowDetailView:\r\n                    require('slickgrid/plugins/slick.rowdetailview');\r\n                    break;\r\n                case ExtensionName.rowMoveManager:\r\n                    require('slickgrid/plugins/slick.rowmovemanager');\r\n                    break;\r\n            }\r\n        }\r\n        catch (e) {\r\n            // do nothing, we fall here when using Angular and RequireJS\r\n        }\r\n    }\r\n    /**\r\n     * From a Grid Menu object property name, we will return the correct title output string following this order\r\n     * 1- if user provided a title, use it as the output title\r\n     * 2- else if user provided a title key, use it to translate the output title\r\n     * 3- else if nothing is provided use text defined as constants\r\n     */\r\n    getPickerTitleOutputString(propName, pickerName) {\r\n        if (this.sharedService.gridOptions && this.sharedService.gridOptions.enableTranslate && (!this.translate || !this.translate.instant)) {\r\n            throw new Error('[Angular-Slickgrid] requires \"ngx-translate\" to be installed and configured when the grid option \"enableTranslate\" is enabled.');\r\n        }\r\n        let output = '';\r\n        const picker = this.sharedService.gridOptions && this.sharedService.gridOptions[pickerName] || {};\r\n        const enableTranslate = this.sharedService.gridOptions && this.sharedService.gridOptions.enableTranslate || false;\r\n        // get locales provided by user in forRoot or else use default English locales via the Constants\r\n        const locales = this.sharedService && this.sharedService.gridOptions && this.sharedService.gridOptions.locales || Constants.locales;\r\n        const title = picker && picker[propName];\r\n        const titleKey = picker && picker[`${propName}Key`];\r\n        if (titleKey && this.translate && this.translate.currentLang && this.translate.instant) {\r\n            output = this.translate.instant(titleKey || ' ');\r\n        }\r\n        else {\r\n            switch (propName) {\r\n                case 'customTitle':\r\n                    output = title || enableTranslate && this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant('COMMANDS' ) || locales && locales.TEXT_COMMANDS;\r\n                    break;\r\n                case 'columnTitle':\r\n                    output = title || enableTranslate && this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant('COLUMNS' ) || locales && locales.TEXT_COLUMNS;\r\n                    break;\r\n                case 'forceFitTitle':\r\n                    output = title || enableTranslate && this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant('FORCE_FIT_COLUMNS' ) || locales && locales.TEXT_FORCE_FIT_COLUMNS;\r\n                    break;\r\n                case 'syncResizeTitle':\r\n                    output = title || enableTranslate && this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant('SYNCHRONOUS_RESIZE' ) || locales && locales.TEXT_SYNCHRONOUS_RESIZE;\r\n                    break;\r\n                default:\r\n                    output = title;\r\n                    break;\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n    /**\r\n     * Sort items (by pointers) in an array by a property name\r\n     * @params items array\r\n     * @param property name to sort with\r\n     */\r\n    sortItems(items, propertyName) {\r\n        // sort the custom items by their position in the list\r\n        if (Array.isArray(items)) {\r\n            items.sort((itemA, itemB) => {\r\n                if (itemA && itemB && itemA.hasOwnProperty(propertyName) && itemB.hasOwnProperty(propertyName)) {\r\n                    return itemA[propertyName] - itemB[propertyName];\r\n                }\r\n                return 0;\r\n            });\r\n        }\r\n    }\r\n    /** Translate the an array of items from an input key and assign to the output key */\r\n    translateItems(items, inputKey, outputKey) {\r\n        if (Array.isArray(items)) {\r\n            for (const item of items) {\r\n                if (item[inputKey]) {\r\n                    item[outputKey] = this.translate && this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant(item[inputKey]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * When \"enabledTranslate\" is set to True, we will try to translate if the Translate Service exist or use the Locales when not\r\n     * @param translationKey\r\n     * @param localeKey\r\n     */\r\n    translateWhenEnabledAndServiceExist(translationKey, localeKey) {\r\n        let text = '';\r\n        const gridOptions = this.sharedService && this.sharedService.gridOptions;\r\n        // get locales provided by user in main file or else use default English locales via the Constants\r\n        const locales = gridOptions && gridOptions.locales || Constants.locales;\r\n        if (gridOptions.enableTranslate && this.translate && this.translate.currentLang && this.translate.instant) {\r\n            text = this.translate.instant(translationKey || ' ');\r\n        }\r\n        else if (locales && locales.hasOwnProperty(localeKey)) {\r\n            text = locales[localeKey];\r\n        }\r\n        else {\r\n            text = localeKey;\r\n        }\r\n        return text;\r\n    }\r\n};\r\nExtensionUtility = __decorate([\r\n    Injectable(),\r\n    __param(1, Optional()),\r\n    __metadata(\"design:paramtypes\", [SharedService, TranslateService])\r\n], ExtensionUtility);\n\nlet AutoTooltipExtension = class AutoTooltipExtension {\r\n    constructor(extensionUtility, sharedService) {\r\n        this.extensionUtility = extensionUtility;\r\n        this.sharedService = sharedService;\r\n    }\r\n    dispose() {\r\n        if (this._addon && this._addon.destroy) {\r\n            this._addon.destroy();\r\n        }\r\n    }\r\n    /** Get the instance of the SlickGrid addon (control or plugin). */\r\n    getAddonInstance() {\r\n        return this._addon;\r\n    }\r\n    register() {\r\n        if (this.sharedService && this.sharedService.grid && this.sharedService.gridOptions) {\r\n            // dynamically import the SlickGrid plugin (addon) with RequireJS\r\n            this.extensionUtility.loadExtensionDynamically(ExtensionName.autoTooltip);\r\n            this._addon = new Slick.AutoTooltips(this.sharedService.gridOptions.autoTooltipOptions || {});\r\n            this.sharedService.grid.registerPlugin(this._addon);\r\n            return this._addon;\r\n        }\r\n        return null;\r\n    }\r\n};\r\nAutoTooltipExtension = __decorate([\r\n    Injectable(),\r\n    __metadata(\"design:paramtypes\", [ExtensionUtility, SharedService])\r\n], AutoTooltipExtension);\n\nlet CellExternalCopyManagerExtension = class CellExternalCopyManagerExtension {\r\n    constructor(extensionUtility, sharedService) {\r\n        this.extensionUtility = extensionUtility;\r\n        this.sharedService = sharedService;\r\n        this._eventHandler = new Slick.EventHandler();\r\n    }\r\n    get addonOptions() {\r\n        return this._addonOptions;\r\n    }\r\n    get eventHandler() {\r\n        return this._eventHandler;\r\n    }\r\n    get commandQueue() {\r\n        return this._commandQueue;\r\n    }\r\n    get undoRedoBuffer() {\r\n        return this._undoRedoBuffer;\r\n    }\r\n    dispose() {\r\n        // unsubscribe all SlickGrid events\r\n        this._eventHandler.unsubscribeAll();\r\n        if (this._addon && this._addon.destroy) {\r\n            this._addon.destroy();\r\n        }\r\n    }\r\n    /** Get the instance of the SlickGrid addon (control or plugin). */\r\n    getAddonInstance() {\r\n        return this._addon;\r\n    }\r\n    register() {\r\n        if (this.sharedService && this.sharedService.grid && this.sharedService.gridOptions) {\r\n            // dynamically import the SlickGrid plugin (addon) with RequireJS\r\n            this.extensionUtility.loadExtensionDynamically(ExtensionName.cellExternalCopyManager);\r\n            this.createUndoRedoBuffer();\r\n            this.hookUndoShortcutKey();\r\n            this._addonOptions = Object.assign({}, this.getDefaultOptions(), this.sharedService.gridOptions.excelCopyBufferOptions);\r\n            this.sharedService.grid.setSelectionModel(new Slick.CellSelectionModel());\r\n            this._addon = new Slick.CellExternalCopyManager(this._addonOptions);\r\n            this.sharedService.grid.registerPlugin(this._addon);\r\n            // hook to all possible events\r\n            if (this.sharedService.grid && this.sharedService.gridOptions.excelCopyBufferOptions) {\r\n                if (this.sharedService.gridOptions.excelCopyBufferOptions.onExtensionRegistered) {\r\n                    this.sharedService.gridOptions.excelCopyBufferOptions.onExtensionRegistered(this._addon);\r\n                }\r\n                this._eventHandler.subscribe(this._addon.onCopyCells, (e, args) => {\r\n                    if (this.sharedService.gridOptions.excelCopyBufferOptions && typeof this.sharedService.gridOptions.excelCopyBufferOptions.onCopyCells === 'function') {\r\n                        this.sharedService.gridOptions.excelCopyBufferOptions.onCopyCells(e, args);\r\n                    }\r\n                });\r\n                this._eventHandler.subscribe(this._addon.onCopyCancelled, (e, args) => {\r\n                    if (this.sharedService.gridOptions.excelCopyBufferOptions && typeof this.sharedService.gridOptions.excelCopyBufferOptions.onCopyCancelled === 'function') {\r\n                        this.sharedService.gridOptions.excelCopyBufferOptions.onCopyCancelled(e, args);\r\n                    }\r\n                });\r\n                this._eventHandler.subscribe(this._addon.onPasteCells, (e, args) => {\r\n                    if (this.sharedService.gridOptions.excelCopyBufferOptions && typeof this.sharedService.gridOptions.excelCopyBufferOptions.onPasteCells === 'function') {\r\n                        this.sharedService.gridOptions.excelCopyBufferOptions.onPasteCells(e, args);\r\n                    }\r\n                });\r\n            }\r\n            return this._addon;\r\n        }\r\n        return null;\r\n    }\r\n    /** Create an undo redo buffer used by the Excel like copy */\r\n    createUndoRedoBuffer() {\r\n        let commandCtr = 0;\r\n        this._commandQueue = [];\r\n        this._undoRedoBuffer = {\r\n            queueAndExecuteCommand: (editCommand) => {\r\n                this._commandQueue[commandCtr] = editCommand;\r\n                commandCtr++;\r\n                editCommand.execute();\r\n            },\r\n            undo: () => {\r\n                if (commandCtr === 0) {\r\n                    return;\r\n                }\r\n                commandCtr--;\r\n                const command = this._commandQueue[commandCtr];\r\n                if (command && Slick.GlobalEditorLock.cancelCurrentEdit()) {\r\n                    command.undo();\r\n                }\r\n            },\r\n            redo: () => {\r\n                if (commandCtr >= this._commandQueue.length) {\r\n                    return;\r\n                }\r\n                const command = this._commandQueue[commandCtr];\r\n                commandCtr++;\r\n                if (command && Slick.GlobalEditorLock.cancelCurrentEdit()) {\r\n                    command.execute();\r\n                }\r\n            }\r\n        };\r\n    }\r\n    /** @return default plugin (addon) options */\r\n    getDefaultOptions() {\r\n        let newRowIds = 0;\r\n        return {\r\n            clipboardCommandHandler: (editCommand) => {\r\n                this._undoRedoBuffer.queueAndExecuteCommand.call(this._undoRedoBuffer, editCommand);\r\n            },\r\n            dataItemColumnValueExtractor: (item, columnDef) => {\r\n                // when grid or cell is not editable, we will possibly evaluate the Formatter if it was passed\r\n                // to decide if we evaluate the Formatter, we will use the same flag from Export which is \"exportWithFormatter\"\r\n                if (!this.sharedService.gridOptions.editable || !columnDef.editor) {\r\n                    const isEvaluatingFormatter = (columnDef.exportWithFormatter !== undefined) ? columnDef.exportWithFormatter : (this.sharedService.gridOptions.exportOptions && this.sharedService.gridOptions.exportOptions.exportWithFormatter);\r\n                    if (columnDef.formatter && isEvaluatingFormatter) {\r\n                        const formattedOutput = columnDef.formatter(0, 0, item[columnDef.field], columnDef, item, this.sharedService.grid);\r\n                        if (columnDef.sanitizeDataExport || (this.sharedService.gridOptions.exportOptions && this.sharedService.gridOptions.exportOptions.sanitizeDataExport)) {\r\n                            let outputString = formattedOutput;\r\n                            if (formattedOutput && typeof formattedOutput === 'object' && formattedOutput.hasOwnProperty('text')) {\r\n                                outputString = formattedOutput.text;\r\n                            }\r\n                            if (outputString === null) {\r\n                                outputString = '';\r\n                            }\r\n                            return sanitizeHtmlToText(outputString);\r\n                        }\r\n                        return formattedOutput;\r\n                    }\r\n                }\r\n                // else use the default \"dataItemColumnValueExtractor\" from the plugin itself\r\n                // we can do that by setting back the getter with null\r\n                return null;\r\n            },\r\n            readOnlyMode: false,\r\n            includeHeaderWhenCopying: false,\r\n            newRowCreator: (count) => {\r\n                for (let i = 0; i < count; i++) {\r\n                    const item = {\r\n                        id: 'newRow_' + newRowIds++\r\n                    };\r\n                    this.sharedService.grid.getData().addItem(item);\r\n                }\r\n            }\r\n        };\r\n    }\r\n    /** Hook an undo shortcut key hook that will redo/undo the copy buffer using Ctrl+(Shift)+Z keyboard events */\r\n    hookUndoShortcutKey() {\r\n        document.addEventListener('keydown', (e) => {\r\n            const keyCode = e.keyCode || e.code;\r\n            if (keyCode === 90 && (e.ctrlKey || e.metaKey)) {\r\n                if (e.shiftKey) {\r\n                    this._undoRedoBuffer.redo(); // Ctrl + Shift + Z\r\n                }\r\n                else {\r\n                    this._undoRedoBuffer.undo(); // Ctrl + Z\r\n                }\r\n            }\r\n        });\r\n    }\r\n};\r\nCellExternalCopyManagerExtension = __decorate([\r\n    Injectable(),\r\n    __metadata(\"design:paramtypes\", [ExtensionUtility, SharedService])\r\n], CellExternalCopyManagerExtension);\n\nlet CellMenuExtension = class CellMenuExtension {\r\n    constructor(extensionUtility, sharedService, translate) {\r\n        this.extensionUtility = extensionUtility;\r\n        this.sharedService = sharedService;\r\n        this.translate = translate;\r\n        this._eventHandler = new Slick.EventHandler();\r\n    }\r\n    get eventHandler() {\r\n        return this._eventHandler;\r\n    }\r\n    dispose() {\r\n        // unsubscribe all SlickGrid events\r\n        this._eventHandler.unsubscribeAll();\r\n        if (this._addon && this._addon.destroy) {\r\n            this._addon.destroy();\r\n        }\r\n    }\r\n    /** Get the instance of the SlickGrid addon (control or plugin). */\r\n    getAddonInstance() {\r\n        return this._addon;\r\n    }\r\n    /**\r\n     * Create the Action Cell Menu and expose all the available hooks that user can subscribe (onCommand, onBeforeMenuShow, ...)\r\n     * @param grid\r\n     * @param dataView\r\n     * @param columnDefinitions\r\n     */\r\n    register() {\r\n        if (this.sharedService.gridOptions && this.sharedService.gridOptions.enableTranslate && (!this.translate || !this.translate.instant)) {\r\n            throw new Error('[Angular-Slickgrid] requires \"ngx-translate\" to be installed and configured when the grid option \"enableTranslate\" is enabled.');\r\n        }\r\n        if (this.sharedService && this.sharedService.grid && this.sharedService.gridOptions) {\r\n            // get locales provided by user in main file or else use default English locales via the Constants\r\n            this._locales = this.sharedService.gridOptions && this.sharedService.gridOptions.locales || Constants.locales;\r\n            // dynamically import the SlickGrid plugin (addon) with RequireJS\r\n            this.extensionUtility.loadExtensionDynamically(ExtensionName.cellMenu);\r\n            this.sharedService.gridOptions.cellMenu = Object.assign({}, this.getDefaultCellMenuOptions(), this.sharedService.gridOptions.cellMenu);\r\n            // translate the item keys when necessary\r\n            if (this.sharedService.gridOptions.enableTranslate) {\r\n                this.translateCellMenu();\r\n            }\r\n            // sort all menu items by their position order when defined\r\n            this.sortMenuItems(this.sharedService.allColumns);\r\n            this._addon = new Slick.Plugins.CellMenu(this.sharedService.gridOptions.cellMenu);\r\n            this.sharedService.grid.registerPlugin(this._addon);\r\n            // hook all events\r\n            if (this.sharedService.grid && this.sharedService.gridOptions.cellMenu) {\r\n                if (this.sharedService.gridOptions.cellMenu.onExtensionRegistered) {\r\n                    this.sharedService.gridOptions.cellMenu.onExtensionRegistered(this._addon);\r\n                }\r\n                if (this.sharedService.gridOptions.cellMenu && typeof this.sharedService.gridOptions.cellMenu.onCommand === 'function') {\r\n                    this._eventHandler.subscribe(this._addon.onCommand, (event, args) => {\r\n                        this.sharedService.gridOptions.cellMenu.onCommand(event, args);\r\n                    });\r\n                }\r\n                if (this.sharedService.gridOptions.cellMenu && typeof this.sharedService.gridOptions.cellMenu.onOptionSelected === 'function') {\r\n                    this._eventHandler.subscribe(this._addon.onOptionSelected, (event, args) => {\r\n                        this.sharedService.gridOptions.cellMenu.onOptionSelected(event, args);\r\n                    });\r\n                }\r\n                if (this.sharedService.gridOptions.cellMenu && typeof this.sharedService.gridOptions.cellMenu.onAfterMenuShow === 'function') {\r\n                    this._eventHandler.subscribe(this._addon.onAfterMenuShow, (event, args) => {\r\n                        this.sharedService.gridOptions.cellMenu.onAfterMenuShow(event, args);\r\n                    });\r\n                }\r\n                if (this.sharedService.gridOptions.cellMenu && typeof this.sharedService.gridOptions.cellMenu.onBeforeMenuShow === 'function') {\r\n                    this._eventHandler.subscribe(this._addon.onBeforeMenuShow, (event, args) => {\r\n                        this.sharedService.gridOptions.cellMenu.onBeforeMenuShow(event, args);\r\n                    });\r\n                }\r\n                if (this.sharedService.gridOptions.cellMenu && typeof this.sharedService.gridOptions.cellMenu.onBeforeMenuClose === 'function') {\r\n                    this._eventHandler.subscribe(this._addon.onBeforeMenuClose, (event, args) => {\r\n                        this.sharedService.gridOptions.cellMenu.onBeforeMenuClose(event, args);\r\n                    });\r\n                }\r\n            }\r\n            return this._addon;\r\n        }\r\n        return null;\r\n    }\r\n    /** Translate the Cell Menu titles, we need to loop through all column definition to re-translate them */\r\n    translateCellMenu() {\r\n        if (this.sharedService.gridOptions && this.sharedService.gridOptions.cellMenu) {\r\n            this.resetMenuTranslations(this.sharedService.allColumns);\r\n        }\r\n    }\r\n    /**\r\n     * @return default Action Cell Menu options\r\n     */\r\n    getDefaultCellMenuOptions() {\r\n        return {\r\n            width: 180,\r\n        };\r\n    }\r\n    /**\r\n     * Reset all the internal Menu options which have text to translate\r\n     * @param grid menu object\r\n     */\r\n    resetMenuTranslations(columnDefinitions) {\r\n        const gridOptions = this.sharedService && this.sharedService.gridOptions;\r\n        if (gridOptions && gridOptions.enableTranslate) {\r\n            columnDefinitions.forEach((columnDef) => {\r\n                if (columnDef && columnDef.cellMenu && (Array.isArray(columnDef.cellMenu.commandItems) || Array.isArray(columnDef.cellMenu.optionItems))) {\r\n                    // get both items list\r\n                    const columnCellMenuCommandItems = columnDef.cellMenu.commandItems || [];\r\n                    const columnCellMenuOptionItems = columnDef.cellMenu.optionItems || [];\r\n                    // translate their titles only if they have a titleKey defined\r\n                    if (columnDef.cellMenu.commandTitleKey) {\r\n                        columnDef.cellMenu.commandTitle = this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant(columnDef.cellMenu.commandTitleKey) || this._locales && this._locales.TEXT_COMMANDS || columnDef.cellMenu.commandTitle;\r\n                    }\r\n                    if (columnDef.cellMenu.optionTitleKey) {\r\n                        columnDef.cellMenu.optionTitle = this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant(columnDef.cellMenu.optionTitleKey) || columnDef.cellMenu.optionTitle;\r\n                    }\r\n                    // translate both command/option items (whichever is provided)\r\n                    this.extensionUtility.translateItems(columnCellMenuCommandItems, 'titleKey', 'title');\r\n                    this.extensionUtility.translateItems(columnCellMenuOptionItems, 'titleKey', 'title');\r\n                }\r\n            });\r\n        }\r\n    }\r\n    sortMenuItems(columnDefinitions) {\r\n        columnDefinitions.forEach((columnDef) => {\r\n            if (columnDef && columnDef.cellMenu && columnDef.cellMenu.commandItems) {\r\n                // get both items list\r\n                const columnCellMenuCommandItems = columnDef.cellMenu.commandItems || [];\r\n                const columnCellMenuOptionItems = columnDef.cellMenu.optionItems || [];\r\n                this.extensionUtility.sortItems(columnCellMenuCommandItems, 'positionOrder');\r\n                this.extensionUtility.sortItems(columnCellMenuOptionItems, 'positionOrder');\r\n            }\r\n        });\r\n    }\r\n};\r\nCellMenuExtension = __decorate([\r\n    Injectable(),\r\n    __param(2, Optional()),\r\n    __metadata(\"design:paramtypes\", [ExtensionUtility,\r\n        SharedService,\r\n        TranslateService])\r\n], CellMenuExtension);\n\nlet CheckboxSelectorExtension = class CheckboxSelectorExtension {\r\n    constructor(extensionUtility, sharedService) {\r\n        this.extensionUtility = extensionUtility;\r\n        this.sharedService = sharedService;\r\n    }\r\n    dispose() {\r\n        if (this._addon && this._addon.destroy) {\r\n            this._addon.destroy();\r\n        }\r\n    }\r\n    /**\r\n     * Create the plugin before the Grid creation, else it will behave oddly.\r\n     * Mostly because the column definitions might change after the grid creation\r\n     */\r\n    create(columnDefinitions, gridOptions) {\r\n        if (Array.isArray(columnDefinitions) && gridOptions) {\r\n            // dynamically import the SlickGrid plugin (addon) with RequireJS\r\n            this.extensionUtility.loadExtensionDynamically(ExtensionName.checkboxSelector);\r\n            if (!this._addon) {\r\n                this._addon = new Slick.CheckboxSelectColumn(gridOptions.checkboxSelector || {});\r\n            }\r\n            const selectionColumn = this._addon.getColumnDefinition();\r\n            if (typeof selectionColumn === 'object') {\r\n                selectionColumn.excludeFromExport = true;\r\n                selectionColumn.excludeFromColumnPicker = true;\r\n                selectionColumn.excludeFromGridMenu = true;\r\n                selectionColumn.excludeFromQuery = true;\r\n                selectionColumn.excludeFromHeaderMenu = true;\r\n                columnDefinitions.unshift(selectionColumn);\r\n            }\r\n            return this._addon;\r\n        }\r\n        return null;\r\n    }\r\n    /** Get the instance of the SlickGrid addon (control or plugin). */\r\n    getAddonInstance() {\r\n        return this._addon;\r\n    }\r\n    register(rowSelectionPlugin) {\r\n        if (this.sharedService && this.sharedService.grid && this.sharedService.gridOptions) {\r\n            // the plugin has to be created BEFORE the grid (else it behaves oddly), but we can only watch grid events AFTER the grid is created\r\n            this.sharedService.grid.registerPlugin(this._addon);\r\n            // this also requires the Row Selection Model to be registered as well\r\n            if (!rowSelectionPlugin || !this.sharedService.grid.getSelectionModel()) {\r\n                this.extensionUtility.loadExtensionDynamically(ExtensionName.rowSelection);\r\n                rowSelectionPlugin = new Slick.RowSelectionModel(this.sharedService.gridOptions.rowSelectionOptions || {});\r\n                this.sharedService.grid.setSelectionModel(rowSelectionPlugin);\r\n            }\r\n            // user might want to pre-select some rows\r\n            // the setTimeout is because of timing issue with styling (row selection happen but rows aren't highlighted properly)\r\n            if (this.sharedService.gridOptions.preselectedRows && rowSelectionPlugin && this.sharedService.grid.getSelectionModel()) {\r\n                setTimeout(() => this._addon.selectRows(this.sharedService.gridOptions.preselectedRows));\r\n            }\r\n            return rowSelectionPlugin;\r\n        }\r\n        return null;\r\n    }\r\n};\r\nCheckboxSelectorExtension = __decorate([\r\n    Injectable(),\r\n    __metadata(\"design:paramtypes\", [ExtensionUtility, SharedService])\r\n], CheckboxSelectorExtension);\n\nlet ColumnPickerExtension = class ColumnPickerExtension {\r\n    constructor(extensionUtility, sharedService) {\r\n        this.extensionUtility = extensionUtility;\r\n        this.sharedService = sharedService;\r\n        this._eventHandler = new Slick.EventHandler();\r\n    }\r\n    get eventHandler() {\r\n        return this._eventHandler;\r\n    }\r\n    dispose() {\r\n        // unsubscribe all SlickGrid events\r\n        this._eventHandler.unsubscribeAll();\r\n        if (this._addon && this._addon.destroy) {\r\n            this._addon.destroy();\r\n        }\r\n    }\r\n    /** Get the instance of the SlickGrid addon (control or plugin). */\r\n    getAddonInstance() {\r\n        return this._addon;\r\n    }\r\n    register() {\r\n        if (this.sharedService && this.sharedService.grid && this.sharedService.gridOptions) {\r\n            // dynamically import the SlickGrid plugin (addon) with RequireJS\r\n            this.extensionUtility.loadExtensionDynamically(ExtensionName.columnPicker);\r\n            // localization support for the picker\r\n            const columnTitle = this.extensionUtility.getPickerTitleOutputString('columnTitle', 'columnPicker');\r\n            const forceFitTitle = this.extensionUtility.getPickerTitleOutputString('forceFitTitle', 'columnPicker');\r\n            const syncResizeTitle = this.extensionUtility.getPickerTitleOutputString('syncResizeTitle', 'columnPicker');\r\n            this.sharedService.gridOptions.columnPicker = this.sharedService.gridOptions.columnPicker || {};\r\n            this.sharedService.gridOptions.columnPicker.columnTitle = this.sharedService.gridOptions.columnPicker.columnTitle || columnTitle;\r\n            this.sharedService.gridOptions.columnPicker.forceFitTitle = this.sharedService.gridOptions.columnPicker.forceFitTitle || forceFitTitle;\r\n            this.sharedService.gridOptions.columnPicker.syncResizeTitle = this.sharedService.gridOptions.columnPicker.syncResizeTitle || syncResizeTitle;\r\n            this._addon = new Slick.Controls.ColumnPicker(this.sharedService.allColumns, this.sharedService.grid, this.sharedService.gridOptions);\r\n            if (this.sharedService.grid && this.sharedService.gridOptions.enableColumnPicker) {\r\n                if (this.sharedService.gridOptions.columnPicker.onExtensionRegistered) {\r\n                    this.sharedService.gridOptions.columnPicker.onExtensionRegistered(this._addon);\r\n                }\r\n                this._eventHandler.subscribe(this._addon.onColumnsChanged, (e, args) => {\r\n                    if (this.sharedService.gridOptions.columnPicker && typeof this.sharedService.gridOptions.columnPicker.onColumnsChanged === 'function') {\r\n                        this.sharedService.gridOptions.columnPicker.onColumnsChanged(e, args);\r\n                    }\r\n                    if (args && Array.isArray(args.columns) && args.columns.length > this.sharedService.visibleColumns.length) {\r\n                        this.sharedService.visibleColumns = args.columns;\r\n                    }\r\n                });\r\n            }\r\n            return this._addon;\r\n        }\r\n        return null;\r\n    }\r\n    /** Translate the Column Picker headers and also the last 2 checkboxes */\r\n    translateColumnPicker() {\r\n        if (this.sharedService && this.sharedService.grid && this.sharedService.gridOptions) {\r\n            // update the properties by pointers, that is the only way to get Column Picker Control to see the new values\r\n            if (this.sharedService.gridOptions.columnPicker) {\r\n                this.emptyColumnPickerTitles();\r\n                this.sharedService.gridOptions.columnPicker.columnTitle = this.extensionUtility.getPickerTitleOutputString('columnTitle', 'columnPicker');\r\n                this.sharedService.gridOptions.columnPicker.forceFitTitle = this.extensionUtility.getPickerTitleOutputString('forceFitTitle', 'columnPicker');\r\n                this.sharedService.gridOptions.columnPicker.syncResizeTitle = this.extensionUtility.getPickerTitleOutputString('syncResizeTitle', 'columnPicker');\r\n            }\r\n            // translate all columns (including hidden columns)\r\n            // eventually deprecate the \"headerKey\" and use only the \"nameKey\"\r\n            this.extensionUtility.translateItems(this.sharedService.allColumns, 'headerKey', 'name');\r\n            this.extensionUtility.translateItems(this.sharedService.allColumns, 'nameKey', 'name');\r\n            // update the Titles of each sections (command, customTitle, ...)\r\n            if (this._addon && this._addon.updateAllTitles) {\r\n                this._addon.updateAllTitles(this.sharedService.gridOptions.columnPicker);\r\n            }\r\n        }\r\n    }\r\n    emptyColumnPickerTitles() {\r\n        if (this.sharedService && this.sharedService.gridOptions && this.sharedService.gridOptions.columnPicker) {\r\n            this.sharedService.gridOptions.columnPicker.columnTitle = '';\r\n            this.sharedService.gridOptions.columnPicker.forceFitTitle = '';\r\n            this.sharedService.gridOptions.columnPicker.syncResizeTitle = '';\r\n        }\r\n    }\r\n};\r\nColumnPickerExtension = __decorate([\r\n    Injectable(),\r\n    __metadata(\"design:paramtypes\", [ExtensionUtility, SharedService])\r\n], ColumnPickerExtension);\n\nlet ContextMenuExtension = class ContextMenuExtension {\r\n    constructor(excelExportService, exportService, extensionUtility, sharedService, translate) {\r\n        this.excelExportService = excelExportService;\r\n        this.exportService = exportService;\r\n        this.extensionUtility = extensionUtility;\r\n        this.sharedService = sharedService;\r\n        this.translate = translate;\r\n        this._eventHandler = new Slick.EventHandler();\r\n    }\r\n    get eventHandler() {\r\n        return this._eventHandler;\r\n    }\r\n    dispose() {\r\n        // unsubscribe all SlickGrid events\r\n        this._eventHandler.unsubscribeAll();\r\n        if (this._addon && this._addon.destroy) {\r\n            this._addon.destroy();\r\n        }\r\n        if (this.sharedService.gridOptions && this.sharedService.gridOptions.contextMenu && this.sharedService.gridOptions.contextMenu.commandItems) {\r\n            this.sharedService.gridOptions.contextMenu = this._userOriginalContextMenu;\r\n        }\r\n    }\r\n    /** Get the instance of the SlickGrid addon (control or plugin). */\r\n    getAddonInstance() {\r\n        return this._addon;\r\n    }\r\n    /**\r\n     * Create the Action Cell Menu and expose all the available hooks that user can subscribe (onCommand, onBeforeMenuShow, ...)\r\n     * @param grid\r\n     * @param dataView\r\n     * @param columnDefinitions\r\n     */\r\n    register() {\r\n        if (this.sharedService.gridOptions && this.sharedService.gridOptions.enableTranslate && (!this.translate || !this.translate.instant)) {\r\n            throw new Error('[Angular-Slickgrid] requires \"ngx-translate\" to be installed and configured when the grid option \"enableTranslate\" is enabled.');\r\n        }\r\n        if (this.sharedService && this.sharedService.grid && this.sharedService.gridOptions && this.sharedService.gridOptions.contextMenu) {\r\n            const contextMenu = this.sharedService.gridOptions.contextMenu;\r\n            // keep original user context menu, useful when switching locale to translate\r\n            this._userOriginalContextMenu = Object.assign({}, contextMenu);\r\n            // dynamically import the SlickGrid plugin (addon) with RequireJS\r\n            this.extensionUtility.loadExtensionDynamically(ExtensionName.contextMenu);\r\n            this.sharedService.gridOptions.contextMenu = Object.assign({}, contextMenu);\r\n            // sort all menu items by their position order when defined\r\n            contextMenu.commandItems = this.addMenuCustomCommands([]);\r\n            this.extensionUtility.sortItems(contextMenu.commandItems || [], 'positionOrder');\r\n            this.extensionUtility.sortItems(contextMenu.optionItems || [], 'positionOrder');\r\n            this._addon = new Slick.Plugins.ContextMenu(contextMenu);\r\n            this.sharedService.grid.registerPlugin(this._addon);\r\n            // translate the item keys when necessary\r\n            if (this.sharedService.gridOptions.enableTranslate) {\r\n                this.translateContextMenu();\r\n            }\r\n            // hook all events\r\n            if (this.sharedService.grid && contextMenu) {\r\n                if (contextMenu.onExtensionRegistered) {\r\n                    contextMenu.onExtensionRegistered(this._addon);\r\n                }\r\n                if (contextMenu && typeof contextMenu.onCommand === 'function') {\r\n                    this._eventHandler.subscribe(this._addon.onCommand, (event, args) => {\r\n                        contextMenu.onCommand(event, args);\r\n                    });\r\n                }\r\n                if (contextMenu && typeof contextMenu.onOptionSelected === 'function') {\r\n                    this._eventHandler.subscribe(this._addon.onOptionSelected, (event, args) => {\r\n                        contextMenu.onOptionSelected(event, args);\r\n                    });\r\n                }\r\n                if (contextMenu && typeof contextMenu.onBeforeMenuShow === 'function') {\r\n                    this._eventHandler.subscribe(this._addon.onBeforeMenuShow, (event, args) => {\r\n                        contextMenu.onBeforeMenuShow(event, args);\r\n                    });\r\n                }\r\n                if (contextMenu && typeof contextMenu.onBeforeMenuClose === 'function') {\r\n                    this._eventHandler.subscribe(this._addon.onBeforeMenuClose, (event, args) => {\r\n                        contextMenu.onBeforeMenuClose(event, args);\r\n                    });\r\n                }\r\n                if (contextMenu && typeof contextMenu.onAfterMenuShow === 'function') {\r\n                    this._eventHandler.subscribe(this._addon.onAfterMenuShow, (event, args) => {\r\n                        contextMenu.onAfterMenuShow(event, args);\r\n                    });\r\n                }\r\n            }\r\n            return this._addon;\r\n        }\r\n        return null;\r\n    }\r\n    /** Translate the Cell Menu titles, we need to loop through all column definition to re-translate them */\r\n    translateContextMenu() {\r\n        if (this.sharedService && this.sharedService.gridOptions && this.sharedService.gridOptions.contextMenu) {\r\n            const contextMenu = this.sharedService.gridOptions.contextMenu;\r\n            const menuOptions = {};\r\n            if (contextMenu.commandTitleKey) {\r\n                contextMenu.commandTitle = this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant(contextMenu.commandTitleKey) || contextMenu.commandTitle;\r\n                menuOptions.commandTitle = contextMenu.commandTitle;\r\n            }\r\n            if (contextMenu.optionTitleKey) {\r\n                contextMenu.optionTitle = this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant(contextMenu.optionTitleKey) || contextMenu.optionTitle;\r\n                menuOptions.optionTitle = contextMenu.optionTitle;\r\n            }\r\n            const originalCommandItems = this._userOriginalContextMenu && Array.isArray(this._userOriginalContextMenu.commandItems) ? this._userOriginalContextMenu.commandItems : [];\r\n            contextMenu.commandItems = [...originalCommandItems, ...this.addMenuCustomCommands(originalCommandItems)];\r\n            menuOptions.commandItems = contextMenu.commandItems; // copy it also to the menuOptions else they won't be translated when locale changes\r\n            // translate all command/options and resort them afterward\r\n            this.extensionUtility.translateItems(contextMenu.commandItems || [], 'titleKey', 'title');\r\n            this.extensionUtility.translateItems(contextMenu.optionItems || [], 'titleKey', 'title');\r\n            this.extensionUtility.sortItems(contextMenu.commandItems || [], 'positionOrder');\r\n            this.extensionUtility.sortItems(contextMenu.optionItems || [], 'positionOrder');\r\n            // update the title options so that it has latest translated values\r\n            if (this._addon && this._addon.setOptions) {\r\n                this._addon.setOptions(menuOptions);\r\n            }\r\n        }\r\n    }\r\n    // --\r\n    // private functions\r\n    // ------------------\r\n    /** Create Context Menu with Custom Commands (copy cell value, export) */\r\n    addMenuCustomCommands(originalCustomItems) {\r\n        const menuCustomItems = [];\r\n        const gridOptions = this.sharedService && this.sharedService.gridOptions || {};\r\n        const contextMenu = gridOptions && gridOptions.contextMenu;\r\n        const dataView = this.sharedService && this.sharedService.dataView;\r\n        // show context menu: Copy (cell value)\r\n        if (contextMenu && !contextMenu.hideCopyCellValueCommand) {\r\n            const commandName = 'copy';\r\n            if (!originalCustomItems.find((item) => item.hasOwnProperty('command') && item.command === commandName)) {\r\n                menuCustomItems.push({\r\n                    iconCssClass: contextMenu.iconCopyCellValueCommand || 'fa fa-clone',\r\n                    title: this.extensionUtility.translateWhenEnabledAndServiceExist('COPY', 'TEXT_COPY'),\r\n                    disabled: false,\r\n                    command: commandName,\r\n                    positionOrder: 50,\r\n                    action: (e, args) => {\r\n                        this.copyToClipboard(args);\r\n                    },\r\n                    itemUsabilityOverride: (args) => {\r\n                        // make sure there's an item to copy before enabling this command\r\n                        const columnDef = args && args.column;\r\n                        const dataContext = args && args.dataContext;\r\n                        if (columnDef && dataContext.hasOwnProperty(columnDef.field)) {\r\n                            return dataContext[columnDef.field] !== '' && dataContext[columnDef.field] !== null && dataContext[columnDef.field] !== undefined;\r\n                        }\r\n                        return false;\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        // show context menu: Export to file\r\n        if (gridOptions && gridOptions.enableExport && contextMenu && !contextMenu.hideExportCsvCommand) {\r\n            const commandName = 'export-csv';\r\n            if (!originalCustomItems.find((item) => item.hasOwnProperty('command') && item.command === commandName)) {\r\n                menuCustomItems.push({\r\n                    iconCssClass: contextMenu.iconExportCsvCommand || 'fa fa-download',\r\n                    title: this.extensionUtility.translateWhenEnabledAndServiceExist('EXPORT_TO_CSV', 'TEXT_EXPORT_TO_CSV'),\r\n                    disabled: false,\r\n                    command: commandName,\r\n                    positionOrder: 51,\r\n                    action: () => this.exportService.exportToFile({\r\n                        delimiter: DelimiterType.comma,\r\n                        filename: 'export',\r\n                        format: FileType.csv,\r\n                        useUtf8WithBom: true,\r\n                    }),\r\n                });\r\n            }\r\n        }\r\n        // show context menu: Export to Excel\r\n        if (gridOptions && gridOptions.enableExcelExport && contextMenu && !contextMenu.hideExportExcelCommand) {\r\n            const commandName = 'export-excel';\r\n            if (!originalCustomItems.find((item) => item.hasOwnProperty('command') && item.command === commandName)) {\r\n                menuCustomItems.push({\r\n                    iconCssClass: contextMenu.iconExportExcelCommand || 'fa fa-file-excel-o text-success',\r\n                    title: this.extensionUtility.translateWhenEnabledAndServiceExist('EXPORT_TO_EXCEL', 'TEXT_EXPORT_TO_EXCEL'),\r\n                    disabled: false,\r\n                    command: commandName,\r\n                    positionOrder: 52,\r\n                    action: () => this.excelExportService.exportToExcel({\r\n                        filename: 'export',\r\n                        format: FileType.xlsx,\r\n                    }),\r\n                });\r\n            }\r\n        }\r\n        // show context menu: export to text file as tab delimited\r\n        if (gridOptions && gridOptions.enableExport && contextMenu && !contextMenu.hideExportTextDelimitedCommand) {\r\n            const commandName = 'export-text-delimited';\r\n            if (!originalCustomItems.find((item) => item.hasOwnProperty('command') && item.command === commandName)) {\r\n                menuCustomItems.push({\r\n                    iconCssClass: contextMenu.iconExportTextDelimitedCommand || 'fa fa-download',\r\n                    title: this.extensionUtility.translateWhenEnabledAndServiceExist('EXPORT_TO_TAB_DELIMITED', 'TEXT_EXPORT_TO_TAB_DELIMITED'),\r\n                    disabled: false,\r\n                    command: commandName,\r\n                    positionOrder: 53,\r\n                    action: () => this.exportService.exportToFile({\r\n                        delimiter: DelimiterType.tab,\r\n                        filename: 'export',\r\n                        format: FileType.txt,\r\n                        useUtf8WithBom: true,\r\n                    }),\r\n                });\r\n            }\r\n        }\r\n        // -- Grouping Commands\r\n        if (gridOptions && (gridOptions.enableGrouping || gridOptions.enableDraggableGrouping)) {\r\n            // add a divider (separator) between the top sort commands and the other clear commands\r\n            menuCustomItems.push({ divider: true, command: '', positionOrder: 54 });\r\n            // show context menu: Clear Grouping\r\n            if (gridOptions && contextMenu && !contextMenu.hideClearAllGrouping) {\r\n                const commandName = 'clear-grouping';\r\n                if (!originalCustomItems.find((item) => item.hasOwnProperty('command') && item.command === commandName)) {\r\n                    menuCustomItems.push({\r\n                        iconCssClass: contextMenu.iconClearGroupingCommand || 'fa fa-times',\r\n                        title: this.extensionUtility.translateWhenEnabledAndServiceExist('CLEAR_ALL_GROUPING', 'TEXT_CLEAR_ALL_GROUPING'),\r\n                        disabled: false,\r\n                        command: commandName,\r\n                        positionOrder: 55,\r\n                        action: () => dataView.setGrouping([]),\r\n                        itemUsabilityOverride: () => {\r\n                            // only enable the command when there's an actually grouping in play\r\n                            const groupingArray = dataView && dataView.getGrouping && dataView.getGrouping();\r\n                            return Array.isArray(groupingArray) && groupingArray.length > 0;\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            // show context menu: Collapse all Groups\r\n            if (gridOptions && contextMenu && !contextMenu.hideCollapseAllGroups) {\r\n                const commandName = 'collapse-all-groups';\r\n                if (!originalCustomItems.find((item) => item.hasOwnProperty('command') && item.command === commandName)) {\r\n                    menuCustomItems.push({\r\n                        iconCssClass: contextMenu.iconCollapseAllGroupsCommand || 'fa fa-compress',\r\n                        title: this.extensionUtility.translateWhenEnabledAndServiceExist('COLLAPSE_ALL_GROUPS', 'TEXT_COLLAPSE_ALL_GROUPS'),\r\n                        disabled: false,\r\n                        command: commandName,\r\n                        positionOrder: 56,\r\n                        action: () => dataView.collapseAllGroups(),\r\n                        itemUsabilityOverride: () => {\r\n                            // only enable the command when there's an actually grouping in play\r\n                            const groupingArray = dataView && dataView.getGrouping && dataView.getGrouping();\r\n                            return Array.isArray(groupingArray) && groupingArray.length > 0;\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            // show context menu: Expand all Groups\r\n            if (gridOptions && contextMenu && !contextMenu.hideExpandAllGroups) {\r\n                const commandName = 'expand-all-groups';\r\n                if (!originalCustomItems.find((item) => item.hasOwnProperty('command') && item.command === commandName)) {\r\n                    menuCustomItems.push({\r\n                        iconCssClass: contextMenu.iconExpandAllGroupsCommand || 'fa fa-expand',\r\n                        title: this.extensionUtility.translateWhenEnabledAndServiceExist('EXPAND_ALL_GROUPS', 'TEXT_EXPAND_ALL_GROUPS'),\r\n                        disabled: false,\r\n                        command: commandName,\r\n                        positionOrder: 57,\r\n                        action: () => dataView.expandAllGroups(),\r\n                        itemUsabilityOverride: () => {\r\n                            // only enable the command when there's an actually grouping in play\r\n                            const groupingArray = dataView && dataView.getGrouping && dataView.getGrouping();\r\n                            return Array.isArray(groupingArray) && groupingArray.length > 0;\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        return menuCustomItems;\r\n    }\r\n    /**\r\n     * First get the value, if \"exportWithFormatter\" is set then we'll use the formatter output\r\n     * Then we create the DOM trick to copy a text value by creating a fake <div> that is not shown to the user\r\n     * and from there we can call the execCommand 'copy' command and expect the value to be in clipboard\r\n     * @param args\r\n     */\r\n    copyToClipboard(args) {\r\n        try {\r\n            if (args && args.grid && args.command) {\r\n                // get the value, if \"exportWithFormatter\" is set then we'll use the formatter output\r\n                const gridOptions = this.sharedService && this.sharedService.gridOptions || {};\r\n                const cell = args && args.cell || 0;\r\n                const row = args && args.row || 0;\r\n                const column = args && args.column;\r\n                const dataContext = args && args.dataContext;\r\n                const grid = this.sharedService && this.sharedService.grid;\r\n                const exportOptions = gridOptions && (gridOptions.excelExportOptions || gridOptions.exportOptions);\r\n                const textToCopy = exportWithFormatterWhenDefined(row, cell, dataContext, column, grid, exportOptions);\r\n                // create fake <div> to copy into clipboard & delete it from the DOM once we're done\r\n                const range = document.createRange();\r\n                const tmpElem = $('<div>').css({ position: 'absolute', left: '-1000px', top: '-1000px' }).text(textToCopy);\r\n                $('body').append(tmpElem);\r\n                range.selectNodeContents(tmpElem.get(0));\r\n                const selection = window.getSelection();\r\n                if (selection && selection.addRange && selection.removeAllRanges) {\r\n                    selection.removeAllRanges();\r\n                    selection.addRange(range);\r\n                    const success = document.execCommand('copy', false, textToCopy);\r\n                    if (success) {\r\n                        tmpElem.remove();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        catch (e) { }\r\n    }\r\n};\r\nContextMenuExtension = __decorate([\r\n    Injectable(),\r\n    __param(4, Optional()),\r\n    __metadata(\"design:paramtypes\", [ExcelExportService,\r\n        ExportService,\r\n        ExtensionUtility,\r\n        SharedService,\r\n        TranslateService])\r\n], ContextMenuExtension);\n\nlet DraggableGroupingExtension = class DraggableGroupingExtension {\r\n    constructor(extensionUtility, sharedService) {\r\n        this.extensionUtility = extensionUtility;\r\n        this.sharedService = sharedService;\r\n        this._eventHandler = new Slick.EventHandler();\r\n    }\r\n    get eventHandler() {\r\n        return this._eventHandler;\r\n    }\r\n    dispose() {\r\n        // unsubscribe all SlickGrid events\r\n        this._eventHandler.unsubscribeAll();\r\n        if (this._addon && this._addon.destroy) {\r\n            this._addon.destroy();\r\n        }\r\n    }\r\n    /**\r\n     * Bind/Create different plugins before the Grid creation.\r\n     * For example the multi-select have to be added to the column definition before the grid is created to work properly\r\n     */\r\n    create(gridOptions) {\r\n        if (gridOptions) {\r\n            // dynamically import the SlickGrid plugin (addon) with RequireJS\r\n            this.extensionUtility.loadExtensionDynamically(ExtensionName.draggableGrouping);\r\n            if (!this._addon) {\r\n                this._addon = new Slick.DraggableGrouping(gridOptions.draggableGrouping || {});\r\n            }\r\n            return this._addon;\r\n        }\r\n        return null;\r\n    }\r\n    /** Get the instance of the SlickGrid addon (control or plugin). */\r\n    getAddonInstance() {\r\n        return this._addon;\r\n    }\r\n    register() {\r\n        if (this.sharedService && this.sharedService.grid && this.sharedService.gridOptions) {\r\n            this.sharedService.grid.registerPlugin(this._addon);\r\n            // Events\r\n            if (this.sharedService.grid && this.sharedService.gridOptions.draggableGrouping) {\r\n                if (this.sharedService.gridOptions.draggableGrouping.onExtensionRegistered) {\r\n                    this.sharedService.gridOptions.draggableGrouping.onExtensionRegistered(this._addon);\r\n                }\r\n                this._eventHandler.subscribe(this._addon.onGroupChanged, (e, args) => {\r\n                    if (this.sharedService.gridOptions.draggableGrouping && typeof this.sharedService.gridOptions.draggableGrouping.onGroupChanged === 'function') {\r\n                        this.sharedService.gridOptions.draggableGrouping.onGroupChanged(e, args);\r\n                    }\r\n                });\r\n            }\r\n            return this._addon;\r\n        }\r\n        return null;\r\n    }\r\n};\r\nDraggableGroupingExtension = __decorate([\r\n    Injectable(),\r\n    __metadata(\"design:paramtypes\", [ExtensionUtility, SharedService])\r\n], DraggableGroupingExtension);\n\nconst booleanFilterCondition = (options) => {\r\n    const searchTerm = Array.isArray(options.searchTerms) && options.searchTerms[0] || '';\r\n    return parseBoolean(options.cellValue) === parseBoolean(searchTerm);\r\n};\n\n/**\r\n * Compare 2 objects,\r\n * we will loop through all properties of the object to compare the entire content of both objects\r\n * Optionally we can compare by a property key, when that is provided we will compare the object content\r\n * @param o1\r\n * @param o2\r\n * @param compareKey optional\r\n * @return boolean are objects equals?\r\n */\r\nfunction compareObjects(o1, o2, compareKey) {\r\n    // if user provided an object compare key then compare directly both objects by that key\r\n    if (compareKey && (o1.hasOwnProperty(compareKey) || o2.hasOwnProperty(compareKey))) {\r\n        return o1[compareKey] === o2 || o1 === o2[compareKey] || o1[compareKey] === o2[compareKey];\r\n    }\r\n    // loop through all object properties to compare the full content of the object\r\n    // we'll return false as soon as a difference is detected\r\n    for (const p in o1) {\r\n        if (o1.hasOwnProperty(p)) {\r\n            if (o1[p] !== o2[p]) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\nconst testFilterCondition = (operator, value1, value2) => {\r\n    switch (operator) {\r\n        case '<':\r\n        case 'LT': return (value1 < value2);\r\n        case '<=':\r\n        case 'LE': return (value1 <= value2);\r\n        case '>':\r\n        case 'GT': return (value1 > value2);\r\n        case '>=':\r\n        case 'GE': return (value1 >= value2);\r\n        case '!=':\r\n        case '<>':\r\n        case 'NE': return (value1 !== value2);\r\n        case '=':\r\n        case '==':\r\n        case 'EQ': return (value1 === value2);\r\n        case 'IN': return ((value2 && value2.indexOf) ? (value2.indexOf(value1) > -1) : false);\r\n        case 'NIN':\r\n        case 'NOT_IN':\r\n            return ((value2 && value2.includes) ? (!value2.includes(value1)) : false);\r\n        case 'IN_CONTAINS':\r\n            if (value2 && Array.isArray(value2) && value2.findIndex) {\r\n                return ((value2.findIndex((val) => value1.indexOf(val) > -1)) > -1);\r\n            }\r\n            return false;\r\n        case 'NIN_CONTAINS':\r\n        case 'NOT_IN_CONTAINS':\r\n            if (value2 && Array.isArray(value2) && value2.findIndex) {\r\n                return !((value2.findIndex((val) => value1.indexOf(val) > -1)) > -1);\r\n            }\r\n            return false;\r\n    }\r\n    return true;\r\n};\n\nconst collectionSearchFilterCondition = (options) => {\r\n    // multiple-select will always return text, so we should make our cell values text as well\r\n    const cellValue = options.cellValue + '';\r\n    return testFilterCondition(options.operator || 'IN', cellValue, options.searchTerms || []);\r\n};\n\nconst numberFilterCondition = (options) => {\r\n    const cellValue = parseFloat(options.cellValue);\r\n    const searchTerms = Array.isArray(options.searchTerms) && options.searchTerms || [0];\r\n    let isRangeSearch = false;\r\n    let searchValue1;\r\n    let searchValue2;\r\n    if (searchTerms.length === 2 || (typeof searchTerms[0] === 'string' && searchTerms[0].indexOf('..') > 0)) {\r\n        isRangeSearch = true;\r\n        const searchValues = (searchTerms.length === 2) ? searchTerms : searchTerms[0].split('..');\r\n        searchValue1 = parseFloat(Array.isArray(searchValues) && searchValues[0] + '');\r\n        searchValue2 = parseFloat(Array.isArray(searchValues) && searchValues[1] + '');\r\n    }\r\n    else {\r\n        searchValue1 = parseFloat(searchTerms[0] + '');\r\n    }\r\n    if (!searchValue1 && !options.operator) {\r\n        return true;\r\n    }\r\n    if (isRangeSearch) {\r\n        const isInclusive = options.operator && options.operator === OperatorType.rangeInclusive;\r\n        const resultCondition1 = testFilterCondition((isInclusive ? '>=' : '>'), cellValue, searchValue1);\r\n        const resultCondition2 = testFilterCondition((isInclusive ? '<=' : '<'), cellValue, searchValue2);\r\n        return (resultCondition1 && resultCondition2);\r\n    }\r\n    return testFilterCondition(options.operator || '==', cellValue, searchValue1);\r\n};\n\nconst objectFilterCondition = (options) => {\r\n    const searchTerm = (Array.isArray(options.searchTerms) && options.searchTerms[0] || '');\r\n    if (!searchTerm && !options.operator) {\r\n        return true;\r\n    }\r\n    switch (options.operator) {\r\n        case '!=':\r\n        case '<>':\r\n        case 'NE':\r\n            return !compareObjects(options.cellValue, searchTerm, options.dataKey);\r\n        case '=':\r\n        case '==':\r\n        case 'EQ':\r\n        default:\r\n            return compareObjects(options.cellValue, searchTerm, options.dataKey);\r\n    }\r\n};\n\nconst stringFilterCondition = (options) => {\r\n    // make sure the cell value is a string by casting it when possible\r\n    options.cellValue = (options.cellValue === undefined || options.cellValue === null) ? '' : options.cellValue.toString();\r\n    // make both the cell value and search value lower for case insensitive comparison\r\n    const cellValue = options.cellValue.toLowerCase();\r\n    let searchTerm = (Array.isArray(options.searchTerms) && options.searchTerms[0]) || '';\r\n    if (typeof searchTerm === 'string') {\r\n        searchTerm = searchTerm.toLowerCase();\r\n    }\r\n    if (options.operator === '*' || options.operator === 'EndsWith') {\r\n        return cellValue.endsWith(searchTerm);\r\n    }\r\n    else if ((options.operator === '' && options.cellValueLastChar === '*') || options.operator === 'StartsWith') {\r\n        return cellValue.startsWith(searchTerm);\r\n    }\r\n    else if (options.operator === '') {\r\n        return (cellValue.indexOf(searchTerm) > -1);\r\n    }\r\n    return testFilterCondition(options.operator || '==', cellValue, searchTerm);\r\n};\n\nconst moment$3 = moment_; // patch to fix rollup \"moment has no default export\" issue, document here https://github.com/rollup/rollup/issues/670\r\nconst executeMappedCondition = (options) => {\r\n    // when using a multi-select ('IN' operator) we will not use the field type but instead go directly with a collection search\r\n    const operator = options && options.operator && options.operator.toUpperCase();\r\n    if (operator === 'IN' || operator === 'NIN' || operator === 'IN_CONTAINS' || operator === 'NIN_CONTAINS') {\r\n        return collectionSearchFilterCondition(options);\r\n    }\r\n    // execute the mapped type, or default to String condition check\r\n    switch (options.fieldType) {\r\n        case FieldType.boolean:\r\n            return booleanFilterCondition(options);\r\n        case FieldType.date:\r\n        case FieldType.dateIso:\r\n        case FieldType.dateUtc:\r\n        case FieldType.dateTime:\r\n        case FieldType.dateTimeIso:\r\n        case FieldType.dateTimeIsoAmPm:\r\n        case FieldType.dateTimeIsoAM_PM:\r\n        case FieldType.dateTimeShortIso:\r\n        case FieldType.dateEuro:\r\n        case FieldType.dateEuroShort:\r\n        case FieldType.dateTimeShortEuro:\r\n        case FieldType.dateTimeEuro:\r\n        case FieldType.dateTimeEuroAmPm:\r\n        case FieldType.dateTimeEuroAM_PM:\r\n        case FieldType.dateTimeEuroShort:\r\n        case FieldType.dateTimeEuroShortAmPm:\r\n        case FieldType.dateTimeEuroShortAM_PM:\r\n        case FieldType.dateUs:\r\n        case FieldType.dateUsShort:\r\n        case FieldType.dateTimeShortUs:\r\n        case FieldType.dateTimeUs:\r\n        case FieldType.dateTimeUsAmPm:\r\n        case FieldType.dateTimeUsAM_PM:\r\n        case FieldType.dateTimeUsShort:\r\n        case FieldType.dateTimeUsShortAmPm:\r\n        case FieldType.dateTimeUsShortAM_PM:\r\n            return executeAssociatedDateCondition(options);\r\n        case FieldType.integer:\r\n        case FieldType.float:\r\n        case FieldType.number:\r\n            return numberFilterCondition(options);\r\n        case FieldType.object:\r\n            return objectFilterCondition(options);\r\n        case FieldType.string:\r\n        default:\r\n            return stringFilterCondition(options);\r\n    }\r\n};\r\n/**\r\n * Execute Date filter condition and use correct date format depending on it's field type (or filterSearchType when that is provided)\r\n * @param options\r\n */\r\nfunction executeAssociatedDateCondition(options) {\r\n    const filterSearchType = options && (options.filterSearchType || options.fieldType) || FieldType.dateIso;\r\n    const FORMAT = mapMomentDateFormatWithFieldType(filterSearchType);\r\n    const searchTerms = Array.isArray(options.searchTerms) && options.searchTerms || [];\r\n    let isRangeSearch = false;\r\n    let dateSearch1;\r\n    let dateSearch2;\r\n    // return when cell value is not a valid date\r\n    if (searchTerms.length === 0 || searchTerms[0] === '' || searchTerms[0] === null || !moment$3(options.cellValue, FORMAT, true).isValid()) {\r\n        return false;\r\n    }\r\n    // cell value in moment format\r\n    const dateCell = moment$3(options.cellValue, FORMAT, true);\r\n    if (searchTerms.length === 2 || (searchTerms[0].indexOf('..') > 0)) {\r\n        isRangeSearch = true;\r\n        const searchValues = (searchTerms.length === 2) ? searchTerms : searchTerms[0].split('..');\r\n        const searchValue1 = (Array.isArray(searchValues) && searchValues[0] || '');\r\n        const searchValue2 = (Array.isArray(searchValues) && searchValues[1] || '');\r\n        const searchTerm1 = moment$3(searchValue1, FORMAT, true);\r\n        const searchTerm2 = moment$3(searchValue2, FORMAT, true);\r\n        // return if any of the 2 values are invalid dates\r\n        if (!moment$3(searchTerm1, FORMAT, true).isValid() || !moment$3(searchTerm2, FORMAT, true).isValid()) {\r\n            return false;\r\n        }\r\n        dateSearch1 = moment$3(searchTerm1, FORMAT, true);\r\n        dateSearch2 = moment$3(searchTerm2, FORMAT, true);\r\n    }\r\n    else {\r\n        // return if the search term is an invalid date\r\n        if (!moment$3(searchTerms[0], FORMAT, true).isValid()) {\r\n            return false;\r\n        }\r\n        dateSearch1 = moment$3(searchTerms[0], FORMAT, true);\r\n    }\r\n    // run the filter condition with date in Unix Timestamp format\r\n    if (isRangeSearch) {\r\n        const isInclusive = options.operator && options.operator === OperatorType.rangeInclusive;\r\n        const resultCondition1 = testFilterCondition((isInclusive ? '>=' : '>'), parseInt(dateCell.format('X'), 10), parseInt(dateSearch1.format('X'), 10));\r\n        const resultCondition2 = testFilterCondition((isInclusive ? '<=' : '<'), parseInt(dateCell.format('X'), 10), parseInt(dateSearch2.format('X'), 10));\r\n        return (resultCondition1 && resultCondition2);\r\n    }\r\n    return testFilterCondition(options.operator || '==', parseInt(dateCell.format('X'), 10), parseInt(dateSearch1.format('X'), 10));\r\n}\n\nconst FilterConditions = {\r\n    executeMappedCondition,\r\n    booleanFilter: booleanFilterCondition,\r\n    collectionSearchFilter: collectionSearchFilterCondition,\r\n    numberFilter: numberFilterCondition,\r\n    stringFilter: stringFilterCondition,\r\n    testFilter: testFilterCondition\r\n};\n\nlet AutoCompleteFilter = class AutoCompleteFilter {\r\n    /**\r\n     * Initialize the Filter\r\n     */\r\n    constructor(translate, collectionService) {\r\n        this.translate = translate;\r\n        this.collectionService = collectionService;\r\n        this._clearFilterTriggered = false;\r\n        this._shouldTriggerQuery = true;\r\n        this.isFilled = false;\r\n        /** The property name for values in the collection */\r\n        this.valueName = 'label';\r\n        this.enableTranslateLabel = false;\r\n        this.subscriptions = [];\r\n    }\r\n    /** Getter for the Autocomplete Option */\r\n    get autoCompleteOptions() {\r\n        return this._autoCompleteOptions || {};\r\n    }\r\n    /** Getter for the Collection Options */\r\n    get collectionOptions() {\r\n        return this.columnDef && this.columnDef.filter && this.columnDef.filter.collectionOptions || {};\r\n    }\r\n    /** Getter for the Collection Used by the Filter */\r\n    get collection() {\r\n        return this._collection;\r\n    }\r\n    /** Getter for the Column Filter */\r\n    get columnFilter() {\r\n        return this.columnDef && this.columnDef.filter || {};\r\n    }\r\n    /** Getter for the Custom Structure if exist */\r\n    get customStructure() {\r\n        return this.columnDef && this.columnDef.filter && this.columnDef.filter.customStructure;\r\n    }\r\n    /** Getter to know what would be the default operator when none is specified */\r\n    get defaultOperator() {\r\n        return OperatorType.equal;\r\n    }\r\n    /** Getter for the Grid Options pulled through the Grid Object */\r\n    get gridOptions() {\r\n        return (this.grid && this.grid.getOptions) ? this.grid.getOptions() : {};\r\n    }\r\n    /** Getter of the Operator to use when doing the filter comparing */\r\n    get operator() {\r\n        return this.columnFilter && this.columnFilter.operator || this.defaultOperator;\r\n    }\r\n    /** Setter for the filter operator */\r\n    set operator(operator) {\r\n        if (this.columnFilter) {\r\n            this.columnFilter.operator = operator;\r\n        }\r\n    }\r\n    /**\r\n     * Initialize the filter template\r\n     */\r\n    init(args) {\r\n        if (!args) {\r\n            throw new Error('[Angular-SlickGrid] A filter must always have an \"init()\" with valid arguments.');\r\n        }\r\n        this.grid = args.grid;\r\n        this.callback = args.callback;\r\n        this.columnDef = args.columnDef;\r\n        this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];\r\n        if (!this.grid || !this.columnDef || !this.columnFilter || (!this.columnFilter.collection && !this.columnFilter.collectionAsync && !this.columnFilter.filterOptions)) {\r\n            throw new Error(`[Angular-SlickGrid] You need to pass a \"collection\" (or \"collectionAsync\") for the AutoComplete Filter to work correctly. Also each option should include a value/label pair (or value/labelKey when using Locale). For example:: { filter: model: Filters.autoComplete, collection: [{ value: true, label: 'True' }, { value: false, label: 'False'}] }`);\r\n        }\r\n        this.enableTranslateLabel = this.columnFilter && this.columnFilter.enableTranslateLabel || false;\r\n        this.labelName = this.customStructure && this.customStructure.label || 'label';\r\n        this.valueName = this.customStructure && this.customStructure.value || 'value';\r\n        // always render the DOM element, even if user passed a \"collectionAsync\",\r\n        const newCollection = this.columnFilter.collection || [];\r\n        this._collection = newCollection;\r\n        this.renderDomElement(newCollection);\r\n        // on every Filter which have a \"collection\" or a \"collectionAsync\"\r\n        // we will add (or replace) a Subject to the \"collectionAsync\" property so that user has possibility to change the collection\r\n        // if \"collectionAsync\" is already set by the user, it will resolve it first then after it will replace it with a Subject\r\n        const collectionAsync = this.columnFilter && this.columnFilter.collectionAsync;\r\n        if (collectionAsync) {\r\n            return this.renderOptionsAsync(collectionAsync); // create Subject after resolve (createCollectionAsyncSubject)\r\n        }\r\n        else {\r\n            return new Promise((resolve) => resolve(true));\r\n        }\r\n    }\r\n    /**\r\n     * Clear the filter value\r\n     */\r\n    clear(shouldTriggerQuery = true) {\r\n        if (this.$filterElm) {\r\n            this._clearFilterTriggered = true;\r\n            this._shouldTriggerQuery = shouldTriggerQuery;\r\n            this.searchTerms = [];\r\n            this.$filterElm.val('');\r\n            this.$filterElm.trigger('keyup');\r\n        }\r\n    }\r\n    /**\r\n     * destroy the filter\r\n     */\r\n    destroy() {\r\n        if (this.$filterElm) {\r\n            this.$filterElm.off('keyup').remove();\r\n        }\r\n    }\r\n    /** Set value(s) on the DOM element */\r\n    setValues(values, operator) {\r\n        if (values) {\r\n            this.$filterElm.val(values);\r\n        }\r\n        // set the operator when defined\r\n        this.operator = operator || this.defaultOperator;\r\n    }\r\n    //\r\n    // protected functions\r\n    // ------------------\r\n    /**\r\n     * user might want to filter certain items of the collection\r\n     * @param inputCollection\r\n     * @return outputCollection filtered and/or sorted collection\r\n     */\r\n    filterCollection(inputCollection) {\r\n        let outputCollection = inputCollection;\r\n        // user might want to filter certain items of the collection\r\n        if (this.columnFilter && this.columnFilter.collectionFilterBy) {\r\n            const filterBy = this.columnFilter.collectionFilterBy;\r\n            const filterCollectionBy = this.columnFilter.collectionOptions && this.columnFilter.collectionOptions.filterResultAfterEachPass || null;\r\n            outputCollection = this.collectionService.filterCollection(outputCollection, filterBy, filterCollectionBy);\r\n        }\r\n        return outputCollection;\r\n    }\r\n    /**\r\n     * user might want to sort the collection in a certain way\r\n     * @param inputCollection\r\n     * @return outputCollection filtered and/or sorted collection\r\n     */\r\n    sortCollection(inputCollection) {\r\n        let outputCollection = inputCollection;\r\n        // user might want to sort the collection\r\n        if (this.columnFilter && this.columnFilter.collectionSortBy) {\r\n            const sortBy = this.columnFilter.collectionSortBy;\r\n            outputCollection = this.collectionService.sortCollection(this.columnDef, outputCollection, sortBy, this.enableTranslateLabel);\r\n        }\r\n        return outputCollection;\r\n    }\r\n    renderOptionsAsync(collectionAsync) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let awaitedCollection = [];\r\n            if (collectionAsync) {\r\n                awaitedCollection = yield castToPromise(collectionAsync);\r\n                this.renderDomElementFromCollectionAsync(awaitedCollection);\r\n                // because we accept Promises & HttpClient Observable only execute once\r\n                // we will re-create an RxJs Subject which will replace the \"collectionAsync\" which got executed once anyway\r\n                // doing this provide the user a way to call a \"collectionAsync.next()\"\r\n                this.createCollectionAsyncSubject();\r\n            }\r\n            return true;\r\n        });\r\n    }\r\n    /** Create or recreate an Observable Subject and reassign it to the \"collectionAsync\" object so user can call a \"collectionAsync.next()\" on it */\r\n    createCollectionAsyncSubject() {\r\n        const newCollectionAsync = new Subject();\r\n        this.columnFilter.collectionAsync = newCollectionAsync;\r\n        this.subscriptions.push(newCollectionAsync.subscribe(collection => this.renderDomElementFromCollectionAsync(collection)));\r\n    }\r\n    /**\r\n     * When user use a CollectionAsync we will use the returned collection to render the filter DOM element\r\n     * and reinitialize filter collection with this new collection\r\n     */\r\n    renderDomElementFromCollectionAsync(collection) {\r\n        this._collection = collection;\r\n        if (this.collectionOptions && (this.collectionOptions.collectionInsideObjectProperty || this.collectionOptions.collectionInObjectProperty)) {\r\n            const collectionInsideObjectProperty = this.collectionOptions.collectionInsideObjectProperty || this.collectionOptions.collectionInObjectProperty;\r\n            collection = getDescendantProperty(collection, collectionInsideObjectProperty);\r\n        }\r\n        if (!Array.isArray(collection)) {\r\n            throw new Error('Something went wrong while trying to pull the collection from the \"collectionAsync\" call in the AutoComplete Filter, the collection is not a valid array.');\r\n        }\r\n        // copy over the array received from the async call to the \"collection\" as the new collection to use\r\n        // this has to be BEFORE the `collectionObserver().subscribe` to avoid going into an infinite loop\r\n        this.columnFilter.collection = collection;\r\n        // recreate Filter DOM element after getting async collection\r\n        this.renderDomElement(collection);\r\n    }\r\n    renderDomElement(collection) {\r\n        if (!Array.isArray(collection) && this.collectionOptions && (this.collectionOptions.collectionInsideObjectProperty || this.collectionOptions.collectionInObjectProperty)) {\r\n            const collectionInsideObjectProperty = this.collectionOptions.collectionInsideObjectProperty || this.collectionOptions.collectionInObjectProperty;\r\n            collection = getDescendantProperty(collection, collectionInsideObjectProperty);\r\n        }\r\n        if (!Array.isArray(collection)) {\r\n            throw new Error('The \"collection\" passed to the Autocomplete Filter is not a valid array.');\r\n        }\r\n        // assign the collection to a temp variable before filtering/sorting the collection\r\n        let newCollection = collection;\r\n        // user might want to filter and/or sort certain items of the collection\r\n        newCollection = this.filterCollection(newCollection);\r\n        newCollection = this.sortCollection(newCollection);\r\n        // filter input can only have 1 search term, so we will use the 1st array index if it exist\r\n        const searchTerm = (Array.isArray(this.searchTerms) && this.searchTerms.length >= 0) ? this.searchTerms[0] : '';\r\n        // step 1, create HTML string template\r\n        const filterTemplate = this.buildTemplateHtmlString();\r\n        // step 2, create the DOM Element of the filter & pre-load search term\r\n        // also subscribe to the onSelect event\r\n        this._collection = newCollection;\r\n        this.$filterElm = this.createDomElement(filterTemplate, newCollection, searchTerm);\r\n        // step 3, subscribe to the keyup event and run the callback when that happens\r\n        // also add/remove \"filled\" class for styling purposes\r\n        this.$filterElm.on('keyup', (e) => {\r\n            let value = e && e.target && e.target.value || '';\r\n            const enableWhiteSpaceTrim = this.gridOptions.enableFilterTrimWhiteSpace || this.columnFilter.enableTrimWhiteSpace;\r\n            if (typeof value === 'string' && enableWhiteSpaceTrim) {\r\n                value = value.trim();\r\n            }\r\n            if (this._clearFilterTriggered) {\r\n                this.callback(e, { columnDef: this.columnDef, clearFilterTriggered: this._clearFilterTriggered, shouldTriggerQuery: this._shouldTriggerQuery });\r\n                this.$filterElm.removeClass('filled');\r\n            }\r\n            else {\r\n                value === '' ? this.$filterElm.removeClass('filled') : this.$filterElm.addClass('filled');\r\n                this.callback(e, { columnDef: this.columnDef, operator: this.operator, searchTerms: [value], shouldTriggerQuery: this._shouldTriggerQuery });\r\n            }\r\n            // reset both flags for next use\r\n            this._clearFilterTriggered = false;\r\n            this._shouldTriggerQuery = true;\r\n        });\r\n    }\r\n    /**\r\n     * Create the HTML template as a string\r\n     */\r\n    buildTemplateHtmlString() {\r\n        const columnId = this.columnDef && this.columnDef.id;\r\n        let placeholder = (this.gridOptions) ? (this.gridOptions.defaultFilterPlaceholder || '') : '';\r\n        if (this.columnFilter && this.columnFilter.placeholder) {\r\n            placeholder = this.columnFilter.placeholder;\r\n        }\r\n        return `<input type=\"text\" role=\"presentation\" autocomplete=\"off\" class=\"form-control autocomplete search-filter filter-${columnId}\" placeholder=\"${placeholder}\">`;\r\n    }\r\n    /**\r\n     * From the html template string, create a DOM element\r\n     * @param filterTemplate\r\n     */\r\n    createDomElement(filterTemplate, collection, searchTerm) {\r\n        const columnId = this.columnDef && this.columnDef.id;\r\n        const $headerElm = this.grid.getHeaderRowColumn(columnId);\r\n        $($headerElm).empty();\r\n        // create the DOM element & add an ID and filter class\r\n        const $filterElm = $(filterTemplate);\r\n        const searchTermInput = searchTerm;\r\n        // user might provide his own custom structure\r\n        // jQuery UI autocomplete requires a label/value pair, so we must remap them when user provide different ones\r\n        if (Array.isArray(collection) && this.customStructure) {\r\n            collection = collection.map((item) => {\r\n                return { label: item[this.labelName], value: item[this.valueName] };\r\n            });\r\n        }\r\n        // user might pass his own autocomplete options\r\n        const autoCompleteOptions = this.columnFilter.filterOptions;\r\n        // when user passes it's own autocomplete options\r\n        // we still need to provide our own \"select\" callback implementation\r\n        if (autoCompleteOptions) {\r\n            autoCompleteOptions.select = (event, ui) => this.onSelect(event, ui);\r\n            this._autoCompleteOptions = Object.assign({}, autoCompleteOptions);\r\n            $filterElm.autocomplete(autoCompleteOptions);\r\n        }\r\n        else {\r\n            const definedOptions = {\r\n                minLength: 0,\r\n                source: collection,\r\n                select: (event, ui) => this.onSelect(event, ui),\r\n            };\r\n            this._autoCompleteOptions = Object.assign({}, definedOptions, this.columnFilter.filterOptions);\r\n            $filterElm.autocomplete(this._autoCompleteOptions);\r\n        }\r\n        $filterElm.val(searchTermInput);\r\n        $filterElm.data('columnId', columnId);\r\n        // if there's a search term, we will add the \"filled\" class for styling purposes\r\n        if (searchTerm) {\r\n            $filterElm.addClass('filled');\r\n        }\r\n        // append the new DOM element to the header row\r\n        if ($filterElm && typeof $filterElm.appendTo === 'function') {\r\n            $filterElm.appendTo($headerElm);\r\n        }\r\n        return $filterElm;\r\n    }\r\n    //\r\n    // private functions\r\n    // ------------------\r\n    // this function should be PRIVATE but for unit tests purposes we'll make it public until a better solution is found\r\n    // a better solution would be to get the autocomplete DOM element to work with selection but I couldn't find how to do that in Jest\r\n    onSelect(event, ui) {\r\n        if (ui && ui.item) {\r\n            const itemLabel = typeof ui.item === 'string' ? ui.item : ui.item.label;\r\n            const itemValue = typeof ui.item === 'string' ? ui.item : ui.item.value;\r\n            this.setValues(itemLabel);\r\n            itemValue === '' ? this.$filterElm.removeClass('filled') : this.$filterElm.addClass('filled');\r\n            this.callback(event, { columnDef: this.columnDef, operator: this.operator, searchTerms: [itemValue], shouldTriggerQuery: this._shouldTriggerQuery });\r\n            // reset both flags for next use\r\n            this._clearFilterTriggered = false;\r\n            this._shouldTriggerQuery = true;\r\n        }\r\n        return false;\r\n    }\r\n};\r\nAutoCompleteFilter = __decorate([\r\n    Injectable(),\r\n    __metadata(\"design:paramtypes\", [TranslateService, CollectionService])\r\n], AutoCompleteFilter);\n\nrequire('flatpickr');\r\nlet CompoundDateFilter = class CompoundDateFilter {\r\n    constructor(translate) {\r\n        this.translate = translate;\r\n        this._clearFilterTriggered = false;\r\n        this._shouldTriggerQuery = true;\r\n    }\r\n    /** Getter for the Grid Options pulled through the Grid Object */\r\n    get gridOptions() {\r\n        return (this.grid && this.grid.getOptions) ? this.grid.getOptions() : {};\r\n    }\r\n    /** Getter for the Column Filter */\r\n    get columnFilter() {\r\n        return this.columnDef && this.columnDef.filter || {};\r\n    }\r\n    /** Getter for the Current Dates selected */\r\n    get currentDate() {\r\n        return this._currentDate;\r\n    }\r\n    /** Getter to know what would be the default operator when none is specified */\r\n    get defaultOperator() {\r\n        return OperatorType.empty;\r\n    }\r\n    /** Getter for the Flatpickr Options */\r\n    get flatpickrOptions() {\r\n        return this._flatpickrOptions || {};\r\n    }\r\n    /** Getter for the Filter Operator */\r\n    get operator() {\r\n        return this._operator || this.columnFilter.operator || this.defaultOperator;\r\n    }\r\n    /** Setter for the Filter Operator */\r\n    set operator(op) {\r\n        this._operator = op;\r\n    }\r\n    /**\r\n     * Initialize the Filter\r\n     */\r\n    init(args) {\r\n        if (!args) {\r\n            throw new Error('[Angular-SlickGrid] A filter must always have an \"init()\" with valid arguments.');\r\n        }\r\n        this.grid = args.grid;\r\n        this.callback = args.callback;\r\n        this.columnDef = args.columnDef;\r\n        this.operator = args.operator || '';\r\n        this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];\r\n        // date input can only have 1 search term, so we will use the 1st array index if it exist\r\n        const searchTerm = (Array.isArray(this.searchTerms) && this.searchTerms.length >= 0) ? this.searchTerms[0] : '';\r\n        // step 1, create the DOM Element of the filter which contain the compound Operator+Input\r\n        // and initialize it if searchTerm is filled\r\n        this.$filterElm = this.createDomElement(searchTerm);\r\n        // step 3, subscribe to the keyup event and run the callback when that happens\r\n        // also add/remove \"filled\" class for styling purposes\r\n        this.$filterInputElm.keyup((e) => {\r\n            this.onTriggerEvent(e);\r\n        });\r\n        this.$selectOperatorElm.change((e) => {\r\n            this.onTriggerEvent(e);\r\n        });\r\n    }\r\n    /**\r\n     * Clear the filter value\r\n     */\r\n    clear(shouldTriggerQuery = true) {\r\n        if (this.flatInstance && this.$selectOperatorElm) {\r\n            this._clearFilterTriggered = true;\r\n            this._shouldTriggerQuery = shouldTriggerQuery;\r\n            this.searchTerms = [];\r\n            this.$selectOperatorElm.val(0);\r\n            this.flatInstance.clear();\r\n        }\r\n    }\r\n    /**\r\n     * destroy the filter\r\n     */\r\n    destroy() {\r\n        if (this.$filterElm) {\r\n            this.$filterElm.off('keyup').remove();\r\n        }\r\n        if (this.flatInstance && typeof this.flatInstance.destroy === 'function') {\r\n            this.flatInstance.destroy();\r\n        }\r\n    }\r\n    hide() {\r\n        if (this.flatInstance && typeof this.flatInstance.close === 'function') {\r\n            this.flatInstance.close();\r\n        }\r\n    }\r\n    show() {\r\n        if (this.flatInstance && typeof this.flatInstance.open === 'function') {\r\n            this.flatInstance.open();\r\n        }\r\n    }\r\n    /** Set value(s) in the DOM element, we can optionally pass an operator and/or trigger a change event */\r\n    setValues(values, operator) {\r\n        if (this.flatInstance && values) {\r\n            const newValue = Array.isArray(values) ? values[0] : values;\r\n            this._currentDate = newValue;\r\n            this.flatInstance.setDate(newValue);\r\n        }\r\n        // set the operator, in the DOM as well, when defined\r\n        this.operator = operator || this.defaultOperator;\r\n        if (operator && this.$selectOperatorElm) {\r\n            const operatorShorthand = mapOperatorToShorthandDesignation(this.operator);\r\n            this.$selectOperatorElm.val(operatorShorthand);\r\n        }\r\n    }\r\n    //\r\n    // private functions\r\n    // ------------------\r\n    buildDatePickerInput(searchTerm) {\r\n        const inputFormat = mapFlatpickrDateFormatWithFieldType(this.columnDef.type || FieldType.dateIso);\r\n        const outputFormat = mapFlatpickrDateFormatWithFieldType(this.columnDef.outputType || this.columnDef.type || FieldType.dateUtc);\r\n        const userFilterOptions = (this.columnFilter && this.columnFilter.filterOptions || {});\r\n        // get current locale, if user defined a custom locale just use or get it the Translate Service if it exist else just use English\r\n        let currentLocale = (userFilterOptions && userFilterOptions.locale) || (this.translate && this.translate.currentLang) || this.gridOptions.locale || 'en';\r\n        if (currentLocale && currentLocale.length > 2) {\r\n            currentLocale = currentLocale.substring(0, 2);\r\n        }\r\n        // if we are preloading searchTerms, we'll keep them for reference\r\n        if (searchTerm) {\r\n            this._currentDate = searchTerm;\r\n        }\r\n        const pickerOptions = {\r\n            defaultDate: searchTerm || '',\r\n            altInput: true,\r\n            altFormat: outputFormat,\r\n            dateFormat: inputFormat,\r\n            wrap: true,\r\n            closeOnSelect: true,\r\n            locale: (currentLocale !== 'en') ? this.loadFlatpickrLocale(currentLocale) : 'en',\r\n            onChange: (selectedDates, dateStr, instance) => {\r\n                this._currentValue = dateStr;\r\n                this._currentDate = Array.isArray(selectedDates) && selectedDates[0];\r\n                // when using the time picker, we can simulate a keyup event to avoid multiple backend request\r\n                // since backend request are only executed after user start typing, changing the time should be treated the same way\r\n                if (pickerOptions.enableTime) {\r\n                    this.onTriggerEvent(new CustomEvent('keyup'));\r\n                }\r\n                else {\r\n                    this.onTriggerEvent(undefined);\r\n                }\r\n            }\r\n        };\r\n        // add the time picker when format is UTC (Z) or has the 'h' (meaning hours)\r\n        if (outputFormat && (outputFormat === 'Z' || outputFormat.toLowerCase().includes('h'))) {\r\n            pickerOptions.enableTime = true;\r\n        }\r\n        // merge options with optional user's custom options\r\n        this._flatpickrOptions = Object.assign({}, pickerOptions, userFilterOptions);\r\n        let placeholder = (this.gridOptions) ? (this.gridOptions.defaultFilterPlaceholder || '') : '';\r\n        if (this.columnFilter && this.columnFilter.placeholder) {\r\n            placeholder = this.columnFilter.placeholder;\r\n        }\r\n        const $filterInputElm = $(`<div class=\"flatpickr\"><input type=\"text\" class=\"form-control\" data-input placeholder=\"${placeholder}\"></div>`);\r\n        this.flatInstance = ($filterInputElm[0] && typeof $filterInputElm[0].flatpickr === 'function') ? $filterInputElm[0].flatpickr(this._flatpickrOptions) : Flatpickr($filterInputElm, this._flatpickrOptions);\r\n        return $filterInputElm;\r\n    }\r\n    buildSelectOperatorHtmlString() {\r\n        const optionValues = this.getOptionValues();\r\n        let optionValueString = '';\r\n        optionValues.forEach((option) => {\r\n            optionValueString += `<option value=\"${option.operator}\" title=\"${option.description}\">${option.operator}</option>`;\r\n        });\r\n        return `<select class=\"form-control\">${optionValueString}</select>`;\r\n    }\r\n    getOptionValues() {\r\n        return [\r\n            { operator: '', description: '' },\r\n            { operator: '=', description: '=' },\r\n            { operator: '<', description: '<' },\r\n            { operator: '<=', description: '<=' },\r\n            { operator: '>', description: '>' },\r\n            { operator: '>=', description: '>=' },\r\n            { operator: '<>', description: '<>' }\r\n        ];\r\n    }\r\n    /**\r\n     * Create the DOM element\r\n     */\r\n    createDomElement(searchTerm) {\r\n        const fieldId = this.columnDef && this.columnDef.id;\r\n        const $headerElm = this.grid.getHeaderRowColumn(fieldId);\r\n        $($headerElm).empty();\r\n        // create the DOM Select dropdown for the Operator\r\n        this.$selectOperatorElm = $(this.buildSelectOperatorHtmlString());\r\n        this.$filterInputElm = this.buildDatePickerInput(searchTerm);\r\n        const $filterContainerElm = $(`<div class=\"form-group search-filter filter-${fieldId}\"></div>`);\r\n        const $containerInputGroup = $(`<div class=\"input-group flatpickr\"></div>`);\r\n        const $operatorInputGroupAddon = $(`<div class=\"input-group-addon input-group-prepend operator\"></div>`);\r\n        /* the DOM element final structure will be\r\n          <div class=\"input-group\">\r\n            <div class=\"input-group-addon input-group-prepend operator\">\r\n              <select class=\"form-control\"></select>\r\n            </div>\r\n            <div class=flatpickr>\r\n              <input type=\"text\" class=\"form-control\" data-input>\r\n            </div>\r\n          </div>\r\n        */\r\n        $operatorInputGroupAddon.append(this.$selectOperatorElm);\r\n        $containerInputGroup.append($operatorInputGroupAddon);\r\n        $containerInputGroup.append(this.$filterInputElm);\r\n        // create the DOM element & add an ID and filter class\r\n        $filterContainerElm.append($containerInputGroup);\r\n        this.$filterInputElm.data('columnId', fieldId);\r\n        if (this.operator) {\r\n            this.$selectOperatorElm.val(this.operator);\r\n        }\r\n        // if there's a search term, we will add the \"filled\" class for styling purposes\r\n        if (searchTerm && searchTerm !== '') {\r\n            this.$filterInputElm.addClass('filled');\r\n            this._currentDate = searchTerm;\r\n            this._currentValue = searchTerm;\r\n        }\r\n        // append the new DOM element to the header row\r\n        if ($filterContainerElm && typeof $filterContainerElm.appendTo === 'function') {\r\n            $filterContainerElm.appendTo($headerElm);\r\n        }\r\n        return $filterContainerElm;\r\n    }\r\n    /** Load a different set of locales for Flatpickr to be localized */\r\n    loadFlatpickrLocale(language) {\r\n        let locales = 'en';\r\n        try {\r\n            if (language !== 'en') {\r\n                // change locale if needed, Flatpickr reference: https://chmln.github.io/flatpickr/localization/\r\n                const localeDefault = require(`flatpickr/dist/l10n/${language}.js`).default;\r\n                locales = (localeDefault && localeDefault[language]) ? localeDefault[language] : 'en';\r\n            }\r\n        }\r\n        catch (e) {\r\n            console.warn(`[Angular-Slickgrid - CompoundDate Filter] It seems that \"${language}\" is not a locale supported by Flatpickr, we will use \"en\" instead. `\r\n                + `To avoid seeing this message, you can specifically set \"filter: { filterOptions: { locale: 'en' } }\" in your column definition.`);\r\n            return 'en';\r\n        }\r\n        return locales;\r\n    }\r\n    onTriggerEvent(e) {\r\n        if (this._clearFilterTriggered) {\r\n            this.callback(e, { columnDef: this.columnDef, clearFilterTriggered: this._clearFilterTriggered, shouldTriggerQuery: this._shouldTriggerQuery });\r\n            this.$filterElm.removeClass('filled');\r\n        }\r\n        else {\r\n            const selectedOperator = this.$selectOperatorElm.find('option:selected').text();\r\n            (this._currentValue) ? this.$filterElm.addClass('filled') : this.$filterElm.removeClass('filled');\r\n            this.callback(e, { columnDef: this.columnDef, searchTerms: (this._currentValue ? [this._currentValue] : null), operator: selectedOperator || '', shouldTriggerQuery: this._shouldTriggerQuery });\r\n        }\r\n        // reset both flags for next use\r\n        this._clearFilterTriggered = false;\r\n        this._shouldTriggerQuery = true;\r\n    }\r\n};\r\nCompoundDateFilter = __decorate([\r\n    __param(0, Optional()),\r\n    __metadata(\"design:paramtypes\", [TranslateService])\r\n], CompoundDateFilter);\n\nclass CompoundInputFilter {\r\n    constructor(translate) {\r\n        this.translate = translate;\r\n        this._clearFilterTriggered = false;\r\n        this._shouldTriggerQuery = true;\r\n        this._inputType = 'text';\r\n    }\r\n    /** Getter for the Grid Options pulled through the Grid Object */\r\n    get gridOptions() {\r\n        return (this.grid && this.grid.getOptions) ? this.grid.getOptions() : {};\r\n    }\r\n    /** Getter for the Column Filter */\r\n    get columnFilter() {\r\n        return this.columnDef && this.columnDef.filter || {};\r\n    }\r\n    /** Getter to know what would be the default operator when none is specified */\r\n    get defaultOperator() {\r\n        return OperatorType.empty;\r\n    }\r\n    /** Getter of input type (text, number, password) */\r\n    get inputType() {\r\n        return this._inputType;\r\n    }\r\n    /** Setter of input type (text, number, password) */\r\n    set inputType(type) {\r\n        this._inputType = type;\r\n    }\r\n    /** Getter of the Operator to use when doing the filter comparing */\r\n    get operator() {\r\n        return this._operator || this.defaultOperator;\r\n    }\r\n    /** Getter of the Operator to use when doing the filter comparing */\r\n    set operator(op) {\r\n        this._operator = op;\r\n    }\r\n    /**\r\n     * Initialize the Filter\r\n     */\r\n    init(args) {\r\n        if (!args) {\r\n            throw new Error('[Angular-SlickGrid] A filter must always have an \"init()\" with valid arguments.');\r\n        }\r\n        this.grid = args.grid;\r\n        this.callback = args.callback;\r\n        this.columnDef = args.columnDef;\r\n        this.operator = args.operator;\r\n        this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];\r\n        // get locales provided by user in forRoot or else use default English locales via the Constants\r\n        this._locales = this.gridOptions && this.gridOptions.locales || Constants.locales;\r\n        // filter input can only have 1 search term, so we will use the 1st array index if it exist\r\n        const searchTerm = (Array.isArray(this.searchTerms) && this.searchTerms.length >= 0) ? this.searchTerms[0] : '';\r\n        // step 1, create the DOM Element of the filter which contain the compound Operator+Input\r\n        // and initialize it if searchTerms is filled\r\n        this.$filterElm = this.createDomElement(searchTerm);\r\n        // step 3, subscribe to the keyup event and run the callback when that happens\r\n        // also add/remove \"filled\" class for styling purposes\r\n        this.$filterInputElm.on('keyup input change', (e) => {\r\n            this.onTriggerEvent(e);\r\n        });\r\n        this.$selectOperatorElm.on('change', (e) => {\r\n            this.onTriggerEvent(e);\r\n        });\r\n    }\r\n    /**\r\n     * Clear the filter value\r\n     */\r\n    clear(shouldTriggerQuery = true) {\r\n        if (this.$filterElm && this.$selectOperatorElm) {\r\n            this._clearFilterTriggered = true;\r\n            this._shouldTriggerQuery = shouldTriggerQuery;\r\n            this.searchTerms = [];\r\n            this.$selectOperatorElm.val(0);\r\n            this.$filterInputElm.val('');\r\n            this.onTriggerEvent(null);\r\n        }\r\n    }\r\n    /**\r\n     * destroy the filter\r\n     */\r\n    destroy() {\r\n        if (this.$filterElm && this.$selectOperatorElm) {\r\n            this.$filterElm.off('keyup input change').remove();\r\n            this.$selectOperatorElm.off('change');\r\n        }\r\n    }\r\n    /** Set value(s) on the DOM element */\r\n    setValues(values, operator) {\r\n        if (values) {\r\n            const newValue = Array.isArray(values) ? values[0] : values;\r\n            this.$filterInputElm.val(newValue);\r\n        }\r\n        // set the operator, in the DOM as well, when defined\r\n        this.operator = operator || this.defaultOperator;\r\n        if (operator && this.$selectOperatorElm) {\r\n            const operatorShorthand = mapOperatorToShorthandDesignation(this.operator);\r\n            this.$selectOperatorElm.val(operatorShorthand);\r\n        }\r\n    }\r\n    //\r\n    // private functions\r\n    // ------------------\r\n    buildInputHtmlString() {\r\n        let placeholder = (this.gridOptions) ? (this.gridOptions.defaultFilterPlaceholder || '') : '';\r\n        if (this.columnFilter && this.columnFilter.placeholder) {\r\n            placeholder = this.columnFilter.placeholder;\r\n        }\r\n        return `<input type=\"${this._inputType || 'text'}\" role=\"presentation\"  autocomplete=\"off\" class=\"form-control compound-input\" placeholder=\"${placeholder}\" /><span></span>`;\r\n    }\r\n    buildSelectOperatorHtmlString() {\r\n        const optionValues = this.getOptionValues();\r\n        let optionValueString = '';\r\n        optionValues.forEach((option) => {\r\n            optionValueString += `<option value=\"${option.operator}\" title=\"${option.description}\">${option.operator}</option>`;\r\n        });\r\n        return `<select class=\"form-control\">${optionValueString}</select>`;\r\n    }\r\n    getOptionValues() {\r\n        const type = (this.columnDef.type && this.columnDef.type) ? this.columnDef.type : FieldType.string;\r\n        let optionValues = [];\r\n        switch (type) {\r\n            case FieldType.string:\r\n                optionValues = [\r\n                    { operator: '', description: this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant('CONTAINS') || this._locales && this._locales.TEXT_CONTAINS },\r\n                    { operator: '=', description: this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant('EQUALS') || this._locales && this._locales.TEXT_EQUALS },\r\n                    { operator: 'a*', description: this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant('STARTS_WITH') || this._locales && this._locales.TEXT_STARTS_WITH },\r\n                    { operator: '*z', description: this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant('ENDS_WITH') || this._locales && this._locales.TEXT_CONTAINS },\r\n                ];\r\n                break;\r\n            default:\r\n                optionValues = [\r\n                    { operator: '', description: '' },\r\n                    { operator: '=', description: '=' },\r\n                    { operator: '<', description: '<' },\r\n                    { operator: '<=', description: '<=' },\r\n                    { operator: '>', description: '>' },\r\n                    { operator: '>=', description: '>=' },\r\n                    { operator: '<>', description: '<>' }\r\n                ];\r\n                break;\r\n        }\r\n        return optionValues;\r\n    }\r\n    /**\r\n     * Create the DOM element\r\n     */\r\n    createDomElement(searchTerm) {\r\n        const fieldId = this.columnDef && this.columnDef.id;\r\n        const $headerElm = this.grid.getHeaderRowColumn(fieldId);\r\n        $($headerElm).empty();\r\n        // create the DOM Select dropdown for the Operator\r\n        this.$selectOperatorElm = $(this.buildSelectOperatorHtmlString());\r\n        this.$filterInputElm = $(this.buildInputHtmlString());\r\n        const $filterContainerElm = $(`<div class=\"form-group search-filter filter-${fieldId}\"></div>`);\r\n        const $containerInputGroup = $(`<div class=\"input-group\"></div>`);\r\n        const $operatorInputGroupAddon = $(`<div class=\"input-group-addon input-group-prepend operator\"></div>`);\r\n        /* the DOM element final structure will be\r\n          <div class=\"input-group\">\r\n            <div class=\"input-group-addon input-group-prepend operator\">\r\n              <select class=\"form-control\"></select>\r\n            </div>\r\n            <input class=\"form-control compount-input\" type=\"text\" />\r\n          </div>\r\n        */\r\n        $operatorInputGroupAddon.append(this.$selectOperatorElm);\r\n        $containerInputGroup.append($operatorInputGroupAddon);\r\n        $containerInputGroup.append(this.$filterInputElm);\r\n        // create the DOM element & add an ID and filter class\r\n        $filterContainerElm.append($containerInputGroup);\r\n        this.$filterInputElm.val(searchTerm);\r\n        this.$filterInputElm.data('columnId', fieldId);\r\n        if (this.operator) {\r\n            this.$selectOperatorElm.val(this.operator);\r\n        }\r\n        // if there's a search term, we will add the \"filled\" class for styling purposes\r\n        if (searchTerm) {\r\n            $filterContainerElm.addClass('filled');\r\n        }\r\n        // append the new DOM element to the header row\r\n        if ($filterContainerElm && typeof $filterContainerElm.appendTo === 'function') {\r\n            $filterContainerElm.appendTo($headerElm);\r\n        }\r\n        return $filterContainerElm;\r\n    }\r\n    onTriggerEvent(e) {\r\n        if (this._clearFilterTriggered) {\r\n            this.callback(e, { columnDef: this.columnDef, clearFilterTriggered: this._clearFilterTriggered, shouldTriggerQuery: this._shouldTriggerQuery });\r\n            this.$filterElm.removeClass('filled');\r\n        }\r\n        else {\r\n            const selectedOperator = this.$selectOperatorElm.find('option:selected').text();\r\n            let value = this.$filterInputElm.val();\r\n            const enableWhiteSpaceTrim = this.gridOptions.enableFilterTrimWhiteSpace || this.columnFilter.enableTrimWhiteSpace;\r\n            if (typeof value === 'string' && enableWhiteSpaceTrim) {\r\n                value = value.trim();\r\n            }\r\n            (value !== null && value !== undefined && value !== '') ? this.$filterElm.addClass('filled') : this.$filterElm.removeClass('filled');\r\n            this.callback(e, { columnDef: this.columnDef, searchTerms: (value ? [value] : null), operator: selectedOperator || '', shouldTriggerQuery: this._shouldTriggerQuery });\r\n        }\r\n        // reset both flags for next use\r\n        this._clearFilterTriggered = false;\r\n        this._shouldTriggerQuery = true;\r\n    }\r\n}\n\nclass CompoundInputNumberFilter extends CompoundInputFilter {\r\n    /** Initialize the Filter */\r\n    constructor(translate) {\r\n        super(translate);\r\n        this.translate = translate;\r\n        this.inputType = 'number';\r\n    }\r\n}\n\nclass CompoundInputPasswordFilter extends CompoundInputFilter {\r\n    /** Initialize the Filter */\r\n    constructor(translate) {\r\n        super(translate);\r\n        this.translate = translate;\r\n        this.inputType = 'password';\r\n    }\r\n}\n\nconst DEFAULT_MIN_VALUE = 0;\r\nconst DEFAULT_MAX_VALUE = 100;\r\nconst DEFAULT_STEP = 1;\r\nclass CompoundSliderFilter {\r\n    constructor() {\r\n        this._clearFilterTriggered = false;\r\n        this._shouldTriggerQuery = true;\r\n    }\r\n    /** Getter to know what would be the default operator when none is specified */\r\n    get defaultOperator() {\r\n        return OperatorType.empty;\r\n    }\r\n    /** Getter for the Filter Generic Params */\r\n    get filterParams() {\r\n        return this.columnDef && this.columnDef.filter && this.columnDef.filter.params || {};\r\n    }\r\n    /** Getter for the `filter` properties */\r\n    get filterProperties() {\r\n        return this.columnDef && this.columnDef.filter;\r\n    }\r\n    get operator() {\r\n        return this._operator || this.defaultOperator;\r\n    }\r\n    set operator(op) {\r\n        this._operator = op;\r\n    }\r\n    /**\r\n     * Initialize the Filter\r\n     */\r\n    init(args) {\r\n        if (!args) {\r\n            throw new Error('[Angular-SlickGrid] A filter must always have an \"init()\" with valid arguments.');\r\n        }\r\n        this.grid = args.grid;\r\n        this.callback = args.callback;\r\n        this.columnDef = args.columnDef;\r\n        this.operator = args.operator || '';\r\n        this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];\r\n        // define the input & slider number IDs\r\n        this._elementRangeInputId = `rangeInput_${this.columnDef.field}`;\r\n        this._elementRangeOutputId = `rangeOutput_${this.columnDef.field}`;\r\n        // filter input can only have 1 search term, so we will use the 1st array index if it exist\r\n        const searchTerm = (Array.isArray(this.searchTerms) && this.searchTerms.length >= 0) ? this.searchTerms[0] : '';\r\n        // step 1, create the DOM Element of the filter which contain the compound Operator+Input\r\n        // and initialize it if searchTerm is filled\r\n        this.$filterElm = this.createDomElement(searchTerm);\r\n        // step 3, subscribe to the keyup event and run the callback when that happens\r\n        // also add/remove \"filled\" class for styling purposes\r\n        this.$filterInputElm.change((e) => {\r\n            this.onTriggerEvent(e);\r\n        });\r\n        this.$selectOperatorElm.change((e) => {\r\n            this.onTriggerEvent(e);\r\n        });\r\n        // if user chose to display the slider number on the right side, then update it every time it changes\r\n        // we need to use both \"input\" and \"change\" event to be all cross-browser\r\n        if (!this.filterParams.hideSliderNumber) {\r\n            this.$filterInputElm.on('input change', (e) => {\r\n                const value = e && e.target && e.target.value || '';\r\n                if (value) {\r\n                    const elements = document.getElementsByClassName(this._elementRangeOutputId);\r\n                    if (elements.length) {\r\n                        elements[0].innerHTML = value;\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Clear the filter value\r\n     */\r\n    clear(shouldTriggerQuery = true) {\r\n        if (this.$filterElm && this.$selectOperatorElm) {\r\n            this._clearFilterTriggered = true;\r\n            this._shouldTriggerQuery = shouldTriggerQuery;\r\n            this.searchTerms = [];\r\n            const clearedValue = this.filterParams.hasOwnProperty('sliderStartValue') ? this.filterParams.sliderStartValue : DEFAULT_MIN_VALUE;\r\n            this._currentValue = +clearedValue;\r\n            this.$selectOperatorElm.val(0);\r\n            this.$filterInputElm.val(clearedValue);\r\n            if (!this.filterParams.hideSliderNumber) {\r\n                this.$containerInputGroupElm.children('div.input-group-addon.input-group-append').children().last().html(clearedValue);\r\n            }\r\n            this.onTriggerEvent(undefined);\r\n            this.$filterElm.removeClass('filled');\r\n        }\r\n    }\r\n    /**\r\n     * destroy the filter\r\n     */\r\n    destroy() {\r\n        if (this.$filterElm) {\r\n            this.$filterElm.off('input change').remove();\r\n        }\r\n    }\r\n    /**\r\n     * Get selected value retrieved from the slider element\r\n     * @params selected items\r\n     */\r\n    getValues() {\r\n        return this._currentValue;\r\n    }\r\n    /** Set value(s) on the DOM element */\r\n    setValues(values, operator) {\r\n        const newValue = Array.isArray(values) ? values[0] : values;\r\n        this._currentValue = +newValue;\r\n        this.$filterInputElm.val(newValue);\r\n        this.$containerInputGroupElm.children('div.input-group-addon.input-group-append').children().last().html(newValue);\r\n        // set the operator, in the DOM as well, when defined\r\n        this.operator = operator || this.defaultOperator;\r\n        if (operator && this.$selectOperatorElm) {\r\n            const operatorShorthand = mapOperatorToShorthandDesignation(this.operator);\r\n            this.$selectOperatorElm.val(operatorShorthand);\r\n        }\r\n    }\r\n    //\r\n    // private functions\r\n    // ------------------\r\n    /** Build HTML Template for the input range (slider) */\r\n    buildTemplateHtmlString() {\r\n        const minValue = this.filterProperties.hasOwnProperty('minValue') ? this.filterProperties.minValue : DEFAULT_MIN_VALUE;\r\n        const maxValue = this.filterProperties.hasOwnProperty('maxValue') ? this.filterProperties.maxValue : DEFAULT_MAX_VALUE;\r\n        const defaultValue = this.filterParams.hasOwnProperty('sliderStartValue') ? this.filterParams.sliderStartValue : minValue;\r\n        const step = this.filterProperties.hasOwnProperty('valueStep') ? this.filterProperties.valueStep : DEFAULT_STEP;\r\n        return `<input type=\"range\" name=\"${this._elementRangeInputId}\"\r\n              defaultValue=\"${defaultValue}\" min=\"${minValue}\" max=\"${maxValue}\" step=\"${step}\"\r\n              class=\"form-control slider-filter-input range compound-slider ${this._elementRangeInputId}\" />`;\r\n    }\r\n    /** Build HTML Template for the text (number) that is shown appended to the slider */\r\n    buildTemplateSliderTextHtmlString() {\r\n        const minValue = this.filterProperties.hasOwnProperty('minValue') ? this.filterProperties.minValue : DEFAULT_MIN_VALUE;\r\n        const defaultValue = this.filterParams.hasOwnProperty('sliderStartValue') ? this.filterParams.sliderStartValue : minValue;\r\n        return `<div class=\"input-group-addon input-group-append slider-value\"><span class=\"input-group-text ${this._elementRangeOutputId}\">${defaultValue}</span></div>`;\r\n    }\r\n    /** Build HTML Template select dropdown (operator) */\r\n    buildSelectOperatorHtmlString() {\r\n        const optionValues = this.getOptionValues();\r\n        let optionValueString = '';\r\n        optionValues.forEach((option) => {\r\n            optionValueString += `<option value=\"${option.operator}\" title=\"${option.description}\">${option.operator}</option>`;\r\n        });\r\n        return `<select class=\"form-control\">${optionValueString}</select>`;\r\n    }\r\n    /** Get the available operator option values */\r\n    getOptionValues() {\r\n        return [\r\n            { operator: '', description: '' },\r\n            { operator: '=', description: '=' },\r\n            { operator: '<', description: '<' },\r\n            { operator: '<=', description: '<=' },\r\n            { operator: '>', description: '>' },\r\n            { operator: '>=', description: '>=' },\r\n            { operator: '<>', description: '<>' }\r\n        ];\r\n    }\r\n    /**\r\n     * Create the DOM element\r\n     */\r\n    createDomElement(searchTerm) {\r\n        const fieldId = this.columnDef && this.columnDef.id;\r\n        const minValue = this.filterProperties.hasOwnProperty('minValue') ? this.filterProperties.minValue : DEFAULT_MIN_VALUE;\r\n        const startValue = this.filterParams.hasOwnProperty('sliderStartValue') ? this.filterParams.sliderStartValue : minValue;\r\n        const $headerElm = this.grid.getHeaderRowColumn(this.columnDef.id);\r\n        $($headerElm).empty();\r\n        let searchTermInput = (searchTerm || '0');\r\n        if (+searchTermInput < minValue) {\r\n            searchTermInput = `${minValue}`;\r\n        }\r\n        if (+searchTermInput < startValue) {\r\n            searchTermInput = `${startValue}`;\r\n        }\r\n        this._currentValue = +searchTermInput;\r\n        // create the DOM Select dropdown for the Operator\r\n        this.$selectOperatorElm = $(this.buildSelectOperatorHtmlString());\r\n        this.$filterInputElm = $(this.buildTemplateHtmlString());\r\n        const $filterContainerElm = $(`<div class=\"form-group slider-container search-filter filter-${fieldId}\"></div>`);\r\n        this.$containerInputGroupElm = $(`<div class=\"input-group search-filter filter-${fieldId}\"></div>`);\r\n        const $operatorInputGroupAddon = $(`<span class=\"input-group-addon input-group-prepend operator\"></span>`);\r\n        /* the DOM element final structure will be\r\n          <div class=\"input-group\">\r\n            <div class=\"input-group-addon input-group-prepend operator\">\r\n              <select class=\"form-control\"></select>\r\n            </div>\r\n            <input class=\"form-control\" type=\"text\" />\r\n            <div class=\"input-group-addon input-group-prepend rangeOuput_percentComplete\"><span class=\"input-group-text\">0</span></div>\r\n          </div>\r\n        */\r\n        $operatorInputGroupAddon.append(this.$selectOperatorElm);\r\n        this.$containerInputGroupElm.append($operatorInputGroupAddon);\r\n        this.$containerInputGroupElm.append(this.$filterInputElm);\r\n        if (!this.filterParams.hideSliderNumber) {\r\n            const $sliderTextInputAppendAddon = $(this.buildTemplateSliderTextHtmlString());\r\n            $sliderTextInputAppendAddon.children().html(searchTermInput);\r\n            this.$containerInputGroupElm.append($sliderTextInputAppendAddon);\r\n        }\r\n        // create the DOM element & add an ID and filter class\r\n        $filterContainerElm.append(this.$containerInputGroupElm);\r\n        this.$filterInputElm.val(searchTermInput);\r\n        this.$filterInputElm.data('columnId', fieldId);\r\n        if (this.operator) {\r\n            this.$selectOperatorElm.val(this.operator);\r\n        }\r\n        // if there's a search term, we will add the \"filled\" class for styling purposes\r\n        if (searchTerm !== '') {\r\n            $filterContainerElm.addClass('filled');\r\n        }\r\n        // append the new DOM element to the header row\r\n        if ($filterContainerElm && typeof $filterContainerElm.appendTo === 'function') {\r\n            $filterContainerElm.appendTo($headerElm);\r\n        }\r\n        return $filterContainerElm;\r\n    }\r\n    onTriggerEvent(e) {\r\n        const value = this.$filterInputElm.val();\r\n        this._currentValue = +value;\r\n        if (this._clearFilterTriggered) {\r\n            this.$filterElm.removeClass('filled');\r\n            this.callback(e, { columnDef: this.columnDef, clearFilterTriggered: this._clearFilterTriggered, shouldTriggerQuery: this._shouldTriggerQuery });\r\n        }\r\n        else {\r\n            this.$filterElm.addClass('filled');\r\n            const selectedOperator = this.$selectOperatorElm.find('option:selected').text();\r\n            this.callback(e, { columnDef: this.columnDef, searchTerms: (value ? [value || '0'] : null), operator: selectedOperator || '', shouldTriggerQuery: this._shouldTriggerQuery });\r\n        }\r\n        // reset both flags for next use\r\n        this._clearFilterTriggered = false;\r\n        this._shouldTriggerQuery = true;\r\n    }\r\n}\n\nclass InputFilter {\r\n    constructor() {\r\n        this._clearFilterTriggered = false;\r\n        this._shouldTriggerQuery = true;\r\n        this._inputType = 'text';\r\n    }\r\n    /** Getter for the Column Filter */\r\n    get columnFilter() {\r\n        return this.columnDef && this.columnDef.filter || {};\r\n    }\r\n    /** Getter to know what would be the default operator when none is specified */\r\n    get defaultOperator() {\r\n        return OperatorType.empty;\r\n    }\r\n    /** Getter of input type (text, number, password) */\r\n    get inputType() {\r\n        return this._inputType;\r\n    }\r\n    /** Setter of input type (text, number, password) */\r\n    set inputType(type) {\r\n        this._inputType = type;\r\n    }\r\n    /** Getter of the Operator to use when doing the filter comparing */\r\n    get operator() {\r\n        return this.columnFilter && this.columnFilter.operator || this.defaultOperator;\r\n    }\r\n    /** Setter for the filter operator */\r\n    set operator(operator) {\r\n        if (this.columnFilter) {\r\n            this.columnFilter.operator = operator;\r\n        }\r\n    }\r\n    /** Getter for the Grid Options pulled through the Grid Object */\r\n    get gridOptions() {\r\n        return (this.grid && this.grid.getOptions) ? this.grid.getOptions() : {};\r\n    }\r\n    /**\r\n     * Initialize the Filter\r\n     */\r\n    init(args) {\r\n        if (!args) {\r\n            throw new Error('[Angular-SlickGrid] A filter must always have an \"init()\" with valid arguments.');\r\n        }\r\n        this.grid = args.grid;\r\n        this.callback = args.callback;\r\n        this.columnDef = args.columnDef;\r\n        this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];\r\n        // filter input can only have 1 search term, so we will use the 1st array index if it exist\r\n        const searchTerm = (Array.isArray(this.searchTerms) && this.searchTerms.length >= 0) ? this.searchTerms[0] : '';\r\n        // step 1, create HTML string template\r\n        const filterTemplate = this.buildTemplateHtmlString();\r\n        // step 2, create the DOM Element of the filter & initialize it if searchTerm is filled\r\n        this.$filterElm = this.createDomElement(filterTemplate, searchTerm);\r\n        // step 3, subscribe to the keyup event and run the callback when that happens\r\n        // also add/remove \"filled\" class for styling purposes\r\n        this.$filterElm.on('keyup input change', (e) => {\r\n            let value = e && e.target && e.target.value || '';\r\n            const enableWhiteSpaceTrim = this.gridOptions.enableFilterTrimWhiteSpace || this.columnFilter.enableTrimWhiteSpace;\r\n            if (typeof value === 'string' && enableWhiteSpaceTrim) {\r\n                value = value.trim();\r\n            }\r\n            if (this._clearFilterTriggered) {\r\n                this.callback(e, { columnDef: this.columnDef, clearFilterTriggered: this._clearFilterTriggered, shouldTriggerQuery: this._shouldTriggerQuery });\r\n                this.$filterElm.removeClass('filled');\r\n            }\r\n            else {\r\n                value === '' ? this.$filterElm.removeClass('filled') : this.$filterElm.addClass('filled');\r\n                this.callback(e, { columnDef: this.columnDef, operator: this.operator, searchTerms: [value], shouldTriggerQuery: this._shouldTriggerQuery });\r\n            }\r\n            // reset both flags for next use\r\n            this._clearFilterTriggered = false;\r\n            this._shouldTriggerQuery = true;\r\n        });\r\n    }\r\n    /**\r\n     * Clear the filter value\r\n     */\r\n    clear(shouldTriggerQuery = true) {\r\n        if (this.$filterElm) {\r\n            this._clearFilterTriggered = true;\r\n            this._shouldTriggerQuery = shouldTriggerQuery;\r\n            this.searchTerms = [];\r\n            this.$filterElm.val('');\r\n            this.$filterElm.trigger('keyup');\r\n        }\r\n    }\r\n    /**\r\n     * destroy the filter\r\n     */\r\n    destroy() {\r\n        if (this.$filterElm) {\r\n            this.$filterElm.off('keyup input change').remove();\r\n        }\r\n    }\r\n    /** Set value(s) on the DOM element */\r\n    setValues(values, operator) {\r\n        if (values) {\r\n            this.$filterElm.val(values);\r\n        }\r\n        // set the operator when defined\r\n        this.operator = operator || this.defaultOperator;\r\n    }\r\n    //\r\n    // protected functions\r\n    // ------------------\r\n    /**\r\n     * Create the HTML template as a string\r\n     */\r\n    buildTemplateHtmlString() {\r\n        const fieldId = this.columnDef && this.columnDef.id;\r\n        let placeholder = (this.gridOptions) ? (this.gridOptions.defaultFilterPlaceholder || '') : '';\r\n        if (this.columnFilter && this.columnFilter.placeholder) {\r\n            placeholder = this.columnFilter.placeholder;\r\n        }\r\n        return `<input type=\"${this._inputType || 'text'}\" role=\"presentation\" autocomplete=\"off\" class=\"form-control search-filter filter-${fieldId}\" placeholder=\"${placeholder}\"><span></span>`;\r\n    }\r\n    /**\r\n     * From the html template string, create a DOM element\r\n     * @param filterTemplate\r\n     */\r\n    createDomElement(filterTemplate, searchTerm) {\r\n        const fieldId = this.columnDef && this.columnDef.id;\r\n        const $headerElm = this.grid.getHeaderRowColumn(fieldId);\r\n        $($headerElm).empty();\r\n        // create the DOM element & add an ID and filter class\r\n        const $filterElm = $(filterTemplate);\r\n        $filterElm.val(searchTerm);\r\n        $filterElm.data('columnId', fieldId);\r\n        // if there's a search term, we will add the \"filled\" class for styling purposes\r\n        if (searchTerm) {\r\n            $filterElm.addClass('filled');\r\n        }\r\n        // append the new DOM element to the header row\r\n        if ($filterElm && typeof $filterElm.appendTo === 'function') {\r\n            $filterElm.appendTo($headerElm);\r\n        }\r\n        return $filterElm;\r\n    }\r\n}\n\nclass InputMaskFilter extends InputFilter {\r\n    /** Initialize the Filter */\r\n    constructor() {\r\n        super();\r\n        this.inputType = 'text';\r\n    }\r\n    /** Getter of the input mask, when provided */\r\n    get inputMask() {\r\n        return this._inputMask;\r\n    }\r\n    /**\r\n     * Override the Filter init used by SlickGrid\r\n     */\r\n    init(args) {\r\n        if (!args) {\r\n            throw new Error('[Angular-SlickGrid] A filter must always have an \"init()\" with valid arguments.');\r\n        }\r\n        this.grid = args.grid;\r\n        this.callback = args.callback;\r\n        this.columnDef = args.columnDef;\r\n        this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];\r\n        // get input mask from params (can be in columnDef or columnFilter params)\r\n        if (this.columnDef && this.columnDef.params && this.columnDef.params.mask) {\r\n            this._inputMask = this.columnDef.params.mask;\r\n        }\r\n        else if (this.columnFilter && this.columnFilter.params && this.columnFilter.params.mask) {\r\n            this._inputMask = this.columnFilter.params.mask;\r\n        }\r\n        if (!this._inputMask) {\r\n            throw new Error(`[Angular-Slickgrid] The Filters.inputMask requires the mask to be passed in the filter params or the column definition params\r\n        for example:: this.columnDefinitions: [{ id: 'phone', field: 'phone', filter: { model: Filters.inputMask, params: { mask: '000-000-0000' }}}]`);\r\n        }\r\n        // filter input can only have 1 search term, so we will use the 1st array index if it exist\r\n        const searchTerm = (Array.isArray(this.searchTerms) && this.searchTerms.length >= 0) ? this.searchTerms[0] : '';\r\n        // step 1, create HTML string template\r\n        const filterTemplate = this.buildTemplateHtmlString();\r\n        // step 2, create the DOM Element of the filter & initialize it if searchTerm is filled\r\n        this.$filterElm = this.createDomElement(filterTemplate, searchTerm);\r\n        // step 3, subscribe to the keyup event and run the callback when that happens\r\n        // also add/remove \"filled\" class for styling purposes\r\n        this.$filterElm.on('keyup input change', (e) => {\r\n            let value = '';\r\n            if (e && e.target && e.target.value) {\r\n                let targetValue = e.target.value;\r\n                const enableWhiteSpaceTrim = this.gridOptions.enableFilterTrimWhiteSpace || this.columnFilter.enableTrimWhiteSpace;\r\n                if (typeof targetValue === 'string' && enableWhiteSpaceTrim) {\r\n                    targetValue = targetValue.trim();\r\n                }\r\n                // if it has a mask, we need to do a bit more work\r\n                // and replace the filter string by the masked output without triggering an event\r\n                const unmaskedValue = this.unmaskValue(targetValue);\r\n                const maskedValue = this.maskValue(unmaskedValue);\r\n                value = unmaskedValue;\r\n                if (e.keyCode >= 48) {\r\n                    this.$filterElm.val(maskedValue); // replace filter string with masked string\r\n                    e.preventDefault();\r\n                }\r\n            }\r\n            if (this._clearFilterTriggered) {\r\n                this.callback(e, { columnDef: this.columnDef, clearFilterTriggered: this._clearFilterTriggered, shouldTriggerQuery: this._shouldTriggerQuery });\r\n                this.$filterElm.removeClass('filled');\r\n            }\r\n            else {\r\n                this.$filterElm.addClass('filled');\r\n                this.callback(e, { columnDef: this.columnDef, operator: this.operator, searchTerms: [value], shouldTriggerQuery: this._shouldTriggerQuery });\r\n            }\r\n            // reset both flags for next use\r\n            this._clearFilterTriggered = false;\r\n            this._shouldTriggerQuery = true;\r\n        });\r\n    }\r\n    /** From a regular string, we will use the mask to output a new string */\r\n    maskValue(inputValue) {\r\n        let i = 0;\r\n        let maskedValue = '';\r\n        if (this._inputMask) {\r\n            maskedValue = this._inputMask.replace(/[09A]/gi, (match) => {\r\n                // only replace the char when the mask is a 0 or 9 for a digit OR the mask is \"A\" and the char is a non-digit meaning a string char\r\n                if (((match === '0' || match === '9') && /\\d+/g.test(inputValue[i])) // mask is 0 or 9 and value is a digit\r\n                    || (match.toUpperCase() === 'A' && /[^\\d]+/gi.test(inputValue[i])) // OR mask is an \"A\" and value is non-digit\r\n                ) {\r\n                    return inputValue[i++] || '';\r\n                }\r\n                return '';\r\n            });\r\n        }\r\n        return maskedValue;\r\n    }\r\n    /** From a masked string, we will remove the mask and make a regular string again */\r\n    unmaskValue(maskedValue) {\r\n        // remove anything else but digits and chars from both the input mask and the input masked value for later comparison\r\n        // e.g. (000) 000-0000 would return 0000000000\r\n        const valueWithoutSymbols = maskedValue.replace(/[^0-9a-z]*/gi, '');\r\n        const maskWithoutSymbols = this._inputMask.replace(/[^0-9a-z]*/gi, '');\r\n        // then we can analyze if each char on each indexes equals what the mask requires, if not the char will be disregarded from the output\r\n        // basically, if our mask is \"0A0\" and input value is \"2ab\", then only \"2a\" will be returned since the last char \"b\" is not part of the mask and is invalid\r\n        let output = '';\r\n        for (let i = 0; i < maskWithoutSymbols.length; i++) {\r\n            if (valueWithoutSymbols[i]) {\r\n                if (((maskWithoutSymbols[i] === '0' || maskWithoutSymbols[i] === '9') && /\\d+/g.test(valueWithoutSymbols[i])) // mask is 0 or 9 and value is a digit\r\n                    || (maskWithoutSymbols[i].toUpperCase() === 'A' && /[^\\d]+/gi.test(valueWithoutSymbols[i])) // OR mask is an \"A\" and value is non-digit\r\n                ) {\r\n                    output += valueWithoutSymbols[i]; // valid and matches the Mask, so we can add it up to the string output\r\n                }\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n}\n\nclass InputNumberFilter extends InputFilter {\r\n    /** Initialize the Filter */\r\n    constructor() {\r\n        super();\r\n        this.inputType = 'number';\r\n    }\r\n}\n\nclass InputPasswordFilter extends InputFilter {\r\n    /** Initialize the Filter */\r\n    constructor() {\r\n        super();\r\n        this.inputType = 'password';\r\n    }\r\n}\n\nconst DOMPurify = DOMPurify_; // patch to fix rollup to work\r\nlet SelectFilter = class SelectFilter {\r\n    /**\r\n     * Initialize the Filter\r\n     */\r\n    constructor(translate, collectionService, isMultipleSelect = true) {\r\n        this.translate = translate;\r\n        this.collectionService = collectionService;\r\n        this._isMultipleSelect = true;\r\n        this._shouldTriggerQuery = true;\r\n        this.isFilled = false;\r\n        this.enableTranslateLabel = false;\r\n        this.subscriptions = [];\r\n        this._isMultipleSelect = isMultipleSelect;\r\n    }\r\n    /** Getter for the Column Filter itself */\r\n    get columnFilter() {\r\n        return this.columnDef && this.columnDef.filter;\r\n    }\r\n    /** Getter for the Collection Options */\r\n    get collectionOptions() {\r\n        return this.columnDef && this.columnDef.filter && this.columnDef.filter.collectionOptions;\r\n    }\r\n    /** Getter for the Custom Structure if exist */\r\n    get customStructure() {\r\n        return this.columnDef && this.columnDef.filter && this.columnDef.filter.customStructure;\r\n    }\r\n    /** Getter for the Grid Options pulled through the Grid Object */\r\n    get gridOptions() {\r\n        return (this.grid && this.grid.getOptions) ? this.grid.getOptions() : {};\r\n    }\r\n    /** Getter to know what would be the default operator when none is specified */\r\n    get defaultOperator() {\r\n        return this.isMultipleSelect ? OperatorType.in : OperatorType.equal;\r\n    }\r\n    /** Getter to know if the current filter is a multiple-select (false means it's a single select) */\r\n    get isMultipleSelect() {\r\n        return this._isMultipleSelect;\r\n    }\r\n    /** Getter for the filter operator */\r\n    get operator() {\r\n        return this.columnFilter && this.columnFilter.operator || this.defaultOperator;\r\n    }\r\n    /** Setter for the filter operator */\r\n    set operator(operator) {\r\n        if (this.columnFilter) {\r\n            this.columnFilter.operator = operator;\r\n        }\r\n    }\r\n    /**\r\n     * Initialize the filter template\r\n     */\r\n    init(args, isFilterFirstRender) {\r\n        if (!args) {\r\n            throw new Error('[Angular-SlickGrid] A filter must always have an \"init()\" with valid arguments.');\r\n        }\r\n        this.grid = args.grid;\r\n        this.callback = args.callback;\r\n        this.columnDef = args.columnDef;\r\n        this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];\r\n        if (!this.grid || !this.columnDef || !this.columnFilter || (!this.columnFilter.collection && !this.columnFilter.collectionAsync)) {\r\n            throw new Error(`[Angular-SlickGrid] You need to pass a \"collection\" (or \"collectionAsync\") for the MultipleSelect/SingleSelect Filter to work correctly. Also each option should include a value/label pair (or value/labelKey when using Locale). For example:: { filter: model: Filters.multipleSelect, collection: [{ value: true, label: 'True' }, { value: false, label: 'False'}] }`);\r\n        }\r\n        this.enableTranslateLabel = this.columnFilter.enableTranslateLabel;\r\n        this.labelName = this.customStructure && this.customStructure.label || 'label';\r\n        this.labelPrefixName = this.customStructure && this.customStructure.labelPrefix || 'labelPrefix';\r\n        this.labelSuffixName = this.customStructure && this.customStructure.labelSuffix || 'labelSuffix';\r\n        this.optionLabel = this.customStructure && this.customStructure.optionLabel || 'value';\r\n        this.valueName = this.customStructure && this.customStructure.value || 'value';\r\n        if (this.enableTranslateLabel && !this.gridOptions.enableTranslate && (!this.translate || typeof this.translate.instant !== 'function')) {\r\n            throw new Error(`[select-filter] The ngx-translate TranslateService is required for the Select Filter to work correctly when \"enableTranslateLabel\" is set.`);\r\n        }\r\n        // get locales provided by user in forRoot or else use default English locales via the Constants\r\n        this._locales = this.gridOptions && this.gridOptions.locales || Constants.locales;\r\n        // create the multiple select element\r\n        this.initMultipleSelect();\r\n        // add placeholder when found\r\n        let placeholder = this.gridOptions && this.gridOptions.defaultFilterPlaceholder || '';\r\n        if (this.columnFilter && this.columnFilter.placeholder) {\r\n            placeholder = this.columnFilter.placeholder;\r\n        }\r\n        this.defaultOptions.placeholder = placeholder || '';\r\n        // always render the Select (dropdown) DOM element, even if user passed a \"collectionAsync\",\r\n        // if that is the case, the Select will simply be without any options but we still have to render it (else SlickGrid would throw an error)\r\n        const newCollection = this.columnFilter.collection || [];\r\n        this.renderDomElement(newCollection);\r\n        // on every Filter which have a \"collection\" or a \"collectionAsync\"\r\n        // we will add (or replace) a Subject to the \"collectionAsync\" property so that user has possibility to change the collection\r\n        // if \"collectionAsync\" is already set by the user, it will resolve it first then after it will replace it with a Subject\r\n        const collectionAsync = this.columnFilter && this.columnFilter.collectionAsync;\r\n        if (collectionAsync) {\r\n            return this.renderOptionsAsync(collectionAsync); // create Subject after resolve (createCollectionAsyncSubject)\r\n        }\r\n        else {\r\n            return new Promise((resolve) => resolve(true));\r\n        }\r\n    }\r\n    /**\r\n     * Clear the filter values\r\n     */\r\n    clear(shouldTriggerQuery = true) {\r\n        if (this.$filterElm && this.$filterElm.multipleSelect) {\r\n            // reload the filter element by it's id, to make sure it's still a valid element (because of some issue in the GraphQL example)\r\n            this.$filterElm.multipleSelect('setSelects', []);\r\n            this.$filterElm.removeClass('filled');\r\n            this.$filterElm.siblings('div .search-filter').removeClass('filled');\r\n            this.searchTerms = [];\r\n            this._shouldTriggerQuery = shouldTriggerQuery;\r\n            this.callback(undefined, { columnDef: this.columnDef, clearFilterTriggered: true, shouldTriggerQuery: this._shouldTriggerQuery });\r\n            // reset both flags for next use\r\n            this._shouldTriggerQuery = true;\r\n        }\r\n    }\r\n    /**\r\n     * destroy the filter\r\n     */\r\n    destroy() {\r\n        if (this.$filterElm) {\r\n            // remove event watcher\r\n            this.$filterElm.off().remove();\r\n            const elementClassName = this.elementName.toString().replace('.', '\\\\.'); // make sure to escape any dot \".\" from CSS class to avoid console error\r\n            $(`[name=${elementClassName}].ms-drop`).remove();\r\n        }\r\n        // also dispose of all Subscriptions\r\n        this.subscriptions = unsubscribeAllObservables(this.subscriptions);\r\n    }\r\n    /**\r\n     * Get selected values retrieved from the multiple-selected element\r\n     * @params selected items\r\n     */\r\n    getValues() {\r\n        if (this.$filterElm && typeof this.$filterElm.multipleSelect === 'function') {\r\n            return this.$filterElm.multipleSelect('getSelects');\r\n        }\r\n        return [];\r\n    }\r\n    /** Set value(s) on the DOM element */\r\n    setValues(values, operator) {\r\n        if (values && this.$filterElm && typeof this.$filterElm.multipleSelect === 'function') {\r\n            values = Array.isArray(values) ? values : [values];\r\n            this.$filterElm.multipleSelect('setSelects', values);\r\n        }\r\n        // set the operator when defined\r\n        this.operator = operator || this.defaultOperator;\r\n    }\r\n    //\r\n    // protected functions\r\n    // ------------------\r\n    /**\r\n     * user might want to filter certain items of the collection\r\n     * @param inputCollection\r\n     * @return outputCollection filtered and/or sorted collection\r\n     */\r\n    filterCollection(inputCollection) {\r\n        let outputCollection = inputCollection;\r\n        // user might want to filter certain items of the collection\r\n        if (this.columnDef && this.columnFilter && this.columnFilter.collectionFilterBy) {\r\n            const filterBy = this.columnFilter.collectionFilterBy;\r\n            const filterCollectionBy = this.columnFilter.collectionOptions && this.columnFilter.collectionOptions.filterResultAfterEachPass || null;\r\n            outputCollection = this.collectionService.filterCollection(outputCollection, filterBy, filterCollectionBy);\r\n        }\r\n        return outputCollection;\r\n    }\r\n    /**\r\n     * user might want to sort the collection in a certain way\r\n     * @param inputCollection\r\n     * @return outputCollection filtered and/or sorted collection\r\n     */\r\n    sortCollection(inputCollection) {\r\n        let outputCollection = inputCollection;\r\n        // user might want to sort the collection\r\n        if (this.columnDef && this.columnFilter && this.columnFilter.collectionSortBy) {\r\n            const sortBy = this.columnFilter.collectionSortBy;\r\n            outputCollection = this.collectionService.sortCollection(this.columnDef, outputCollection, sortBy, this.enableTranslateLabel);\r\n        }\r\n        return outputCollection;\r\n    }\r\n    renderOptionsAsync(collectionAsync) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let awaitedCollection = [];\r\n            if (collectionAsync) {\r\n                awaitedCollection = yield castToPromise(collectionAsync);\r\n                this.renderDomElementFromCollectionAsync(awaitedCollection);\r\n                // because we accept Promises & HttpClient Observable only execute once\r\n                // we will re-create an RxJs Subject which will replace the \"collectionAsync\" which got executed once anyway\r\n                // doing this provide the user a way to call a \"collectionAsync.next()\"\r\n                this.createCollectionAsyncSubject();\r\n            }\r\n            return true;\r\n        });\r\n    }\r\n    /** Create or recreate an Observable Subject and reassign it to the \"collectionAsync\" object so user can call a \"collectionAsync.next()\" on it */\r\n    createCollectionAsyncSubject() {\r\n        const newCollectionAsync = new Subject();\r\n        this.columnFilter.collectionAsync = newCollectionAsync;\r\n        this.subscriptions.push(newCollectionAsync.subscribe(collection => this.renderDomElementFromCollectionAsync(collection)));\r\n    }\r\n    /**\r\n     * When user use a CollectionAsync we will use the returned collection to render the filter DOM element\r\n     * and reinitialize filter collection with this new collection\r\n     */\r\n    renderDomElementFromCollectionAsync(collection) {\r\n        if (this.collectionOptions && (this.collectionOptions.collectionInsideObjectProperty || this.collectionOptions.collectionInObjectProperty)) {\r\n            const collectionInsideObjectProperty = this.collectionOptions.collectionInsideObjectProperty || this.collectionOptions.collectionInObjectProperty;\r\n            collection = getDescendantProperty(collection, collectionInsideObjectProperty);\r\n        }\r\n        if (!Array.isArray(collection)) {\r\n            throw new Error('Something went wrong while trying to pull the collection from the \"collectionAsync\" call in the Select Filter, the collection is not a valid array.');\r\n        }\r\n        // copy over the array received from the async call to the \"collection\" as the new collection to use\r\n        // this has to be BEFORE the `collectionObserver().subscribe` to avoid going into an infinite loop\r\n        this.columnFilter.collection = collection;\r\n        // recreate Multiple Select after getting async collection\r\n        this.renderDomElement(collection);\r\n    }\r\n    renderDomElement(collection) {\r\n        if (!Array.isArray(collection) && this.collectionOptions && (this.collectionOptions.collectionInsideObjectProperty || this.collectionOptions.collectionInObjectProperty)) {\r\n            const collectionInsideObjectProperty = this.collectionOptions.collectionInsideObjectProperty || this.collectionOptions.collectionInObjectProperty;\r\n            collection = getDescendantProperty(collection, collectionInsideObjectProperty);\r\n        }\r\n        if (!Array.isArray(collection)) {\r\n            throw new Error('The \"collection\" passed to the Select Filter is not a valid array.');\r\n        }\r\n        // make sure however that it wasn't added more than once\r\n        if (this.collectionOptions && this.collectionOptions.addBlankEntry && Array.isArray(collection) && collection.length > 0 && collection[0][this.labelName] !== '') {\r\n            collection.unshift(this.createBlankEntry());\r\n        }\r\n        let newCollection = collection;\r\n        // user might want to filter and/or sort certain items of the collection\r\n        newCollection = this.filterCollection(newCollection);\r\n        newCollection = this.sortCollection(newCollection);\r\n        // step 1, create HTML string template\r\n        const filterTemplate = this.buildTemplateHtmlString(newCollection, this.searchTerms);\r\n        // step 2, create the DOM Element of the filter & pre-load search terms\r\n        // also subscribe to the onClose event\r\n        this.createDomElement(filterTemplate);\r\n    }\r\n    /** Create the HTML template as a string */\r\n    buildTemplateHtmlString(optionCollection, searchTerms) {\r\n        let options = '';\r\n        const columnId = this.columnDef && this.columnDef.id;\r\n        const separatorBetweenLabels = this.collectionOptions && this.collectionOptions.separatorBetweenTextLabels || '';\r\n        const isEnableTranslate = this.gridOptions && this.gridOptions.enableTranslate;\r\n        const isRenderHtmlEnabled = this.columnFilter && this.columnFilter.enableRenderHtml || false;\r\n        const sanitizedOptions = this.gridOptions && this.gridOptions.sanitizeHtmlOptions || {};\r\n        // collection could be an Array of Strings OR Objects\r\n        if (Array.isArray(optionCollection)) {\r\n            if (optionCollection.every(x => typeof x === 'string')) {\r\n                optionCollection.forEach((option) => {\r\n                    const selected = (searchTerms.findIndex((term) => term === option) >= 0) ? 'selected' : '';\r\n                    options += `<option value=\"${option}\" label=\"${option}\" ${selected}>${option}</option>`;\r\n                    // if there's at least 1 search term found, we will add the \"filled\" class for styling purposes\r\n                    // on a single select, we'll also make sure the single value is not an empty string to consider this being filled\r\n                    if ((selected && this.isMultipleSelect) || (selected && !this.isMultipleSelect && option !== '')) {\r\n                        this.isFilled = true;\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                // array of objects will require a label/value pair unless a customStructure is passed\r\n                optionCollection.forEach((option) => {\r\n                    if (!option || (option[this.labelName] === undefined && option.labelKey === undefined)) {\r\n                        throw new Error(`[select-filter] A collection with value/label (or value/labelKey when using Locale) is required to populate the Select list, for example:: { filter: model: Filters.multipleSelect, collection: [ { value: '1', label: 'One' } ]')`);\r\n                    }\r\n                    const labelKey = (option.labelKey || option[this.labelName]);\r\n                    const selected = (searchTerms.findIndex((term) => term === option[this.valueName]) >= 0) ? 'selected' : '';\r\n                    const labelText = ((option.labelKey || this.enableTranslateLabel) && labelKey && isEnableTranslate) ? this.translate && this.translate.currentLang && this.translate.instant(labelKey || ' ') : labelKey;\r\n                    let prefixText = option[this.labelPrefixName] || '';\r\n                    let suffixText = option[this.labelSuffixName] || '';\r\n                    let optionLabel = option.hasOwnProperty(this.optionLabel) ? option[this.optionLabel] : '';\r\n                    optionLabel = optionLabel.toString().replace(/\\\"/g, '\\''); // replace double quotes by single quotes to avoid interfering with regular html\r\n                    // also translate prefix/suffix if enableTranslateLabel is true and text is a string\r\n                    prefixText = (this.enableTranslateLabel && isEnableTranslate && prefixText && typeof prefixText === 'string') ? this.translate && this.translate.currentLang && this.translate.instant(prefixText || ' ') : prefixText;\r\n                    suffixText = (this.enableTranslateLabel && isEnableTranslate && suffixText && typeof suffixText === 'string') ? this.translate && this.translate.currentLang && this.translate.instant(suffixText || ' ') : suffixText;\r\n                    optionLabel = (this.enableTranslateLabel && isEnableTranslate && optionLabel && typeof optionLabel === 'string') ? this.translate && this.translate.currentLang && this.translate.instant(optionLabel || ' ') : optionLabel;\r\n                    // add to a temp array for joining purpose and filter out empty text\r\n                    const tmpOptionArray = [prefixText, (typeof labelText === 'string' || typeof labelText === 'number') ? labelText.toString() : labelText, suffixText].filter((text) => text);\r\n                    let optionText = tmpOptionArray.join(separatorBetweenLabels);\r\n                    // if user specifically wants to render html text, he needs to opt-in else it will stripped out by default\r\n                    // also, the 3rd party lib will saninitze any html code unless it's encoded, so we'll do that\r\n                    if (isRenderHtmlEnabled) {\r\n                        // sanitize any unauthorized html tags like script and others\r\n                        // for the remaining allowed tags we'll permit all attributes\r\n                        const sanitizedText = (DOMPurify.sanitize(optionText, sanitizedOptions) || '').toString();\r\n                        optionText = htmlEncode(sanitizedText);\r\n                    }\r\n                    // html text of each select option\r\n                    options += `<option value=\"${option[this.valueName]}\" label=\"${optionLabel}\" ${selected}>${optionText}</option>`;\r\n                    // if there's at least 1 search term found, we will add the \"filled\" class for styling purposes\r\n                    // on a single select, we'll also make sure the single value is not an empty string to consider this being filled\r\n                    if ((selected && this.isMultipleSelect) || (selected && !this.isMultipleSelect && option[this.valueName] !== '')) {\r\n                        this.isFilled = true;\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        return `<select class=\"ms-filter search-filter filter-${columnId}\" ${this.isMultipleSelect ? 'multiple=\"multiple\"' : ''}>${options}</select>`;\r\n    }\r\n    /** Create a blank entry that can be added to the collection. It will also reuse the same customStructure if need be */\r\n    createBlankEntry() {\r\n        const blankEntry = {\r\n            [this.labelName]: '',\r\n            [this.valueName]: ''\r\n        };\r\n        if (this.labelPrefixName) {\r\n            blankEntry[this.labelPrefixName] = '';\r\n        }\r\n        if (this.labelSuffixName) {\r\n            blankEntry[this.labelSuffixName] = '';\r\n        }\r\n        return blankEntry;\r\n    }\r\n    /**\r\n     * From the html template string, create a DOM element\r\n     * Subscribe to the onClose event and run the callback when that happens\r\n     * @param filterTemplate\r\n     */\r\n    createDomElement(filterTemplate) {\r\n        const fieldId = this.columnDef && this.columnDef.id;\r\n        // provide the name attribute to the DOM element which will be needed to auto-adjust drop position (dropup / dropdown)\r\n        this.elementName = `filter-${fieldId}`;\r\n        this.defaultOptions.name = this.elementName;\r\n        const $headerElm = this.grid.getHeaderRowColumn(fieldId);\r\n        $($headerElm).empty();\r\n        // create the DOM element & add an ID and filter class\r\n        this.$filterElm = $(filterTemplate);\r\n        if (typeof this.$filterElm.multipleSelect !== 'function') {\r\n            throw new Error(`multiple-select.js was not found, make sure to modify your \"angular-cli.json\" file and include \"../node_modules/angular-slickgrid/lib/multiple-select/multiple-select.js\" and it's css or SASS file`);\r\n        }\r\n        this.$filterElm.attr('name', this.elementName);\r\n        this.$filterElm.data('columnId', fieldId);\r\n        // if there's a search term, we will add the \"filled\" class for styling purposes\r\n        if (this.isFilled) {\r\n            this.$filterElm.addClass('filled');\r\n        }\r\n        // append the new DOM element to the header row\r\n        if (this.$filterElm && typeof this.$filterElm.appendTo === 'function') {\r\n            this.$filterElm.appendTo($headerElm);\r\n        }\r\n        // merge options & attach multiSelect\r\n        const filterOptions = Object.assign({}, this.defaultOptions, this.columnFilter.filterOptions);\r\n        this.filterElmOptions = Object.assign({}, this.defaultOptions, filterOptions);\r\n        this.$filterElm = this.$filterElm.multipleSelect(this.filterElmOptions);\r\n    }\r\n    /** Initialize the Multiple Select element and its options to use */\r\n    initMultipleSelect() {\r\n        // default options used by this Filter, user can overwrite any of these by passing \"otions\"\r\n        const options = {\r\n            autoAdjustDropHeight: true,\r\n            autoAdjustDropPosition: true,\r\n            autoAdjustDropWidthByTextSize: true,\r\n            container: 'body',\r\n            filter: false,\r\n            maxHeight: 275,\r\n            single: true,\r\n            textTemplate: ($elm) => {\r\n                // are we rendering HTML code? by default it is sanitized and won't be rendered\r\n                const isRenderHtmlEnabled = this.columnDef && this.columnDef.filter && this.columnDef.filter.enableRenderHtml || false;\r\n                return isRenderHtmlEnabled ? $elm.text() : $elm.html();\r\n            },\r\n            onClose: () => {\r\n                // we will subscribe to the onClose event for triggering our callback\r\n                // also add/remove \"filled\" class for styling purposes\r\n                this.onTriggerEvent(undefined);\r\n            }\r\n        };\r\n        if (this.isMultipleSelect) {\r\n            options.single = false;\r\n            options.okButton = true;\r\n            options.addTitle = true; // show tooltip of all selected items while hovering the filter\r\n            options.countSelected = this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant('X_OF_Y_SELECTED') || this._locales && this._locales.TEXT_X_OF_Y_SELECTED;\r\n            options.allSelected = this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant('ALL_SELECTED') || this._locales && this._locales.TEXT_ALL_SELECTED;\r\n            options.okButtonText = this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant('OK') || this._locales && this._locales.TEXT_OK;\r\n            options.selectAllText = this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant('SELECT_ALL') || this._locales && this._locales.TEXT_SELECT_ALL;\r\n            options.selectAllDelimiter = ['', '']; // remove default square brackets of default text \"[Select All]\" => \"Select All\"\r\n        }\r\n        this.defaultOptions = options;\r\n    }\r\n    onTriggerEvent(e) {\r\n        const selectedItems = this.getValues();\r\n        if (Array.isArray(selectedItems) && selectedItems.length > 1 || (selectedItems.length === 1 && selectedItems[0] !== '')) {\r\n            this.isFilled = true;\r\n            this.$filterElm.addClass('filled').siblings('div .search-filter').addClass('filled');\r\n        }\r\n        else {\r\n            this.isFilled = false;\r\n            this.$filterElm.removeClass('filled');\r\n            this.$filterElm.siblings('div .search-filter').removeClass('filled');\r\n        }\r\n        this.searchTerms = selectedItems;\r\n        this.callback(undefined, { columnDef: this.columnDef, operator: this.operator, searchTerms: selectedItems, shouldTriggerQuery: this._shouldTriggerQuery });\r\n        // reset flag for next use\r\n        this._shouldTriggerQuery = true;\r\n    }\r\n};\r\nSelectFilter = __decorate([\r\n    __param(0, Optional()),\r\n    __metadata(\"design:paramtypes\", [TranslateService, CollectionService, Object])\r\n], SelectFilter);\n\nclass MultipleSelectFilter extends SelectFilter {\r\n    /**\r\n     * Initialize the Filter\r\n     */\r\n    constructor(translate, collectionService) {\r\n        super(translate, collectionService, true);\r\n        this.translate = translate;\r\n        this.collectionService = collectionService;\r\n    }\r\n}\n\nlet NativeSelectFilter = class NativeSelectFilter {\r\n    constructor(translate) {\r\n        this.translate = translate;\r\n        this._clearFilterTriggered = false;\r\n        this._shouldTriggerQuery = true;\r\n        this._currentValues = [];\r\n    }\r\n    /** Getter for the Column Filter itself */\r\n    get columnFilter() {\r\n        return this.columnDef && this.columnDef.filter;\r\n    }\r\n    /** Getter to know what would be the default operator when none is specified */\r\n    get defaultOperator() {\r\n        return OperatorType.equal;\r\n    }\r\n    /** Getter for the Grid Options pulled through the Grid Object */\r\n    get gridOptions() {\r\n        return (this.grid && this.grid.getOptions) ? this.grid.getOptions() : {};\r\n    }\r\n    get operator() {\r\n        return this.columnFilter && this.columnFilter.operator || this.defaultOperator;\r\n    }\r\n    /** Setter for the filter operator */\r\n    set operator(operator) {\r\n        if (this.columnFilter) {\r\n            this.columnFilter.operator = operator;\r\n        }\r\n    }\r\n    /**\r\n     * Initialize the Filter\r\n     */\r\n    init(args) {\r\n        if (!args) {\r\n            throw new Error('[Angular-SlickGrid] A filter must always have an \"init()\" with valid arguments.');\r\n        }\r\n        this.grid = args.grid;\r\n        this.callback = args.callback;\r\n        this.columnDef = args.columnDef;\r\n        this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];\r\n        if (!this.grid || !this.columnDef || !this.columnFilter || !this.columnFilter.collection) {\r\n            throw new Error(`[Angular-SlickGrid] You need to pass a \"collection\" for the Native Select Filter to work correctly.`);\r\n        }\r\n        if (this.columnFilter.enableTranslateLabel && !this.gridOptions.enableTranslate && (!this.translate || typeof this.translate.instant !== 'function')) {\r\n            throw new Error(`The ngx-translate TranslateService is required for the Native Select Filter to work correctly when \"enableTranslateLabel\" is set.`);\r\n        }\r\n        // filter input can only have 1 search term, so we will use the 1st array index if it exist\r\n        let searchTerm = (Array.isArray(this.searchTerms) && this.searchTerms.length >= 0) ? this.searchTerms[0] : '';\r\n        if (typeof searchTerm === 'boolean' || typeof searchTerm === 'number') {\r\n            searchTerm = `${searchTerm}`;\r\n        }\r\n        // step 1, create HTML string template\r\n        const filterTemplate = this.buildTemplateHtmlString();\r\n        // step 2, create the DOM Element of the filter & initialize it if searchTerm is filled\r\n        this.$filterElm = this.createDomElement(filterTemplate, searchTerm);\r\n        // step 3, subscribe to the change event and run the callback when that happens\r\n        // also add/remove \"filled\" class for styling purposes\r\n        this.$filterElm.change((e) => {\r\n            const value = e && e.target && e.target.value || '';\r\n            this._currentValues = [value];\r\n            if (this._clearFilterTriggered) {\r\n                this.callback(e, { columnDef: this.columnDef, clearFilterTriggered: this._clearFilterTriggered, shouldTriggerQuery: this._shouldTriggerQuery });\r\n                this.$filterElm.removeClass('filled');\r\n            }\r\n            else {\r\n                value === '' ? this.$filterElm.removeClass('filled') : this.$filterElm.addClass('filled');\r\n                this.callback(e, { columnDef: this.columnDef, operator: this.operator, searchTerms: [value], shouldTriggerQuery: this._shouldTriggerQuery });\r\n            }\r\n            // reset both flags for next use\r\n            this._clearFilterTriggered = false;\r\n            this._shouldTriggerQuery = true;\r\n        });\r\n    }\r\n    /**\r\n     * Clear the filter values\r\n     */\r\n    clear(shouldTriggerQuery = true) {\r\n        if (this.$filterElm) {\r\n            this._clearFilterTriggered = true;\r\n            this._shouldTriggerQuery = shouldTriggerQuery;\r\n            this.searchTerms = [];\r\n            this._currentValues = [];\r\n            this.$filterElm.val('');\r\n            this.$filterElm.trigger('change');\r\n        }\r\n    }\r\n    /**\r\n     * destroy the filter\r\n     */\r\n    destroy() {\r\n        if (this.$filterElm) {\r\n            this.$filterElm.off('change').remove();\r\n        }\r\n    }\r\n    /**\r\n     * Get selected values retrieved from the select element\r\n     * @params selected items\r\n     */\r\n    getValues() {\r\n        return this._currentValues;\r\n    }\r\n    /** Set value(s) on the DOM element */\r\n    setValues(values, operator) {\r\n        if (Array.isArray(values)) {\r\n            this.$filterElm.val(values[0]);\r\n            this._currentValues = values;\r\n        }\r\n        else if (values) {\r\n            this.$filterElm.val(values);\r\n            this._currentValues = [values];\r\n        }\r\n        // set the operator when defined\r\n        this.operator = operator || this.defaultOperator;\r\n    }\r\n    //\r\n    // private functions\r\n    // ------------------\r\n    buildTemplateHtmlString() {\r\n        const collection = this.columnFilter && this.columnFilter.collection || [];\r\n        if (!Array.isArray(collection)) {\r\n            throw new Error('The \"collection\" passed to the Native Select Filter is not a valid array.');\r\n        }\r\n        const fieldId = this.columnDef && this.columnDef.id;\r\n        const labelName = (this.columnDef.filter.customStructure) ? this.columnDef.filter.customStructure.label : 'label';\r\n        const valueName = (this.columnDef.filter.customStructure) ? this.columnDef.filter.customStructure.value : 'value';\r\n        let options = '';\r\n        // collection could be an Array of Strings OR Objects\r\n        if (collection.every(x => typeof x === 'string')) {\r\n            collection.forEach((option) => {\r\n                options += `<option value=\"${option}\" label=\"${option}\">${option}</option>`;\r\n            });\r\n        }\r\n        else {\r\n            collection.forEach((option) => {\r\n                if (!option || (option[labelName] === undefined && option.labelKey === undefined)) {\r\n                    throw new Error(`A collection with value/label (or value/labelKey when using Locale) is required to populate the Native Select Filter list, for example:: { filter: model: Filters.select, collection: [ { value: '1', label: 'One' } ]')`);\r\n                }\r\n                const labelKey = option.labelKey || option[labelName];\r\n                const textLabel = ((option.labelKey || this.columnDef.filter.enableTranslateLabel) && this.translate && this.translate.currentLang && this.translate.instant) ? this.translate.instant(labelKey || ' ') : labelKey;\r\n                options += `<option value=\"${option[valueName]}\">${textLabel}</option>`;\r\n            });\r\n        }\r\n        return `<select class=\"form-control search-filter filter-${fieldId}\">${options}</select>`;\r\n    }\r\n    /**\r\n     * From the html template string, create a DOM element\r\n     * @param filterTemplate\r\n     */\r\n    createDomElement(filterTemplate, searchTerm) {\r\n        const fieldId = this.columnDef && this.columnDef.id;\r\n        const $headerElm = this.grid.getHeaderRowColumn(fieldId);\r\n        $($headerElm).empty();\r\n        // create the DOM element & add an ID and filter class\r\n        const $filterElm = $(filterTemplate);\r\n        const searchTermInput = (searchTerm || '');\r\n        $filterElm.val(searchTermInput);\r\n        $filterElm.data('columnId', fieldId);\r\n        if (searchTermInput) {\r\n            this._currentValues = [searchTermInput];\r\n        }\r\n        // append the new DOM element to the header row\r\n        if ($filterElm && typeof $filterElm.appendTo === 'function') {\r\n            $filterElm.appendTo($headerElm);\r\n        }\r\n        return $filterElm;\r\n    }\r\n};\r\nNativeSelectFilter = __decorate([\r\n    __param(0, Optional()),\r\n    __metadata(\"design:paramtypes\", [TranslateService])\r\n], NativeSelectFilter);\n\nconst moment$4 = moment_; // patch to fix rollup \"moment has no default export\" issue, document here https://github.com/rollup/rollup/issues/670\r\nrequire('flatpickr');\r\nlet DateRangeFilter = class DateRangeFilter {\r\n    constructor(translate) {\r\n        this.translate = translate;\r\n        this._clearFilterTriggered = false;\r\n        this._shouldTriggerQuery = true;\r\n    }\r\n    /** Getter for the Grid Options pulled through the Grid Object */\r\n    get gridOptions() {\r\n        return (this.grid && this.grid.getOptions) ? this.grid.getOptions() : {};\r\n    }\r\n    /** Getter for the Column Filter */\r\n    get columnFilter() {\r\n        return this.columnDef && this.columnDef.filter || {};\r\n    }\r\n    /** Getter for the Current Dates selected */\r\n    get currentDates() {\r\n        return this._currentDates;\r\n    }\r\n    /** Getter to know what would be the default operator when none is specified */\r\n    get defaultOperator() {\r\n        return this.gridOptions.defaultFilterRangeOperator || OperatorType.rangeExclusive;\r\n    }\r\n    /** Getter for the Flatpickr Options */\r\n    get flatpickrOptions() {\r\n        return this._flatpickrOptions || {};\r\n    }\r\n    /** Getter of the Operator to use when doing the filter comparing */\r\n    get operator() {\r\n        return this.columnFilter && this.columnFilter.operator || this.defaultOperator;\r\n    }\r\n    /** Setter for the filter operator */\r\n    set operator(operator) {\r\n        if (this.columnFilter) {\r\n            this.columnFilter.operator = operator;\r\n        }\r\n    }\r\n    /**\r\n     * Initialize the Filter\r\n     */\r\n    init(args) {\r\n        if (!args) {\r\n            throw new Error('[Angular-SlickGrid] A filter must always have an \"init()\" with valid arguments.');\r\n        }\r\n        this.grid = args.grid;\r\n        this.callback = args.callback;\r\n        this.columnDef = args.columnDef;\r\n        this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];\r\n        // step 1, create the DOM Element of the filter which contain the compound Operator+Input\r\n        this.$filterElm = this.createDomElement(this.searchTerms);\r\n        // step 3, subscribe to the keyup event and run the callback when that happens\r\n        // also add/remove \"filled\" class for styling purposes\r\n        this.$filterInputElm.keyup((e) => {\r\n            this.onTriggerEvent(e);\r\n        });\r\n    }\r\n    /**\r\n     * Clear the filter value\r\n     */\r\n    clear(shouldTriggerQuery = true) {\r\n        if (this.flatInstance) {\r\n            this._clearFilterTriggered = true;\r\n            this._shouldTriggerQuery = shouldTriggerQuery;\r\n            this.searchTerms = [];\r\n            this.flatInstance.clear();\r\n        }\r\n    }\r\n    /**\r\n     * destroy the filter\r\n     */\r\n    destroy() {\r\n        if (this.$filterElm) {\r\n            this.$filterElm.off('keyup').remove();\r\n        }\r\n        if (this.flatInstance && typeof this.flatInstance.destroy === 'function') {\r\n            this.flatInstance.destroy();\r\n        }\r\n    }\r\n    hide() {\r\n        if (this.flatInstance && typeof this.flatInstance.close === 'function') {\r\n            this.flatInstance.close();\r\n        }\r\n    }\r\n    show() {\r\n        if (this.flatInstance && typeof this.flatInstance.open === 'function') {\r\n            this.flatInstance.open();\r\n        }\r\n    }\r\n    /**\r\n     * Set value(s) on the DOM element\r\n     * @params searchTerms\r\n     */\r\n    setValues(searchTerms, operator) {\r\n        let pickerValues = [];\r\n        // get the picker values, if it's a string with the \"..\", we'll do the split else we'll use the array of search terms\r\n        if (typeof searchTerms === 'string' || (Array.isArray(searchTerms) && typeof searchTerms[0] === 'string') && searchTerms[0].indexOf('..') > 0) {\r\n            pickerValues = (typeof searchTerms === 'string') ? [searchTerms] : searchTerms[0].split('..');\r\n        }\r\n        else if (Array.isArray(searchTerms)) {\r\n            pickerValues = searchTerms;\r\n        }\r\n        if (this.flatInstance && searchTerms) {\r\n            this._currentDates = pickerValues;\r\n            this.flatInstance.setDate(pickerValues);\r\n        }\r\n        // set the operator when defined\r\n        this.operator = operator || this.defaultOperator;\r\n    }\r\n    //\r\n    // private functions\r\n    // ------------------\r\n    buildDatePickerInput(searchTerms) {\r\n        const columnId = this.columnDef && this.columnDef.id;\r\n        const inputFormat = mapFlatpickrDateFormatWithFieldType(this.columnDef.type || FieldType.dateIso);\r\n        const outputFormat = mapFlatpickrDateFormatWithFieldType(this.columnDef.outputType || this.columnDef.type || FieldType.dateUtc);\r\n        const userFilterOptions = (this.columnFilter && this.columnFilter.filterOptions || {});\r\n        // get current locale, if user defined a custom locale just use or get it the Translate Service if it exist else just use English\r\n        let currentLocale = (userFilterOptions && userFilterOptions.locale) || (this.translate && this.translate.currentLang) || this.gridOptions.locale || 'en';\r\n        if (currentLocale.length > 2) {\r\n            currentLocale = currentLocale.substring(0, 2);\r\n        }\r\n        let pickerValues = [];\r\n        // get the picker values, if it's a string with the \"..\", we'll do the split else we'll use the array of search terms\r\n        if (typeof searchTerms === 'string' || (Array.isArray(searchTerms) && typeof searchTerms[0] === 'string') && searchTerms[0].indexOf('..') > 0) {\r\n            pickerValues = (typeof searchTerms === 'string') ? [searchTerms] : searchTerms[0].split('..');\r\n        }\r\n        else if (Array.isArray(searchTerms)) {\r\n            pickerValues = searchTerms;\r\n        }\r\n        // if we are preloading searchTerms, we'll keep them for reference\r\n        if (pickerValues) {\r\n            this._currentDates = pickerValues;\r\n            const outFormat = mapMomentDateFormatWithFieldType(this.columnDef.type || FieldType.dateIso);\r\n            this._currentDateStrings = pickerValues.map(date => moment$4(date).format(outFormat));\r\n        }\r\n        const pickerOptions = {\r\n            defaultDate: pickerValues || '',\r\n            altInput: true,\r\n            altFormat: outputFormat,\r\n            dateFormat: inputFormat,\r\n            mode: 'range',\r\n            wrap: true,\r\n            closeOnSelect: true,\r\n            locale: (currentLocale !== 'en') ? this.loadFlatpickrLocale(currentLocale) : 'en',\r\n            onChange: (selectedDates, dateStr, instance) => {\r\n                if (Array.isArray(selectedDates)) {\r\n                    this._currentDates = selectedDates;\r\n                    const outFormat = mapMomentDateFormatWithFieldType(this.columnDef.outputType || this.columnDef.type || FieldType.dateIso);\r\n                    this._currentDateStrings = selectedDates.map(date => moment$4(date).format(outFormat));\r\n                    this._currentValue = this._currentDateStrings.join('..');\r\n                }\r\n                // when using the time picker, we can simulate a keyup event to avoid multiple backend request\r\n                // since backend request are only executed after user start typing, changing the time should be treated the same way\r\n                const newEvent = pickerOptions.enableTime ? new CustomEvent('keyup') : undefined;\r\n                this.onTriggerEvent(newEvent);\r\n            }\r\n        };\r\n        // add the time picker when format is UTC (Z) or has the 'h' (meaning hours)\r\n        if (outputFormat && (outputFormat === 'Z' || outputFormat.toLowerCase().includes('h'))) {\r\n            pickerOptions.enableTime = true;\r\n        }\r\n        // merge options with optional user's custom options\r\n        this._flatpickrOptions = Object.assign({}, pickerOptions, userFilterOptions);\r\n        let placeholder = (this.gridOptions) ? (this.gridOptions.defaultFilterPlaceholder || '') : '';\r\n        if (this.columnFilter && this.columnFilter.placeholder) {\r\n            placeholder = this.columnFilter.placeholder;\r\n        }\r\n        const $filterInputElm = $(`<div class=\"flatpickr search-filter filter-${columnId}\"><input type=\"text\" class=\"form-control\" data-input placeholder=\"${placeholder}\"></div>`);\r\n        this.flatInstance = ($filterInputElm[0] && typeof $filterInputElm[0].flatpickr === 'function') ? $filterInputElm[0].flatpickr(this._flatpickrOptions) : Flatpickr($filterInputElm, this._flatpickrOptions);\r\n        return $filterInputElm;\r\n    }\r\n    /**\r\n     * Create the DOM element\r\n     * @params searchTerms\r\n     */\r\n    createDomElement(searchTerms) {\r\n        const fieldId = this.columnDef && this.columnDef.id;\r\n        const $headerElm = this.grid.getHeaderRowColumn(fieldId);\r\n        $($headerElm).empty();\r\n        // create the DOM Select dropdown for the Operator\r\n        this.$filterInputElm = this.buildDatePickerInput(searchTerms);\r\n        /* the DOM element final structure will be\r\n          <div class=flatpickr>\r\n            <input type=\"text\" class=\"form-control\" data-input>\r\n          </div>\r\n        */\r\n        // create the DOM element & add an ID and filter class\r\n        this.$filterInputElm.data('columnId', fieldId);\r\n        // if there's a search term, we will add the \"filled\" class for styling purposes\r\n        if (Array.isArray(searchTerms) && searchTerms.length > 0 && searchTerms[0] !== '') {\r\n            this.$filterInputElm.addClass('filled');\r\n            this._currentDates = searchTerms;\r\n            this._currentValue = searchTerms[0];\r\n        }\r\n        // append the new DOM element to the header row\r\n        if (this.$filterInputElm && typeof this.$filterInputElm.appendTo === 'function') {\r\n            this.$filterInputElm.appendTo($headerElm);\r\n        }\r\n        return this.$filterInputElm;\r\n    }\r\n    /** Load a different set of locales for Flatpickr to be localized */\r\n    loadFlatpickrLocale(language) {\r\n        let locales = 'en';\r\n        try {\r\n            if (language !== 'en') {\r\n                // change locale if needed, Flatpickr reference: https://chmln.github.io/flatpickr/localization/\r\n                const localeDefault = require(`flatpickr/dist/l10n/${language}.js`).default;\r\n                locales = (localeDefault && localeDefault[language]) ? localeDefault[language] : 'en';\r\n            }\r\n        }\r\n        catch (e) {\r\n            console.warn(`[Angular-Slickgrid - DateRange Filter] It seems that \"${language}\" is not a locale supported by Flatpickr, we will use \"en\" instead. `\r\n                + `To avoid seeing this message, you can specifically set \"filter: { filterOptions: { locale: 'en' } }\" in your column definition.`);\r\n            return 'en';\r\n        }\r\n        return locales;\r\n    }\r\n    onTriggerEvent(e) {\r\n        if (this._clearFilterTriggered) {\r\n            this.callback(e, { columnDef: this.columnDef, clearFilterTriggered: this._clearFilterTriggered, shouldTriggerQuery: this._shouldTriggerQuery });\r\n            this.$filterElm.removeClass('filled');\r\n        }\r\n        else {\r\n            (this._currentDateStrings) ? this.$filterElm.addClass('filled') : this.$filterElm.removeClass('filled');\r\n            this.callback(e, { columnDef: this.columnDef, searchTerms: (this._currentDateStrings ? this._currentDateStrings : [this._currentValue]), operator: this.operator || '', shouldTriggerQuery: this._shouldTriggerQuery });\r\n        }\r\n        // reset both flags for next use\r\n        this._clearFilterTriggered = false;\r\n        this._shouldTriggerQuery = true;\r\n    }\r\n};\r\nDateRangeFilter = __decorate([\r\n    __param(0, Optional()),\r\n    __metadata(\"design:paramtypes\", [TranslateService])\r\n], DateRangeFilter);\n\nclass SingleSelectFilter extends SelectFilter {\r\n    /**\r\n     * Initialize the Filter\r\n     */\r\n    constructor(translate, collectionService) {\r\n        super(translate, collectionService, false);\r\n        this.translate = translate;\r\n        this.collectionService = collectionService;\r\n    }\r\n}\n\nconst DEFAULT_MIN_VALUE$1 = 0;\r\nconst DEFAULT_MAX_VALUE$1 = 100;\r\nconst DEFAULT_STEP$1 = 1;\r\nclass SliderFilter {\r\n    constructor() {\r\n        this._clearFilterTriggered = false;\r\n        this._shouldTriggerQuery = true;\r\n    }\r\n    /** Getter for the Column Filter */\r\n    get columnFilter() {\r\n        return this.columnDef && this.columnDef.filter || {};\r\n    }\r\n    /** Getter to know what would be the default operator when none is specified */\r\n    get defaultOperator() {\r\n        return OperatorType.equal;\r\n    }\r\n    /** Getter for the Filter Generic Params */\r\n    get filterParams() {\r\n        return this.columnDef && this.columnDef.filter && this.columnDef.filter.params || {};\r\n    }\r\n    /** Getter for the `filter` properties */\r\n    get filterProperties() {\r\n        return this.columnDef && this.columnDef.filter;\r\n    }\r\n    get operator() {\r\n        return this.columnFilter && this.columnFilter.operator || this.defaultOperator;\r\n    }\r\n    /** Setter for the filter operator */\r\n    set operator(operator) {\r\n        if (this.columnFilter) {\r\n            this.columnFilter.operator = operator;\r\n        }\r\n    }\r\n    /**\r\n     * Initialize the Filter\r\n     */\r\n    init(args) {\r\n        if (!args) {\r\n            throw new Error('[Angular-SlickGrid] A filter must always have an \"init()\" with valid arguments.');\r\n        }\r\n        this.grid = args.grid;\r\n        this.callback = args.callback;\r\n        this.columnDef = args.columnDef;\r\n        this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];\r\n        // define the input & slider number IDs\r\n        this._elementRangeInputId = `rangeInput_${this.columnDef.field}`;\r\n        this._elementRangeOutputId = `rangeOutput_${this.columnDef.field}`;\r\n        // filter input can only have 1 search term, so we will use the 1st array index if it exist\r\n        const searchTerm = (Array.isArray(this.searchTerms) && this.searchTerms.length >= 0) ? this.searchTerms[0] : '';\r\n        // step 1, create HTML string template\r\n        const filterTemplate = this.buildTemplateHtmlString();\r\n        // step 2, create the DOM Element of the filter & initialize it if searchTerm is filled\r\n        this.$filterElm = this.createDomElement(filterTemplate, searchTerm);\r\n        // step 3, subscribe to the change event and run the callback when that happens\r\n        // also add/remove \"filled\" class for styling purposes\r\n        this.$filterElm.change((e) => {\r\n            const value = e && e.target && e.target.value;\r\n            this._currentValue = +value;\r\n            if (this._clearFilterTriggered) {\r\n                this.$filterElm.removeClass('filled');\r\n                this.callback(e, { columnDef: this.columnDef, clearFilterTriggered: this._clearFilterTriggered, searchTerms: [], shouldTriggerQuery: this._shouldTriggerQuery });\r\n            }\r\n            else {\r\n                this.$filterElm.addClass('filled');\r\n                this.callback(e, { columnDef: this.columnDef, operator: this.operator, searchTerms: [value || '0'], shouldTriggerQuery: this._shouldTriggerQuery });\r\n            }\r\n            // reset both flags for next use\r\n            this._clearFilterTriggered = false;\r\n            this._shouldTriggerQuery = true;\r\n        });\r\n        // if user chose to display the slider number on the right side, then update it every time it changes\r\n        // we need to use both \"input\" and \"change\" event to be all cross-browser\r\n        if (!this.filterParams.hideSliderNumber) {\r\n            this.$filterElm.on('input change', (e) => {\r\n                const value = e && e.target && e.target.value;\r\n                if (value !== undefined && value !== null) {\r\n                    const elements = document.getElementsByClassName(this._elementRangeOutputId);\r\n                    if (elements.length) {\r\n                        elements[0].innerHTML = value;\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Clear the filter value\r\n     */\r\n    clear(shouldTriggerQuery = true) {\r\n        if (this.$filterElm) {\r\n            this._clearFilterTriggered = true;\r\n            this._shouldTriggerQuery = shouldTriggerQuery;\r\n            this.searchTerms = [];\r\n            const clearedValue = this.filterParams.hasOwnProperty('sliderStartValue') ? this.filterParams.sliderStartValue : DEFAULT_MIN_VALUE$1;\r\n            this._currentValue = +clearedValue;\r\n            this.$filterElm.children('input').val(clearedValue);\r\n            this.$filterElm.children('div.input-group-addon.input-group-append').children().html(clearedValue);\r\n            this.$filterElm.val(clearedValue);\r\n            this.$filterElm.trigger('change');\r\n        }\r\n    }\r\n    /**\r\n     * destroy the filter\r\n     */\r\n    destroy() {\r\n        if (this.$filterElm) {\r\n            this.$filterElm.off('change').remove();\r\n        }\r\n    }\r\n    /**\r\n     * Get selected value retrieved from the slider element\r\n     * @params selected items\r\n     */\r\n    getValues() {\r\n        return this._currentValue;\r\n    }\r\n    /** Set value(s) on the DOM element */\r\n    setValues(values, operator) {\r\n        if (Array.isArray(values)) {\r\n            this.$filterElm.val(values[0]);\r\n            this._currentValue = +values[0];\r\n        }\r\n        else if (values) {\r\n            this.$filterElm.val(values);\r\n            this._currentValue = +values;\r\n        }\r\n        // set the operator when defined\r\n        this.operator = operator || this.defaultOperator;\r\n    }\r\n    //\r\n    // private functions\r\n    // ------------------\r\n    /**\r\n     * Create the HTML template as a string\r\n     */\r\n    buildTemplateHtmlString() {\r\n        const fieldId = this.columnDef && this.columnDef.id;\r\n        const minValue = this.filterProperties.hasOwnProperty('minValue') ? this.filterProperties.minValue : DEFAULT_MIN_VALUE$1;\r\n        const maxValue = this.filterProperties.hasOwnProperty('maxValue') ? this.filterProperties.maxValue : DEFAULT_MAX_VALUE$1;\r\n        const defaultValue = this.filterParams.hasOwnProperty('sliderStartValue') ? this.filterParams.sliderStartValue : minValue;\r\n        const step = this.filterProperties.hasOwnProperty('valueStep') ? this.filterProperties.valueStep : DEFAULT_STEP$1;\r\n        if (this.filterParams.hideSliderNumber) {\r\n            return `\r\n      <div class=\"search-filter slider-container filter-${fieldId}\">\r\n        <input type=\"range\" name=\"${this._elementRangeInputId}\"\r\n          defaultValue=\"${defaultValue}\" value=\"${defaultValue}\"\r\n          min=\"${minValue}\" max=\"${maxValue}\" step=\"${step}\"\r\n          class=\"form-control slider-filter-input range ${this._elementRangeInputId}\" />\r\n      </div>`;\r\n        }\r\n        return `\r\n      <div class=\"input-group slider-container search-filter filter-${fieldId}\">\r\n        <input type=\"range\" name=\"${this._elementRangeInputId}\"\r\n          defaultValue=\"${defaultValue}\" value=\"${defaultValue}\"\r\n          min=\"${minValue}\" max=\"${maxValue}\" step=\"${step}\"\r\n          class=\"form-control slider-filter-input range ${this._elementRangeInputId}\" />\r\n        <div class=\"input-group-addon input-group-append slider-value\">\r\n          <span class=\"input-group-text ${this._elementRangeOutputId}\">${defaultValue}</span>\r\n        </div>\r\n      </div>`;\r\n    }\r\n    /**\r\n     * From the html template string, create a DOM element\r\n     * @param filterTemplate string\r\n     * @param searchTerm optional preset search terms\r\n     */\r\n    createDomElement(filterTemplate, searchTerm) {\r\n        const fieldId = this.columnDef && this.columnDef.id;\r\n        const minValue = this.filterProperties.hasOwnProperty('minValue') ? this.filterProperties.minValue : DEFAULT_MIN_VALUE$1;\r\n        const startValue = this.filterParams.hasOwnProperty('sliderStartValue') ? this.filterParams.sliderStartValue : minValue;\r\n        const $headerElm = this.grid.getHeaderRowColumn(fieldId);\r\n        $($headerElm).empty();\r\n        // create the DOM element & add an ID and filter class\r\n        const $filterElm = $(filterTemplate);\r\n        let searchTermInput = (searchTerm || '0');\r\n        if (+searchTermInput < minValue) {\r\n            searchTermInput = `${minValue}`;\r\n        }\r\n        if (+searchTermInput < startValue) {\r\n            searchTermInput = `${startValue}`;\r\n        }\r\n        this._currentValue = +searchTermInput;\r\n        $filterElm.children('input').val(searchTermInput);\r\n        $filterElm.children('div.input-group-addon.input-group-append').children().html(searchTermInput);\r\n        $filterElm.data('columnId', fieldId);\r\n        // if there's a search term, we will add the \"filled\" class for styling purposes\r\n        if (searchTerm) {\r\n            $filterElm.addClass('filled');\r\n        }\r\n        // append the new DOM element to the header row\r\n        if ($filterElm && typeof $filterElm.appendTo === 'function') {\r\n            $filterElm.appendTo($headerElm);\r\n        }\r\n        return $filterElm;\r\n    }\r\n}\n\nconst DEFAULT_MIN_VALUE$2 = 0;\r\nconst DEFAULT_MAX_VALUE$2 = 100;\r\nconst DEFAULT_STEP$2 = 1;\r\n/** A Slider Range Filter which uses jQuery UI, this is only meant to be used as a range filter (with 2 handles lowest & highest values) */\r\nclass SliderRangeFilter {\r\n    constructor() {\r\n        this._clearFilterTriggered = false;\r\n        this._shouldTriggerQuery = true;\r\n    }\r\n    /** Getter for the Filter Generic Params */\r\n    get filterParams() {\r\n        return this.columnDef && this.columnDef.filter && this.columnDef.filter.params || {};\r\n    }\r\n    /** Getter for the `filter` properties */\r\n    get filterProperties() {\r\n        return this.columnDef && this.columnDef.filter;\r\n    }\r\n    /** Getter for the Column Filter */\r\n    get columnFilter() {\r\n        return this.columnDef && this.columnDef.filter || {};\r\n    }\r\n    /** Getter for the Current Slider Values */\r\n    get currentValues() {\r\n        return this._currentValues;\r\n    }\r\n    /** Getter to know what would be the default operator when none is specified */\r\n    get defaultOperator() {\r\n        return this.gridOptions.defaultFilterRangeOperator || OperatorType.rangeExclusive;\r\n    }\r\n    /** Getter for the Grid Options pulled through the Grid Object */\r\n    get gridOptions() {\r\n        return (this.grid && this.grid.getOptions) ? this.grid.getOptions() : {};\r\n    }\r\n    /** Getter for the JQuery UI Slider Options */\r\n    get sliderOptions() {\r\n        return this._sliderOptions || {};\r\n    }\r\n    /** Getter of the Operator to use when doing the filter comparing */\r\n    get operator() {\r\n        return this.columnFilter && this.columnFilter.operator || this.defaultOperator;\r\n    }\r\n    /** Setter for the filter operator */\r\n    set operator(operator) {\r\n        if (this.columnFilter) {\r\n            this.columnFilter.operator = operator;\r\n        }\r\n    }\r\n    /**\r\n     * Initialize the Filter\r\n     */\r\n    init(args) {\r\n        if (!args) {\r\n            throw new Error('[Angular-SlickGrid] A filter must always have an \"init()\" with valid arguments.');\r\n        }\r\n        this.grid = args.grid;\r\n        this.callback = args.callback;\r\n        this.columnDef = args.columnDef;\r\n        this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];\r\n        // step 1, create the DOM Element of the filter & initialize it if searchTerm is filled\r\n        this.$filterElm = this.createDomElement(this.searchTerms);\r\n    }\r\n    /**\r\n     * Clear the filter value\r\n     */\r\n    clear(shouldTriggerQuery = true) {\r\n        if (this.$filterElm) {\r\n            this._clearFilterTriggered = true;\r\n            this._shouldTriggerQuery = shouldTriggerQuery;\r\n            this.searchTerms = [];\r\n            const lowestValue = this.filterParams.hasOwnProperty('sliderStartValue') ? this.filterParams.sliderStartValue : DEFAULT_MIN_VALUE$2;\r\n            const highestValue = this.filterParams.hasOwnProperty('sliderEndValue') ? this.filterParams.sliderEndValue : DEFAULT_MAX_VALUE$2;\r\n            this._currentValues = [lowestValue, highestValue];\r\n            this.$filterElm.slider('values', [lowestValue, highestValue]);\r\n            if (!this.filterParams.hideSliderNumbers) {\r\n                this.renderSliderValues(lowestValue, highestValue);\r\n            }\r\n            this.callback(null, { columnDef: this.columnDef, clearFilterTriggered: true, shouldTriggerQuery });\r\n            this.$filterContainerElm.removeClass('filled');\r\n        }\r\n    }\r\n    /**\r\n     * destroy the filter\r\n     */\r\n    destroy() {\r\n        if (this.$filterElm) {\r\n            this.$filterElm.off('change').remove();\r\n        }\r\n    }\r\n    /**\r\n     * Render both slider values (low/high) on screen\r\n     * @param lowestValue number\r\n     * @param highestValue number\r\n     */\r\n    renderSliderValues(lowestValue, highestValue) {\r\n        const columndId = this.columnDef && this.columnDef.id;\r\n        const lowerElm = document.querySelector(`.lowest-range-${columndId}`);\r\n        const highestElm = document.querySelector(`.highest-range-${columndId}`);\r\n        if (lowerElm && lowerElm.innerHTML) {\r\n            lowerElm.innerHTML = lowestValue.toString();\r\n        }\r\n        if (highestElm && highestElm.innerHTML) {\r\n            highestElm.innerHTML = highestValue.toString();\r\n        }\r\n    }\r\n    /**\r\n     * Set value(s) on the DOM element\r\n     * @params searchTerms\r\n     */\r\n    setValues(searchTerms, operator) {\r\n        if (searchTerms) {\r\n            let sliderValues = [];\r\n            // get the slider values, if it's a string with the \"..\", we'll do the split else we'll use the array of search terms\r\n            if (typeof searchTerms === 'string' || (Array.isArray(searchTerms) && typeof searchTerms[0] === 'string') && searchTerms[0].indexOf('..') > 0) {\r\n                sliderValues = (typeof searchTerms === 'string') ? [searchTerms] : searchTerms[0].split('..');\r\n            }\r\n            else if (Array.isArray(searchTerms)) {\r\n                sliderValues = searchTerms;\r\n            }\r\n            if (Array.isArray(sliderValues) && sliderValues.length === 2) {\r\n                this.$filterElm.slider('values', sliderValues);\r\n                if (!this.filterParams.hideSliderNumbers) {\r\n                    this.renderSliderValues(sliderValues[0], sliderValues[1]);\r\n                }\r\n            }\r\n        }\r\n        // set the operator when defined\r\n        this.operator = operator || this.defaultOperator;\r\n    }\r\n    //\r\n    // private functions\r\n    // ------------------\r\n    /**\r\n     * From the html template string, create a DOM element\r\n     * @param searchTerm optional preset search terms\r\n     */\r\n    createDomElement(searchTerms) {\r\n        if (this.columnFilter && this.columnFilter.filterOptions && (this.columnFilter.filterOptions.change || this.columnFilter.filterOptions.slide)) {\r\n            throw new Error(`[Angular-Slickgrid] You cannot override the \"change\" and/or the \"slide\" callback methods\r\n        since they are used in SliderRange Filter itself, however any other methods can be used for example the \"create\", \"start\", \"stop\" methods.`);\r\n        }\r\n        const fieldId = this.columnDef && this.columnDef.id;\r\n        const $headerElm = this.grid.getHeaderRowColumn(fieldId);\r\n        const minValue = this.filterProperties.hasOwnProperty('minValue') ? this.filterProperties.minValue : DEFAULT_MIN_VALUE$2;\r\n        const maxValue = this.filterProperties.hasOwnProperty('maxValue') ? this.filterProperties.maxValue : DEFAULT_MAX_VALUE$2;\r\n        const step = this.filterProperties.hasOwnProperty('valueStep') ? this.filterProperties.valueStep : DEFAULT_STEP$2;\r\n        let defaultStartValue = DEFAULT_MIN_VALUE$2;\r\n        let defaultEndValue = DEFAULT_MAX_VALUE$2;\r\n        if (Array.isArray(searchTerms) && searchTerms.length > 1) {\r\n            defaultStartValue = +searchTerms[0];\r\n            defaultEndValue = +searchTerms[1];\r\n        }\r\n        else {\r\n            defaultStartValue = +(this.filterParams.hasOwnProperty('sliderStartValue') ? this.filterParams.sliderStartValue : minValue);\r\n            defaultEndValue = +(this.filterParams.hasOwnProperty('sliderEndValue') ? this.filterParams.sliderEndValue : maxValue);\r\n        }\r\n        $($headerElm).empty();\r\n        // create the DOM element & add an ID and filter class\r\n        const $lowestSliderValueElm = $(`\r\n    <div class=\"input-group-addon input-group-prepend slider-range-value\">\r\n      <span class=\"input-group-text lowest-range-${fieldId}\">${defaultStartValue}</span>\r\n    </div>`);\r\n        const $highestSliderValueElm = $(`\r\n    <div class=\"input-group-addon input-group-append slider-range-value\">\r\n      <span class=\"input-group-text highest-range-${fieldId}\">${defaultEndValue}</span>\r\n    </div>`);\r\n        this.$filterElm = $(`<div class=\"filter-input filter-${fieldId}\"></div>`);\r\n        this.$filterContainerElm = $(`<div class=\"input-group form-control search-filter slider-range-container slider-values filter-${fieldId}\">`);\r\n        if (this.filterParams.hideSliderNumbers) {\r\n            this.$filterContainerElm.append(this.$filterElm);\r\n        }\r\n        else {\r\n            this.$filterContainerElm.append($lowestSliderValueElm);\r\n            this.$filterContainerElm.append(this.$filterElm);\r\n            this.$filterContainerElm.append($highestSliderValueElm);\r\n        }\r\n        // if we are preloading searchTerms, we'll keep them for reference\r\n        this._currentValues = [defaultStartValue, defaultEndValue];\r\n        const definedOptions = {\r\n            range: true,\r\n            min: +minValue,\r\n            max: +maxValue,\r\n            step: +step,\r\n            values: [defaultStartValue, defaultEndValue],\r\n            change: (e, ui) => this.onValueChanged(e, ui),\r\n            slide: (e, ui) => {\r\n                const values = ui.values;\r\n                if (!this.filterParams.hideSliderNumbers && Array.isArray(values)) {\r\n                    this.renderSliderValues(values[0], values[1]);\r\n                }\r\n            }\r\n        };\r\n        // merge options with optional user's custom options\r\n        this._sliderOptions = Object.assign({}, definedOptions, this.columnFilter.filterOptions);\r\n        this.$filterElm.slider(this._sliderOptions);\r\n        // if there's a search term, we will add the \"filled\" class for styling purposes\r\n        if (Array.isArray(searchTerms) && searchTerms.length > 0 && searchTerms[0] !== '') {\r\n            this.$filterContainerElm.addClass('filled');\r\n        }\r\n        // append the new DOM element to the header row\r\n        if (this.$filterContainerElm && typeof this.$filterContainerElm.appendTo === 'function') {\r\n            this.$filterContainerElm.appendTo($headerElm);\r\n        }\r\n        return this.$filterElm;\r\n    }\r\n    /** On a value change event triggered */\r\n    onValueChanged(e, ui) {\r\n        const values = ui && Array.isArray(ui.values) ? ui.values : [];\r\n        const value = values.join('..');\r\n        if (this._clearFilterTriggered) {\r\n            this.callback(e, { columnDef: this.columnDef, clearFilterTriggered: this._clearFilterTriggered, shouldTriggerQuery: this._shouldTriggerQuery });\r\n            this.$filterContainerElm.removeClass('filled');\r\n        }\r\n        else {\r\n            value === '' ? this.$filterContainerElm.removeClass('filled') : this.$filterContainerElm.addClass('filled');\r\n            this.callback(e, { columnDef: this.columnDef, operator: this.operator, searchTerms: values, shouldTriggerQuery: this._shouldTriggerQuery });\r\n        }\r\n        // reset both flags for next use\r\n        this._clearFilterTriggered = false;\r\n        this._shouldTriggerQuery = true;\r\n    }\r\n}\n\nconst Filters = {\r\n    /** AutoComplete Filter (using jQuery UI autocomplete feature) */\r\n    autoComplete: AutoCompleteFilter,\r\n    /** Compound Date Filter (compound of Operator + Date picker) */\r\n    compoundDate: CompoundDateFilter,\r\n    /** Alias to compoundInputText to Compound Input Filter (compound of Operator + Input Text) */\r\n    compoundInput: CompoundInputFilter,\r\n    /** Compound Input Number Filter (compound of Operator + Input of type Number) */\r\n    compoundInputNumber: CompoundInputNumberFilter,\r\n    /** Compound Input Password Filter (compound of Operator + Input of type Password, also note that only the text shown in the UI will be masked, filter query is still plain text) */\r\n    compoundInputPassword: CompoundInputPasswordFilter,\r\n    /** Compound Input Text Filter (compound of Operator + Input Text) */\r\n    compoundInputText: CompoundInputFilter,\r\n    /** Compound Slider Filter (compound of Operator + Slider) */\r\n    compoundSlider: CompoundSliderFilter,\r\n    /** Range Date Filter (uses the Flactpickr Date picker with range option) */\r\n    dateRange: DateRangeFilter,\r\n    /** Alias to inputText, input type text filter */\r\n    input: InputFilter,\r\n    /**\r\n     * Input Filter of type text that will be formatted with a mask output\r\n     * e.g.: column: { filter: { model: Filters.inputMask }, params: { mask: '(000) 000-0000' }}\r\n     */\r\n    inputMask: InputMaskFilter,\r\n    /** Input Filter of type Number */\r\n    inputNumber: InputNumberFilter,\r\n    /** Input Filter of type Password (note that only the text shown in the UI will be masked, filter query is still plain text) */\r\n    inputPassword: InputPasswordFilter,\r\n    /** Default Filter, input type text filter */\r\n    inputText: InputFilter,\r\n    /** Multiple Select filter, which uses 3rd party lib \"multiple-select.js\" */\r\n    multipleSelect: MultipleSelectFilter,\r\n    /** Select filter, which uses native DOM element select */\r\n    select: NativeSelectFilter,\r\n    /** Single Select filter, which uses 3rd party lib \"multiple-select.js\" */\r\n    singleSelect: SingleSelectFilter,\r\n    /** Slider Filter (only 1 value) */\r\n    slider: SliderFilter,\r\n    /** Slider Range Filter, uses jQuery UI Range Slider (2 values, lowest/highest search range) */\r\n    sliderRange: SliderRangeFilter,\r\n};\n\n/**\r\n * Options that can be passed to the Bootstrap-Datetimepicker directly\r\n */\r\nconst GlobalGridOptions = {\r\n    alwaysShowVerticalScroll: true,\r\n    autoEdit: false,\r\n    asyncEditorLoading: false,\r\n    autoFitColumnsOnFirstLoad: true,\r\n    autoResize: {\r\n        calculateAvailableSizeBy: 'window',\r\n        bottomPadding: 20,\r\n        minHeight: 180,\r\n        minWidth: 300,\r\n        sidePadding: 0\r\n    },\r\n    cellHighlightCssClass: 'slick-cell-modified',\r\n    checkboxSelector: {\r\n        cssClass: 'slick-cell-checkboxsel'\r\n    },\r\n    columnPicker: {\r\n        fadeSpeed: 0,\r\n        hideForceFitButton: false,\r\n        hideSyncResizeButton: true\r\n    },\r\n    cellMenu: {\r\n        autoAdjustDrop: true,\r\n        autoAlignSide: true,\r\n        hideCloseButton: true,\r\n        hideCommandSection: false,\r\n        hideOptionSection: false,\r\n    },\r\n    contextMenu: {\r\n        autoAdjustDrop: true,\r\n        autoAlignSide: true,\r\n        hideCloseButton: true,\r\n        hideClearAllGrouping: false,\r\n        hideCollapseAllGroups: false,\r\n        hideCommandSection: false,\r\n        hideCopyCellValueCommand: false,\r\n        hideExpandAllGroups: false,\r\n        hideExportCsvCommand: false,\r\n        hideExportExcelCommand: false,\r\n        hideExportTextDelimitedCommand: true,\r\n        hideMenuOnScroll: true,\r\n        hideOptionSection: false,\r\n        iconCopyCellValueCommand: 'fa fa-clone',\r\n        iconExportCsvCommand: 'fa fa-download',\r\n        iconExportExcelCommand: 'fa fa-file-excel-o text-success',\r\n        iconExportTextDelimitedCommand: 'fa fa-download',\r\n        width: 200,\r\n    },\r\n    customFooterOptions: {\r\n        dateFormat: 'yyyy-MM-dd hh:mm aaaaa\\'m\\'',\r\n        hideTotalItemCount: false,\r\n        hideLastUpdateTimestamp: true,\r\n        footerHeight: 20,\r\n        leftContainerClass: 'col-xs-12 col-sm-5',\r\n        rightContainerClass: 'col-xs-6 col-sm-7',\r\n        metricSeparator: '|',\r\n        metricTexts: {\r\n            items: 'items',\r\n            of: 'of',\r\n            itemsKey: 'ITEMS',\r\n            ofKey: 'OF',\r\n        }\r\n    },\r\n    dataView: {\r\n        syncGridSelection: true,\r\n        syncGridSelectionWithBackendService: false,\r\n    },\r\n    datasetIdPropertyName: 'id',\r\n    defaultFilter: Filters.input,\r\n    enableFilterTrimWhiteSpace: false,\r\n    defaultFilterPlaceholder: '&#128269;',\r\n    defaultFilterRangeOperator: OperatorType.rangeExclusive,\r\n    editable: false,\r\n    enableAutoResize: true,\r\n    enableAutoSizeColumns: true,\r\n    enableCellNavigation: false,\r\n    enableColumnPicker: true,\r\n    enableColumnReorder: true,\r\n    enableContextMenu: true,\r\n    enableExcelExport: true,\r\n    enableExport: false,\r\n    enableGridMenu: true,\r\n    enableHeaderMenu: true,\r\n    enableMouseHoverHighlightRow: true,\r\n    enableSorting: true,\r\n    enableTextSelectionOnCells: true,\r\n    explicitInitialization: true,\r\n    excelExportOptions: {\r\n        addGroupIndentation: true,\r\n        exportWithFormatter: false,\r\n        filename: 'export',\r\n        format: FileType.xlsx,\r\n        groupingColumnHeaderTitle: 'Group By',\r\n        groupCollapsedSymbol: '\\u25B9',\r\n        groupExpandedSymbol: '\\u25BF',\r\n        groupingAggregatorRowText: '',\r\n        sanitizeDataExport: false,\r\n    },\r\n    exportOptions: {\r\n        delimiter: DelimiterType.comma,\r\n        exportWithFormatter: false,\r\n        filename: 'export',\r\n        format: FileType.csv,\r\n        groupingColumnHeaderTitle: 'Group By',\r\n        groupingAggregatorRowText: '',\r\n        sanitizeDataExport: false,\r\n        useUtf8WithBom: true\r\n    },\r\n    forceFitColumns: false,\r\n    gridMenu: {\r\n        hideClearAllFiltersCommand: false,\r\n        hideClearAllSortingCommand: false,\r\n        hideExportCsvCommand: false,\r\n        hideExportExcelCommand: false,\r\n        hideExportTextDelimitedCommand: true,\r\n        hideForceFitButton: false,\r\n        hideRefreshDatasetCommand: false,\r\n        hideSyncResizeButton: true,\r\n        hideToggleFilterCommand: false,\r\n        hideTogglePreHeaderCommand: false,\r\n        iconCssClass: 'fa fa-bars',\r\n        iconClearAllFiltersCommand: 'fa fa-filter text-danger',\r\n        iconClearAllSortingCommand: 'fa fa-unsorted text-danger',\r\n        iconExportCsvCommand: 'fa fa-download',\r\n        iconExportExcelCommand: 'fa fa-file-excel-o text-success',\r\n        iconExportTextDelimitedCommand: 'fa fa-download',\r\n        iconRefreshDatasetCommand: 'fa fa-refresh',\r\n        iconToggleFilterCommand: 'fa fa-random',\r\n        iconTogglePreHeaderCommand: 'fa fa-random',\r\n        menuWidth: 16,\r\n        resizeOnShowHeaderRow: true\r\n    },\r\n    headerMenu: {\r\n        autoAlign: true,\r\n        autoAlignOffset: 12,\r\n        minWidth: 140,\r\n        iconClearFilterCommand: 'fa fa-filter text-danger',\r\n        iconClearSortCommand: 'fa fa-unsorted',\r\n        iconSortAscCommand: 'fa fa-sort-amount-asc',\r\n        iconSortDescCommand: 'fa fa-sort-amount-desc',\r\n        iconColumnHideCommand: 'fa fa-times',\r\n        hideColumnHideCommand: false,\r\n        hideClearFilterCommand: false,\r\n        hideClearSortCommand: false,\r\n        hideSortCommands: false\r\n    },\r\n    headerRowHeight: 35,\r\n    multiColumnSort: true,\r\n    numberedMultiColumnSort: true,\r\n    tristateMultiColumnSort: false,\r\n    sortColNumberInSeparateSpan: true,\r\n    suppressActiveCellChangeOnEdit: true,\r\n    pagination: {\r\n        pageSizes: [10, 15, 20, 25, 30, 40, 50, 75, 100],\r\n        pageSize: 25,\r\n        totalItems: 0\r\n    },\r\n    // @ts-ignore\r\n    // technically speaking the Row Detail requires the process & viewComponent but we'll ignore it just to set certain options\r\n    rowDetailView: {\r\n        cssClass: 'detail-view-toggle',\r\n        panelRows: 1,\r\n        keyPrefix: '__',\r\n        useRowClick: true,\r\n        useSimpleViewportCalc: true,\r\n        saveDetailViewOnScroll: false,\r\n    },\r\n    rowHeight: 35,\r\n    topPanelHeight: 35\r\n};\n\nclass SlickgridConfig {\r\n    constructor() {\r\n        this.options = GlobalGridOptions;\r\n    }\r\n}\n\nlet FilterFactory = class FilterFactory {\r\n    constructor(config, translate, collectionService) {\r\n        this.config = config;\r\n        this.translate = translate;\r\n        this.collectionService = collectionService;\r\n        this._options = this.config.options;\r\n    }\r\n    // Uses the User model to create a new User\r\n    createFilter(columnFilter) {\r\n        let filter;\r\n        if (columnFilter && columnFilter.model) {\r\n            filter = typeof columnFilter.model === 'function' ? new columnFilter.model(this.translate, this.collectionService) : columnFilter.model;\r\n        }\r\n        // fallback to the default filter\r\n        if (!filter && this._options.defaultFilter) {\r\n            filter = new this._options.defaultFilter(this.translate, this.collectionService);\r\n        }\r\n        return filter;\r\n    }\r\n};\r\nFilterFactory = __decorate([\r\n    Injectable(),\r\n    __param(1, Optional()),\r\n    __metadata(\"design:paramtypes\", [SlickgridConfig, TranslateService, CollectionService])\r\n], FilterFactory);\n\nconst isequal = isequal_; // patch to fix rollup to work\r\n// timer for keeping track of user typing waits\r\nlet timer;\r\nconst DEFAULT_FILTER_TYPING_DEBOUNCE = 500;\r\nlet FilterService = class FilterService {\r\n    constructor(filterFactory, sharedService) {\r\n        this.filterFactory = filterFactory;\r\n        this.sharedService = sharedService;\r\n        this._isFilterFirstRender = true;\r\n        this._firstColumnIdRendered = '';\r\n        this._filtersMetadata = [];\r\n        this._columnFilters = {};\r\n        this.httpCancelRequests$ = new Subject(); // this will be used to cancel any pending http request\r\n        this.onFilterChanged = new Subject();\r\n        this.onFilterCleared = new Subject();\r\n        this._eventHandler = new Slick.EventHandler();\r\n        this._onSearchChange = new Slick.Event();\r\n    }\r\n    /** Getter of the SlickGrid Event Handler */\r\n    get eventHandler() {\r\n        return this._eventHandler;\r\n    }\r\n    /** Getter to know if the filter was already rendered or if it was its first time render */\r\n    get isFilterFirstRender() {\r\n        return this._isFilterFirstRender;\r\n    }\r\n    /** Getter of the SlickGrid Event Handler */\r\n    get onSearchChange() {\r\n        return this._onSearchChange;\r\n    }\r\n    /** Getter for the Grid Options pulled through the Grid Object */\r\n    get _gridOptions() {\r\n        return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};\r\n    }\r\n    /** Getter for the Column Definitions pulled through the Grid Object */\r\n    get _columnDefinitions() {\r\n        return (this._grid && this._grid.getColumns) ? this._grid.getColumns() : [];\r\n    }\r\n    init(grid) {\r\n        this._grid = grid;\r\n    }\r\n    dispose() {\r\n        this.disposeColumnFilters();\r\n        // unsubscribe all SlickGrid events\r\n        if (this._eventHandler && this._eventHandler.unsubscribeAll) {\r\n            this._eventHandler.unsubscribeAll();\r\n        }\r\n        if (isObservable(this.httpCancelRequests$)) {\r\n            this.httpCancelRequests$.next(); // this cancels any pending http requests\r\n        }\r\n    }\r\n    /**\r\n     * Dispose of the filters, since it's a singleton, we don't want to affect other grids with same columns\r\n     */\r\n    disposeColumnFilters() {\r\n        // we need to loop through all columnFilters and delete them 1 by 1\r\n        // only trying to make columnFilter an empty (without looping) would not trigger a dataset change\r\n        if (typeof this._columnFilters === 'object') {\r\n            for (const columnId in this._columnFilters) {\r\n                if (columnId && this._columnFilters[columnId]) {\r\n                    delete this._columnFilters[columnId];\r\n                }\r\n            }\r\n        }\r\n        // also destroy each Filter instances\r\n        if (Array.isArray(this._filtersMetadata)) {\r\n            this._filtersMetadata.forEach((filter) => {\r\n                if (filter && filter.destroy) {\r\n                    filter.destroy(true);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Bind a backend filter hook to the grid\r\n     * @param grid SlickGrid Grid object\r\n     */\r\n    bindBackendOnFilter(grid, dataView) {\r\n        this._dataView = dataView;\r\n        this._filtersMetadata = [];\r\n        // subscribe to SlickGrid onHeaderRowCellRendered event to create filter template\r\n        this._eventHandler.subscribe(grid.onHeaderRowCellRendered, (e, args) => {\r\n            // firstColumnIdRendered is null at first, so if it changes to being filled and equal, then we would know that it was already rendered\r\n            // this is to avoid rendering the filter twice (only the Select Filter for now), rendering it again also clears the filter which has unwanted side effect\r\n            if (args.column.id === this._firstColumnIdRendered) {\r\n                this._isFilterFirstRender = false;\r\n            }\r\n            this.addFilterTemplateToHeaderRow(args, this._isFilterFirstRender);\r\n            if (this._firstColumnIdRendered === '') {\r\n                this._firstColumnIdRendered = args.column.id;\r\n            }\r\n        });\r\n        // subscribe to the SlickGrid event and call the backend execution\r\n        this._eventHandler.subscribe(this._onSearchChange, this.onBackendFilterChange.bind(this));\r\n    }\r\n    /**\r\n     * Bind a local filter hook to the grid\r\n     * @param grid SlickGrid Grid object\r\n     * @param dataView\r\n     */\r\n    bindLocalOnFilter(grid, dataView) {\r\n        this._filtersMetadata = [];\r\n        this._dataView = dataView;\r\n        dataView.setFilterArgs({ columnFilters: this._columnFilters, grid: this._grid, dataView });\r\n        dataView.setFilter(this.customLocalFilter.bind(this));\r\n        this._eventHandler.subscribe(this._onSearchChange, (e, args) => {\r\n            const columnId = args.columnId;\r\n            if (columnId != null) {\r\n                dataView.refresh();\r\n            }\r\n            // emit an onFilterChanged event when it's not called by a clear filter\r\n            if (args && !args.clearFilterTriggered) {\r\n                this.emitFilterChanged(EmitterType.local);\r\n            }\r\n        });\r\n        // subscribe to SlickGrid onHeaderRowCellRendered event to create filter template\r\n        this._eventHandler.subscribe(grid.onHeaderRowCellRendered, (e, args) => {\r\n            this.addFilterTemplateToHeaderRow(args);\r\n        });\r\n    }\r\n    clearFilterByColumnId(event, columnId) {\r\n        // get current column filter before clearing, this allow us to know if the filter was empty prior to calling the clear filter\r\n        const currentColumnFilters = Object.keys(this._columnFilters);\r\n        let currentColFilter;\r\n        if (Array.isArray(currentColumnFilters)) {\r\n            currentColFilter = currentColumnFilters.find((name) => name === columnId);\r\n        }\r\n        // find the filter object and call its clear method with true (the argument tells the method it was called by a clear filter)\r\n        const colFilter = this._filtersMetadata.find((filter) => filter.columnDef.id === columnId);\r\n        if (colFilter && colFilter.clear) {\r\n            colFilter.clear(true);\r\n        }\r\n        let emitter = EmitterType.local;\r\n        const isBackendApi = this._gridOptions && this._gridOptions.backendServiceApi || false;\r\n        // when using a backend service, we need to manually trigger a filter change but only if the filter was previously filled\r\n        if (isBackendApi) {\r\n            emitter = EmitterType.remote;\r\n            if (currentColFilter) {\r\n                this.onBackendFilterChange(event, { grid: this._grid, columnFilters: this._columnFilters });\r\n            }\r\n        }\r\n        // emit an event when filter is cleared\r\n        this.emitFilterChanged(emitter);\r\n    }\r\n    /** Clear the search filters (below the column titles) */\r\n    clearFilters(triggerChange = true) {\r\n        this._filtersMetadata.forEach((filter) => {\r\n            if (filter && filter.clear) {\r\n                // clear element but don't trigger individual clear change,\r\n                // we'll do 1 trigger for all filters at once afterward\r\n                filter.clear(false);\r\n            }\r\n        });\r\n        // we also need to refresh the dataView and optionally the grid (it's optional since we use DataView)\r\n        if (this._dataView && this._grid) {\r\n            this._dataView.refresh();\r\n            this._grid.invalidate();\r\n        }\r\n        // when using backend service, we need to query only once so it's better to do it here\r\n        const backendApi = this._gridOptions && this._gridOptions.backendServiceApi;\r\n        if (backendApi && triggerChange) {\r\n            const callbackArgs = { clearFilterTriggered: true, shouldTriggerQuery: triggerChange, grid: this._grid, columnFilters: this._columnFilters };\r\n            const queryResponse = backendApi.service.processOnFilterChanged(undefined, callbackArgs);\r\n            if (queryResponse instanceof Promise && queryResponse.then) {\r\n                // @deprecated, processOnFilterChanged in the future should be returned as a query string NOT as a Promise\r\n                console.warn(`[Angular-Slickgrid] please note that the \"processOnFilterChanged\" from your Backend Service, should now return a string instead of a Promise.\r\n          Returning a Promise will be deprecated in the future.`);\r\n                queryResponse.then((query) => {\r\n                    const totalItems = this._gridOptions && this._gridOptions.pagination && this._gridOptions.pagination.totalItems;\r\n                    executeBackendCallback(backendApi, query, callbackArgs, new Date(), totalItems, this.emitFilterChanged.bind(this));\r\n                });\r\n            }\r\n            else {\r\n                const query = queryResponse;\r\n                const totalItems = this._gridOptions && this._gridOptions.pagination && this._gridOptions.pagination.totalItems;\r\n                executeBackendCallback(backendApi, query, callbackArgs, new Date(), totalItems, this.emitFilterChanged.bind(this));\r\n            }\r\n        }\r\n        // emit an event when filters are all cleared\r\n        if (triggerChange) {\r\n            this.onFilterCleared.next(true);\r\n        }\r\n    }\r\n    customLocalFilter(item, args) {\r\n        const dataView = args && args.dataView;\r\n        for (const columnId of Object.keys(args.columnFilters)) {\r\n            const columnFilter = args.columnFilters[columnId];\r\n            let columnIndex = args.grid.getColumnIndex(columnId);\r\n            let columnDef = args.grid.getColumns()[columnIndex];\r\n            // it might be a hidden column, if so it won't be part of the getColumns (because it we hide a column via setColumns)\r\n            // when that happens we can try to get the column definition from all defined columns\r\n            if (!columnDef && this.sharedService && Array.isArray(this.sharedService.allColumns)) {\r\n                columnIndex = this.sharedService.allColumns.findIndex((col) => col.field === columnId);\r\n                columnDef = this.sharedService.allColumns[columnIndex];\r\n            }\r\n            // if we still don't have a column definition then we should return then row anyway (true)\r\n            if (!columnDef) {\r\n                return true;\r\n            }\r\n            // Row Detail View plugin, if the row is padding we just get the value we're filtering on from it's parent\r\n            if (this._gridOptions.enableRowDetailView) {\r\n                const metadataPrefix = this._gridOptions.rowDetailView && this._gridOptions.rowDetailView.keyPrefix || '__';\r\n                if (item[`${metadataPrefix}isPadding`] && item[`${metadataPrefix}parent`]) {\r\n                    item = item[`${metadataPrefix}parent`];\r\n                }\r\n            }\r\n            const dataKey = columnDef.dataKey;\r\n            const fieldName = columnDef.queryFieldFilter || columnDef.queryField || columnDef.field;\r\n            const fieldType = columnDef.type || FieldType.string;\r\n            const filterSearchType = (columnDef.filterSearchType) ? columnDef.filterSearchType : null;\r\n            let cellValue = item[fieldName];\r\n            // when item is a complex object (dot \".\" notation), we need to filter the value contained in the object tree\r\n            if (fieldName.indexOf('.') >= 0) {\r\n                cellValue = getDescendantProperty(item, fieldName);\r\n            }\r\n            // if we find searchTerms use them but make a deep copy so that we don't affect original array\r\n            // we might have to overwrite the value(s) locally that are returned\r\n            // e.g: we don't want to operator within the search value, since it will fail filter condition check trigger afterward\r\n            const searchValues = (columnFilter && columnFilter.searchTerms) ? $.extend(true, [], columnFilter.searchTerms) : null;\r\n            let fieldSearchValue = (Array.isArray(searchValues) && searchValues.length === 1) ? searchValues[0] : '';\r\n            let matches = null;\r\n            if (fieldType !== FieldType.object) {\r\n                fieldSearchValue = '' + fieldSearchValue; // make sure it's a string\r\n                matches = fieldSearchValue.match(/^([<>!=\\*]{0,2})(.*[^<>!=\\*])([\\*]?)$/); // group 1: Operator, 2: searchValue, 3: last char is '*' (meaning starts with, ex.: abc*)\r\n            }\r\n            let operator = columnFilter.operator || ((matches) ? matches[1] : '');\r\n            const searchTerm = (!!matches) ? matches[2] : '';\r\n            const lastValueChar = (!!matches) ? matches[3] : (operator === '*z' ? '*' : '');\r\n            if (searchValues && searchValues.length > 1) {\r\n                fieldSearchValue = searchValues.join(',');\r\n            }\r\n            else if (typeof fieldSearchValue === 'string') {\r\n                // escaping the search value\r\n                fieldSearchValue = fieldSearchValue.replace(`'`, `''`); // escape single quotes by doubling them\r\n                if (operator === '*' || operator === 'a*' || operator === '*z' || lastValueChar === '*') {\r\n                    operator = (operator === '*' || operator === '*z') ? OperatorType.endsWith : OperatorType.startsWith;\r\n                }\r\n            }\r\n            // no need to query if search value is empty\r\n            if (searchTerm === '' && (!searchValues || (Array.isArray(searchValues) && searchValues.length === 0))) {\r\n                return true;\r\n            }\r\n            // if search value has a regex match we will only keep the value without the operator\r\n            // in this case we need to overwrite the returned search values to truncate operator from the string search\r\n            if (Array.isArray(matches) && matches.length >= 1 && (Array.isArray(searchValues) && searchValues.length === 1)) {\r\n                searchValues[0] = searchTerm;\r\n            }\r\n            // filter search terms should always be string type (even though we permit the end user to input numbers)\r\n            // so make sure each term are strings, if user has some default search terms, we will cast them to string\r\n            if (searchValues && Array.isArray(searchValues) && fieldType !== FieldType.object) {\r\n                for (let k = 0, ln = searchValues.length; k < ln; k++) {\r\n                    // make sure all search terms are strings\r\n                    searchValues[k] = ((searchValues[k] === undefined || searchValues[k] === null) ? '' : searchValues[k]) + '';\r\n                }\r\n            }\r\n            // when using localization (i18n), we should use the formatter output to search as the new cell value\r\n            if (columnDef && columnDef.params && columnDef.params.useFormatterOuputToFilter) {\r\n                const rowIndex = (dataView && typeof dataView.getIdxById === 'function') ? dataView.getIdxById(item.id) : 0;\r\n                cellValue = columnDef.formatter(rowIndex, columnIndex, cellValue, columnDef, item, this._grid);\r\n            }\r\n            // make sure cell value is always a string\r\n            if (typeof cellValue === 'number') {\r\n                cellValue = cellValue.toString();\r\n            }\r\n            const conditionOptions = {\r\n                dataKey,\r\n                fieldType,\r\n                searchTerms: searchValues,\r\n                cellValue,\r\n                operator: operator,\r\n                cellValueLastChar: lastValueChar,\r\n                filterSearchType\r\n            };\r\n            if (!FilterConditions.executeMappedCondition(conditionOptions)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    getColumnFilters() {\r\n        return this._columnFilters;\r\n    }\r\n    getFiltersMetadata() {\r\n        return this._filtersMetadata;\r\n    }\r\n    getCurrentLocalFilters() {\r\n        const currentFilters = [];\r\n        if (this._columnFilters) {\r\n            for (const colId of Object.keys(this._columnFilters)) {\r\n                const columnFilter = this._columnFilters[colId];\r\n                const filter = { columnId: colId || '' };\r\n                if (columnFilter && columnFilter.searchTerms) {\r\n                    filter.searchTerms = columnFilter.searchTerms;\r\n                }\r\n                if (columnFilter.operator) {\r\n                    filter.operator = columnFilter.operator;\r\n                }\r\n                if (Array.isArray(filter.searchTerms) && filter.searchTerms.length > 0 && filter.searchTerms[0] !== '') {\r\n                    currentFilters.push(filter);\r\n                }\r\n            }\r\n        }\r\n        return currentFilters;\r\n    }\r\n    /**\r\n     * A simple function that is binded to the subscriber and emit a change when the filter is called.\r\n     * Other services, like Pagination, can then subscribe to it.\r\n     * @param caller\r\n     */\r\n    emitFilterChanged(caller) {\r\n        if (caller === EmitterType.remote && this._gridOptions && this._gridOptions.backendServiceApi) {\r\n            let currentFilters = [];\r\n            const backendService = this._gridOptions.backendServiceApi.service;\r\n            if (backendService && backendService.getCurrentFilters) {\r\n                currentFilters = backendService.getCurrentFilters();\r\n            }\r\n            this.onFilterChanged.next(currentFilters);\r\n        }\r\n        else if (caller === EmitterType.local) {\r\n            this.onFilterChanged.next(this.getCurrentLocalFilters());\r\n        }\r\n    }\r\n    onBackendFilterChange(event, args) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!args || !args.grid) {\r\n                throw new Error('Something went wrong when trying to bind the \"onBackendFilterChange(event, args)\" function, it seems that \"args\" is not populated correctly');\r\n            }\r\n            // const gridOptions: GridOption = (args.grid && args.grid.getOptions) ? args.grid.getOptions() : {};\r\n            const backendApi = this._gridOptions.backendServiceApi;\r\n            if (!backendApi || !backendApi.process || !backendApi.service) {\r\n                throw new Error(`BackendServiceApi requires at least a \"process\" function and a \"service\" defined`);\r\n            }\r\n            // keep start time & end timestamps & return it after process execution\r\n            const startTime = new Date();\r\n            // run a preProcess callback if defined\r\n            if (backendApi.preProcess) {\r\n                backendApi.preProcess();\r\n            }\r\n            // only add a delay when user is typing, on select dropdown filter (or \"Clear Filter\") it will execute right away\r\n            let debounceTypingDelay = 0;\r\n            const isTriggeredByClearFilter = args && args.clearFilterTriggered; // was it trigger by a \"Clear Filter\" command?\r\n            const eventType = event && event.type;\r\n            const eventKeyCode = event && event.keyCode;\r\n            if (!isTriggeredByClearFilter && eventKeyCode !== KeyCode.ENTER && (eventType === 'input' || eventType === 'keyup' || eventType === 'keydown')) {\r\n                debounceTypingDelay = backendApi.hasOwnProperty('filterTypingDebounce') ? backendApi.filterTypingDebounce : DEFAULT_FILTER_TYPING_DEBOUNCE;\r\n            }\r\n            // query backend, except when it's called by a ClearFilters then we won't\r\n            if (args && args.shouldTriggerQuery) {\r\n                // call the service to get a query back\r\n                // @deprecated TODO: remove async/await on next major change, refer to processOnFilterChanged in BackendService interface (with @deprecated)\r\n                clearTimeout(timer);\r\n                if (debounceTypingDelay > 0) {\r\n                    timer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {\r\n                        const query = yield backendApi.service.processOnFilterChanged(event, args);\r\n                        const totalItems = this._gridOptions && this._gridOptions.pagination && this._gridOptions.pagination.totalItems;\r\n                        executeBackendCallback(backendApi, query, args, startTime, totalItems, this.emitFilterChanged.bind(this), this.httpCancelRequests$);\r\n                    }), debounceTypingDelay);\r\n                }\r\n                else {\r\n                    const query = yield backendApi.service.processOnFilterChanged(event, args);\r\n                    const totalItems = this._gridOptions && this._gridOptions.pagination && this._gridOptions.pagination.totalItems;\r\n                    executeBackendCallback(backendApi, query, args, startTime, totalItems, this.emitFilterChanged.bind(this), this.httpCancelRequests$);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * When user passes an array of preset filters, we need to pre-populate each column filter searchTerm(s)\r\n     * The process is to loop through the preset filters array, find the associated column from columnDefinitions and fill in the filter object searchTerm(s)\r\n     * This is basically the same as if we would manually add searchTerm(s) to a column filter object in the column definition, but we do it programmatically.\r\n     * At the end of the day, when creating the Filter (DOM Element), it will use these searchTerm(s) so we can take advantage of that without recoding each Filter type (DOM element)\r\n     */\r\n    populateColumnFilterSearchTermPresets(filters) {\r\n        if (Array.isArray(filters) && filters.length > 0) {\r\n            this._columnDefinitions.forEach((columnDef) => {\r\n                // clear any columnDef searchTerms before applying Presets\r\n                if (columnDef.filter && columnDef.filter.searchTerms) {\r\n                    delete columnDef.filter.searchTerms;\r\n                }\r\n                // from each presets, we will find the associated columnDef and apply the preset searchTerms & operator if there is\r\n                const columnPreset = filters.find((presetFilter) => {\r\n                    return presetFilter.columnId === columnDef.id;\r\n                });\r\n                if (columnPreset && columnPreset.searchTerms && Array.isArray(columnPreset.searchTerms)) {\r\n                    columnDef.filter = columnDef.filter || {};\r\n                    columnDef.filter.operator = columnPreset.operator || columnDef.filter.operator || '';\r\n                    columnDef.filter.searchTerms = columnPreset.searchTerms;\r\n                }\r\n            });\r\n        }\r\n        return this._columnDefinitions;\r\n    }\r\n    /**\r\n     * Set the sort icons in the UI (ONLY the icons, it does not do any sorting)\r\n     * The column sort icons are not necessarily inter-connected to the sorting functionality itself,\r\n     * you can change the sorting icons separately by passing an array of columnId/sortAsc and that will change ONLY the icons\r\n     * @param sortColumns\r\n     */\r\n    setSortColumnIcons(sortColumns) {\r\n        if (this._grid && Array.isArray(sortColumns)) {\r\n            this._grid.setSortColumns(sortColumns);\r\n        }\r\n    }\r\n    /**\r\n     * Update Filters dynamically just by providing an array of filter(s).\r\n     * You can also choose emit (default) a Filter Changed event that will be picked by the Grid State Service.\r\n     *\r\n     * Also for backend service only, you can choose to trigger a backend query (default) or not if you wish to do it later,\r\n     * this could be useful when using updateFilters & updateSorting and you wish to only send the backend query once.\r\n     * @param filters array\r\n     * @param triggerEvent defaults to True, do we want to emit a filter changed event?\r\n     * @param triggerBackendQuery defaults to True, which will query the backend.\r\n     */\r\n    updateFilters(filters, emitChangedEvent = true, triggerBackendQuery = true) {\r\n        if (!this._filtersMetadata || this._filtersMetadata.length === 0 || !this._gridOptions || !this._gridOptions.enableFiltering) {\r\n            throw new Error('[Angular-Slickgrid] in order to use \"updateFilters\" method, you need to have Filterable Columns defined in your grid and \"enableFiltering\" set in your Grid Options');\r\n        }\r\n        if (Array.isArray(filters)) {\r\n            // start by clearing all filters (without triggering an event) before applying any new filters\r\n            this.clearFilters(false);\r\n            // pre-fill (value + operator) and render all filters in the DOM\r\n            // loop through each Filters provided (which has a columnId property)\r\n            // then find their associated Filter instances that were originally created in the grid\r\n            filters.forEach((newFilter) => {\r\n                const uiFilter = this._filtersMetadata.find((filter) => newFilter.columnId === filter.columnDef.id);\r\n                if (newFilter && uiFilter) {\r\n                    const newOperator = newFilter.operator || uiFilter.defaultOperator;\r\n                    this.updateColumnFilters(newFilter.searchTerms, uiFilter.columnDef, newOperator);\r\n                    uiFilter.setValues(newFilter.searchTerms, newOperator);\r\n                }\r\n            });\r\n            const backendApi = this._gridOptions && this._gridOptions.backendServiceApi;\r\n            // refresh the DataView and trigger an event after all filters were updated and rendered\r\n            this._dataView.refresh();\r\n            if (backendApi) {\r\n                const backendApiService = backendApi && backendApi.service;\r\n                if (backendApiService) {\r\n                    backendApiService.updateFilters(filters, true);\r\n                    if (triggerBackendQuery) {\r\n                        refreshBackendDataset(this._gridOptions);\r\n                    }\r\n                }\r\n            }\r\n            if (emitChangedEvent) {\r\n                const emitterType = backendApi ? EmitterType.remote : EmitterType.local;\r\n                this.emitFilterChanged(emitterType);\r\n            }\r\n        }\r\n    }\r\n    // --\r\n    // private functions\r\n    // -------------------\r\n    /** Add all created filters (from their template) to the header row section area */\r\n    addFilterTemplateToHeaderRow(args, isFilterFirstRender = true) {\r\n        const columnDef = args.column;\r\n        const columnId = columnDef && columnDef.id || '';\r\n        if (columnDef && columnId !== 'selector' && columnDef.filterable) {\r\n            let searchTerms;\r\n            let operator;\r\n            const newFilter = this.filterFactory.createFilter(args.column.filter);\r\n            operator = (columnDef && columnDef.filter && columnDef.filter.operator) || (newFilter && newFilter.operator) || undefined;\r\n            if (this._columnFilters[columnDef.id]) {\r\n                searchTerms = this._columnFilters[columnDef.id].searchTerms || undefined;\r\n                operator = this._columnFilters[columnDef.id].operator || undefined;\r\n            }\r\n            else if (columnDef.filter) {\r\n                // when hiding/showing (with Column Picker or Grid Menu), it will try to re-create yet again the filters (since SlickGrid does a re-render)\r\n                // because of that we need to first get searchTerm(s) from the columnFilters (that is what the user last typed in a filter search input)\r\n                searchTerms = columnDef.filter.searchTerms || undefined;\r\n                this.updateColumnFilters(searchTerms, columnDef, operator);\r\n            }\r\n            const filterArguments = {\r\n                grid: this._grid,\r\n                operator,\r\n                searchTerms,\r\n                columnDef,\r\n                callback: this.callbackSearchEvent.bind(this)\r\n            };\r\n            if (newFilter) {\r\n                newFilter.init(filterArguments, isFilterFirstRender);\r\n                const filterExistIndex = this._filtersMetadata.findIndex((filter) => newFilter.columnDef.id === filter.columnDef.id);\r\n                // add to the filters arrays or replace it when found\r\n                if (filterExistIndex === -1) {\r\n                    this._filtersMetadata.push(newFilter);\r\n                }\r\n                else {\r\n                    this._filtersMetadata[filterExistIndex] = newFilter;\r\n                }\r\n                // when hiding/showing (with Column Picker or Grid Menu), it will try to re-create yet again the filters (since SlickGrid does a re-render)\r\n                // we need to also set again the values in the DOM elements if the values were set by a searchTerm(s)\r\n                if (searchTerms && newFilter.setValues) {\r\n                    newFilter.setValues(searchTerms);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Callback method that is called and executed by the individual Filter (DOM element),\r\n     * for example when user type in a word to search (which uses InputFilter), this Filter will execute the callback from a keyup event.\r\n     */\r\n    callbackSearchEvent(event, args) {\r\n        if (args) {\r\n            const searchTerm = ((event && event.target) ? event.target.value : undefined);\r\n            const searchTerms = (args.searchTerms && Array.isArray(args.searchTerms)) ? args.searchTerms : (searchTerm ? [searchTerm] : undefined);\r\n            const columnDef = args.columnDef || null;\r\n            const columnId = columnDef && columnDef.id || '';\r\n            const operator = args.operator || undefined;\r\n            const hasSearchTerms = searchTerms && Array.isArray(searchTerms);\r\n            const termsCount = hasSearchTerms && searchTerms && searchTerms.length;\r\n            const oldColumnFilters = Object.assign({}, this._columnFilters);\r\n            if (columnDef && columnId) {\r\n                if (!hasSearchTerms || termsCount === 0 || (termsCount === 1 && Array.isArray(searchTerms) && searchTerms[0] === '')) {\r\n                    // delete the property from the columnFilters when it becomes empty\r\n                    // without doing this, it would leave an incorrect state of the previous column filters when filtering on another column\r\n                    delete this._columnFilters[columnId];\r\n                }\r\n                else {\r\n                    const colId = '' + columnId;\r\n                    const colFilter = {\r\n                        columnId: colId,\r\n                        columnDef,\r\n                        searchTerms,\r\n                    };\r\n                    if (operator) {\r\n                        colFilter.operator = operator;\r\n                    }\r\n                    this._columnFilters[colId] = colFilter;\r\n                }\r\n            }\r\n            // event might have been created as a CustomEvent (e.g. CompoundDateFilter), without being a valid Slick.EventData,\r\n            // if so we will create a new Slick.EventData and merge it with that CustomEvent to avoid having SlickGrid errors\r\n            const eventData = (event && typeof event.isPropagationStopped !== 'function') ? $.extend({}, new Slick.EventData(), event) : event;\r\n            // trigger an event only if Filters changed or if ENTER key was pressed\r\n            const eventKeyCode = event && event.keyCode;\r\n            if (eventKeyCode === KeyCode.ENTER || !isequal(oldColumnFilters, this._columnFilters)) {\r\n                this._onSearchChange.notify({\r\n                    clearFilterTriggered: args.clearFilterTriggered,\r\n                    shouldTriggerQuery: args.shouldTriggerQuery,\r\n                    columnId,\r\n                    columnDef,\r\n                    columnFilters: this._columnFilters,\r\n                    operator,\r\n                    searchTerms,\r\n                    grid: this._grid\r\n                }, eventData);\r\n            }\r\n        }\r\n    }\r\n    updateColumnFilters(searchTerms, columnDef, operator) {\r\n        if (searchTerms && columnDef) {\r\n            this._columnFilters[columnDef.id] = {\r\n                columnId: columnDef.id,\r\n                columnDef,\r\n                searchTerms,\r\n                operator\r\n            };\r\n        }\r\n    }\r\n};\r\nFilterService = __decorate([\r\n    Injectable(),\r\n    __metadata(\"design:paramtypes\", [FilterFactory, SharedService])\r\n], FilterService);\n\nclass SortService {\r\n    constructor() {\r\n        this._currentLocalSorters = [];\r\n        this._isBackendGrid = false;\r\n        this.httpCancelRequests$ = new Subject(); // this will be used to cancel any pending http request\r\n        this.onSortChanged = new Subject();\r\n        this.onSortCleared = new Subject();\r\n        this._eventHandler = new Slick.EventHandler();\r\n    }\r\n    /** Getter of the SlickGrid Event Handler */\r\n    get eventHandler() {\r\n        return this._eventHandler;\r\n    }\r\n    /** Getter for the Grid Options pulled through the Grid Object */\r\n    get _gridOptions() {\r\n        return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};\r\n    }\r\n    /** Getter for the Column Definitions pulled through the Grid Object */\r\n    get _columnDefinitions() {\r\n        return (this._grid && this._grid.getColumns) ? this._grid.getColumns() : [];\r\n    }\r\n    /**\r\n     * Bind a backend sort (single/multi) hook to the grid\r\n     * @param grid SlickGrid Grid object\r\n     * @param dataView SlickGrid DataView object\r\n     */\r\n    bindBackendOnSort(grid, dataView) {\r\n        this._isBackendGrid = true;\r\n        this._grid = grid;\r\n        this._dataView = dataView;\r\n        // subscribe to the SlickGrid event and call the backend execution\r\n        this._eventHandler.subscribe(grid.onSort, this.onBackendSortChanged.bind(this));\r\n    }\r\n    /**\r\n     * Bind a local sort (single/multi) hook to the grid\r\n     * @param grid SlickGrid Grid object\r\n     * @param gridOptions Grid Options object\r\n     * @param dataView\r\n     */\r\n    bindLocalOnSort(grid, dataView) {\r\n        this._isBackendGrid = false;\r\n        this._grid = grid;\r\n        this._dataView = dataView;\r\n        this._eventHandler.subscribe(grid.onSort, (e, args) => {\r\n            if (args && (args.sortCols || args.sortCol)) {\r\n                // multiSort and singleSort are not exactly the same, but we want to structure it the same for the (for loop) after\r\n                // also to avoid having to rewrite the for loop in the sort, we will make the singleSort an array of 1 object\r\n                const sortColumns = (args.multiColumnSort) ? args.sortCols : new Array({ sortAsc: args.sortAsc, sortCol: args.sortCol });\r\n                // keep current sorters\r\n                this._currentLocalSorters = []; // reset current local sorters\r\n                if (Array.isArray(sortColumns)) {\r\n                    sortColumns.forEach((sortColumn) => {\r\n                        if (sortColumn.sortCol) {\r\n                            this._currentLocalSorters.push({\r\n                                columnId: sortColumn.sortCol.id,\r\n                                direction: sortColumn.sortAsc ? SortDirection.ASC : SortDirection.DESC\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n                this.onLocalSortChanged(grid, dataView, sortColumns);\r\n                this.emitSortChanged(EmitterType.local);\r\n            }\r\n        });\r\n    }\r\n    clearSorting(triggerQueryEvent = true) {\r\n        if (this._grid && this._gridOptions && this._dataView) {\r\n            // remove any sort icons (this setSortColumns function call really does only that)\r\n            this._grid.setSortColumns([]);\r\n            // we also need to trigger a sort change\r\n            // for a backend grid, we will trigger a backend sort changed with an empty sort columns array\r\n            // however for a local grid, we need to pass a sort column and so we will sort by the 1st column\r\n            if (triggerQueryEvent) {\r\n                if (this._isBackendGrid) {\r\n                    this.onBackendSortChanged(undefined, { grid: this._grid, sortCols: [], clearSortTriggered: true });\r\n                }\r\n                else {\r\n                    if (this._columnDefinitions && Array.isArray(this._columnDefinitions)) {\r\n                        this.onLocalSortChanged(this._grid, this._dataView, new Array({ sortAsc: true, sortCol: this._columnDefinitions[0], clearSortTriggered: true }));\r\n                    }\r\n                }\r\n            }\r\n            else if (this._isBackendGrid) {\r\n                const backendService = this._gridOptions && this._gridOptions.backendServiceApi && this._gridOptions.backendServiceApi.service;\r\n                if (backendService && backendService.clearSorters) {\r\n                    backendService.clearSorters();\r\n                }\r\n            }\r\n        }\r\n        // set current sorter to empty & emit a sort changed event\r\n        this._currentLocalSorters = [];\r\n        // emit an event when sorts are all cleared\r\n        this.onSortCleared.next(true);\r\n    }\r\n    dispose() {\r\n        // unsubscribe all SlickGrid events\r\n        if (this._eventHandler && this._eventHandler.unsubscribeAll) {\r\n            this._eventHandler.unsubscribeAll();\r\n        }\r\n        if (isObservable(this.httpCancelRequests$)) {\r\n            this.httpCancelRequests$.next(); // this cancels any pending http requests\r\n        }\r\n    }\r\n    /**\r\n     * A simple function that is binded to the subscriber and emit a change when the sort is called.\r\n     * Other services, like Pagination, can then subscribe to it.\r\n     * @param sender\r\n     */\r\n    emitSortChanged(sender, currentLocalSorters) {\r\n        if (sender === EmitterType.remote && this._gridOptions && this._gridOptions.backendServiceApi) {\r\n            let currentSorters = [];\r\n            const backendService = this._gridOptions.backendServiceApi.service;\r\n            if (backendService && backendService.getCurrentSorters) {\r\n                currentSorters = backendService.getCurrentSorters();\r\n            }\r\n            this.onSortChanged.next(currentSorters);\r\n        }\r\n        else if (sender === EmitterType.local) {\r\n            if (currentLocalSorters) {\r\n                this._currentLocalSorters = currentLocalSorters;\r\n            }\r\n            this.onSortChanged.next(this.getCurrentLocalSorters());\r\n        }\r\n    }\r\n    getCurrentLocalSorters() {\r\n        return this._currentLocalSorters;\r\n    }\r\n    /**\r\n     * Get current column sorts,\r\n     * If a column is passed as an argument, that will be exclusion so we won't add this column to our output array since it is already in the array.\r\n     * The usage of this method is that we want to know the sort prior to calling the next sorting command\r\n     */\r\n    getCurrentColumnSorts(excludedColumnId) {\r\n        // getSortColumns() only returns sortAsc & columnId, we want the entire column definition\r\n        const oldSortColumns = this._grid && this._grid.getSortColumns();\r\n        // get the column definition but only keep column which are not equal to our current column\r\n        if (Array.isArray(oldSortColumns)) {\r\n            const sortedCols = oldSortColumns.reduce((cols, col) => {\r\n                if (!excludedColumnId || col.columnId !== excludedColumnId) {\r\n                    cols.push({ sortCol: this._columnDefinitions[this._grid.getColumnIndex(col.columnId)], sortAsc: col.sortAsc });\r\n                }\r\n                return cols;\r\n            }, []);\r\n            return sortedCols;\r\n        }\r\n        return [];\r\n    }\r\n    /** Load defined Sorting (sorters) into the grid */\r\n    loadGridSorters(sorters) {\r\n        this._currentLocalSorters = []; // reset current local sorters\r\n        const sortCols = [];\r\n        if (Array.isArray(sorters)) {\r\n            sorters.forEach((sorter) => {\r\n                const gridColumn = this._columnDefinitions.find((col) => col.id === sorter.columnId);\r\n                if (gridColumn) {\r\n                    sortCols.push({\r\n                        columnId: gridColumn.id,\r\n                        sortAsc: ((sorter.direction.toUpperCase() === SortDirection.ASC) ? true : false),\r\n                        sortCol: gridColumn\r\n                    });\r\n                    // keep current sorters\r\n                    this._currentLocalSorters.push({\r\n                        columnId: gridColumn.id + '',\r\n                        direction: sorter.direction.toUpperCase()\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        if (sortCols.length > 0) {\r\n            this.onLocalSortChanged(this._grid, this._dataView, sortCols);\r\n            this._grid.setSortColumns(sortCols); // use this to add sort icon(s) in UI\r\n        }\r\n        return sortCols;\r\n    }\r\n    onBackendSortChanged(event, args) {\r\n        if (!args || !args.grid) {\r\n            throw new Error('Something went wrong when trying to bind the \"onBackendSortChanged(event, args)\" function, it seems that \"args\" is not populated correctly');\r\n        }\r\n        const gridOptions = (args.grid && args.grid.getOptions) ? args.grid.getOptions() : {};\r\n        const backendApi = gridOptions.backendServiceApi;\r\n        if (!backendApi || !backendApi.process || !backendApi.service) {\r\n            throw new Error(`BackendServiceApi requires at least a \"process\" function and a \"service\" defined`);\r\n        }\r\n        // keep start time & end timestamps & return it after process execution\r\n        const startTime = new Date();\r\n        if (backendApi.preProcess) {\r\n            backendApi.preProcess();\r\n        }\r\n        // query backend\r\n        const query = backendApi.service.processOnSortChanged(event, args);\r\n        const totalItems = gridOptions && gridOptions.pagination && gridOptions.pagination.totalItems;\r\n        executeBackendCallback(backendApi, query, args, startTime, totalItems, this.emitSortChanged.bind(this), this.httpCancelRequests$);\r\n    }\r\n    onLocalSortChanged(grid, dataView, sortColumns, forceReSort = false) {\r\n        if (grid && dataView) {\r\n            if (forceReSort) {\r\n                dataView.reSort();\r\n            }\r\n            dataView.sort(this.sortComparer.bind(this, sortColumns));\r\n            grid.invalidate();\r\n            grid.render();\r\n        }\r\n    }\r\n    sortComparer(sortColumns, dataRow1, dataRow2) {\r\n        if (Array.isArray(sortColumns)) {\r\n            for (let i = 0, l = sortColumns.length; i < l; i++) {\r\n                const columnSortObj = sortColumns[i];\r\n                if (columnSortObj && columnSortObj.sortCol) {\r\n                    const sortDirection = columnSortObj.sortAsc ? SortDirectionNumber.asc : SortDirectionNumber.desc;\r\n                    const sortField = columnSortObj.sortCol.queryFieldSorter || columnSortObj.sortCol.queryField || columnSortObj.sortCol.field;\r\n                    const fieldType = columnSortObj.sortCol.type || FieldType.string;\r\n                    let value1 = dataRow1[sortField];\r\n                    let value2 = dataRow2[sortField];\r\n                    // when item is a complex object (dot \".\" notation), we need to filter the value contained in the object tree\r\n                    if (sortField && sortField.indexOf('.') >= 0) {\r\n                        value1 = getDescendantProperty(dataRow1, sortField);\r\n                        value2 = getDescendantProperty(dataRow2, sortField);\r\n                    }\r\n                    // user could provide his own custom Sorter\r\n                    if (columnSortObj.sortCol && columnSortObj.sortCol.sorter) {\r\n                        const customSortResult = columnSortObj.sortCol.sorter(value1, value2, sortDirection, columnSortObj.sortCol);\r\n                        if (customSortResult !== SortDirectionNumber.neutral) {\r\n                            return customSortResult;\r\n                        }\r\n                    }\r\n                    else {\r\n                        const sortResult = sortByFieldType(fieldType, value1, value2, sortDirection, columnSortObj.sortCol);\r\n                        if (sortResult !== SortDirectionNumber.neutral) {\r\n                            return sortResult;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return SortDirectionNumber.neutral;\r\n    }\r\n    /**\r\n     * Update Sorting (sorters) dynamically just by providing an array of sorter(s).\r\n     * You can also choose emit (default) a Sort Changed event that will be picked by the Grid State Service.\r\n     *\r\n     * Also for backend service only, you can choose to trigger a backend query (default) or not if you wish to do it later,\r\n     * this could be useful when using updateFilters & updateSorting and you wish to only send the backend query once.\r\n     * @param sorters array\r\n     * @param triggerEvent defaults to True, do we want to emit a sort changed event?\r\n     * @param triggerBackendQuery defaults to True, which will query the backend.\r\n     */\r\n    updateSorting(sorters, emitChangedEvent = true, triggerBackendQuery = true) {\r\n        if (!this._gridOptions || !this._gridOptions.enableSorting) {\r\n            throw new Error('[Angular-Slickgrid] in order to use \"updateSorting\" method, you need to have Sortable Columns defined in your grid and \"enableSorting\" set in your Grid Options');\r\n        }\r\n        if (Array.isArray(sorters)) {\r\n            const backendApi = this._gridOptions && this._gridOptions.backendServiceApi;\r\n            if (backendApi) {\r\n                const backendApiService = backendApi && backendApi.service;\r\n                if (backendApiService) {\r\n                    backendApiService.updateSorters(undefined, sorters);\r\n                    if (triggerBackendQuery) {\r\n                        refreshBackendDataset(this._gridOptions);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                this.loadGridSorters(sorters);\r\n            }\r\n            if (emitChangedEvent) {\r\n                const emitterType = backendApi ? EmitterType.remote : EmitterType.local;\r\n                this.emitSortChanged(emitterType);\r\n            }\r\n        }\r\n    }\r\n}\n\nlet GridMenuExtension = class GridMenuExtension {\r\n    constructor(excelExportService, exportService, extensionUtility, filterService, sharedService, sortService, translate) {\r\n        this.excelExportService = excelExportService;\r\n        this.exportService = exportService;\r\n        this.extensionUtility = extensionUtility;\r\n        this.filterService = filterService;\r\n        this.sharedService = sharedService;\r\n        this.sortService = sortService;\r\n        this.translate = translate;\r\n        this._areVisibleColumnDifferent = false;\r\n        this._eventHandler = new Slick.EventHandler();\r\n    }\r\n    get eventHandler() {\r\n        return this._eventHandler;\r\n    }\r\n    dispose() {\r\n        // unsubscribe all SlickGrid events\r\n        this._eventHandler.unsubscribeAll();\r\n        if (this._addon && this._addon.destroy) {\r\n            this._addon.destroy();\r\n        }\r\n        if (this.sharedService.gridOptions && this.sharedService.gridOptions.gridMenu && this.sharedService.gridOptions.gridMenu.customItems) {\r\n            this.sharedService.gridOptions.gridMenu = this._userOriginalGridMenu;\r\n        }\r\n    }\r\n    /** Get the instance of the SlickGrid addon (control or plugin). */\r\n    getAddonInstance() {\r\n        return this._addon;\r\n    }\r\n    /** Create the Header Menu and expose all the available hooks that user can subscribe (onCommand, onBeforeMenuShow, ...) */\r\n    register() {\r\n        if (this.sharedService.gridOptions && this.sharedService.gridOptions.enableTranslate && (!this.translate || !this.translate.instant)) {\r\n            throw new Error('[Angular-Slickgrid] requires \"ngx-translate\" to be installed and configured when the grid option \"enableTranslate\" is enabled.');\r\n        }\r\n        if (this.sharedService && this.sharedService.gridOptions && this.sharedService.gridOptions.gridMenu) {\r\n            // keep original user grid menu, useful when switching locale to translate\r\n            this._userOriginalGridMenu = Object.assign({}, this.sharedService.gridOptions.gridMenu);\r\n            // get locales provided by user in forRoot or else use default English locales via the Constants\r\n            this._locales = this.sharedService.gridOptions && this.sharedService.gridOptions.locales || Constants.locales;\r\n            // dynamically import the SlickGrid plugin (addon) with RequireJS\r\n            this.extensionUtility.loadExtensionDynamically(ExtensionName.gridMenu);\r\n            this.sharedService.gridOptions.gridMenu = Object.assign({}, this.getDefaultGridMenuOptions(), this.sharedService.gridOptions.gridMenu);\r\n            // merge original user grid menu items with internal items\r\n            // then sort all Grid Menu Custom Items (sorted by pointer, no need to use the return)\r\n            const originalCustomItems = this._userOriginalGridMenu && Array.isArray(this._userOriginalGridMenu.customItems) ? this._userOriginalGridMenu.customItems : [];\r\n            this.sharedService.gridOptions.gridMenu.customItems = [...originalCustomItems, ...this.addGridMenuCustomCommands(originalCustomItems)];\r\n            this.extensionUtility.translateItems(this.sharedService.gridOptions.gridMenu.customItems, 'titleKey', 'title');\r\n            this.extensionUtility.sortItems(this.sharedService.gridOptions.gridMenu.customItems, 'positionOrder');\r\n            this._addon = new Slick.Controls.GridMenu(this.sharedService.allColumns, this.sharedService.grid, this.sharedService.gridOptions);\r\n            // hook all events\r\n            if (this.sharedService.grid && this.sharedService.gridOptions.gridMenu) {\r\n                if (this.sharedService.gridOptions.gridMenu.onExtensionRegistered) {\r\n                    this.sharedService.gridOptions.gridMenu.onExtensionRegistered(this._addon);\r\n                }\r\n                if (this.sharedService.gridOptions.gridMenu && typeof this.sharedService.gridOptions.gridMenu.onBeforeMenuShow === 'function') {\r\n                    this._eventHandler.subscribe(this._addon.onBeforeMenuShow, (e, args) => {\r\n                        this.sharedService.gridOptions.gridMenu.onBeforeMenuShow(e, args);\r\n                    });\r\n                }\r\n                if (this.sharedService.gridOptions.gridMenu && typeof this.sharedService.gridOptions.gridMenu.onAfterMenuShow === 'function') {\r\n                    this._eventHandler.subscribe(this._addon.onAfterMenuShow, (e, args) => {\r\n                        this.sharedService.gridOptions.gridMenu.onAfterMenuShow(e, args);\r\n                    });\r\n                }\r\n                this._eventHandler.subscribe(this._addon.onColumnsChanged, (e, args) => {\r\n                    this._areVisibleColumnDifferent = true;\r\n                    if (this.sharedService.gridOptions.gridMenu && typeof this.sharedService.gridOptions.gridMenu.onColumnsChanged === 'function') {\r\n                        this.sharedService.gridOptions.gridMenu.onColumnsChanged(e, args);\r\n                    }\r\n                    if (args && Array.isArray(args.columns) && args.columns.length > this.sharedService.visibleColumns.length) {\r\n                        this.sharedService.visibleColumns = args.columns;\r\n                    }\r\n                });\r\n                this._eventHandler.subscribe(this._addon.onCommand, (e, args) => {\r\n                    this.executeGridMenuInternalCustomCommands(e, args);\r\n                    if (this.sharedService.gridOptions.gridMenu && typeof this.sharedService.gridOptions.gridMenu.onCommand === 'function') {\r\n                        this.sharedService.gridOptions.gridMenu.onCommand(e, args);\r\n                    }\r\n                });\r\n                this._eventHandler.subscribe(this._addon.onMenuClose, (e, args) => {\r\n                    if (this.sharedService.gridOptions.gridMenu && typeof this.sharedService.gridOptions.gridMenu.onMenuClose === 'function') {\r\n                        this.sharedService.gridOptions.gridMenu.onMenuClose(e, args);\r\n                    }\r\n                    // we also want to resize the columns if the user decided to hide certain column(s)\r\n                    if (this.sharedService.grid && typeof this.sharedService.grid.autosizeColumns === 'function') {\r\n                        // make sure that the grid still exist (by looking if the Grid UID is found in the DOM tree)\r\n                        const gridUid = this.sharedService.grid.getUID();\r\n                        if (this._areVisibleColumnDifferent && gridUid && $(`.${gridUid}`).length > 0) {\r\n                            if (this.sharedService.gridOptions && this.sharedService.gridOptions.enableAutoSizeColumns) {\r\n                                this.sharedService.grid.autosizeColumns();\r\n                            }\r\n                            this._areVisibleColumnDifferent = false;\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            return this._addon;\r\n        }\r\n        return null;\r\n    }\r\n    /** Refresh the dataset through the Backend Service */\r\n    refreshBackendDataset(gridOptions) {\r\n        // user can pass new set of grid options which will override current ones\r\n        if (gridOptions) {\r\n            this.sharedService.gridOptions = Object.assign({}, this.sharedService.gridOptions, gridOptions);\r\n        }\r\n        refreshBackendDataset(this.sharedService.gridOptions);\r\n    }\r\n    showGridMenu(e) {\r\n        this._addon.showGridMenu(e);\r\n    }\r\n    /** Translate the Grid Menu titles and column picker */\r\n    translateGridMenu() {\r\n        // update the properties by pointers, that is the only way to get Grid Menu Control to see the new values\r\n        // we also need to call the control init so that it takes the new Grid object with latest values\r\n        if (this.sharedService && this.sharedService.gridOptions && this.sharedService.gridOptions.gridMenu) {\r\n            this.sharedService.gridOptions.gridMenu.customItems = [];\r\n            this.emptyGridMenuTitles();\r\n            // merge original user grid menu items with internal items\r\n            // then sort all Grid Menu Custom Items (sorted by pointer, no need to use the return)\r\n            const originalCustomItems = this._userOriginalGridMenu && Array.isArray(this._userOriginalGridMenu.customItems) ? this._userOriginalGridMenu.customItems : [];\r\n            this.sharedService.gridOptions.gridMenu.customItems = [...originalCustomItems, ...this.addGridMenuCustomCommands(originalCustomItems)];\r\n            this.extensionUtility.translateItems(this.sharedService.gridOptions.gridMenu.customItems, 'titleKey', 'title');\r\n            this.extensionUtility.sortItems(this.sharedService.gridOptions.gridMenu.customItems, 'positionOrder');\r\n            this.sharedService.gridOptions.gridMenu.columnTitle = this.extensionUtility.getPickerTitleOutputString('columnTitle', 'gridMenu');\r\n            this.sharedService.gridOptions.gridMenu.forceFitTitle = this.extensionUtility.getPickerTitleOutputString('forceFitTitle', 'gridMenu');\r\n            this.sharedService.gridOptions.gridMenu.syncResizeTitle = this.extensionUtility.getPickerTitleOutputString('syncResizeTitle', 'gridMenu');\r\n            // translate all columns (including non-visible)\r\n            // eventually deprecate the \"headerKey\" and use only the \"nameKey\"\r\n            this.extensionUtility.translateItems(this.sharedService.allColumns, 'headerKey', 'name');\r\n            this.extensionUtility.translateItems(this.sharedService.allColumns, 'nameKey', 'name');\r\n            // update the Titles of each sections (command, customTitle, ...)\r\n            if (this._addon && this._addon.updateAllTitles) {\r\n                this._addon.updateAllTitles(this.sharedService.gridOptions.gridMenu);\r\n            }\r\n        }\r\n    }\r\n    // --\r\n    // private functions\r\n    // ------------------\r\n    /** Create Grid Menu with Custom Commands if user has enabled Filters and/or uses a Backend Service (OData, GraphQL) */\r\n    addGridMenuCustomCommands(originalCustomItems) {\r\n        const backendApi = this.sharedService.gridOptions.backendServiceApi || null;\r\n        const gridMenuCustomItems = [];\r\n        if (this.sharedService.gridOptions && (this.sharedService.gridOptions.enableFiltering && this.sharedService.gridOptions.showHeaderRow)) {\r\n            // show grid menu: Clear all Filters\r\n            if (this.sharedService.gridOptions && this.sharedService.gridOptions.gridMenu && !this.sharedService.gridOptions.gridMenu.hideClearAllFiltersCommand) {\r\n                const commandName = 'clear-filter';\r\n                if (!originalCustomItems.find((item) => item.hasOwnProperty('command') && item.command === commandName)) {\r\n                    gridMenuCustomItems.push({\r\n                        iconCssClass: this.sharedService.gridOptions.gridMenu.iconClearAllFiltersCommand || 'fa fa-filter text-danger',\r\n                        title: this.sharedService.gridOptions.enableTranslate ? this.translate.instant('CLEAR_ALL_FILTERS') : this._locales && this._locales.TEXT_CLEAR_ALL_FILTERS,\r\n                        disabled: false,\r\n                        command: commandName,\r\n                        positionOrder: 50\r\n                    });\r\n                }\r\n            }\r\n            // show grid menu: toggle filter row\r\n            if (this.sharedService.gridOptions && this.sharedService.gridOptions.gridMenu && !this.sharedService.gridOptions.gridMenu.hideToggleFilterCommand) {\r\n                const commandName = 'toggle-filter';\r\n                if (!originalCustomItems.find((item) => item.hasOwnProperty('command') && item.command === commandName)) {\r\n                    gridMenuCustomItems.push({\r\n                        iconCssClass: this.sharedService.gridOptions.gridMenu.iconToggleFilterCommand || 'fa fa-random',\r\n                        title: this.sharedService.gridOptions.enableTranslate ? this.translate.instant('TOGGLE_FILTER_ROW') : this._locales && this._locales.TEXT_TOGGLE_FILTER_ROW,\r\n                        disabled: false,\r\n                        command: commandName,\r\n                        positionOrder: 52\r\n                    });\r\n                }\r\n            }\r\n            // show grid menu: refresh dataset\r\n            if (this.sharedService.gridOptions && this.sharedService.gridOptions.gridMenu && !this.sharedService.gridOptions.gridMenu.hideRefreshDatasetCommand && backendApi) {\r\n                const commandName = 'refresh-dataset';\r\n                if (!originalCustomItems.find((item) => item.hasOwnProperty('command') && item.command === commandName)) {\r\n                    gridMenuCustomItems.push({\r\n                        iconCssClass: this.sharedService.gridOptions.gridMenu.iconRefreshDatasetCommand || 'fa fa-refresh',\r\n                        title: this.sharedService.gridOptions.enableTranslate ? this.translate.instant('REFRESH_DATASET') : this._locales && this._locales.TEXT_REFRESH_DATASET,\r\n                        disabled: false,\r\n                        command: commandName,\r\n                        positionOrder: 56\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        if (this.sharedService.gridOptions.showPreHeaderPanel) {\r\n            // show grid menu: toggle pre-header row\r\n            if (this.sharedService.gridOptions && this.sharedService.gridOptions.gridMenu && !this.sharedService.gridOptions.gridMenu.hideTogglePreHeaderCommand) {\r\n                const commandName = 'toggle-preheader';\r\n                if (!originalCustomItems.find((item) => item.hasOwnProperty('command') && item.command === commandName)) {\r\n                    gridMenuCustomItems.push({\r\n                        iconCssClass: this.sharedService.gridOptions.gridMenu.iconTogglePreHeaderCommand || 'fa fa-random',\r\n                        title: this.sharedService.gridOptions.enableTranslate ? this.translate.instant('TOGGLE_PRE_HEADER_ROW') : this._locales && this._locales.TEXT_TOGGLE_PRE_HEADER_ROW,\r\n                        disabled: false,\r\n                        command: commandName,\r\n                        positionOrder: 52\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        if (this.sharedService.gridOptions.enableSorting) {\r\n            // show grid menu: Clear all Sorting\r\n            if (this.sharedService.gridOptions && this.sharedService.gridOptions.gridMenu && !this.sharedService.gridOptions.gridMenu.hideClearAllSortingCommand) {\r\n                const commandName = 'clear-sorting';\r\n                if (!originalCustomItems.find((item) => item.hasOwnProperty('command') && item.command === commandName)) {\r\n                    gridMenuCustomItems.push({\r\n                        iconCssClass: this.sharedService.gridOptions.gridMenu.iconClearAllSortingCommand || 'fa fa-unsorted text-danger',\r\n                        title: this.sharedService.gridOptions.enableTranslate ? this.translate.instant('CLEAR_ALL_SORTING') : this._locales && this._locales.TEXT_CLEAR_ALL_SORTING,\r\n                        disabled: false,\r\n                        command: commandName,\r\n                        positionOrder: 51\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        // show grid menu: Export to file\r\n        if (this.sharedService.gridOptions && this.sharedService.gridOptions.enableExport && this.sharedService.gridOptions.gridMenu && !this.sharedService.gridOptions.gridMenu.hideExportCsvCommand) {\r\n            const commandName = 'export-csv';\r\n            if (!originalCustomItems.find((item) => item.hasOwnProperty('command') && item.command === commandName)) {\r\n                gridMenuCustomItems.push({\r\n                    iconCssClass: this.sharedService.gridOptions.gridMenu.iconExportCsvCommand || 'fa fa-download',\r\n                    title: this.sharedService.gridOptions.enableTranslate ? this.translate.instant('EXPORT_TO_CSV') : this._locales && this._locales.TEXT_EXPORT_TO_CSV,\r\n                    disabled: false,\r\n                    command: commandName,\r\n                    positionOrder: 53\r\n                });\r\n            }\r\n        }\r\n        // show grid menu: Export to Excel\r\n        if (this.sharedService.gridOptions && this.sharedService.gridOptions.enableExcelExport && this.sharedService.gridOptions.gridMenu && !this.sharedService.gridOptions.gridMenu.hideExportExcelCommand) {\r\n            const commandName = 'export-excel';\r\n            if (!originalCustomItems.find((item) => item.hasOwnProperty('command') && item.command === commandName)) {\r\n                gridMenuCustomItems.push({\r\n                    iconCssClass: this.sharedService.gridOptions.gridMenu.iconExportExcelCommand || 'fa fa-file-excel-o text-success',\r\n                    title: this.sharedService.gridOptions.enableTranslate ? this.translate.instant('EXPORT_TO_EXCEL') : this._locales && this._locales.TEXT_EXPORT_TO_EXCEL,\r\n                    disabled: false,\r\n                    command: commandName,\r\n                    positionOrder: 54\r\n                });\r\n            }\r\n        }\r\n        // show grid menu: export to text file as tab delimited\r\n        if (this.sharedService.gridOptions && this.sharedService.gridOptions.enableExport && this.sharedService.gridOptions.gridMenu && !this.sharedService.gridOptions.gridMenu.hideExportTextDelimitedCommand) {\r\n            const commandName = 'export-text-delimited';\r\n            if (!originalCustomItems.find((item) => item.hasOwnProperty('command') && item.command === commandName)) {\r\n                gridMenuCustomItems.push({\r\n                    iconCssClass: this.sharedService.gridOptions.gridMenu.iconExportTextDelimitedCommand || 'fa fa-download',\r\n                    title: this.sharedService.gridOptions.enableTranslate ? this.translate.instant('EXPORT_TO_TAB_DELIMITED') : this._locales && this._locales.TEXT_EXPORT_TO_TAB_DELIMITED,\r\n                    disabled: false,\r\n                    command: commandName,\r\n                    positionOrder: 55\r\n                });\r\n            }\r\n        }\r\n        // add the custom \"Commands\" title if there are any commands\r\n        if (this.sharedService && this.sharedService.gridOptions && this.sharedService.gridOptions.gridMenu && (Array.isArray(gridMenuCustomItems) && gridMenuCustomItems.length > 0 || (Array.isArray(this.sharedService.gridOptions.gridMenu.customItems) && this.sharedService.gridOptions.gridMenu.customItems.length > 0))) {\r\n            this.sharedService.gridOptions.gridMenu.customTitle = this.sharedService.gridOptions.gridMenu.customTitle || this.extensionUtility.getPickerTitleOutputString('customTitle', 'gridMenu');\r\n        }\r\n        return gridMenuCustomItems;\r\n    }\r\n    /**\r\n     * Execute the Grid Menu Custom command callback that was triggered by the onCommand subscribe\r\n     * These are the default internal custom commands\r\n     * @param event\r\n     * @param GridMenuItem args\r\n     */\r\n    executeGridMenuInternalCustomCommands(e, args) {\r\n        if (args && args.command) {\r\n            switch (args.command) {\r\n                case 'clear-filter':\r\n                    this.filterService.clearFilters();\r\n                    this.sharedService.dataView.refresh();\r\n                    break;\r\n                case 'clear-sorting':\r\n                    this.sortService.clearSorting();\r\n                    this.sharedService.dataView.refresh();\r\n                    break;\r\n                case 'export-csv':\r\n                    this.exportService.exportToFile({\r\n                        delimiter: DelimiterType.comma,\r\n                        filename: 'export',\r\n                        format: FileType.csv,\r\n                        useUtf8WithBom: true,\r\n                    });\r\n                    break;\r\n                case 'export-excel':\r\n                    this.excelExportService.exportToExcel({\r\n                        filename: 'export',\r\n                        format: FileType.xlsx,\r\n                    });\r\n                    break;\r\n                case 'export-text-delimited':\r\n                    this.exportService.exportToFile({\r\n                        delimiter: DelimiterType.tab,\r\n                        filename: 'export',\r\n                        format: FileType.txt,\r\n                        useUtf8WithBom: true,\r\n                    });\r\n                    break;\r\n                case 'toggle-filter':\r\n                    const showHeaderRow = this.sharedService && this.sharedService.gridOptions && this.sharedService.gridOptions.showHeaderRow || false;\r\n                    this.sharedService.grid.setHeaderRowVisibility(!showHeaderRow);\r\n                    break;\r\n                case 'toggle-toppanel':\r\n                    const showTopPanel = this.sharedService && this.sharedService.gridOptions && this.sharedService.gridOptions.showTopPanel || false;\r\n                    this.sharedService.grid.setTopPanelVisibility(!showTopPanel);\r\n                    break;\r\n                case 'toggle-preheader':\r\n                    const showPreHeaderPanel = this.sharedService && this.sharedService.gridOptions && this.sharedService.gridOptions.showPreHeaderPanel || false;\r\n                    this.sharedService.grid.setPreHeaderPanelVisibility(!showPreHeaderPanel);\r\n                    break;\r\n                case 'refresh-dataset':\r\n                    this.refreshBackendDataset();\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    emptyGridMenuTitles() {\r\n        if (this.sharedService && this.sharedService.gridOptions && this.sharedService.gridOptions.gridMenu) {\r\n            this.sharedService.gridOptions.gridMenu.customTitle = '';\r\n            this.sharedService.gridOptions.gridMenu.columnTitle = '';\r\n            this.sharedService.gridOptions.gridMenu.forceFitTitle = '';\r\n            this.sharedService.gridOptions.gridMenu.syncResizeTitle = '';\r\n        }\r\n    }\r\n    /** @return default Grid Menu options */\r\n    getDefaultGridMenuOptions() {\r\n        return {\r\n            customTitle: undefined,\r\n            columnTitle: this.extensionUtility.getPickerTitleOutputString('columnTitle', 'gridMenu'),\r\n            forceFitTitle: this.extensionUtility.getPickerTitleOutputString('forceFitTitle', 'gridMenu'),\r\n            syncResizeTitle: this.extensionUtility.getPickerTitleOutputString('syncResizeTitle', 'gridMenu'),\r\n            iconCssClass: 'fa fa-bars',\r\n            menuWidth: 18,\r\n            customItems: [],\r\n            hideClearAllFiltersCommand: false,\r\n            hideRefreshDatasetCommand: false,\r\n            hideToggleFilterCommand: false,\r\n        };\r\n    }\r\n};\r\nGridMenuExtension = __decorate([\r\n    Injectable(),\r\n    __param(6, Optional()),\r\n    __metadata(\"design:paramtypes\", [ExcelExportService,\r\n        ExportService,\r\n        ExtensionUtility,\r\n        FilterService,\r\n        SharedService,\r\n        SortService,\r\n        TranslateService])\r\n], GridMenuExtension);\n\nlet GroupItemMetaProviderExtension = class GroupItemMetaProviderExtension {\r\n    constructor(sharedService) {\r\n        this.sharedService = sharedService;\r\n    }\r\n    dispose() {\r\n        if (this._addon && this._addon.destroy) {\r\n            this._addon.destroy();\r\n        }\r\n    }\r\n    /** Get the instance of the SlickGrid addon (control or plugin). */\r\n    getAddonInstance() {\r\n        return this._addon;\r\n    }\r\n    /** register the group item metadata provider to add expand/collapse group handlers */\r\n    register() {\r\n        if (this.sharedService && this.sharedService.grid) {\r\n            this._addon = this.sharedService.groupItemMetadataProvider || {};\r\n            this.sharedService.grid.registerPlugin(this._addon);\r\n            return this._addon;\r\n        }\r\n        return null;\r\n    }\r\n};\r\nGroupItemMetaProviderExtension = __decorate([\r\n    Injectable(),\r\n    __metadata(\"design:paramtypes\", [SharedService])\r\n], GroupItemMetaProviderExtension);\n\nlet HeaderButtonExtension = class HeaderButtonExtension {\r\n    constructor(extensionUtility, sharedService) {\r\n        this.extensionUtility = extensionUtility;\r\n        this.sharedService = sharedService;\r\n        this._eventHandler = new Slick.EventHandler();\r\n    }\r\n    get eventHandler() {\r\n        return this._eventHandler;\r\n    }\r\n    dispose() {\r\n        // unsubscribe all SlickGrid events\r\n        this._eventHandler.unsubscribeAll();\r\n        if (this._addon && this._addon.destroy) {\r\n            this._addon.destroy();\r\n        }\r\n    }\r\n    /** Get the instance of the SlickGrid addon (control or plugin). */\r\n    getAddonInstance() {\r\n        return this._addon;\r\n    }\r\n    // Header Button Plugin\r\n    register() {\r\n        if (this.sharedService && this.sharedService.grid && this.sharedService.gridOptions) {\r\n            // dynamically import the SlickGrid plugin (addon) with RequireJS\r\n            this.extensionUtility.loadExtensionDynamically(ExtensionName.headerButton);\r\n            this._addon = new Slick.Plugins.HeaderButtons(this.sharedService.gridOptions.headerButton || {});\r\n            this.sharedService.grid.registerPlugin(this._addon);\r\n            // hook all events\r\n            if (this.sharedService.grid && this.sharedService.gridOptions.headerButton) {\r\n                if (this.sharedService.gridOptions.headerButton.onExtensionRegistered) {\r\n                    this.sharedService.gridOptions.headerButton.onExtensionRegistered(this._addon);\r\n                }\r\n                this._eventHandler.subscribe(this._addon.onCommand, (e, args) => {\r\n                    if (this.sharedService.gridOptions.headerButton && typeof this.sharedService.gridOptions.headerButton.onCommand === 'function') {\r\n                        this.sharedService.gridOptions.headerButton.onCommand(e, args);\r\n                    }\r\n                });\r\n            }\r\n            return this._addon;\r\n        }\r\n        return null;\r\n    }\r\n};\r\nHeaderButtonExtension = __decorate([\r\n    Injectable(),\r\n    __metadata(\"design:paramtypes\", [ExtensionUtility, SharedService])\r\n], HeaderButtonExtension);\n\nlet HeaderMenuExtension = class HeaderMenuExtension {\r\n    constructor(extensionUtility, filterService, sharedService, sortService, translate) {\r\n        this.extensionUtility = extensionUtility;\r\n        this.filterService = filterService;\r\n        this.sharedService = sharedService;\r\n        this.sortService = sortService;\r\n        this.translate = translate;\r\n        this._eventHandler = new Slick.EventHandler();\r\n    }\r\n    get eventHandler() {\r\n        return this._eventHandler;\r\n    }\r\n    dispose() {\r\n        // unsubscribe all SlickGrid events\r\n        this._eventHandler.unsubscribeAll();\r\n        if (this._addon && this._addon.destroy) {\r\n            this._addon.destroy();\r\n        }\r\n    }\r\n    /** Get the instance of the SlickGrid addon (control or plugin). */\r\n    getAddonInstance() {\r\n        return this._addon;\r\n    }\r\n    /**\r\n     * Create the Header Menu and expose all the available hooks that user can subscribe (onCommand, onBeforeMenuShow, ...)\r\n     * @param grid\r\n     * @param dataView\r\n     * @param columnDefinitions\r\n     */\r\n    register() {\r\n        if (this.sharedService.gridOptions && this.sharedService.gridOptions.enableTranslate && (!this.translate || !this.translate.instant)) {\r\n            throw new Error('[Angular-Slickgrid] requires \"ngx-translate\" to be installed and configured when the grid option \"enableTranslate\" is enabled.');\r\n        }\r\n        if (this.sharedService && this.sharedService.grid && this.sharedService.gridOptions) {\r\n            // get locales provided by user in forRoot or else use default English locales via the Constants\r\n            this._locales = this.sharedService.gridOptions && this.sharedService.gridOptions.locales || Constants.locales;\r\n            // dynamically import the SlickGrid plugin (addon) with RequireJS\r\n            this.extensionUtility.loadExtensionDynamically(ExtensionName.headerMenu);\r\n            this.sharedService.gridOptions.headerMenu = Object.assign({}, this.getDefaultHeaderMenuOptions(), this.sharedService.gridOptions.headerMenu);\r\n            if (this.sharedService.gridOptions.enableHeaderMenu) {\r\n                this.sharedService.gridOptions.headerMenu = this.addHeaderMenuCustomCommands(this.sharedService.gridOptions, this.sharedService.columnDefinitions);\r\n            }\r\n            this._addon = new Slick.Plugins.HeaderMenu(this.sharedService.gridOptions.headerMenu);\r\n            this.sharedService.grid.registerPlugin(this._addon);\r\n            // hook all events\r\n            if (this.sharedService.grid && this.sharedService.gridOptions.headerMenu) {\r\n                if (this.sharedService.gridOptions.headerMenu.onExtensionRegistered) {\r\n                    this.sharedService.gridOptions.headerMenu.onExtensionRegistered(this._addon);\r\n                }\r\n                this._eventHandler.subscribe(this._addon.onCommand, (e, args) => {\r\n                    this.executeHeaderMenuInternalCommands(e, args);\r\n                    if (this.sharedService.gridOptions.headerMenu && typeof this.sharedService.gridOptions.headerMenu.onCommand === 'function') {\r\n                        this.sharedService.gridOptions.headerMenu.onCommand(e, args);\r\n                    }\r\n                });\r\n                if (this.sharedService.gridOptions.headerMenu && typeof this.sharedService.gridOptions.headerMenu.onBeforeMenuShow === 'function') {\r\n                    this._eventHandler.subscribe(this._addon.onBeforeMenuShow, (e, args) => {\r\n                        this.sharedService.gridOptions.headerMenu.onBeforeMenuShow(e, args);\r\n                    });\r\n                }\r\n                if (this.sharedService.gridOptions.headerMenu && typeof this.sharedService.gridOptions.headerMenu.onAfterMenuShow === 'function') {\r\n                    this._eventHandler.subscribe(this._addon.onAfterMenuShow, (e, args) => {\r\n                        this.sharedService.gridOptions.headerMenu.onAfterMenuShow(e, args);\r\n                    });\r\n                }\r\n            }\r\n            return this._addon;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Create Header Menu with Custom Commands if user has enabled Header Menu\r\n     * @param options\r\n     * @param columnDefinitions\r\n     * @return header menu\r\n     */\r\n    addHeaderMenuCustomCommands(options, columnDefinitions) {\r\n        const headerMenuOptions = options.headerMenu || {};\r\n        if (columnDefinitions && Array.isArray(columnDefinitions) && options.enableHeaderMenu) {\r\n            columnDefinitions.forEach((columnDef) => {\r\n                if (columnDef && !columnDef.excludeFromHeaderMenu) {\r\n                    if (!columnDef.header || !columnDef.header.menu) {\r\n                        columnDef.header = {\r\n                            menu: {\r\n                                items: []\r\n                            }\r\n                        };\r\n                    }\r\n                    const columnHeaderMenuItems = columnDef && columnDef.header && columnDef.header.menu && columnDef.header.menu.items || [];\r\n                    // Sorting Commands\r\n                    if (options.enableSorting && columnDef.sortable && headerMenuOptions && !headerMenuOptions.hideSortCommands) {\r\n                        if (columnHeaderMenuItems.filter((item) => item.hasOwnProperty('command') && item.command === 'sort-asc').length === 0) {\r\n                            columnHeaderMenuItems.push({\r\n                                iconCssClass: headerMenuOptions.iconSortAscCommand || 'fa fa-sort-asc',\r\n                                title: options.enableTranslate ? this.translate.instant('SORT_ASCENDING') : this._locales && this._locales.TEXT_SORT_ASCENDING,\r\n                                command: 'sort-asc',\r\n                                positionOrder: 50\r\n                            });\r\n                        }\r\n                        if (columnHeaderMenuItems.filter((item) => item.hasOwnProperty('command') && item.command === 'sort-desc').length === 0) {\r\n                            columnHeaderMenuItems.push({\r\n                                iconCssClass: headerMenuOptions.iconSortDescCommand || 'fa fa-sort-desc',\r\n                                title: options.enableTranslate ? this.translate.instant('SORT_DESCENDING') : this._locales && this._locales.TEXT_SORT_DESCENDING,\r\n                                command: 'sort-desc',\r\n                                positionOrder: 51\r\n                            });\r\n                        }\r\n                        // add a divider (separator) between the top sort commands and the other clear commands\r\n                        if (columnHeaderMenuItems.filter((item) => item.hasOwnProperty('command') && item.positionOrder === 52).length === 0) {\r\n                            columnHeaderMenuItems.push({ divider: true, command: '', positionOrder: 52 });\r\n                        }\r\n                        if (!headerMenuOptions.hideClearSortCommand && columnHeaderMenuItems.filter((item) => item.hasOwnProperty('command') && item.command === 'clear-sort').length === 0) {\r\n                            columnHeaderMenuItems.push({\r\n                                iconCssClass: headerMenuOptions.iconClearSortCommand || 'fa fa-unsorted',\r\n                                title: options.enableTranslate ? this.translate.instant('REMOVE_SORT') : this._locales && this._locales.TEXT_REMOVE_SORT,\r\n                                command: 'clear-sort',\r\n                                positionOrder: 54\r\n                            });\r\n                        }\r\n                    }\r\n                    // Filtering Commands\r\n                    if (options.enableFiltering && columnDef.filterable && headerMenuOptions && !headerMenuOptions.hideFilterCommands) {\r\n                        if (!headerMenuOptions.hideClearFilterCommand && columnHeaderMenuItems.filter((item) => item.hasOwnProperty('command') && item.command === 'clear-filter').length === 0) {\r\n                            columnHeaderMenuItems.push({\r\n                                iconCssClass: headerMenuOptions.iconClearFilterCommand || 'fa fa-filter',\r\n                                title: options.enableTranslate ? this.translate.instant('REMOVE_FILTER') : this._locales && this._locales.TEXT_REMOVE_FILTER,\r\n                                command: 'clear-filter',\r\n                                positionOrder: 53\r\n                            });\r\n                        }\r\n                    }\r\n                    // Hide Column Command\r\n                    if (headerMenuOptions && !headerMenuOptions.hideColumnHideCommand && columnHeaderMenuItems.filter((item) => item.hasOwnProperty('command') && item.command === 'hide').length === 0) {\r\n                        columnHeaderMenuItems.push({\r\n                            iconCssClass: headerMenuOptions.iconColumnHideCommand || 'fa fa-times',\r\n                            title: options.enableTranslate ? this.translate.instant('HIDE_COLUMN') : this._locales && this._locales.TEXT_HIDE_COLUMN,\r\n                            command: 'hide',\r\n                            positionOrder: 55\r\n                        });\r\n                    }\r\n                    this.extensionUtility.translateItems(columnHeaderMenuItems, 'titleKey', 'title');\r\n                    this.extensionUtility.sortItems(columnHeaderMenuItems, 'positionOrder');\r\n                }\r\n            });\r\n        }\r\n        return headerMenuOptions;\r\n    }\r\n    /** Hide a column from the grid */\r\n    hideColumn(column) {\r\n        if (this.sharedService.grid && this.sharedService.grid.getColumns && this.sharedService.grid.setColumns && this.sharedService.grid.getColumnIndex) {\r\n            const columnIndex = this.sharedService.grid.getColumnIndex(column.id);\r\n            const currentColumns = this.sharedService.grid.getColumns();\r\n            const visibleColumns = this.extensionUtility.arrayRemoveItemByIndex(currentColumns, columnIndex);\r\n            this.sharedService.visibleColumns = visibleColumns;\r\n            this.sharedService.grid.setColumns(visibleColumns);\r\n            this.sharedService.onColumnsChanged.next(visibleColumns);\r\n        }\r\n    }\r\n    /**\r\n     * Translate the Header Menu titles, we need to loop through all column definition to re-translate them\r\n     */\r\n    translateHeaderMenu() {\r\n        if (this.sharedService.gridOptions && this.sharedService.gridOptions.headerMenu) {\r\n            this.resetHeaderMenuTranslations(this.sharedService.visibleColumns);\r\n        }\r\n    }\r\n    // --\r\n    // private functions\r\n    // ------------------\r\n    /** @return default Header Menu options */\r\n    getDefaultHeaderMenuOptions() {\r\n        return {\r\n            autoAlignOffset: 12,\r\n            minWidth: 140,\r\n            hideColumnHideCommand: false,\r\n            hideSortCommands: false,\r\n            title: ''\r\n        };\r\n    }\r\n    /**\r\n     * Reset all the internal Menu options which have text to translate\r\n     * @param header menu object\r\n     */\r\n    resetHeaderMenuTranslations(columnDefinitions) {\r\n        columnDefinitions.forEach((columnDef) => {\r\n            if (columnDef && columnDef.header && columnDef.header && columnDef.header.menu && columnDef.header.menu.items) {\r\n                if (!columnDef.excludeFromHeaderMenu) {\r\n                    const columnHeaderMenuItems = columnDef.header.menu.items || [];\r\n                    columnHeaderMenuItems.forEach((item) => {\r\n                        if (item.hasOwnProperty('command')) {\r\n                            switch (item.command) {\r\n                                case 'clear-filter':\r\n                                    item.title = this.translate.instant('REMOVE_FILTER') || this._locales && this._locales.TEXT_REMOVE_FILTER;\r\n                                    break;\r\n                                case 'clear-sort':\r\n                                    item.title = this.translate.instant('REMOVE_SORT') || this._locales && this._locales.TEXT_REMOVE_SORT;\r\n                                    break;\r\n                                case 'sort-asc':\r\n                                    item.title = this.translate.instant('SORT_ASCENDING') || this._locales && this._locales.TEXT_SORT_ASCENDING;\r\n                                    break;\r\n                                case 'sort-desc':\r\n                                    item.title = this.translate.instant('SORT_DESCENDING') || this._locales && this._locales.TEXT_SORT_DESCENDING;\r\n                                    break;\r\n                                case 'hide':\r\n                                    item.title = this.translate.instant('HIDE_COLUMN') || this._locales && this._locales.TEXT_HIDE_COLUMN;\r\n                                    break;\r\n                            }\r\n                        }\r\n                        // re-translate if there's a \"titleKey\"\r\n                        if (this.sharedService.gridOptions && this.sharedService.gridOptions.enableTranslate) {\r\n                            this.extensionUtility.translateItems(columnHeaderMenuItems, 'titleKey', 'title');\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /** Clear the Filter on the current column (if it's actually filtered) */\r\n    clearColumnFilter(event, args) {\r\n        if (args && args.column) {\r\n            this.filterService.clearFilterByColumnId(event, args.column.id);\r\n        }\r\n    }\r\n    /** Clear the Sort on the current column (if it's actually sorted) */\r\n    clearColumnSort(event, args) {\r\n        if (args && args.column && this.sharedService) {\r\n            // get current sorted columns, prior to calling the new column sort\r\n            const allSortedCols = this.sortService.getCurrentColumnSorts();\r\n            const sortedColsWithoutCurrent = this.sortService.getCurrentColumnSorts(args.column.id + '');\r\n            if (Array.isArray(allSortedCols) && Array.isArray(sortedColsWithoutCurrent) && allSortedCols.length !== sortedColsWithoutCurrent.length) {\r\n                if (this.sharedService.gridOptions && this.sharedService.gridOptions.backendServiceApi) {\r\n                    this.sortService.onBackendSortChanged(event, { multiColumnSort: true, sortCols: sortedColsWithoutCurrent, grid: this.sharedService.grid });\r\n                }\r\n                else if (this.sharedService.dataView) {\r\n                    this.sortService.onLocalSortChanged(this.sharedService.grid, this.sharedService.dataView, sortedColsWithoutCurrent, true);\r\n                }\r\n                else {\r\n                    // when using customDataView, we will simply send it as a onSort event with notify\r\n                    const isMultiSort = this.sharedService.gridOptions && this.sharedService.gridOptions.multiColumnSort || false;\r\n                    const sortOutput = isMultiSort ? sortedColsWithoutCurrent : sortedColsWithoutCurrent[0];\r\n                    args.grid.onSort.notify(sortOutput);\r\n                }\r\n                // update the this.sharedService.gridObj sortColumns array which will at the same add the visual sort icon(s) on the UI\r\n                const updatedSortColumns = sortedColsWithoutCurrent.map((col) => {\r\n                    return {\r\n                        columnId: col && col.sortCol && col.sortCol.id,\r\n                        sortAsc: col && col.sortAsc,\r\n                        sortCol: col && col.sortCol,\r\n                    };\r\n                });\r\n                this.sharedService.grid.setSortColumns(updatedSortColumns); // add sort icon in UI\r\n            }\r\n        }\r\n    }\r\n    /** Execute the Header Menu Commands that was triggered by the onCommand subscribe */\r\n    executeHeaderMenuInternalCommands(event, args) {\r\n        if (args && args.command) {\r\n            switch (args.command) {\r\n                case 'hide':\r\n                    this.hideColumn(args.column);\r\n                    if (this.sharedService.gridOptions && this.sharedService.gridOptions.enableAutoSizeColumns) {\r\n                        this.sharedService.grid.autosizeColumns();\r\n                    }\r\n                    break;\r\n                case 'clear-filter':\r\n                    this.clearColumnFilter(event, args);\r\n                    break;\r\n                case 'clear-sort':\r\n                    this.clearColumnSort(event, args);\r\n                    break;\r\n                case 'sort-asc':\r\n                case 'sort-desc':\r\n                    const isSortingAsc = (args.command === 'sort-asc');\r\n                    this.sortColumn(event, args, isSortingAsc);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    /** Sort the current column */\r\n    sortColumn(event, args, isSortingAsc = true) {\r\n        if (args && args.column) {\r\n            // get previously sorted columns\r\n            const sortedColsWithoutCurrent = this.sortService.getCurrentColumnSorts(args.column.id + '');\r\n            let emitterType;\r\n            // add to the column array, the column sorted by the header menu\r\n            sortedColsWithoutCurrent.push({ sortCol: args.column, sortAsc: isSortingAsc });\r\n            if (this.sharedService.gridOptions.backendServiceApi) {\r\n                this.sortService.onBackendSortChanged(event, { multiColumnSort: true, sortCols: sortedColsWithoutCurrent, grid: this.sharedService.grid });\r\n                emitterType = EmitterType.remote;\r\n            }\r\n            else if (this.sharedService.dataView) {\r\n                this.sortService.onLocalSortChanged(this.sharedService.grid, this.sharedService.dataView, sortedColsWithoutCurrent);\r\n                emitterType = EmitterType.local;\r\n            }\r\n            else {\r\n                // when using customDataView, we will simply send it as a onSort event with notify\r\n                const isMultiSort = this.sharedService && this.sharedService.gridOptions && this.sharedService.gridOptions.multiColumnSort || false;\r\n                const sortOutput = isMultiSort ? sortedColsWithoutCurrent : sortedColsWithoutCurrent[0];\r\n                args.grid.onSort.notify(sortOutput);\r\n            }\r\n            // update the this.sharedService.gridObj sortColumns array which will at the same add the visual sort icon(s) on the UI\r\n            const newSortColumns = sortedColsWithoutCurrent.map((col) => {\r\n                return {\r\n                    columnId: col && col.sortCol && col.sortCol.id,\r\n                    sortAsc: col && col.sortAsc,\r\n                    sortCol: col && col.sortCol,\r\n                };\r\n            });\r\n            // add sort icon in UI\r\n            this.sharedService.grid.setSortColumns(newSortColumns);\r\n            // if we have an emitter type set, we will emit a sort changed\r\n            // for the Grid State Service to see the change.\r\n            // We also need to pass current sorters changed to the emitSortChanged method\r\n            if (emitterType) {\r\n                const currentLocalSorters = [];\r\n                newSortColumns.forEach((sortCol) => {\r\n                    currentLocalSorters.push({\r\n                        columnId: sortCol.columnId + '',\r\n                        direction: sortCol.sortAsc ? 'ASC' : 'DESC'\r\n                    });\r\n                });\r\n                this.sortService.emitSortChanged(emitterType, currentLocalSorters);\r\n            }\r\n        }\r\n    }\r\n};\r\nHeaderMenuExtension = __decorate([\r\n    Injectable(),\r\n    __param(4, Optional()),\r\n    __metadata(\"design:paramtypes\", [ExtensionUtility,\r\n        FilterService,\r\n        SharedService,\r\n        SortService,\r\n        TranslateService])\r\n], HeaderMenuExtension);\n\nconst DOMPurify$1 = DOMPurify_; // patch to fix rollup to work\r\nconst ROW_DETAIL_CONTAINER_PREFIX = 'container_';\r\nconst PRELOAD_CONTAINER_PREFIX = 'container_loading';\r\nlet RowDetailViewExtension = class RowDetailViewExtension {\r\n    constructor(angularUtilService, appRef, extensionUtility, filterService, sharedService) {\r\n        this.angularUtilService = angularUtilService;\r\n        this.appRef = appRef;\r\n        this.extensionUtility = extensionUtility;\r\n        this.filterService = filterService;\r\n        this.sharedService = sharedService;\r\n        this._views = [];\r\n        this._subscriptions = [];\r\n        this._eventHandler = new Slick.EventHandler();\r\n    }\r\n    get datasetIdPropName() {\r\n        return this.gridOptions.datasetIdPropertyName || 'id';\r\n    }\r\n    get eventHandler() {\r\n        return this._eventHandler;\r\n    }\r\n    get gridOptions() {\r\n        return this.sharedService && this.sharedService.gridOptions || {};\r\n    }\r\n    get rowDetailViewOptions() {\r\n        return this.gridOptions.rowDetailView;\r\n    }\r\n    /** Dispose of the RowDetailView Extension */\r\n    dispose() {\r\n        // unsubscribe all SlickGrid events\r\n        this._eventHandler.unsubscribeAll();\r\n        if (this._addon && this._addon.destroy) {\r\n            this._addon.destroy();\r\n        }\r\n        // also unsubscribe all RxJS subscriptions\r\n        this._subscriptions = unsubscribeAllObservables(this._subscriptions);\r\n        this.disposeAllViewComponents();\r\n    }\r\n    /** Dispose of all the opened Row Detail Panels Angular View Components */\r\n    disposeAllViewComponents() {\r\n        this._views.forEach((compRef) => this.disposeViewComponent(compRef));\r\n        this._views = [];\r\n    }\r\n    /**\r\n     * Create the plugin before the Grid creation, else it will behave oddly.\r\n     * Mostly because the column definitions might change after the grid creation\r\n     */\r\n    create(columnDefinitions, gridOptions) {\r\n        if (columnDefinitions && gridOptions) {\r\n            // dynamically import the SlickGrid plugin (addon) with RequireJS\r\n            this.extensionUtility.loadExtensionDynamically(ExtensionName.rowDetailView);\r\n            if (!gridOptions.rowDetailView) {\r\n                throw new Error('The Row Detail View requires options to be passed via the \"rowDetailView\" property of the Grid Options');\r\n            }\r\n            if (gridOptions && gridOptions.rowDetailView) {\r\n                if (!this._addon) {\r\n                    if (typeof gridOptions.rowDetailView.process === 'function') {\r\n                        // we need to keep the user \"process\" method and replace it with our own execution method\r\n                        // we do this because when we get the item detail, we need to call \"onAsyncResponse.notify\" for the plugin to work\r\n                        this._userProcessFn = gridOptions.rowDetailView.process; // keep user's process method\r\n                        gridOptions.rowDetailView.process = (item) => this.onProcessing(item); // replace process method & run our internal one\r\n                    }\r\n                    else {\r\n                        throw new Error('You need to provide a \"process\" function for the Row Detail Extension to work properly');\r\n                    }\r\n                    // load the Preload & RowDetail Templates (could be straight HTML or Angular View/ViewModel)\r\n                    // when those are Angular View/ViewModel, we need to create View Component & provide the html containers to the Plugin (preTemplate/postTemplate methods)\r\n                    if (!gridOptions.rowDetailView.preTemplate) {\r\n                        this._preloadComponent = gridOptions && gridOptions.rowDetailView && gridOptions.rowDetailView.preloadComponent;\r\n                        gridOptions.rowDetailView.preTemplate = () => DOMPurify$1.sanitize(`<div class=\"${PRELOAD_CONTAINER_PREFIX}\"></div>`);\r\n                    }\r\n                    if (!gridOptions.rowDetailView.postTemplate) {\r\n                        this._viewComponent = gridOptions && gridOptions.rowDetailView && gridOptions.rowDetailView.viewComponent;\r\n                        gridOptions.rowDetailView.postTemplate = (itemDetail) => DOMPurify$1.sanitize(`<div class=\"${ROW_DETAIL_CONTAINER_PREFIX}${itemDetail[this.datasetIdPropName]}\"></div>`);\r\n                    }\r\n                    // finally register the Row Detail View Plugin\r\n                    this._addon = new Slick.Plugins.RowDetailView(gridOptions.rowDetailView);\r\n                }\r\n                const selectionColumn = this._addon.getColumnDefinition();\r\n                if (typeof selectionColumn === 'object') {\r\n                    selectionColumn.excludeFromExport = true;\r\n                    selectionColumn.excludeFromColumnPicker = true;\r\n                    selectionColumn.excludeFromGridMenu = true;\r\n                    selectionColumn.excludeFromQuery = true;\r\n                    selectionColumn.excludeFromHeaderMenu = true;\r\n                    columnDefinitions.unshift(selectionColumn);\r\n                }\r\n            }\r\n            return this._addon;\r\n        }\r\n        return null;\r\n    }\r\n    /** Get the instance of the SlickGrid addon (control or plugin). */\r\n    getAddonInstance() {\r\n        return this._addon;\r\n    }\r\n    register(rowSelectionPlugin) {\r\n        if (this.sharedService && this.sharedService.grid && this.sharedService.gridOptions) {\r\n            // the plugin has to be created BEFORE the grid (else it behaves oddly), but we can only watch grid events AFTER the grid is created\r\n            this.sharedService.grid.registerPlugin(this._addon);\r\n            // this also requires the Row Selection Model to be registered as well\r\n            if (!rowSelectionPlugin || !this.sharedService.grid.getSelectionModel()) {\r\n                this.extensionUtility.loadExtensionDynamically(ExtensionName.rowSelection);\r\n                rowSelectionPlugin = new Slick.RowSelectionModel(this.sharedService.gridOptions.rowSelectionOptions || { selectActiveRow: true });\r\n                this.sharedService.grid.setSelectionModel(rowSelectionPlugin);\r\n            }\r\n            // hook all events\r\n            if (this.sharedService.grid && this.rowDetailViewOptions) {\r\n                if (this.rowDetailViewOptions.onExtensionRegistered) {\r\n                    this.rowDetailViewOptions.onExtensionRegistered(this._addon);\r\n                }\r\n                this._eventHandler.subscribe(this._addon.onAsyncResponse, (e, args) => {\r\n                    if (this.rowDetailViewOptions && typeof this.rowDetailViewOptions.onAsyncResponse === 'function') {\r\n                        this.rowDetailViewOptions.onAsyncResponse(e, args);\r\n                    }\r\n                });\r\n                this._eventHandler.subscribe(this._addon.onAsyncEndUpdate, (e, args) => {\r\n                    // triggers after backend called \"onAsyncResponse.notify()\"\r\n                    this.renderViewModel(args && args.item);\r\n                    if (this.rowDetailViewOptions && typeof this.rowDetailViewOptions.onAsyncEndUpdate === 'function') {\r\n                        this.rowDetailViewOptions.onAsyncEndUpdate(e, args);\r\n                    }\r\n                });\r\n                this._eventHandler.subscribe(this._addon.onAfterRowDetailToggle, (e, args) => {\r\n                    // display preload template & re-render all the other Detail Views after toggling\r\n                    // the preload View will eventually go away once the data gets loaded after the \"onAsyncEndUpdate\" event\r\n                    this.renderPreloadView();\r\n                    this.renderAllViewComponents();\r\n                    if (this.rowDetailViewOptions && typeof this.rowDetailViewOptions.onAfterRowDetailToggle === 'function') {\r\n                        this.rowDetailViewOptions.onAfterRowDetailToggle(e, args);\r\n                    }\r\n                });\r\n                this._eventHandler.subscribe(this._addon.onBeforeRowDetailToggle, (e, args) => {\r\n                    // before toggling row detail, we need to create View Component if it doesn't exist\r\n                    this.onBeforeRowDetailToggle(e, args);\r\n                    if (this.rowDetailViewOptions && typeof this.rowDetailViewOptions.onBeforeRowDetailToggle === 'function') {\r\n                        this.rowDetailViewOptions.onBeforeRowDetailToggle(e, args);\r\n                    }\r\n                });\r\n                this._eventHandler.subscribe(this._addon.onRowBackToViewportRange, (e, args) => {\r\n                    // when row is back to viewport range, we will re-render the View Component(s)\r\n                    this.onRowBackToViewportRange(e, args);\r\n                    if (this.rowDetailViewOptions && typeof this.rowDetailViewOptions.onRowBackToViewportRange === 'function') {\r\n                        this.rowDetailViewOptions.onRowBackToViewportRange(e, args);\r\n                    }\r\n                });\r\n                this._eventHandler.subscribe(this._addon.onRowOutOfViewportRange, (e, args) => {\r\n                    if (this.rowDetailViewOptions && typeof this.rowDetailViewOptions.onRowOutOfViewportRange === 'function') {\r\n                        this.rowDetailViewOptions.onRowOutOfViewportRange(e, args);\r\n                    }\r\n                });\r\n                // --\r\n                // hook some events needed by the Plugin itself\r\n                this._eventHandler.subscribe(this.sharedService.grid.onColumnsReordered, () => this.redrawAllViewComponents());\r\n                // on sort, all row detail are collapsed so we can dispose of all the Views as well\r\n                this._eventHandler.subscribe(this.sharedService.grid.onSort, () => this.disposeAllViewComponents());\r\n                // on filter changed, we need to re-render all Views\r\n                this._subscriptions.push(this.filterService.onFilterChanged.subscribe(() => this.redrawAllViewComponents()));\r\n            }\r\n            return this._addon;\r\n        }\r\n        return null;\r\n    }\r\n    /** Redraw (re-render) all the expanded row detail View Components */\r\n    redrawAllViewComponents() {\r\n        this._views.forEach((compRef) => {\r\n            this.redrawViewComponent(compRef);\r\n        });\r\n    }\r\n    /** Render all the expanded row detail View Components */\r\n    renderAllViewComponents() {\r\n        this._views.forEach((view) => {\r\n            if (view && view.dataContext) {\r\n                this.renderViewModel(view.dataContext);\r\n            }\r\n        });\r\n    }\r\n    /** Redraw the necessary View Component */\r\n    redrawViewComponent(createdView) {\r\n        const containerElements = document.getElementsByClassName(`${ROW_DETAIL_CONTAINER_PREFIX}${createdView[this.datasetIdPropName]}`);\r\n        if (containerElements && containerElements.length) {\r\n            this.renderViewModel(createdView.dataContext);\r\n        }\r\n    }\r\n    /** Render (or rerender) the View Component (Row Detail) */\r\n    renderPreloadView() {\r\n        const containerElements = document.getElementsByClassName(`${PRELOAD_CONTAINER_PREFIX}`);\r\n        if (containerElements && containerElements.length) {\r\n            this.angularUtilService.createAngularComponentAppendToDom(this._preloadComponent, containerElements[0], true);\r\n        }\r\n    }\r\n    /** Render (or rerender) the View Component (Row Detail) */\r\n    renderViewModel(item) {\r\n        const containerElements = document.getElementsByClassName(`${ROW_DETAIL_CONTAINER_PREFIX}${item[this.datasetIdPropName]}`);\r\n        if (containerElements && containerElements.length) {\r\n            const componentOutput = this.angularUtilService.createAngularComponentAppendToDom(this._viewComponent, containerElements[0], true);\r\n            if (componentOutput && componentOutput.componentRef && componentOutput.componentRef.instance) {\r\n                // pass a few properties to the Row Detail template component\r\n                Object.assign(componentOutput.componentRef.instance, {\r\n                    model: item,\r\n                    addon: this._addon,\r\n                    grid: this.sharedService.grid,\r\n                    dataView: this.sharedService.dataView,\r\n                    parent: this.rowDetailViewOptions && this.rowDetailViewOptions.parent,\r\n                });\r\n                const viewObj = this._views.find((obj) => obj[this.datasetIdPropName] === item[this.datasetIdPropName]);\r\n                if (viewObj) {\r\n                    viewObj.componentRef = componentOutput.componentRef;\r\n                }\r\n                return viewObj;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    // --\r\n    // private functions\r\n    // ------------------\r\n    disposeViewComponent(expandedView) {\r\n        const compRef = expandedView && expandedView.componentRef;\r\n        if (compRef) {\r\n            this.appRef.detachView(compRef.hostView);\r\n            compRef.destroy();\r\n            return expandedView;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * notify the onAsyncResponse with the \"args.item\" (required property)\r\n     * the plugin will then use item to populate the row detail panel with the \"postTemplate\"\r\n     * @param item\r\n     */\r\n    notifyTemplate(item) {\r\n        if (this._addon) {\r\n            this._addon.onAsyncResponse.notify({ item }, undefined, this);\r\n        }\r\n    }\r\n    /**\r\n     * On Processing, we will notify the plugin with the new item detail once backend server call completes\r\n     * @param item\r\n     */\r\n    onProcessing(item) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (item && typeof this._userProcessFn === 'function') {\r\n                let awaitedItemDetail;\r\n                const userProcessFn = this._userProcessFn(item);\r\n                // wait for the \"userProcessFn\", once resolved we will save it into the \"collection\"\r\n                const response = yield userProcessFn;\r\n                if (response.hasOwnProperty(this.datasetIdPropName)) {\r\n                    awaitedItemDetail = response; // from Promise\r\n                }\r\n                else if (response && response instanceof Observable || response instanceof Promise) {\r\n                    awaitedItemDetail = yield castToPromise(response); // from Angular-http-client\r\n                }\r\n                if (!awaitedItemDetail || !awaitedItemDetail.hasOwnProperty(this.datasetIdPropName)) {\r\n                    throw new Error(`[Angular-Slickgrid] could not process the Row Detail, you must make sure that your \"process\" callback\r\n          (a Promise or an HttpClient call returning an Observable) returns an item object that has an \"${this.datasetIdPropName}\" property`);\r\n                }\r\n                // notify the plugin with the new item details\r\n                this.notifyTemplate(awaitedItemDetail || {});\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Just before the row get expanded or collapsed we will do the following\r\n     * First determine if the row is expanding or collapsing,\r\n     * if it's expanding we will add it to our View Components reference array if we don't already have it\r\n     * or if it's collapsing we will remove it from our View Components reference array\r\n     */\r\n    onBeforeRowDetailToggle(e, args) {\r\n        // expanding\r\n        if (args && args.item && args.item.__collapsed) {\r\n            // expanding row detail\r\n            const viewInfo = {\r\n                id: args.item[this.datasetIdPropName],\r\n                dataContext: args.item\r\n            };\r\n            addToArrayWhenNotExists(this._views, viewInfo);\r\n        }\r\n        else {\r\n            // collapsing, so dispose of the View/Component\r\n            const foundViewIndex = this._views.findIndex((view) => view[this.datasetIdPropName] === args.item[this.datasetIdPropName]);\r\n            if (foundViewIndex >= 0 && this._views.hasOwnProperty(foundViewIndex)) {\r\n                const compRef = this._views[foundViewIndex].componentRef;\r\n                this.appRef.detachView(compRef.hostView);\r\n                compRef.destroy();\r\n                this._views.splice(foundViewIndex, 1);\r\n            }\r\n        }\r\n    }\r\n    /** When Row comes back to Viewport Range, we need to redraw the View */\r\n    onRowBackToViewportRange(e, args) {\r\n        if (args && args.item) {\r\n            this._views.forEach((view) => {\r\n                if (view[this.datasetIdPropName] === args.item[this.datasetIdPropName]) {\r\n                    this.redrawViewComponent(view);\r\n                }\r\n            });\r\n        }\r\n    }\r\n};\r\nRowDetailViewExtension = __decorate([\r\n    Injectable(),\r\n    __metadata(\"design:paramtypes\", [AngularUtilService,\r\n        ApplicationRef,\r\n        ExtensionUtility,\r\n        FilterService,\r\n        SharedService])\r\n], RowDetailViewExtension);\n\nlet RowMoveManagerExtension = class RowMoveManagerExtension {\r\n    constructor(extensionUtility, sharedService) {\r\n        this.extensionUtility = extensionUtility;\r\n        this.sharedService = sharedService;\r\n        this._eventHandler = new Slick.EventHandler();\r\n    }\r\n    get eventHandler() {\r\n        return this._eventHandler;\r\n    }\r\n    dispose() {\r\n        // unsubscribe all SlickGrid events\r\n        this._eventHandler.unsubscribeAll();\r\n        if (this._addon && this._addon.destroy) {\r\n            this._addon.destroy();\r\n        }\r\n    }\r\n    /** Get the instance of the SlickGrid addon (control or plugin). */\r\n    getAddonInstance() {\r\n        return this._addon;\r\n    }\r\n    register(rowSelectionPlugin) {\r\n        if (this.sharedService && this.sharedService.grid && this.sharedService.gridOptions) {\r\n            // dynamically import the SlickGrid plugin (addon) with RequireJS\r\n            this.extensionUtility.loadExtensionDynamically(ExtensionName.rowMoveManager);\r\n            // this also requires the Row Selection Model to be registered as well\r\n            if (!rowSelectionPlugin || !this.sharedService.grid.getSelectionModel()) {\r\n                this.extensionUtility.loadExtensionDynamically(ExtensionName.rowSelection);\r\n                rowSelectionPlugin = new Slick.RowSelectionModel(this.sharedService.gridOptions.rowSelectionOptions || {});\r\n                this.sharedService.grid.setSelectionModel(rowSelectionPlugin);\r\n            }\r\n            this._addon = new Slick.RowMoveManager(this.sharedService.gridOptions.rowMoveManager || { cancelEditOnDrag: true });\r\n            this.sharedService.grid.registerPlugin(this._addon);\r\n            // hook all events\r\n            if (this.sharedService.grid && this.sharedService.gridOptions.rowMoveManager) {\r\n                if (this.sharedService.gridOptions.rowMoveManager.onExtensionRegistered) {\r\n                    this.sharedService.gridOptions.rowMoveManager.onExtensionRegistered(this._addon);\r\n                }\r\n                this._eventHandler.subscribe(this._addon.onBeforeMoveRows, (e, args) => {\r\n                    if (this.sharedService.gridOptions.rowMoveManager && typeof this.sharedService.gridOptions.rowMoveManager.onBeforeMoveRows === 'function') {\r\n                        this.sharedService.gridOptions.rowMoveManager.onBeforeMoveRows(e, args);\r\n                    }\r\n                });\r\n                this._eventHandler.subscribe(this._addon.onMoveRows, (e, args) => {\r\n                    if (this.sharedService.gridOptions.rowMoveManager && typeof this.sharedService.gridOptions.rowMoveManager.onMoveRows === 'function') {\r\n                        this.sharedService.gridOptions.rowMoveManager.onMoveRows(e, args);\r\n                    }\r\n                });\r\n            }\r\n            return this._addon;\r\n        }\r\n        return null;\r\n    }\r\n};\r\nRowMoveManagerExtension = __decorate([\r\n    Injectable(),\r\n    __metadata(\"design:paramtypes\", [ExtensionUtility, SharedService])\r\n], RowMoveManagerExtension);\n\nlet RowSelectionExtension = class RowSelectionExtension {\r\n    constructor(extensionUtility, sharedService) {\r\n        this.extensionUtility = extensionUtility;\r\n        this.sharedService = sharedService;\r\n    }\r\n    dispose() {\r\n        if (this._addon && this._addon.destroy) {\r\n            this._addon.destroy();\r\n        }\r\n    }\r\n    /** Get the instance of the SlickGrid addon (control or plugin). */\r\n    getAddonInstance() {\r\n        return this._addon;\r\n    }\r\n    register() {\r\n        if (this.sharedService && this.sharedService.grid && this.sharedService.gridOptions) {\r\n            // dynamically import the SlickGrid plugin (addon) with RequireJS\r\n            this.extensionUtility.loadExtensionDynamically(ExtensionName.rowSelection);\r\n            this._addon = new Slick.RowSelectionModel(this.sharedService.gridOptions.rowSelectionOptions || {});\r\n            this.sharedService.grid.setSelectionModel(this._addon);\r\n            return this._addon;\r\n        }\r\n        return null;\r\n    }\r\n};\r\nRowSelectionExtension = __decorate([\r\n    Injectable(),\r\n    __metadata(\"design:paramtypes\", [ExtensionUtility, SharedService])\r\n], RowSelectionExtension);\n\nlet ExtensionService = class ExtensionService {\r\n    constructor(autoTooltipExtension, cellExternalCopyExtension, cellMenuExtension, checkboxSelectorExtension, columnPickerExtension, contextMenuExtension, draggableGroupingExtension, gridMenuExtension, groupItemMetaExtension, headerButtonExtension, headerMenuExtension, rowDetailViewExtension, rowMoveManagerExtension, rowSelectionExtension, sharedService, translate) {\r\n        this.autoTooltipExtension = autoTooltipExtension;\r\n        this.cellExternalCopyExtension = cellExternalCopyExtension;\r\n        this.cellMenuExtension = cellMenuExtension;\r\n        this.checkboxSelectorExtension = checkboxSelectorExtension;\r\n        this.columnPickerExtension = columnPickerExtension;\r\n        this.contextMenuExtension = contextMenuExtension;\r\n        this.draggableGroupingExtension = draggableGroupingExtension;\r\n        this.gridMenuExtension = gridMenuExtension;\r\n        this.groupItemMetaExtension = groupItemMetaExtension;\r\n        this.headerButtonExtension = headerButtonExtension;\r\n        this.headerMenuExtension = headerMenuExtension;\r\n        this.rowDetailViewExtension = rowDetailViewExtension;\r\n        this.rowMoveManagerExtension = rowMoveManagerExtension;\r\n        this.rowSelectionExtension = rowSelectionExtension;\r\n        this.sharedService = sharedService;\r\n        this.translate = translate;\r\n        this._extensionCreatedList = [];\r\n        this._extensionList = [];\r\n    }\r\n    /** Dispose of all the controls & plugins */\r\n    dispose() {\r\n        this.sharedService.grid = null;\r\n        this.sharedService.visibleColumns = [];\r\n        // dispose of each control/plugin & reset the list\r\n        this._extensionList.forEach((item) => {\r\n            if (item && item.class && item.class.dispose) {\r\n                item.class.dispose();\r\n            }\r\n        });\r\n        this._extensionList = [];\r\n    }\r\n    /** Get all columns (includes visible and non-visible) */\r\n    getAllColumns() {\r\n        return this.sharedService.allColumns || [];\r\n    }\r\n    /** Get only visible columns */\r\n    getVisibleColumns() {\r\n        return this.sharedService.visibleColumns || [];\r\n    }\r\n    /** Get all Extensions */\r\n    getAllExtensions() {\r\n        return this._extensionList;\r\n    }\r\n    /**\r\n     * Get an Extension by it's name\r\n     *  @param name\r\n     */\r\n    getExtensionByName(name) {\r\n        return Array.isArray(this._extensionList) && this._extensionList.find((p) => p.name === name);\r\n    }\r\n    /**\r\n     * Get the instance of the SlickGrid addon (control or plugin).\r\n     * This is the raw addon coming directly from SlickGrid itself, not to confuse with Angular-Slickgrid extension\r\n     *  @param name\r\n     */\r\n    getSlickgridAddonInstance(name) {\r\n        const extension = this.getExtensionByName(name);\r\n        if (extension && extension.class && (extension.instance || extension.addon)) {\r\n            if (extension.class && extension.class.getAddonInstance) {\r\n                return extension.class.getAddonInstance();\r\n            }\r\n            return extension.instance;\r\n        }\r\n        return null;\r\n    }\r\n    /** Auto-resize all the column in the grid to fit the grid width */\r\n    autoResizeColumns() {\r\n        this.sharedService.grid.autosizeColumns();\r\n    }\r\n    /** Bind/Create different Controls or Plugins after the Grid is created */\r\n    bindDifferentExtensions() {\r\n        if (this.sharedService && this.sharedService.gridOptions) {\r\n            // make sure all columns are translated before creating ColumnPicker/GridMenu Controls\r\n            // this is to avoid having hidden columns not being translated on first load\r\n            if (this.sharedService.gridOptions.enableTranslate) {\r\n                // eventually deprecate the \"headerKey\" and use only the \"nameKey\"\r\n                this.translateItems(this.sharedService.allColumns, 'headerKey', 'name');\r\n                this.translateItems(this.sharedService.allColumns, 'nameKey', 'name');\r\n            }\r\n            // Auto Tooltip Plugin\r\n            if (this.sharedService.gridOptions.enableAutoTooltip) {\r\n                if (this.autoTooltipExtension && this.autoTooltipExtension.register) {\r\n                    const instance = this.autoTooltipExtension.register();\r\n                    this._extensionList.push({ name: ExtensionName.autoTooltip, class: this.autoTooltipExtension, addon: instance, instance });\r\n                }\r\n            }\r\n            // Cell External Copy Manager Plugin (Excel Like)\r\n            if (this.sharedService.gridOptions.enableExcelCopyBuffer) {\r\n                if (this.cellExternalCopyExtension && this.cellExternalCopyExtension.register) {\r\n                    const instance = this.cellExternalCopyExtension.register();\r\n                    this._extensionList.push({ name: ExtensionName.cellExternalCopyManager, class: this.cellExternalCopyExtension, addon: instance, instance });\r\n                }\r\n            }\r\n            // (Action) Cell Menu Plugin\r\n            if (this.sharedService.gridOptions.enableCellMenu) {\r\n                if (this.cellMenuExtension && this.cellMenuExtension.register) {\r\n                    const instance = this.cellMenuExtension.register();\r\n                    this._extensionList.push({ name: ExtensionName.cellMenu, class: this.cellMenuExtension, addon: instance, instance });\r\n                }\r\n            }\r\n            // Row Selection Plugin\r\n            // this extension should be registered BEFORE the Checkbox Selector & Row Detail since it can be use by these 2 plugins\r\n            if (!this.getExtensionByName(ExtensionName.rowSelection) && (this.sharedService.gridOptions.enableRowSelection || this.sharedService.gridOptions.enableCheckboxSelector || this.sharedService.gridOptions.enableRowDetailView)) {\r\n                if (this.rowSelectionExtension && this.rowSelectionExtension.register) {\r\n                    const instance = this.rowSelectionExtension.register();\r\n                    this._extensionList.push({ name: ExtensionName.rowSelection, class: this.rowSelectionExtension, addon: instance, instance });\r\n                }\r\n            }\r\n            // Checkbox Selector Plugin\r\n            if (this.sharedService.gridOptions.enableCheckboxSelector) {\r\n                if (this.checkboxSelectorExtension && this.checkboxSelectorExtension.register) {\r\n                    const rowSelectionExtension = this.getExtensionByName(ExtensionName.rowSelection);\r\n                    this.checkboxSelectorExtension.register(rowSelectionExtension);\r\n                    const createdExtension = this.getCreatedExtensionByName(ExtensionName.checkboxSelector); // get the instance from when it was really created earlier\r\n                    const instance = createdExtension && createdExtension.instance;\r\n                    this._extensionList.push({ name: ExtensionName.checkboxSelector, class: this.checkboxSelectorExtension, addon: instance, instance });\r\n                }\r\n            }\r\n            // Column Picker Control\r\n            if (this.sharedService.gridOptions.enableColumnPicker) {\r\n                if (this.columnPickerExtension && this.columnPickerExtension.register) {\r\n                    const instance = this.columnPickerExtension.register();\r\n                    this._extensionList.push({ name: ExtensionName.columnPicker, class: this.columnPickerExtension, addon: instance, instance });\r\n                }\r\n            }\r\n            // Context Menu Control\r\n            if (this.sharedService.gridOptions.enableContextMenu) {\r\n                if (this.contextMenuExtension && this.contextMenuExtension.register) {\r\n                    const instance = this.contextMenuExtension.register();\r\n                    this._extensionList.push({ name: ExtensionName.contextMenu, class: this.contextMenuExtension, addon: instance, instance });\r\n                }\r\n            }\r\n            // Draggable Grouping Plugin\r\n            if (this.sharedService.gridOptions.enableDraggableGrouping) {\r\n                if (this.draggableGroupingExtension && this.draggableGroupingExtension.register) {\r\n                    const instance = this.draggableGroupingExtension.register();\r\n                    this._extensionList.push({ name: ExtensionName.draggableGrouping, class: this.draggableGroupingExtension, addon: instance, instance });\r\n                }\r\n            }\r\n            // Grid Menu Control\r\n            if (this.sharedService.gridOptions.enableGridMenu) {\r\n                if (this.gridMenuExtension && this.gridMenuExtension.register) {\r\n                    const instance = this.gridMenuExtension.register();\r\n                    this._extensionList.push({ name: ExtensionName.gridMenu, class: this.gridMenuExtension, addon: instance, instance });\r\n                }\r\n            }\r\n            // Grouping Plugin\r\n            // register the group item metadata provider to add expand/collapse group handlers\r\n            if (this.sharedService.gridOptions.enableDraggableGrouping || this.sharedService.gridOptions.enableGrouping) {\r\n                if (this.groupItemMetaExtension && this.groupItemMetaExtension.register) {\r\n                    const instance = this.groupItemMetaExtension.register();\r\n                    this._extensionList.push({ name: ExtensionName.groupItemMetaProvider, class: this.groupItemMetaExtension, addon: instance, instance });\r\n                }\r\n            }\r\n            // Header Button Plugin\r\n            if (this.sharedService.gridOptions.enableHeaderButton) {\r\n                if (this.headerButtonExtension && this.headerButtonExtension.register) {\r\n                    const instance = this.headerButtonExtension.register();\r\n                    this._extensionList.push({ name: ExtensionName.headerButton, class: this.headerButtonExtension, addon: instance, instance });\r\n                }\r\n            }\r\n            // Header Menu Plugin\r\n            if (this.sharedService.gridOptions.enableHeaderMenu) {\r\n                if (this.headerMenuExtension && this.headerMenuExtension.register) {\r\n                    const instance = this.headerMenuExtension.register();\r\n                    this._extensionList.push({ name: ExtensionName.headerMenu, class: this.headerMenuExtension, addon: instance, instance });\r\n                }\r\n            }\r\n            // Row Detail View Plugin\r\n            if (this.sharedService.gridOptions.enableRowDetailView) {\r\n                if (this.rowDetailViewExtension && this.rowDetailViewExtension.register) {\r\n                    const rowSelectionExtension = this.getExtensionByName(ExtensionName.rowSelection);\r\n                    this.rowDetailViewExtension.register(rowSelectionExtension);\r\n                    const createdExtension = this.getCreatedExtensionByName(ExtensionName.rowDetailView); // get the plugin from when it was really created earlier\r\n                    const instance = createdExtension && createdExtension.instance;\r\n                    this._extensionList.push({ name: ExtensionName.rowDetailView, class: this.rowDetailViewExtension, addon: instance, instance });\r\n                }\r\n            }\r\n            // Row Move Manager Plugin\r\n            if (this.sharedService.gridOptions.enableRowMoveManager) {\r\n                if (this.rowMoveManagerExtension && this.rowMoveManagerExtension.register) {\r\n                    const instance = this.rowMoveManagerExtension.register();\r\n                    this._extensionList.push({ name: ExtensionName.rowMoveManager, class: this.rowMoveManagerExtension, addon: instance, instance });\r\n                }\r\n            }\r\n            // manually register other plugins\r\n            if (this.sharedService.gridOptions.registerPlugins !== undefined) {\r\n                if (Array.isArray(this.sharedService.gridOptions.registerPlugins)) {\r\n                    this.sharedService.gridOptions.registerPlugins.forEach((plugin) => {\r\n                        const instance = this.sharedService.grid.registerPlugin(plugin);\r\n                        this._extensionList.push({ name: ExtensionName.noname, class: null, addon: instance, instance });\r\n                    });\r\n                }\r\n                else {\r\n                    this.sharedService.grid.registerPlugin(this.sharedService.gridOptions.registerPlugins);\r\n                    const plugin = this.sharedService.gridOptions.registerPlugins;\r\n                    const instance = this.sharedService.grid.registerPlugin(plugin);\r\n                    this._extensionList.push({ name: ExtensionName.noname, class: null, addon: instance, instance });\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Bind/Create certain plugins before the Grid creation, else they might behave oddly.\r\n     * Mostly because the column definitions might change after the grid creation\r\n     * @param columnDefinitions\r\n     * @param options\r\n     */\r\n    createExtensionsBeforeGridCreation(columnDefinitions, options) {\r\n        if (options.enableCheckboxSelector) {\r\n            if (!this.getCreatedExtensionByName(ExtensionName.checkboxSelector)) {\r\n                const checkboxInstance = this.checkboxSelectorExtension.create(columnDefinitions, options);\r\n                this._extensionCreatedList.push({ name: ExtensionName.checkboxSelector, instance: checkboxInstance });\r\n            }\r\n        }\r\n        if (options.enableRowDetailView) {\r\n            if (!this.getCreatedExtensionByName(ExtensionName.rowDetailView)) {\r\n                const rowDetailInstance = this.rowDetailViewExtension.create(columnDefinitions, options);\r\n                this._extensionCreatedList.push({ name: ExtensionName.rowDetailView, instance: rowDetailInstance });\r\n            }\r\n        }\r\n        if (options.enableDraggableGrouping) {\r\n            if (!this.getCreatedExtensionByName(ExtensionName.rowDetailView)) {\r\n                const draggableInstance = this.draggableGroupingExtension.create(options);\r\n                options.enableColumnReorder = draggableInstance.getSetupColumnReorder;\r\n                this._extensionCreatedList.push({ name: ExtensionName.draggableGrouping, instance: draggableInstance });\r\n            }\r\n        }\r\n    }\r\n    /** Hide a column from the grid */\r\n    hideColumn(column) {\r\n        if (this.sharedService && this.sharedService.grid && this.sharedService.grid.getColumns && this.sharedService.grid.setColumns) {\r\n            const columnIndex = this.sharedService.grid.getColumnIndex(column.id);\r\n            this.sharedService.visibleColumns = this.removeColumnByIndex(this.sharedService.grid.getColumns(), columnIndex);\r\n            this.sharedService.grid.setColumns(this.sharedService.visibleColumns);\r\n        }\r\n    }\r\n    /** Refresh the dataset through the Backend Service */\r\n    refreshBackendDataset(gridOptions) {\r\n        this.gridMenuExtension.refreshBackendDataset(gridOptions);\r\n    }\r\n    /**\r\n     * Remove a column from the grid by it's index in the grid\r\n     * @param columns input\r\n     * @param index\r\n     */\r\n    removeColumnByIndex(columns, index) {\r\n        if (Array.isArray(columns)) {\r\n            return columns.filter((el, i) => index !== i);\r\n        }\r\n        return columns;\r\n    }\r\n    /** Translate the Cell Menu titles, we need to loop through all column definition to re-translate them */\r\n    translateCellMenu() {\r\n        if (this.cellMenuExtension && this.cellMenuExtension.translateCellMenu) {\r\n            this.cellMenuExtension.translateCellMenu();\r\n        }\r\n    }\r\n    /** Translate the Column Picker and it's last 2 checkboxes */\r\n    translateColumnPicker() {\r\n        if (this.columnPickerExtension && this.columnPickerExtension.translateColumnPicker) {\r\n            this.columnPickerExtension.translateColumnPicker();\r\n        }\r\n    }\r\n    /** Translate the Context Menu titles, we need to loop through all column definition to re-translate them */\r\n    translateContextMenu() {\r\n        if (this.contextMenuExtension && this.contextMenuExtension.translateContextMenu) {\r\n            this.contextMenuExtension.translateContextMenu();\r\n        }\r\n    }\r\n    /**\r\n     * Translate the Header Menu titles, we need to loop through all column definition to re-translate them\r\n     */\r\n    translateGridMenu() {\r\n        if (this.gridMenuExtension && this.gridMenuExtension.translateGridMenu) {\r\n            this.gridMenuExtension.translateGridMenu();\r\n        }\r\n    }\r\n    /**\r\n     * Translate the Header Menu titles, we need to loop through all column definition to re-translate them\r\n     */\r\n    translateHeaderMenu() {\r\n        if (this.headerMenuExtension && this.headerMenuExtension.translateHeaderMenu) {\r\n            this.headerMenuExtension.translateHeaderMenu();\r\n        }\r\n    }\r\n    /**\r\n     * Translate manually the header titles.\r\n     * We could optionally pass a locale (that will change currently loaded locale), else it will use current locale\r\n     * @param locale to use\r\n     * @param new column definitions (optional)\r\n     */\r\n    translateColumnHeaders(locale, newColumnDefinitions) {\r\n        if (this.sharedService && this.sharedService.gridOptions && this.sharedService.gridOptions.enableTranslate && (!this.translate || !this.translate.instant)) {\r\n            throw new Error('[Angular-Slickgrid] requires \"ngx-translate\" to be installed and configured when the grid option \"enableTranslate\" is enabled.');\r\n        }\r\n        if (locale) {\r\n            this.translate.use(locale);\r\n        }\r\n        let columnDefinitions = newColumnDefinitions;\r\n        if (!columnDefinitions) {\r\n            columnDefinitions = this.sharedService.columnDefinitions;\r\n        }\r\n        // eventually deprecate the \"headerKey\" and use only the \"nameKey\"\r\n        this.translateItems(columnDefinitions, 'headerKey', 'name');\r\n        this.translateItems(this.sharedService.allColumns, 'headerKey', 'name');\r\n        this.translateItems(columnDefinitions, 'nameKey', 'name');\r\n        this.translateItems(this.sharedService.allColumns, 'nameKey', 'name');\r\n        // re-render the column headers\r\n        this.renderColumnHeaders(columnDefinitions);\r\n        this.gridMenuExtension.translateGridMenu();\r\n    }\r\n    /**\r\n     * Render (or re-render) the column headers from column definitions.\r\n     * calling setColumns() will trigger a grid re-render\r\n     */\r\n    renderColumnHeaders(newColumnDefinitions) {\r\n        let collection = newColumnDefinitions;\r\n        if (!collection) {\r\n            collection = this.sharedService.columnDefinitions;\r\n        }\r\n        if (Array.isArray(collection) && this.sharedService.grid && this.sharedService.grid.setColumns) {\r\n            if (collection.length > this.sharedService.allColumns.length) {\r\n                this.sharedService.allColumns = collection;\r\n            }\r\n            this.sharedService.grid.setColumns(collection);\r\n        }\r\n        // dispose of previous Column Picker instance, then re-register it and don't forget to overwrite previous instance ref\r\n        if (this.sharedService.gridOptions.enableColumnPicker) {\r\n            this.columnPickerExtension.dispose();\r\n            const instance = this.columnPickerExtension.register();\r\n            const extension = this.getExtensionByName(ExtensionName.columnPicker);\r\n            if (extension) {\r\n                extension.addon = instance;\r\n                extension.instance = instance;\r\n            }\r\n        }\r\n        // dispose of previous Grid Menu instance, then re-register it and don't forget to overwrite previous instance ref\r\n        if (this.sharedService.gridOptions.enableGridMenu) {\r\n            this.gridMenuExtension.dispose();\r\n            const instance = this.gridMenuExtension.register();\r\n            const extension = this.getExtensionByName(ExtensionName.gridMenu);\r\n            if (extension) {\r\n                extension.addon = instance;\r\n                extension.instance = instance;\r\n            }\r\n        }\r\n    }\r\n    //\r\n    // private functions\r\n    // -------------------\r\n    /**\r\n     * Get an Extension that was created by calling its \"create\" method (there are only 3 extensions which uses this method)\r\n     *  @param name\r\n     */\r\n    getCreatedExtensionByName(name) {\r\n        return Array.isArray(this._extensionCreatedList) && this._extensionCreatedList.find((p) => p.name === name);\r\n    }\r\n    /** Translate an array of items from an input key and assign translated value to the output key */\r\n    translateItems(items, inputKey, outputKey) {\r\n        if (this.sharedService.gridOptions && this.sharedService.gridOptions.enableTranslate && (!this.translate || !this.translate.instant)) {\r\n            throw new Error('[Angular-Slickgrid] requires \"ngx-translate\" to be installed and configured when the grid option \"enableTranslate\" is enabled.');\r\n        }\r\n        if (Array.isArray(items)) {\r\n            for (const item of items) {\r\n                if (item[inputKey]) {\r\n                    item[outputKey] = this.translate && this.translate.currentLang && this.translate.instant(item[inputKey]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\nExtensionService = __decorate([\r\n    Injectable(),\r\n    __param(15, Optional()),\r\n    __metadata(\"design:paramtypes\", [AutoTooltipExtension,\r\n        CellExternalCopyManagerExtension,\r\n        CellMenuExtension,\r\n        CheckboxSelectorExtension,\r\n        ColumnPickerExtension,\r\n        ContextMenuExtension,\r\n        DraggableGroupingExtension,\r\n        GridMenuExtension,\r\n        GroupItemMetaProviderExtension,\r\n        HeaderButtonExtension,\r\n        HeaderMenuExtension,\r\n        RowDetailViewExtension,\r\n        RowMoveManagerExtension,\r\n        RowSelectionExtension,\r\n        SharedService,\r\n        TranslateService])\r\n], ExtensionService);\n\n/**\r\n * This GraphqlQueryBuilder class is a lib that already exist\r\n * but was causing issues with TypeScript, RequireJS and other bundler/packagers\r\n * and so I rewrote it in pure TypeScript.\r\n *\r\n * The previous lib can be viewed here at this Github\r\n * https://github.com/codemeasandwich/graphql-query-builder\r\n */\r\nclass GraphqlQueryBuilder {\r\n    /* Constructor, query/mutator you wish to use, and an alias or filter arguments. */\r\n    constructor(queryFnName, aliasOrFilter) {\r\n        this.queryFnName = queryFnName;\r\n        this.head = [];\r\n        if (typeof aliasOrFilter === 'string') {\r\n            this.alias = aliasOrFilter;\r\n        }\r\n        else if (typeof aliasOrFilter === 'object') {\r\n            this.filter(aliasOrFilter);\r\n        }\r\n        else if (aliasOrFilter === undefined && arguments.length === 2) {\r\n            throw new TypeError(`You have passed undefined as Second argument to \"Query\"`);\r\n        }\r\n        else if (aliasOrFilter !== undefined) {\r\n            throw new TypeError(`Second argument to \"Query\" should be an alias name(String) or filter arguments(Object). What was passed is: ${aliasOrFilter}`);\r\n        }\r\n    }\r\n    /**\r\n     * The parameters to run the query against.\r\n     * @param filters An object mapping attribute to values\r\n     */\r\n    filter(filters) {\r\n        for (const prop of Object.keys(filters)) {\r\n            if (typeof filters[prop] === 'function') {\r\n                continue;\r\n            }\r\n            const val = this.getGraphQLValue(filters[prop]);\r\n            if (val === '{}') {\r\n                continue;\r\n            }\r\n            this.head.push(`${prop}:${val}`);\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Outlines the properties you wish to be returned from the query.\r\n     * @param properties representing each attribute you want Returned\r\n     */\r\n    find(...searches) {\r\n        if (!searches || !Array.isArray(searches) || searches.length === 0) {\r\n            throw new TypeError(`find value can not be >>falsy<<`);\r\n        }\r\n        // if its a string.. it may have other values\r\n        // else it sould be an Object or Array of maped values\r\n        const searchKeys = (searches.length === 1 && Array.isArray(searches[0])) ? searches[0] : searches;\r\n        this.body = this.parceFind(searchKeys);\r\n        return this;\r\n    }\r\n    /**\r\n     * set an alias for this result.\r\n     * @param alias\r\n     */\r\n    setAlias(alias) {\r\n        this.alias = alias;\r\n    }\r\n    /**\r\n     * Return to the formatted query string\r\n     * @return\r\n     */\r\n    toString() {\r\n        if (this.body === undefined) {\r\n            throw new ReferenceError(`return properties are not defined. use the 'find' function to defined them`);\r\n        }\r\n        return `${(this.alias) ? (this.alias + ':') : ''} ${this.queryFnName} ${(this.head.length > 0) ? '(' + this.head.join(',') + ')' : ''}  { ${this.body} }`;\r\n    }\r\n    // --\r\n    // PRIVATE FUNCTIONS\r\n    // -----------------\r\n    parceFind(_levelA) {\r\n        const propsA = _levelA.map((currentValue, index) => {\r\n            const itemX = _levelA[index];\r\n            if (itemX instanceof GraphqlQueryBuilder) {\r\n                return itemX.toString();\r\n            }\r\n            else if (!Array.isArray(itemX) && typeof itemX === 'object') {\r\n                const propsAA = Object.keys(itemX);\r\n                if (1 !== propsAA.length) {\r\n                    throw new RangeError(`Alias objects should only have one value. was passed: ${JSON.stringify(itemX)}`);\r\n                }\r\n                const propS = propsAA[0];\r\n                const item = itemX[propS];\r\n                if (Array.isArray(item)) {\r\n                    return new GraphqlQueryBuilder(propS).find(item);\r\n                }\r\n                return `${propS} : ${item} `;\r\n            }\r\n            else if (typeof itemX === 'string') {\r\n                return itemX;\r\n            }\r\n            else {\r\n                throw new RangeError(`cannot handle Find value of ${itemX}`);\r\n            }\r\n        });\r\n        return propsA.join(',');\r\n    }\r\n    getGraphQLValue(value) {\r\n        if (typeof value === 'string') {\r\n            value = JSON.stringify(value);\r\n        }\r\n        else if (Array.isArray(value)) {\r\n            value = value.map(item => {\r\n                return this.getGraphQLValue(item);\r\n            }).join();\r\n            value = `[${value}]`;\r\n        }\r\n        else if (value instanceof Date) {\r\n            value = JSON.stringify(value);\r\n        }\r\n        else if (value !== null && typeof value === 'object') {\r\n            value = this.objectToString(value);\r\n        }\r\n        return value;\r\n    }\r\n    objectToString(obj) {\r\n        const sourceA = [];\r\n        for (const prop of Object.keys(obj)) {\r\n            if (typeof obj[prop] === 'function') {\r\n                continue;\r\n            }\r\n            sourceA.push(`${prop}:${this.getGraphQLValue(obj[prop])}`);\r\n        }\r\n        return `{${sourceA.join()}}`;\r\n    }\r\n}\n\nconst DEFAULT_ITEMS_PER_PAGE = 25;\r\nconst DEFAULT_PAGE_SIZE = 20;\r\nclass GraphqlService {\r\n    constructor() {\r\n        this._currentFilters = [];\r\n        this._currentSorters = [];\r\n        this._datasetIdPropName = 'id';\r\n        this.defaultPaginationOptions = {\r\n            first: DEFAULT_ITEMS_PER_PAGE,\r\n            offset: 0\r\n        };\r\n    }\r\n    /** Getter for the Column Definitions */\r\n    get columnDefinitions() {\r\n        return this._columnDefinitions;\r\n    }\r\n    /** Getter for the Grid Options pulled through the Grid Object */\r\n    get _gridOptions() {\r\n        return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};\r\n    }\r\n    /** Initialization of the service, which acts as a constructor */\r\n    init(serviceOptions, pagination, grid) {\r\n        this._grid = grid;\r\n        this.options = serviceOptions || { datasetName: '', columnDefinitions: [] };\r\n        this.pagination = pagination;\r\n        this._datasetIdPropName = this._gridOptions.datasetIdPropertyName || 'id';\r\n        if (grid && grid.getColumns) {\r\n            this._columnDefinitions = (serviceOptions && serviceOptions.columnDefinitions) || grid.getColumns();\r\n        }\r\n    }\r\n    /**\r\n     * Build the GraphQL query, since the service include/exclude cursor, the output query will be different.\r\n     * @param serviceOptions GraphqlServiceOption\r\n     */\r\n    buildQuery() {\r\n        if (!this.options || !this.options.datasetName || (!this._columnDefinitions && !Array.isArray(this.options.columnDefinitions))) {\r\n            throw new Error('GraphQL Service requires the \"datasetName\" property to properly build the GraphQL query');\r\n        }\r\n        // get the column definitions and exclude some if they were tagged as excluded\r\n        let columnDefinitions = this._columnDefinitions || this.options.columnDefinitions;\r\n        columnDefinitions = columnDefinitions.filter((column) => !column.excludeFromQuery);\r\n        const queryQb = new GraphqlQueryBuilder('query');\r\n        const datasetQb = new GraphqlQueryBuilder(this.options.datasetName);\r\n        const nodesQb = new GraphqlQueryBuilder('nodes');\r\n        // get all the columnds Ids for the filters to work\r\n        const columnIds = [];\r\n        if (columnDefinitions && Array.isArray(columnDefinitions)) {\r\n            for (const column of columnDefinitions) {\r\n                columnIds.push(column.field);\r\n                // if extra \"fields\" are passed, also push them to columnIds\r\n                if (column.fields) {\r\n                    columnIds.push(...column.fields);\r\n                }\r\n            }\r\n        }\r\n        // Slickgrid also requires the \"id\" (or the dataset defined unique ide) field to be part of DataView\r\n        // add it to the GraphQL query if it wasn't already part of the list\r\n        if (columnIds.indexOf(this._datasetIdPropName) === -1) {\r\n            columnIds.unshift(this._datasetIdPropName);\r\n        }\r\n        const columnsQuery = this.buildFilterQuery(columnIds);\r\n        let graphqlNodeFields = [];\r\n        if (this._gridOptions.enablePagination !== false) {\r\n            if (this.options.isWithCursor) {\r\n                // ...pageInfo { hasNextPage, endCursor }, edges { cursor, node { _columns_ } }, totalCount: 100\r\n                const edgesQb = new GraphqlQueryBuilder('edges');\r\n                const pageInfoQb = new GraphqlQueryBuilder('pageInfo');\r\n                pageInfoQb.find('hasNextPage', 'hasPreviousPage', 'endCursor', 'startCursor');\r\n                nodesQb.find(columnsQuery);\r\n                edgesQb.find(['cursor']);\r\n                graphqlNodeFields = ['totalCount', nodesQb, pageInfoQb, edgesQb];\r\n            }\r\n            else {\r\n                // ...nodes { _columns_ }, totalCount: 100\r\n                nodesQb.find(columnsQuery);\r\n                graphqlNodeFields = ['totalCount', nodesQb];\r\n            }\r\n            // all properties to be returned by the query\r\n            datasetQb.find(graphqlNodeFields);\r\n        }\r\n        else {\r\n            // include all columns to be returned\r\n            datasetQb.find(columnsQuery);\r\n        }\r\n        // add dataset filters, could be Pagination and SortingFilters and/or FieldFilters\r\n        let datasetFilters = {};\r\n        // only add pagination if it's enabled in the grid options\r\n        if (this._gridOptions.enablePagination !== false) {\r\n            datasetFilters = Object.assign({}, this.options.paginationOptions, { first: ((this.options.paginationOptions && this.options.paginationOptions.first) ? this.options.paginationOptions.first : ((this.pagination && this.pagination.pageSize) ? this.pagination.pageSize : null)) || this.defaultPaginationOptions.first });\r\n            if (!this.options.isWithCursor) {\r\n                datasetFilters.offset = ((this.options.paginationOptions && this.options.paginationOptions.hasOwnProperty('offset')) ? +this.options.paginationOptions['offset'] : 0);\r\n            }\r\n        }\r\n        if (this.options.sortingOptions && Array.isArray(this.options.sortingOptions) && this.options.sortingOptions.length > 0) {\r\n            // orderBy: [{ field:x, direction: 'ASC' }]\r\n            datasetFilters.orderBy = this.options.sortingOptions;\r\n        }\r\n        if (this.options.filteringOptions && Array.isArray(this.options.filteringOptions) && this.options.filteringOptions.length > 0) {\r\n            // filterBy: [{ field: date, operator: '>', value: '2000-10-10' }]\r\n            datasetFilters.filterBy = this.options.filteringOptions;\r\n        }\r\n        if (this.options.addLocaleIntoQuery) {\r\n            // first: 20, ... locale: \"en-CA\"\r\n            datasetFilters.locale = this._gridOptions && this._gridOptions.i18n && this._gridOptions.i18n.currentLang || this._gridOptions.locale || 'en';\r\n        }\r\n        if (this.options.extraQueryArguments) {\r\n            // first: 20, ... userId: 123\r\n            for (const queryArgument of this.options.extraQueryArguments) {\r\n                datasetFilters[queryArgument.field] = queryArgument.value;\r\n            }\r\n        }\r\n        // with pagination:: query { users(first: 20, offset: 0, orderBy: [], filterBy: []) { totalCount: 100, nodes: { _columns_ }}}\r\n        // without pagination:: query { users(orderBy: [], filterBy: []) { _columns_ }}\r\n        datasetQb.filter(datasetFilters);\r\n        queryQb.find(datasetQb);\r\n        const enumSearchProperties = ['direction:', 'field:', 'operator:'];\r\n        return this.trimDoubleQuotesOnEnumField(queryQb.toString(), enumSearchProperties, this.options.keepArgumentFieldDoubleQuotes || false);\r\n    }\r\n    /**\r\n     * From an input array of strings, we want to build a GraphQL query string.\r\n     * The process has to take the dot notation and parse it into a valid GraphQL query\r\n     * Following this SO answer https://stackoverflow.com/a/47705476/1212166\r\n     *\r\n     * INPUT\r\n     *  ['firstName', 'lastName', 'billing.address.street', 'billing.address.zip']\r\n     * OUTPUT\r\n     * firstName, lastName, billing{address{street, zip}}\r\n     * @param inputArray\r\n     */\r\n    buildFilterQuery(inputArray) {\r\n        const set = (o = {}, a) => {\r\n            const k = a.shift();\r\n            o[k] = a.length ? set(o[k], a) : null;\r\n            return o;\r\n        };\r\n        const output = inputArray.reduce((o, a) => set(o, a.split('.')), {});\r\n        return JSON.stringify(output)\r\n            .replace(/\\\"|\\:|null/g, '')\r\n            .replace(/^\\{/, '')\r\n            .replace(/\\}$/, '');\r\n    }\r\n    clearFilters() {\r\n        this._currentFilters = [];\r\n        this.updateOptions({ filteringOptions: [] });\r\n    }\r\n    clearSorters() {\r\n        this._currentSorters = [];\r\n        this.updateOptions({ sortingOptions: [] });\r\n    }\r\n    /**\r\n     * Get an initialization of Pagination options\r\n     * @return Pagination Options\r\n     */\r\n    getInitPaginationOptions() {\r\n        const paginationFirst = this.pagination ? this.pagination.pageSize : DEFAULT_ITEMS_PER_PAGE;\r\n        return (this.options && this.options.isWithCursor) ? { first: paginationFirst } : { first: paginationFirst, offset: 0 };\r\n    }\r\n    /** Get the GraphQL dataset name */\r\n    getDatasetName() {\r\n        return this.options.datasetName || '';\r\n    }\r\n    /** Get the Filters that are currently used by the grid */\r\n    getCurrentFilters() {\r\n        return this._currentFilters;\r\n    }\r\n    /** Get the Pagination that is currently used by the grid */\r\n    getCurrentPagination() {\r\n        return this._currentPagination;\r\n    }\r\n    /** Get the Sorters that are currently used by the grid */\r\n    getCurrentSorters() {\r\n        return this._currentSorters;\r\n    }\r\n    /*\r\n     * Reset the pagination options\r\n     */\r\n    resetPaginationOptions() {\r\n        let paginationOptions;\r\n        if (this.options && this.options.isWithCursor) {\r\n            // first, last, after, before\r\n            paginationOptions = {\r\n                after: '',\r\n                before: undefined,\r\n                last: undefined\r\n            };\r\n        }\r\n        else {\r\n            // first, last, offset\r\n            paginationOptions = ((this.options && this.options.paginationOptions) || this.getInitPaginationOptions());\r\n            paginationOptions.offset = 0;\r\n        }\r\n        // save current pagination as Page 1 and page size as \"first\" set size\r\n        this._currentPagination = {\r\n            pageNumber: 1,\r\n            pageSize: paginationOptions.first || DEFAULT_PAGE_SIZE,\r\n        };\r\n        this.updateOptions({ paginationOptions });\r\n    }\r\n    updateOptions(serviceOptions) {\r\n        this.options = Object.assign({}, this.options, serviceOptions);\r\n    }\r\n    /*\r\n     * FILTERING\r\n     */\r\n    processOnFilterChanged(event, args) {\r\n        const gridOptions = this._gridOptions;\r\n        const backendApi = gridOptions.backendServiceApi;\r\n        if (backendApi === undefined) {\r\n            throw new Error('Something went wrong in the GraphqlService, \"backendServiceApi\" is not initialized');\r\n        }\r\n        // keep current filters & always save it as an array (columnFilters can be an object when it is dealt by SlickGrid Filter)\r\n        this._currentFilters = this.castFilterToColumnFilters(args.columnFilters);\r\n        if (!args || !args.grid) {\r\n            throw new Error('Something went wrong when trying create the GraphQL Backend Service, it seems that \"args\" is not populated correctly');\r\n        }\r\n        // loop through all columns to inspect filters & set the query\r\n        this.updateFilters(args.columnFilters, false);\r\n        this.resetPaginationOptions();\r\n        return this.buildQuery();\r\n    }\r\n    /*\r\n     * PAGINATION\r\n     * With cursor, the query can have 4 arguments (first, after, last, before), for example:\r\n     *   users (first:20, after:\"YXJyYXljb25uZWN0aW9uOjM=\") {\r\n     *     totalCount\r\n     *     pageInfo {\r\n     *       hasNextPage\r\n     *       hasPreviousPage\r\n     *       endCursor\r\n     *       startCursor\r\n     *     }\r\n     *     edges {\r\n     *       cursor\r\n     *       node {\r\n     *         name\r\n     *         gender\r\n     *       }\r\n     *     }\r\n     *   }\r\n     * Without cursor, the query can have 3 arguments (first, last, offset), for example:\r\n     *   users (first:20, offset: 10) {\r\n     *     totalCount\r\n     *     nodes {\r\n     *       name\r\n     *       gender\r\n     *     }\r\n     *   }\r\n     */\r\n    processOnPaginationChanged(event, args) {\r\n        const pageSize = +(args.pageSize || ((this.pagination) ? this.pagination.pageSize : DEFAULT_PAGE_SIZE));\r\n        this.updatePagination(args.newPage, pageSize);\r\n        // build the GraphQL query which we will use in the WebAPI callback\r\n        return this.buildQuery();\r\n    }\r\n    /*\r\n     * SORTING\r\n     * we will use sorting as per a Facebook suggestion on a Github issue (with some small changes)\r\n     * https://github.com/graphql/graphql-relay-js/issues/20#issuecomment-220494222\r\n     *\r\n     *  users (first: 20, offset: 10, orderBy: [{field: lastName, direction: ASC}, {field: firstName, direction: DESC}]) {\r\n     *    totalCount\r\n     *    nodes {\r\n     *      name\r\n     *      gender\r\n     *    }\r\n     *  }\r\n     */\r\n    // @deprecated note, we should remove \"SortChangedArgs\" and only use: ColumnSort | MultiColumnSort\r\n    processOnSortChanged(event, args) {\r\n        const sortColumns = (args.multiColumnSort) ? args.sortCols : new Array({ sortCol: args.sortCol, sortAsc: args.sortAsc });\r\n        // loop through all columns to inspect sorters & set the query\r\n        this.updateSorters(sortColumns);\r\n        // build the GraphQL query which we will use in the WebAPI callback\r\n        return this.buildQuery();\r\n    }\r\n    /**\r\n     * loop through all columns to inspect filters & update backend service filteringOptions\r\n     * @param columnFilters\r\n     */\r\n    updateFilters(columnFilters, isUpdatedByPresetOrDynamically) {\r\n        const searchByArray = [];\r\n        let searchValue;\r\n        // on filter preset load, we need to keep current filters\r\n        if (isUpdatedByPresetOrDynamically) {\r\n            this._currentFilters = this.castFilterToColumnFilters(columnFilters);\r\n        }\r\n        for (const columnId in columnFilters) {\r\n            if (columnFilters.hasOwnProperty(columnId)) {\r\n                const columnFilter = columnFilters[columnId];\r\n                // if user defined some \"presets\", then we need to find the filters from the column definitions instead\r\n                let columnDef;\r\n                if (isUpdatedByPresetOrDynamically && Array.isArray(this._columnDefinitions)) {\r\n                    columnDef = this._columnDefinitions.find((column) => column.id === columnFilter.columnId);\r\n                }\r\n                else {\r\n                    columnDef = columnFilter.columnDef;\r\n                }\r\n                if (!columnDef) {\r\n                    throw new Error('[GraphQL Service]: Something went wrong in trying to get the column definition of the specified filter (or preset filters). Did you make a typo on the filter columnId?');\r\n                }\r\n                const fieldName = columnDef.queryFieldFilter || columnDef.queryField || columnDef.field || columnDef.name || '';\r\n                let searchTerms = columnFilter && columnFilter.searchTerms || [];\r\n                let fieldSearchValue = (Array.isArray(searchTerms) && searchTerms.length === 1) ? searchTerms[0] : '';\r\n                if (typeof fieldSearchValue === 'undefined') {\r\n                    fieldSearchValue = '';\r\n                }\r\n                if (!fieldName) {\r\n                    throw new Error(`GraphQL filter could not find the field name to query the search, your column definition must include a valid \"field\" or \"name\" (optionally you can also use the \"queryfield\" or \"queryFieldFilter\").`);\r\n                }\r\n                fieldSearchValue = '' + fieldSearchValue; // make sure it's a string\r\n                const matches = fieldSearchValue.match(/^([<>!=\\*]{0,2})(.*[^<>!=\\*])([\\*]?)$/); // group 1: Operator, 2: searchValue, 3: last char is '*' (meaning starts with, ex.: abc*)\r\n                let operator = columnFilter.operator || ((matches) ? matches[1] : '');\r\n                searchValue = (!!matches) ? matches[2] : '';\r\n                const lastValueChar = (!!matches) ? matches[3] : (operator === '*z' ? '*' : '');\r\n                // no need to query if search value is empty\r\n                if (fieldName && searchValue === '' && searchTerms.length === 0) {\r\n                    continue;\r\n                }\r\n                if (Array.isArray(searchTerms) && searchTerms.length === 1 && typeof searchTerms[0] === 'string' && searchTerms[0].indexOf('..') > 0) {\r\n                    searchTerms = searchTerms[0].split('..');\r\n                    if (!operator) {\r\n                        operator = OperatorType.rangeExclusive;\r\n                    }\r\n                }\r\n                if (typeof searchValue === 'string') {\r\n                    // escaping the search value\r\n                    searchValue = searchValue.replace(`'`, `''`); // escape single quotes by doubling them\r\n                    if (operator === '*' || operator === 'a*' || operator === '*z' || lastValueChar === '*') {\r\n                        operator = ((operator === '*' || operator === '*z') ? 'EndsWith' : 'StartsWith');\r\n                    }\r\n                }\r\n                // if we didn't find an Operator but we have a Column Operator inside the Filter (DOM Element), we should use its default Operator\r\n                // multipleSelect is \"IN\", while singleSelect is \"EQ\", else don't map any operator\r\n                if (!operator && columnDef.filter) {\r\n                    operator = columnDef.filter.operator;\r\n                }\r\n                // when having more than 1 search term (we need to create a CSV string for GraphQL \"IN\" or \"NOT IN\" filter search)\r\n                if (searchTerms && searchTerms.length > 1 && (operator === 'IN' || operator === 'NIN' || operator === 'NOTIN' || operator === 'NOT IN' || operator === 'NOT_IN')) {\r\n                    searchValue = searchTerms.join(',');\r\n                }\r\n                else if (searchTerms && searchTerms.length === 2 && (!operator || operator === OperatorType.rangeExclusive || operator === OperatorType.rangeInclusive)) {\r\n                    if (!operator) {\r\n                        operator = OperatorType.rangeExclusive;\r\n                    }\r\n                    searchByArray.push({ field: fieldName, operator: (operator === OperatorType.rangeInclusive ? 'GE' : 'GT'), value: searchTerms[0] });\r\n                    searchByArray.push({ field: fieldName, operator: (operator === OperatorType.rangeInclusive ? 'LE' : 'LT'), value: searchTerms[1] });\r\n                    continue;\r\n                }\r\n                // if we still don't have an operator find the proper Operator to use by it's field type\r\n                if (!operator) {\r\n                    operator = mapOperatorByFieldType(columnDef.type || FieldType.string);\r\n                }\r\n                // build the search array\r\n                searchByArray.push({ field: fieldName, operator: mapOperatorType(operator), value: searchValue });\r\n            }\r\n        }\r\n        // update the service options with filters for the buildQuery() to work later\r\n        this.updateOptions({ filteringOptions: searchByArray });\r\n    }\r\n    /**\r\n     * Update the pagination component with it's new page number and size\r\n     * @param newPage\r\n     * @param pageSize\r\n     */\r\n    updatePagination(newPage, pageSize) {\r\n        this._currentPagination = {\r\n            pageNumber: newPage,\r\n            pageSize,\r\n        };\r\n        let paginationOptions;\r\n        if (this.options && this.options.isWithCursor) {\r\n            paginationOptions = {\r\n                first: pageSize\r\n            };\r\n        }\r\n        else {\r\n            paginationOptions = {\r\n                first: pageSize,\r\n                offset: (newPage > 1) ? ((newPage - 1) * pageSize) : 0 // recalculate offset but make sure the result is always over 0\r\n            };\r\n        }\r\n        // unless user specifically set \"enablePagination\" to False, we'll update pagination options in every other cases\r\n        if (this._gridOptions && (this._gridOptions.enablePagination || !this._gridOptions.hasOwnProperty('enablePagination'))) {\r\n            this.updateOptions({ paginationOptions });\r\n        }\r\n    }\r\n    /**\r\n     * loop through all columns to inspect sorters & update backend service sortingOptions\r\n     * @param columnFilters\r\n     */\r\n    updateSorters(sortColumns, presetSorters) {\r\n        let currentSorters = [];\r\n        const graphqlSorters = [];\r\n        if (!sortColumns && presetSorters) {\r\n            // make the presets the current sorters, also make sure that all direction are in uppercase for GraphQL\r\n            currentSorters = presetSorters;\r\n            currentSorters.forEach((sorter) => sorter.direction = sorter.direction.toUpperCase());\r\n            // display the correct sorting icons on the UI, for that it requires (columnId, sortAsc) properties\r\n            const tmpSorterArray = currentSorters.map((sorter) => {\r\n                const columnDef = this._columnDefinitions.find((column) => column.id === sorter.columnId);\r\n                graphqlSorters.push({\r\n                    field: columnDef ? ((columnDef.queryFieldSorter || columnDef.queryField || columnDef.field) + '') : (sorter.columnId + ''),\r\n                    direction: sorter.direction\r\n                });\r\n                // return only the column(s) found in the Column Definitions ELSE null\r\n                if (columnDef) {\r\n                    return {\r\n                        columnId: sorter.columnId,\r\n                        sortAsc: sorter.direction.toUpperCase() === SortDirection.ASC\r\n                    };\r\n                }\r\n                return null;\r\n            });\r\n            // set the sort icons, but also make sure to filter out null values (that happens when columnDef is not found)\r\n            if (Array.isArray(tmpSorterArray)) {\r\n                this._grid.setSortColumns(tmpSorterArray.filter((sorter) => sorter));\r\n            }\r\n        }\r\n        else if (sortColumns && !presetSorters) {\r\n            // build the orderBy array, it could be multisort, example\r\n            // orderBy:[{field: lastName, direction: ASC}, {field: firstName, direction: DESC}]\r\n            if (Array.isArray(sortColumns) && sortColumns.length > 0) {\r\n                for (const column of sortColumns) {\r\n                    if (column && column.sortCol) {\r\n                        currentSorters.push({\r\n                            columnId: column.sortCol.id + '',\r\n                            direction: column.sortAsc ? SortDirection.ASC : SortDirection.DESC\r\n                        });\r\n                        const fieldName = (column.sortCol.queryFieldSorter || column.sortCol.queryField || column.sortCol.field || '') + '';\r\n                        if (fieldName) {\r\n                            graphqlSorters.push({\r\n                                field: fieldName,\r\n                                direction: column.sortAsc ? SortDirection.ASC : SortDirection.DESC\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // keep current Sorters and update the service options with the new sorting\r\n        this._currentSorters = currentSorters;\r\n        this.updateOptions({ sortingOptions: graphqlSorters });\r\n    }\r\n    /**\r\n     * A function which takes an input string and removes double quotes only\r\n     * on certain fields are identified as GraphQL enums (except fields with dot notation)\r\n     * For example let say we identified (\"direction:\", \"sort\") as word which are GraphQL enum fields\r\n     * then the result will be:\r\n     * FROM\r\n     * query { users (orderBy:[{field:\"firstName\", direction:\"ASC\"} }]) }\r\n     * TO\r\n     * query { users (orderBy:[{field: firstName, direction: ASC}})}\r\n     *\r\n     * EXCEPTIONS (fields with dot notation \".\" which are inside a \"field:\")\r\n     * these fields will keep double quotes while everything else will be stripped of double quotes\r\n     * query { users (orderBy:[{field:\"billing.street.name\", direction: \"ASC\"} }\r\n     * TO\r\n     * query { users (orderBy:[{field:\"billing.street.name\", direction: ASC}}\r\n     * @param inputStr input string\r\n     * @param enumSearchWords array of enum words to filter\r\n     * @returns outputStr output string\r\n     */\r\n    trimDoubleQuotesOnEnumField(inputStr, enumSearchWords, keepArgumentFieldDoubleQuotes) {\r\n        const patternWordInQuotes = `\\s?((field:\\s*)?\".*?\")`;\r\n        let patternRegex = enumSearchWords.join(patternWordInQuotes + '|');\r\n        patternRegex += patternWordInQuotes; // the last one should also have the pattern but without the pipe \"|\"\r\n        // example with (field: & direction:):  /field:s?(\".*?\")|direction:s?(\".*?\")/\r\n        const reg = new RegExp(patternRegex, 'g');\r\n        return inputStr.replace(reg, (group1, group2, group3) => {\r\n            // remove double quotes except when the string starts with a \"field:\"\r\n            let removeDoubleQuotes = true;\r\n            if (group1.startsWith('field:') && keepArgumentFieldDoubleQuotes) {\r\n                removeDoubleQuotes = false;\r\n            }\r\n            const rep = removeDoubleQuotes ? group1.replace(/\"/g, '') : group1;\r\n            return rep;\r\n        });\r\n    }\r\n    //\r\n    // private functions\r\n    // -------------------\r\n    /**\r\n     * Cast provided filters (could be in multiple formats) into an array of CurrentFilter\r\n     * @param columnFilters\r\n     */\r\n    castFilterToColumnFilters(columnFilters) {\r\n        // keep current filters & always save it as an array (columnFilters can be an object when it is dealt by SlickGrid Filter)\r\n        const filtersArray = (typeof columnFilters === 'object') ? Object.keys(columnFilters).map(key => columnFilters[key]) : columnFilters;\r\n        if (!Array.isArray(filtersArray)) {\r\n            return [];\r\n        }\r\n        return filtersArray.map((filter) => {\r\n            const tmpFilter = { columnId: filter.columnId || '' };\r\n            if (filter.operator) {\r\n                tmpFilter.operator = filter.operator;\r\n            }\r\n            if (Array.isArray(filter.searchTerms)) {\r\n                tmpFilter.searchTerms = filter.searchTerms;\r\n            }\r\n            return tmpFilter;\r\n        });\r\n    }\r\n}\n\nclass OdataQueryBuilderService {\r\n    constructor() {\r\n        this._odataOptions = {\r\n            filterQueue: [],\r\n            orderBy: ''\r\n        };\r\n        this._defaultSortBy = '';\r\n        this._columnFilters = {};\r\n    }\r\n    /*\r\n      * Build the OData query string from all the options provided\r\n      * @return string OData query\r\n      */\r\n    buildQuery() {\r\n        if (!this._odataOptions) {\r\n            throw new Error('Odata Service requires certain options like \"top\" for it to work');\r\n        }\r\n        this._odataOptions.filterQueue = [];\r\n        const queryTmpArray = [];\r\n        // When enableCount is set, add it to the OData query\r\n        if (this._odataOptions.enableCount === true) {\r\n            const countQuery = (this._odataOptions.version >= 4) ? '$count=true' : '$inlinecount=allpages';\r\n            queryTmpArray.push(countQuery);\r\n        }\r\n        if (this._odataOptions.top) {\r\n            queryTmpArray.push(`$top=${this._odataOptions.top}`);\r\n        }\r\n        if (this._odataOptions.skip) {\r\n            queryTmpArray.push(`$skip=${this._odataOptions.skip}`);\r\n        }\r\n        if (this._odataOptions.orderBy) {\r\n            let argument = '';\r\n            if (Array.isArray(this._odataOptions.orderBy)) {\r\n                argument = this._odataOptions.orderBy.join(','); // csv, that will form a query, for example: $orderby=RoleName asc, Id desc\r\n            }\r\n            else {\r\n                argument = this._odataOptions.orderBy;\r\n            }\r\n            queryTmpArray.push(`$orderby=${argument}`);\r\n        }\r\n        if (this._odataOptions.filterBy || this._odataOptions.filter) {\r\n            const filterBy = this._odataOptions.filter || this._odataOptions.filterBy;\r\n            if (filterBy) {\r\n                this._filterCount = 1;\r\n                this._odataOptions.filterQueue = [];\r\n                let filterStr = filterBy;\r\n                if (Array.isArray(filterBy)) {\r\n                    this._filterCount = filterBy.length;\r\n                    filterStr = filterBy.join(` ${this._odataOptions.filterBySeparator || 'and'} `);\r\n                }\r\n                if (typeof filterStr === 'string') {\r\n                    if (!(filterStr[0] === '(' && filterStr.slice(-1) === ')')) {\r\n                        this.addToFilterQueueWhenNotExists(`(${filterStr})`);\r\n                    }\r\n                    else {\r\n                        this.addToFilterQueueWhenNotExists(filterStr);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (this._odataOptions.filterQueue.length > 0) {\r\n            const query = this._odataOptions.filterQueue.join(` ${this._odataOptions.filterBySeparator || 'and'} `);\r\n            this._odataOptions.filter = query; // overwrite with\r\n            queryTmpArray.push(`$filter=${query}`);\r\n        }\r\n        // join all the odata functions by a '&'\r\n        return queryTmpArray.join('&');\r\n    }\r\n    getFilterCount() {\r\n        return this._filterCount;\r\n    }\r\n    get columnFilters() {\r\n        return this._columnFilters;\r\n    }\r\n    get options() {\r\n        return this._odataOptions;\r\n    }\r\n    set options(options) {\r\n        this._odataOptions = options;\r\n    }\r\n    removeColumnFilter(fieldName) {\r\n        if (this._columnFilters && this._columnFilters.hasOwnProperty(fieldName)) {\r\n            delete this._columnFilters[fieldName];\r\n        }\r\n    }\r\n    saveColumnFilter(fieldName, value, searchTerms) {\r\n        this._columnFilters[fieldName] = {\r\n            search: searchTerms,\r\n            value\r\n        };\r\n    }\r\n    /**\r\n     * Change any OData options that will be used to build the query\r\n     * @param object options\r\n     */\r\n    updateOptions(options) {\r\n        for (const property of Object.keys(options)) {\r\n            if (options.hasOwnProperty(property)) {\r\n                this._odataOptions[property] = options[property]; // replace of the property\r\n            }\r\n            // we need to keep the defaultSortBy for references whenever the user removes his Sorting\r\n            // then we would revert to the defaultSortBy and the only way is to keep a hard copy here\r\n            if (property === 'orderBy' || property === 'sortBy') {\r\n                let sortBy = options[property];\r\n                // make sure first char of each orderBy field is capitalize\r\n                if (this._odataOptions.caseType === CaseType.pascalCase) {\r\n                    if (Array.isArray(sortBy)) {\r\n                        sortBy.forEach((field, index, inputArray) => {\r\n                            inputArray[index] = titleCase(field);\r\n                        });\r\n                    }\r\n                    else {\r\n                        sortBy = titleCase(options[property]);\r\n                    }\r\n                }\r\n                this._odataOptions.orderBy = sortBy;\r\n                this._defaultSortBy = sortBy;\r\n            }\r\n        }\r\n    }\r\n    //\r\n    // private functions\r\n    // -------------------\r\n    addToFilterQueueWhenNotExists(filterStr) {\r\n        if (this._odataOptions.filterQueue && this._odataOptions.filterQueue.indexOf(filterStr) === -1) {\r\n            this._odataOptions.filterQueue.push(filterStr);\r\n        }\r\n    }\r\n}\n\nconst DEFAULT_ITEMS_PER_PAGE$1 = 25;\r\nconst DEFAULT_PAGE_SIZE$1 = 20;\r\nlet GridOdataService = class GridOdataService {\r\n    constructor() {\r\n        this._currentFilters = [];\r\n        this._currentSorters = [];\r\n        this.defaultOptions = {\r\n            top: DEFAULT_ITEMS_PER_PAGE$1,\r\n            orderBy: '',\r\n            caseType: CaseType.pascalCase\r\n        };\r\n        this._odataService = new OdataQueryBuilderService();\r\n    }\r\n    /** Getter for the Column Definitions */\r\n    get columnDefinitions() {\r\n        return this._columnDefinitions;\r\n    }\r\n    /** Getter for the Odata Service */\r\n    get odataService() {\r\n        return this._odataService;\r\n    }\r\n    /** Getter for the Grid Options pulled through the Grid Object */\r\n    get _gridOptions() {\r\n        return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};\r\n    }\r\n    init(serviceOptions, pagination, grid) {\r\n        this._grid = grid;\r\n        const mergedOptions = Object.assign({}, this.defaultOptions, serviceOptions);\r\n        // unless user specifically set \"enablePagination\" to False, we'll add \"top\" property for the pagination in every other cases\r\n        if (this._gridOptions && !this._gridOptions.enablePagination) {\r\n            // save current pagination as Page 1 and page size as \"top\"\r\n            this._odataService.options = Object.assign({}, mergedOptions, { top: null });\r\n            this._currentPagination = null;\r\n        }\r\n        else {\r\n            const topOption = (pagination && pagination.pageSize) ? pagination.pageSize : this.defaultOptions.top;\r\n            this._odataService.options = Object.assign({}, mergedOptions, { top: topOption });\r\n            this._currentPagination = {\r\n                pageNumber: 1,\r\n                pageSize: this._odataService.options.top || this.defaultOptions.top || DEFAULT_PAGE_SIZE$1,\r\n            };\r\n        }\r\n        this.options = this._odataService.options;\r\n        this.pagination = pagination;\r\n        if (grid && grid.getColumns) {\r\n            this._columnDefinitions = serviceOptions && serviceOptions.columnDefinitions || grid.getColumns();\r\n            this._columnDefinitions = this._columnDefinitions.filter((column) => !column.excludeFromQuery);\r\n        }\r\n    }\r\n    buildQuery() {\r\n        return this._odataService.buildQuery();\r\n    }\r\n    clearFilters() {\r\n        this._currentFilters = [];\r\n        this.updateFilters([]);\r\n    }\r\n    clearSorters() {\r\n        this._currentSorters = [];\r\n        this.updateSorters([]);\r\n    }\r\n    updateOptions(serviceOptions) {\r\n        this.options = Object.assign({}, this.options, serviceOptions);\r\n        this._odataService.options = this.options;\r\n    }\r\n    removeColumnFilter(fieldName) {\r\n        this._odataService.removeColumnFilter(fieldName);\r\n    }\r\n    /** Get the Filters that are currently used by the grid */\r\n    getCurrentFilters() {\r\n        return this._currentFilters;\r\n    }\r\n    /** Get the Pagination that is currently used by the grid */\r\n    getCurrentPagination() {\r\n        return this._currentPagination;\r\n    }\r\n    /** Get the Sorters that are currently used by the grid */\r\n    getCurrentSorters() {\r\n        return this._currentSorters;\r\n    }\r\n    /**\r\n     * Mapper for mathematical operators (ex.: <= is \"le\", > is \"gt\")\r\n     * @param string operator\r\n     * @returns string map\r\n     */\r\n    mapOdataOperator(operator) {\r\n        let map = '';\r\n        switch (operator) {\r\n            case '<':\r\n                map = 'lt';\r\n                break;\r\n            case '<=':\r\n                map = 'le';\r\n                break;\r\n            case '>':\r\n                map = 'gt';\r\n                break;\r\n            case '>=':\r\n                map = 'ge';\r\n                break;\r\n            case '<>':\r\n            case '!=':\r\n                map = 'ne';\r\n                break;\r\n            case '=':\r\n            case '==':\r\n            default:\r\n                map = 'eq';\r\n                break;\r\n        }\r\n        return map;\r\n    }\r\n    /*\r\n     * Reset the pagination options\r\n     */\r\n    resetPaginationOptions() {\r\n        this._odataService.updateOptions({\r\n            skip: 0\r\n        });\r\n    }\r\n    saveColumnFilter(fieldName, value, terms) {\r\n        this._odataService.saveColumnFilter(fieldName, value, terms);\r\n    }\r\n    /*\r\n     * FILTERING\r\n     */\r\n    processOnFilterChanged(event, args) {\r\n        const gridOptions = this._gridOptions;\r\n        const backendApi = gridOptions.backendServiceApi;\r\n        if (backendApi === undefined) {\r\n            throw new Error('Something went wrong in the GridOdataService, \"backendServiceApi\" is not initialized');\r\n        }\r\n        // keep current filters & always save it as an array (columnFilters can be an object when it is dealt by SlickGrid Filter)\r\n        this._currentFilters = this.castFilterToColumnFilters(args.columnFilters);\r\n        if (!args || !args.grid) {\r\n            throw new Error('Something went wrong when trying create the GridOdataService, it seems that \"args\" is not populated correctly');\r\n        }\r\n        // loop through all columns to inspect filters & set the query\r\n        this.updateFilters(args.columnFilters);\r\n        this.resetPaginationOptions();\r\n        return this._odataService.buildQuery();\r\n    }\r\n    /*\r\n     * PAGINATION\r\n     */\r\n    processOnPaginationChanged(event, args) {\r\n        const pageSize = +(args.pageSize || ((this.pagination) ? this.pagination.pageSize : DEFAULT_PAGE_SIZE$1));\r\n        this.updatePagination(args.newPage, pageSize);\r\n        // build the OData query which we will use in the WebAPI callback\r\n        return this._odataService.buildQuery();\r\n    }\r\n    /*\r\n     * SORTING\r\n     */\r\n    processOnSortChanged(event, args) {\r\n        const sortColumns = (args.multiColumnSort) ? args.sortCols : new Array({ sortCol: args.sortCol, sortAsc: args.sortAsc });\r\n        // loop through all columns to inspect sorters & set the query\r\n        this.updateSorters(sortColumns);\r\n        // build the OData query which we will use in the WebAPI callback\r\n        return this._odataService.buildQuery();\r\n    }\r\n    /**\r\n     * loop through all columns to inspect filters & update backend service filters\r\n     * @param columnFilters\r\n     */\r\n    updateFilters(columnFilters, isUpdatedByPresetOrDynamically) {\r\n        let searchBy = '';\r\n        const searchByArray = [];\r\n        const odataVersion = this._odataService && this._odataService.options && this._odataService.options.version || 2;\r\n        // on filter preset load, we need to keep current filters\r\n        if (isUpdatedByPresetOrDynamically) {\r\n            this._currentFilters = this.castFilterToColumnFilters(columnFilters);\r\n        }\r\n        // loop through all columns to inspect filters\r\n        for (const columnId in columnFilters) {\r\n            if (columnFilters.hasOwnProperty(columnId)) {\r\n                const columnFilter = columnFilters[columnId];\r\n                // if user defined some \"presets\", then we need to find the filters from the column definitions instead\r\n                let columnDef;\r\n                if (isUpdatedByPresetOrDynamically && Array.isArray(this._columnDefinitions)) {\r\n                    columnDef = this._columnDefinitions.find((column) => {\r\n                        return column.id === columnFilter.columnId;\r\n                    });\r\n                }\r\n                else {\r\n                    columnDef = columnFilter.columnDef;\r\n                }\r\n                if (!columnDef) {\r\n                    throw new Error('[GridOData Service]: Something went wrong in trying to get the column definition of the specified filter (or preset filters). Did you make a typo on the filter columnId?');\r\n                }\r\n                let fieldName = columnDef.queryFieldFilter || columnDef.queryField || columnDef.field || columnDef.name || '';\r\n                const fieldType = columnDef.type || FieldType.string;\r\n                let searchTerms = (columnFilter ? columnFilter.searchTerms : null) || [];\r\n                let fieldSearchValue = (Array.isArray(searchTerms) && searchTerms.length === 1) ? searchTerms[0] : '';\r\n                if (typeof fieldSearchValue === 'undefined') {\r\n                    fieldSearchValue = '';\r\n                }\r\n                if (!fieldName) {\r\n                    throw new Error(`GridOData filter could not find the field name to query the search, your column definition must include a valid \"field\" or \"name\" (optionally you can also use the \"queryfield\" or \"queryFieldFilter\").`);\r\n                }\r\n                fieldSearchValue = '' + fieldSearchValue; // make sure it's a string\r\n                const matches = fieldSearchValue.match(/^([<>!=\\*]{0,2})(.*[^<>!=\\*])([\\*]?)$/); // group 1: Operator, 2: searchValue, 3: last char is '*' (meaning starts with, ex.: abc*)\r\n                let operator = columnFilter.operator || ((matches) ? matches[1] : '');\r\n                let searchValue = (!!matches) ? matches[2] : '';\r\n                const lastValueChar = (!!matches) ? matches[3] : (operator === '*z' ? '*' : '');\r\n                const bypassOdataQuery = columnFilter.bypassBackendQuery || false;\r\n                // no need to query if search value is empty\r\n                if (fieldName && searchValue === '' && searchTerms.length <= 1) {\r\n                    this.removeColumnFilter(fieldName);\r\n                    continue;\r\n                }\r\n                if (Array.isArray(searchTerms) && searchTerms.length === 1 && typeof searchTerms[0] === 'string' && searchTerms[0].indexOf('..') > 0) {\r\n                    searchTerms = searchTerms[0].split('..');\r\n                    if (!operator) {\r\n                        operator = OperatorType.rangeExclusive;\r\n                    }\r\n                }\r\n                // escaping the search value\r\n                searchValue = searchValue.replace(`'`, `''`); // escape single quotes by doubling them\r\n                searchValue = encodeURIComponent(searchValue); // encode URI of the final search value\r\n                // if we didn't find an Operator but we have a Column Operator inside the Filter (DOM Element), we should use its default Operator\r\n                // multipleSelect is \"IN\", while singleSelect is \"EQ\", else don't map any operator\r\n                if (!operator && columnDef.filter) {\r\n                    operator = columnDef.filter.operator;\r\n                }\r\n                // if we still don't have an operator find the proper Operator to use by it's field type\r\n                if (!operator) {\r\n                    operator = mapOperatorByFieldType(columnDef.type || FieldType.string);\r\n                }\r\n                // extra query arguments\r\n                if (bypassOdataQuery) {\r\n                    // push to our temp array and also trim white spaces\r\n                    if (fieldName) {\r\n                        this.saveColumnFilter(fieldName, fieldSearchValue, searchTerms);\r\n                    }\r\n                }\r\n                else {\r\n                    searchBy = '';\r\n                    // titleCase the fieldName so that it matches the WebApi names\r\n                    if (this._odataService.options.caseType === CaseType.pascalCase) {\r\n                        fieldName = titleCase(fieldName || '');\r\n                    }\r\n                    if (fieldType === FieldType.date) {\r\n                        searchBy = this.filterBySearchDate(fieldName, operator, searchTerms, odataVersion);\r\n                    }\r\n                    else if (searchTerms && searchTerms.length > 1 && (operator === 'IN' || operator === 'NIN' || operator === 'NOTIN' || operator === 'NOT IN' || operator === 'NOT_IN')) {\r\n                        // when having more than 1 search term (then check if we have a \"IN\" or \"NOT IN\" filter search)\r\n                        const tmpSearchTerms = [];\r\n                        if (operator === 'IN') {\r\n                            // example:: (Stage eq \"Expired\" or Stage eq \"Renewal\")\r\n                            for (let j = 0, lnj = searchTerms.length; j < lnj; j++) {\r\n                                if (fieldType === FieldType.string) {\r\n                                    const searchVal = searchTerms[j].replace(`'`, `''`);\r\n                                    tmpSearchTerms.push(`${fieldName} eq '${searchVal}'`);\r\n                                }\r\n                                else {\r\n                                    // Single quote escape is not needed for non string type\r\n                                    tmpSearchTerms.push(`${fieldName} eq ${searchTerms[j]}`);\r\n                                }\r\n                            }\r\n                            searchBy = tmpSearchTerms.join(' or ');\r\n                            if (!(typeof searchBy === 'string' && searchBy[0] === '(' && searchBy.slice(-1) === ')')) {\r\n                                searchBy = `(${searchBy})`;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // example:: (Stage ne \"Expired\" and Stage ne \"Renewal\")\r\n                            for (let k = 0, lnk = searchTerms.length; k < lnk; k++) {\r\n                                const searchVal = searchTerms[k].replace(`'`, `''`);\r\n                                tmpSearchTerms.push(`${fieldName} ne '${searchVal}'`);\r\n                            }\r\n                            searchBy = tmpSearchTerms.join(' and ');\r\n                            if (!(typeof searchBy === 'string' && searchBy[0] === '(' && searchBy.slice(-1) === ')')) {\r\n                                searchBy = `(${searchBy})`;\r\n                            }\r\n                        }\r\n                    }\r\n                    else if (operator === '*' || operator === 'a*' || operator === '*z' || lastValueChar === '*') {\r\n                        // first/last character is a '*' will be a startsWith or endsWith\r\n                        searchBy = (operator === '*' || operator === '*z') ? `endswith(${fieldName}, '${searchValue}')` : `startswith(${fieldName}, '${searchValue}')`;\r\n                    }\r\n                    else if (fieldType === FieldType.string) {\r\n                        // string field needs to be in single quotes\r\n                        if (operator === '' || operator === OperatorType.contains || operator === OperatorType.notContains) {\r\n                            searchBy = this.odataQueryVersionWrapper('substring', odataVersion, fieldName, searchValue);\r\n                            if (operator === OperatorType.notContains) {\r\n                                searchBy = `not ${searchBy}`;\r\n                            }\r\n                        }\r\n                        else if (operator === OperatorType.rangeExclusive || operator === OperatorType.rangeInclusive) {\r\n                            // example:: (Duration >= 5 and Duration <= 10)\r\n                            searchBy = this.filterBySearchTermRange(fieldName, operator, searchTerms);\r\n                        }\r\n                        else {\r\n                            searchBy = `${fieldName} ${this.mapOdataOperator(operator)} '${searchValue}'`;\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (operator === OperatorType.rangeExclusive || operator === OperatorType.rangeInclusive) {\r\n                            // example:: (Duration >= 5 and Duration <= 10)\r\n                            searchBy = this.filterBySearchTermRange(fieldName, operator, searchTerms);\r\n                        }\r\n                        else {\r\n                            // any other field type (or undefined type)\r\n                            searchValue = (fieldType === FieldType.number || fieldType === FieldType.boolean) ? searchValue : `'${searchValue}'`;\r\n                            searchBy = `${fieldName} ${this.mapOdataOperator(operator)} ${searchValue}`;\r\n                        }\r\n                    }\r\n                    // push to our temp array and also trim white spaces\r\n                    if (searchBy !== '') {\r\n                        searchByArray.push(searchBy.trim());\r\n                        this.saveColumnFilter(fieldName || '', fieldSearchValue, searchValue);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // update the service options with filters for the buildQuery() to work later\r\n        this._odataService.updateOptions({\r\n            filter: (searchByArray.length > 0) ? searchByArray.join(' and ') : '',\r\n            skip: undefined\r\n        });\r\n    }\r\n    /**\r\n     * Update the pagination component with it's new page number and size\r\n     * @param newPage\r\n     * @param pageSize\r\n     */\r\n    updatePagination(newPage, pageSize) {\r\n        this._currentPagination = {\r\n            pageNumber: newPage,\r\n            pageSize,\r\n        };\r\n        // unless user specifically set \"enablePagination\" to False, we'll update pagination options in every other cases\r\n        if (this._gridOptions && (this._gridOptions.enablePagination || !this._gridOptions.hasOwnProperty('enablePagination'))) {\r\n            this._odataService.updateOptions({\r\n                top: pageSize,\r\n                skip: (newPage - 1) * pageSize\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * loop through all columns to inspect sorters & update backend service orderBy\r\n     * @param columnFilters\r\n     */\r\n    updateSorters(sortColumns, presetSorters) {\r\n        let currentSorters = [];\r\n        const odataSorters = [];\r\n        if (!sortColumns && presetSorters) {\r\n            // make the presets the current sorters, also make sure that all direction are in lowercase for OData\r\n            currentSorters = presetSorters;\r\n            currentSorters.forEach((sorter) => sorter.direction = sorter.direction.toLowerCase());\r\n            // display the correct sorting icons on the UI, for that it requires (columnId, sortAsc) properties\r\n            const tmpSorterArray = currentSorters.map((sorter) => {\r\n                const columnDef = this._columnDefinitions.find((column) => column.id === sorter.columnId);\r\n                odataSorters.push({\r\n                    field: columnDef ? ((columnDef.queryFieldSorter || columnDef.queryField || columnDef.field) + '') : (sorter.columnId + ''),\r\n                    direction: sorter.direction\r\n                });\r\n                // return only the column(s) found in the Column Definitions ELSE null\r\n                if (columnDef) {\r\n                    return {\r\n                        columnId: sorter.columnId,\r\n                        sortAsc: sorter.direction.toUpperCase() === SortDirection.ASC\r\n                    };\r\n                }\r\n                return null;\r\n            });\r\n            // set the sort icons, but also make sure to filter out null values (that happens when columnDef is not found)\r\n            if (Array.isArray(tmpSorterArray)) {\r\n                this._grid.setSortColumns(tmpSorterArray);\r\n            }\r\n        }\r\n        else if (sortColumns && !presetSorters) {\r\n            // build the SortBy string, it could be multisort, example: customerNo asc, purchaserName desc\r\n            if (sortColumns && sortColumns.length === 0) ;\r\n            else {\r\n                if (sortColumns) {\r\n                    for (const columnDef of sortColumns) {\r\n                        if (columnDef.sortCol) {\r\n                            let fieldName = (columnDef.sortCol.queryFieldSorter || columnDef.sortCol.queryField || columnDef.sortCol.field) + '';\r\n                            let columnFieldName = (columnDef.sortCol.field || columnDef.sortCol.id) + '';\r\n                            let queryField = (columnDef.sortCol.queryFieldSorter || columnDef.sortCol.queryField || columnDef.sortCol.field || '') + '';\r\n                            if (this._odataService.options.caseType === CaseType.pascalCase) {\r\n                                fieldName = titleCase(fieldName);\r\n                                columnFieldName = titleCase(columnFieldName);\r\n                                queryField = titleCase(queryField);\r\n                            }\r\n                            if (columnFieldName !== '') {\r\n                                currentSorters.push({\r\n                                    columnId: columnFieldName,\r\n                                    direction: columnDef.sortAsc ? 'asc' : 'desc'\r\n                                });\r\n                            }\r\n                            if (queryField !== '') {\r\n                                odataSorters.push({\r\n                                    field: queryField,\r\n                                    direction: columnDef.sortAsc ? SortDirection.ASC : SortDirection.DESC\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // transform the sortby array into a CSV string for OData\r\n        currentSorters = currentSorters || [];\r\n        const csvString = odataSorters.map((sorter) => {\r\n            let str = '';\r\n            if (sorter && sorter.field) {\r\n                const sortField = (this._odataService.options.caseType === CaseType.pascalCase) ? titleCase(sorter.field) : sorter.field;\r\n                str = `${sortField} ${sorter && sorter.direction && sorter.direction.toLowerCase() || ''}`;\r\n            }\r\n            return str;\r\n        }).join(',');\r\n        this._odataService.updateOptions({\r\n            orderBy: csvString\r\n        });\r\n        // keep current Sorters and update the service options with the new sorting\r\n        this._currentSorters = currentSorters;\r\n        // build the OData query which we will use in the WebAPI callback\r\n        return this._odataService.buildQuery();\r\n    }\r\n    //\r\n    // private functions\r\n    // -------------------\r\n    /**\r\n     * Cast provided filters (could be in multiple format) into an array of ColumnFilter\r\n     * @param columnFilters\r\n     */\r\n    castFilterToColumnFilters(columnFilters) {\r\n        // keep current filters & always save it as an array (columnFilters can be an object when it is dealt by SlickGrid Filter)\r\n        const filtersArray = (typeof columnFilters === 'object') ? Object.keys(columnFilters).map(key => columnFilters[key]) : columnFilters;\r\n        if (!Array.isArray(filtersArray)) {\r\n            return [];\r\n        }\r\n        return filtersArray.map((filter) => {\r\n            const tmpFilter = { columnId: filter.columnId || '' };\r\n            if (filter.operator) {\r\n                tmpFilter.operator = filter.operator;\r\n            }\r\n            if (Array.isArray(filter.searchTerms)) {\r\n                tmpFilter.searchTerms = filter.searchTerms;\r\n            }\r\n            return tmpFilter;\r\n        });\r\n    }\r\n    odataQueryVersionWrapper(queryType, version, fieldName, searchValue) {\r\n        let query = '';\r\n        switch (queryType) {\r\n            case 'dateTime':\r\n                query = version >= 4 ? searchValue : `DateTime'${searchValue}'`;\r\n                break;\r\n            case 'substring':\r\n                query = version >= 4 ? `contains(${fieldName}, '${searchValue}')` : `substringof('${searchValue}', ${fieldName})`;\r\n                break;\r\n        }\r\n        return query;\r\n    }\r\n    /**\r\n     * Filter by a search date, the searchTerms might be a single value or range of dates (2 searchTerms OR 1 string separated by 2 dots \"date1..date2\")\r\n     * Also depending on the OData version number, the output will be different, previous version must wrap dates with DateTime\r\n     * - version 2-3:: Finish gt DateTime'2019-08-12T00:00:00Z'\r\n     * - version 4:: Finish gt 2019-08-12T00:00:00Z\r\n     */\r\n    filterBySearchDate(fieldName, operator, searchTerms, version) {\r\n        let query = '';\r\n        let searchValues;\r\n        if (Array.isArray(searchTerms) && searchTerms.length > 1) {\r\n            searchValues = searchTerms;\r\n            if (operator !== OperatorType.rangeExclusive && operator !== OperatorType.rangeInclusive) {\r\n                operator = this._gridOptions.defaultFilterRangeOperator;\r\n            }\r\n        }\r\n        // single search value\r\n        if (!Array.isArray(searchValues) && Array.isArray(searchTerms) && searchTerms.length === 1 && searchTerms[0]) {\r\n            const searchValue1 = this.odataQueryVersionWrapper('dateTime', version, fieldName, parseUtcDate(searchTerms[0], true));\r\n            if (searchValue1) {\r\n                return `${fieldName} ${this.mapOdataOperator(operator)} ${searchValue1}`;\r\n            }\r\n        }\r\n        // multiple search value (date range)\r\n        if (Array.isArray(searchValues) && searchValues.length === 2 && searchValues[0] && searchValues[1]) {\r\n            // date field needs to be UTC and within DateTime function\r\n            const searchValue1 = this.odataQueryVersionWrapper('dateTime', version, fieldName, parseUtcDate(searchValues[0], true));\r\n            const searchValue2 = this.odataQueryVersionWrapper('dateTime', version, fieldName, parseUtcDate(searchValues[1], true));\r\n            if (searchValue1 && searchValue2) {\r\n                if (operator === OperatorType.rangeInclusive) {\r\n                    // example:: (Finish >= DateTime'2019-08-11T00:00:00Z' and Finish <= DateTime'2019-09-12T00:00:00Z')\r\n                    query = `(${fieldName} ge ${searchValue1} and ${fieldName} le ${searchValue2})`;\r\n                }\r\n                else if (operator === OperatorType.rangeExclusive) {\r\n                    // example:: (Finish > DateTime'2019-08-11T00:00:00Z' and Finish < DateTime'2019-09-12T00:00:00Z')\r\n                    query = `(${fieldName} gt ${searchValue1} and ${fieldName} lt ${searchValue2})`;\r\n                }\r\n            }\r\n        }\r\n        return query;\r\n    }\r\n    /**\r\n     * Filter by a range of searchTerms (2 searchTerms OR 1 string separated by 2 dots \"value1..value2\")\r\n     */\r\n    filterBySearchTermRange(fieldName, operator, searchTerms) {\r\n        let query = '';\r\n        if (Array.isArray(searchTerms) && searchTerms.length === 2) {\r\n            if (operator === OperatorType.rangeInclusive) {\r\n                // example:: (Duration >= 5 and Duration <= 10)\r\n                query = `(${fieldName} ge ${searchTerms[0]} and ${fieldName} le ${searchTerms[1]})`;\r\n            }\r\n            else if (operator === OperatorType.rangeExclusive) {\r\n                // example:: (Duration > 5 and Duration < 10)\r\n                query = `(${fieldName} gt ${searchTerms[0]} and ${fieldName} lt ${searchTerms[1]})`;\r\n            }\r\n        }\r\n        return query;\r\n    }\r\n};\r\nGridOdataService = __decorate([\r\n    Injectable(),\r\n    __metadata(\"design:paramtypes\", [])\r\n], GridOdataService);\n\nclass GridEventService {\r\n    get eventHandler() {\r\n        return this._eventHandler;\r\n    }\r\n    constructor() {\r\n        this._eventHandler = new Slick.EventHandler();\r\n    }\r\n    /* OnCellChange Event */\r\n    bindOnCellChange(grid, dataView) {\r\n        // subscribe to this Slickgrid event of onCellChange\r\n        this._eventHandler.subscribe(grid.onCellChange, (e, args) => {\r\n            if (!e || !args || !grid || args.cell === undefined || !grid.getColumns || !grid.getDataItem) {\r\n                return;\r\n            }\r\n            const column = grid.getColumns()[args.cell];\r\n            // if the column definition has a onCellChange property (a callback function), then run it\r\n            if (typeof column.onCellChange === 'function') {\r\n                // add to the output gridOptions & dataView since we'll need them inside the AJAX column.onCellChange\r\n                const returnedArgs = {\r\n                    row: args.row,\r\n                    cell: args.cell,\r\n                    dataView,\r\n                    grid,\r\n                    columnDef: column,\r\n                    dataContext: grid.getDataItem(args.row)\r\n                };\r\n                // finally call up the Slick.column.onCellChanges.... function\r\n                column.onCellChange(e, returnedArgs);\r\n            }\r\n        });\r\n    }\r\n    /* OnClick Event */\r\n    bindOnClick(grid, dataView) {\r\n        this._eventHandler.subscribe(grid.onClick, (e, args) => {\r\n            if (!e || !args || !grid || args.cell === undefined || !grid.getColumns || !grid.getDataItem) {\r\n                return;\r\n            }\r\n            const column = grid && grid.getColumns && grid.getColumns()[args.cell];\r\n            const gridOptions = grid && grid.getOptions && grid.getOptions() || {};\r\n            // only when using autoCommitEdit, we will make the cell active (in focus) when clicked\r\n            // setting the cell as active as a side effect and if autoCommitEdit is set to false then the Editors won't save correctly\r\n            if (gridOptions.enableCellNavigation && (!gridOptions.editable || (gridOptions.editable && gridOptions.autoCommitEdit))) {\r\n                grid.setActiveCell(args.row, args.cell);\r\n            }\r\n            // if the column definition has a onCellClick property (a callback function), then run it\r\n            if (typeof column.onCellClick === 'function') {\r\n                // add to the output gridOptions & dataView since we'll need them inside the AJAX column.onClick\r\n                const returnedArgs = {\r\n                    row: args.row,\r\n                    cell: args.cell,\r\n                    dataView,\r\n                    grid,\r\n                    columnDef: column,\r\n                    dataContext: grid.getDataItem(args.row)\r\n                };\r\n                // finally call up the Slick.column.onCellClick.... function\r\n                column.onCellClick(e, returnedArgs);\r\n            }\r\n        });\r\n    }\r\n    dispose() {\r\n        this._eventHandler.unsubscribeAll();\r\n    }\r\n}\n\nconst isequal$1 = isequal_; // patch to fix rollup to work\r\nlet GridStateService = class GridStateService {\r\n    constructor(extensionService, filterService, sharedService, sortService) {\r\n        this.extensionService = extensionService;\r\n        this.filterService = filterService;\r\n        this.sharedService = sharedService;\r\n        this.sortService = sortService;\r\n        this._columns = [];\r\n        this._currentColumns = [];\r\n        this._subscriptions = [];\r\n        this._selectedRowDataContextIds = []; // used with row selection\r\n        this._selectedFilteredRowDataContextIds = []; // used with row selection\r\n        this._wasRecheckedAfterPageChange = true; // used with row selection & pagination\r\n        this.onGridStateChanged = new Subject();\r\n        this._eventHandler = new Slick.EventHandler();\r\n    }\r\n    /** Getter for the Grid Options pulled through the Grid Object */\r\n    get _gridOptions() {\r\n        return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};\r\n    }\r\n    get datasetIdPropName() {\r\n        return this._gridOptions.datasetIdPropertyName || 'id';\r\n    }\r\n    /** Getter of the selected data context object IDs */\r\n    get selectedRowDataContextIds() {\r\n        return this._selectedRowDataContextIds;\r\n    }\r\n    /** Setter of the selected data context object IDs */\r\n    set selectedRowDataContextIds(dataContextIds) {\r\n        this._selectedRowDataContextIds = dataContextIds;\r\n        // since this is coming from a preset, we also need to update the filtered IDs\r\n        this._selectedFilteredRowDataContextIds = dataContextIds;\r\n    }\r\n    /**\r\n     * Initialize the Grid State Service\r\n     * @param grid\r\n     */\r\n    init(grid, dataView) {\r\n        this._grid = grid;\r\n        this._dataView = dataView;\r\n        this.subscribeToAllGridChanges(grid);\r\n    }\r\n    /** Dispose of all the SlickGrid & Angular subscriptions */\r\n    dispose() {\r\n        // unsubscribe all SlickGrid events\r\n        this._eventHandler.unsubscribeAll();\r\n        // also unsubscribe all Angular Subscriptions\r\n        this._subscriptions = unsubscribeAllObservables(this._subscriptions);\r\n        this._currentColumns = [];\r\n        this._columns = [];\r\n    }\r\n    /**\r\n     * Get the current grid state (filters/sorters/pagination)\r\n     * @return grid state\r\n     */\r\n    getCurrentGridState(args) {\r\n        const gridState = {\r\n            columns: this.getCurrentColumns(),\r\n            filters: this.getCurrentFilters(),\r\n            sorters: this.getCurrentSorters(),\r\n        };\r\n        const currentPagination = this.getCurrentPagination();\r\n        if (currentPagination) {\r\n            gridState.pagination = currentPagination;\r\n        }\r\n        if (this.hasRowSelectionEnabled()) {\r\n            const currentRowSelection = this.getCurrentRowSelections(args && args.requestRefreshRowFilteredRow);\r\n            if (currentRowSelection) {\r\n                gridState.rowSelection = currentRowSelection;\r\n            }\r\n        }\r\n        return gridState;\r\n    }\r\n    /**\r\n     * Get the Columns (and their state: visibility/position) that are currently applied in the grid\r\n     * @return current columns\r\n     */\r\n    getColumns() {\r\n        return this._columns;\r\n    }\r\n    /**\r\n     * From an array of Grid Column Definitions, get the associated Current Columns\r\n     * @param gridColumns\r\n     */\r\n    getAssociatedCurrentColumns(gridColumns) {\r\n        const currentColumns = [];\r\n        if (gridColumns && Array.isArray(gridColumns)) {\r\n            gridColumns.forEach((column, index) => {\r\n                if (column && column.id) {\r\n                    currentColumns.push({\r\n                        columnId: column.id,\r\n                        cssClass: column.cssClass || '',\r\n                        headerCssClass: column.headerCssClass || '',\r\n                        width: column.width || 0\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        this._currentColumns = currentColumns;\r\n        return currentColumns;\r\n    }\r\n    /**\r\n     * From an array of Current Columns, get the associated Grid Column Definitions\r\n     * @param grid\r\n     * @param currentColumns\r\n     */\r\n    getAssociatedGridColumns(grid, currentColumns) {\r\n        const columns = [];\r\n        const gridColumns = grid.getColumns();\r\n        if (currentColumns && Array.isArray(currentColumns)) {\r\n            currentColumns.forEach((currentColumn, index) => {\r\n                const gridColumn = gridColumns.find((c) => c.id === currentColumn.columnId);\r\n                if (gridColumn && gridColumn.id) {\r\n                    columns.push(Object.assign({}, gridColumn, { cssClass: currentColumn.cssClass, headerCssClass: currentColumn.headerCssClass, width: currentColumn.width }));\r\n                }\r\n            });\r\n        }\r\n        this._columns = columns;\r\n        return columns;\r\n    }\r\n    /**\r\n     * Get the Columns (and their state: visibility/position) that are currently applied in the grid\r\n     * @return current columns\r\n     */\r\n    getCurrentColumns() {\r\n        let currentColumns = [];\r\n        if (this._currentColumns && Array.isArray(this._currentColumns) && this._currentColumns.length > 0) {\r\n            currentColumns = this._currentColumns;\r\n        }\r\n        else {\r\n            currentColumns = this.getAssociatedCurrentColumns(this._grid.getColumns());\r\n        }\r\n        return currentColumns;\r\n    }\r\n    /**\r\n     * Get the Filters (and their state, columnId, searchTerm(s)) that are currently applied in the grid\r\n     * @return current filters\r\n     */\r\n    getCurrentFilters() {\r\n        if (this._gridOptions && this._gridOptions.backendServiceApi) {\r\n            const backendService = this._gridOptions.backendServiceApi.service;\r\n            if (backendService && backendService.getCurrentFilters) {\r\n                return backendService.getCurrentFilters();\r\n            }\r\n        }\r\n        else if (this.filterService && this.filterService.getCurrentLocalFilters) {\r\n            return this.filterService.getCurrentLocalFilters();\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Get current Pagination (and it's state, pageNumber, pageSize) that are currently applied in the grid\r\n     * @return current pagination state\r\n     */\r\n    getCurrentPagination() {\r\n        if (this._gridOptions.enablePagination) {\r\n            if (this._gridOptions && this._gridOptions.backendServiceApi) {\r\n                const backendService = this._gridOptions.backendServiceApi.service;\r\n                if (backendService && backendService.getCurrentPagination) {\r\n                    return backendService.getCurrentPagination();\r\n                }\r\n            }\r\n            else {\r\n                return this.sharedService.currentPagination;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Get the current Sorters (and their state, columnId, direction) that are currently applied in the grid\r\n     * @return current sorters\r\n     */\r\n    getCurrentRowSelections(requestRefreshFilteredRow = true) {\r\n        if (this._grid && this._gridOptions && this._dataView && this.hasRowSelectionEnabled()) {\r\n            if (this._grid.getSelectedRows && this._dataView.mapRowsToIds) {\r\n                let filteredDataContextIds = [];\r\n                const gridRowIndexes = this._dataView.mapIdsToRows(this._selectedRowDataContextIds || []); // note that this will return only what is visible in current page\r\n                const dataContextIds = this._selectedRowDataContextIds;\r\n                // user might request to refresh the filtered selection dataset\r\n                // typically always True, except when \"reEvaluateRowSelectionAfterFilterChange\" is called and we don't need to refresh the filtered dataset twice\r\n                if (requestRefreshFilteredRow === true) {\r\n                    filteredDataContextIds = this.refreshFilteredRowSelections();\r\n                }\r\n                filteredDataContextIds = this._selectedFilteredRowDataContextIds;\r\n                return { gridRowIndexes, dataContextIds, filteredDataContextIds };\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Get the current Sorters (and their state, columnId, direction) that are currently applied in the grid\r\n     * @return current sorters\r\n     */\r\n    getCurrentSorters() {\r\n        if (this._gridOptions && this._gridOptions.backendServiceApi) {\r\n            const backendService = this._gridOptions.backendServiceApi.service;\r\n            if (backendService && backendService.getCurrentSorters) {\r\n                return backendService.getCurrentSorters();\r\n            }\r\n        }\r\n        else if (this.sortService && this.sortService.getCurrentLocalSorters) {\r\n            return this.sortService.getCurrentLocalSorters();\r\n        }\r\n        return null;\r\n    }\r\n    /** Check whether the row selection needs to be preserved */\r\n    needToPreserveRowSelection() {\r\n        let preservedRowSelection = false;\r\n        if (this._gridOptions && this._gridOptions.dataView && this._gridOptions.dataView.hasOwnProperty('syncGridSelection')) {\r\n            const syncGridSelection = this._gridOptions.dataView.syncGridSelection;\r\n            if (typeof syncGridSelection === 'boolean') {\r\n                preservedRowSelection = this._gridOptions.dataView.syncGridSelection;\r\n            }\r\n            else {\r\n                preservedRowSelection = syncGridSelection.preserveHidden;\r\n            }\r\n            // if the result is True but the grid is using a Backend Service, we will do an extra flag check the reason is because it might have some unintended behaviors\r\n            // with the BackendServiceApi because technically the data in the page changes the DataView on every page.\r\n            if (preservedRowSelection && this._gridOptions.backendServiceApi && this._gridOptions.dataView.hasOwnProperty('syncGridSelectionWithBackendService')) {\r\n                preservedRowSelection = this._gridOptions.dataView.syncGridSelectionWithBackendService;\r\n            }\r\n        }\r\n        return preservedRowSelection;\r\n    }\r\n    resetColumns(columnDefinitions) {\r\n        const columns = columnDefinitions || this._columns;\r\n        const currentColumns = this.getAssociatedCurrentColumns(columns);\r\n        this.onGridStateChanged.next({ change: { newValues: currentColumns, type: GridStateType.columns }, gridState: this.getCurrentGridState() });\r\n    }\r\n    /** if we use Row Selection or the Checkbox Selector, we need to reset any selection */\r\n    resetRowSelectionWhenRequired() {\r\n        if (!this.needToPreserveRowSelection() && (this._gridOptions.enableRowSelection || this._gridOptions.enableCheckboxSelector)) {\r\n            // this also requires the Row Selection Model to be registered as well\r\n            const rowSelectionExtension = this.extensionService && this.extensionService.getExtensionByName && this.extensionService.getExtensionByName(ExtensionName.rowSelection);\r\n            if (rowSelectionExtension && rowSelectionExtension.instance) {\r\n                this._grid.setSelectedRows([]);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Subscribe to all necessary SlickGrid or Service Events that deals with a Grid change,\r\n     * when triggered, we will publish a Grid State Event with current Grid State\r\n     */\r\n    subscribeToAllGridChanges(grid) {\r\n        // Subscribe to Event Emitter of Filter changed\r\n        this._subscriptions.push(this.filterService.onFilterChanged.subscribe((currentFilters) => {\r\n            this.resetRowSelectionWhenRequired();\r\n            // trigger a Grid State filter change, however don't reevaluate the filtered row selections, we'll do that on the next Grid State change below\r\n            this.onGridStateChanged.next({ change: { newValues: currentFilters, type: GridStateType.filter }, gridState: this.getCurrentGridState({ requestRefreshRowFilteredRow: !this.hasRowSelectionEnabled() }) });\r\n            // when Row Selection is enabled, we also need to re-evaluate the row selection with the leftover filtered dataset\r\n            if (this.hasRowSelectionEnabled()) {\r\n                this.reEvaluateRowSelectionAfterFilterChange();\r\n            }\r\n        }));\r\n        // Subscribe to Event Emitter of Filter cleared\r\n        this._subscriptions.push(this.filterService.onFilterCleared.subscribe(() => {\r\n            this.resetRowSelectionWhenRequired();\r\n            this.onGridStateChanged.next({ change: { newValues: [], type: GridStateType.filter }, gridState: this.getCurrentGridState() });\r\n        }));\r\n        // Subscribe to Event Emitter of Sort changed\r\n        this._subscriptions.push(this.sortService.onSortChanged.subscribe((currentSorters) => {\r\n            this.resetRowSelectionWhenRequired();\r\n            this.onGridStateChanged.next({ change: { newValues: currentSorters, type: GridStateType.sorter }, gridState: this.getCurrentGridState() });\r\n        }));\r\n        // Subscribe to Event Emitter of Sort cleared\r\n        this._subscriptions.push(this.sortService.onSortCleared.subscribe(() => {\r\n            this.resetRowSelectionWhenRequired();\r\n            this.onGridStateChanged.next({ change: { newValues: [], type: GridStateType.sorter }, gridState: this.getCurrentGridState() });\r\n        }));\r\n        // Subscribe to ColumnPicker and/or GridMenu for show/hide Columns visibility changes\r\n        this.bindExtensionAddonEventToGridStateChange(ExtensionName.columnPicker, 'onColumnsChanged');\r\n        this.bindExtensionAddonEventToGridStateChange(ExtensionName.gridMenu, 'onColumnsChanged');\r\n        // subscribe to Column Resize & Reordering\r\n        this.bindSlickGridColumnChangeEventToGridStateChange('onColumnsReordered', grid);\r\n        this.bindSlickGridColumnChangeEventToGridStateChange('onColumnsResized', grid);\r\n        // subscribe to Row Selection changes (when enabled)\r\n        if (this._gridOptions.enableRowSelection || this._gridOptions.enableCheckboxSelector) {\r\n            this.bindSlickGridRowSelectionToGridStateChange();\r\n        }\r\n        // subscribe to HeaderMenu (hide column)\r\n        this._subscriptions.push(this.sharedService.onColumnsChanged.subscribe((visibleColumns) => {\r\n            const currentColumns = this.getAssociatedCurrentColumns(visibleColumns);\r\n            this.onGridStateChanged.next({ change: { newValues: currentColumns, type: GridStateType.columns }, gridState: this.getCurrentGridState() });\r\n        }));\r\n    }\r\n    // --\r\n    // private methods\r\n    // ------------------\r\n    /**\r\n     * Bind a SlickGrid Extension Event to a Grid State change event\r\n     * @param extension name\r\n     * @param grid\r\n     */\r\n    bindExtensionAddonEventToGridStateChange(extensionName, eventName) {\r\n        const extension = this.extensionService && this.extensionService.getExtensionByName && this.extensionService.getExtensionByName(extensionName);\r\n        const slickEvent = extension && extension.instance && extension.instance[eventName];\r\n        if (slickEvent && slickEvent.subscribe) {\r\n            this._eventHandler.subscribe(slickEvent, (e, args) => {\r\n                const columns = args && args.columns;\r\n                const currentColumns = this.getAssociatedCurrentColumns(columns);\r\n                this.onGridStateChanged.next({ change: { newValues: currentColumns, type: GridStateType.columns }, gridState: this.getCurrentGridState() });\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Bind a Grid Event (of Column changes) to a Grid State change event\r\n     * @param event name\r\n     * @param grid\r\n     */\r\n    bindSlickGridColumnChangeEventToGridStateChange(eventName, grid) {\r\n        const slickGridEvent = grid && grid[eventName];\r\n        if (slickGridEvent && slickGridEvent.subscribe) {\r\n            this._eventHandler.subscribe(slickGridEvent, () => {\r\n                const columns = grid.getColumns();\r\n                const currentColumns = this.getAssociatedCurrentColumns(columns);\r\n                this.onGridStateChanged.next({ change: { newValues: currentColumns, type: GridStateType.columns }, gridState: this.getCurrentGridState() });\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Bind a Grid Event of Row Selection change to a Grid State change event\r\n     * For the row selection, we can't just use the getSelectedRows() since this will only return the visible rows shown in the UI which is not enough.\r\n     * The process is much more complex, what we have to do instead is the following\r\n     * 1. when changing a row selection, we'll add the new selection if it's not yet in the global array of selected IDs\r\n     * 2. when deleting a row selection, we'll remove the selection from our global array of selected IDs (unless it came from a page change)\r\n     * 3. if we use Pagination and we change page, we'll keep track with a flag (this flag will be used to skip any deletion when we're changing page)\r\n     * 4. after the Page or DataView is changed or updated, we'll do an extra (and delayed) check to make sure that what we have in our global array of selected IDs is displayed on screen\r\n     */\r\n    bindSlickGridRowSelectionToGridStateChange() {\r\n        if (this._grid && this._gridOptions && this._dataView) {\r\n            this._eventHandler.subscribe(this._dataView.onBeforePagingInfoChanged, () => {\r\n                this._wasRecheckedAfterPageChange = false; // reset the page check flag, to skip deletions on page change (used in code below)\r\n            });\r\n            this._eventHandler.subscribe(this._dataView.onPagingInfoChanged, () => {\r\n                // when user changes page, the selected row indexes might not show up\r\n                // we can check to make sure it is but it has to be in a delay so it happens after the first \"onSelectedRowsChanged\" is triggered\r\n                setTimeout(() => {\r\n                    const shouldBeSelectedRowIndexes = this._dataView.mapIdsToRows(this._selectedRowDataContextIds || []);\r\n                    const currentSelectedRowIndexes = this._grid.getSelectedRows();\r\n                    if (!isequal$1(shouldBeSelectedRowIndexes, currentSelectedRowIndexes)) {\r\n                        this._grid.setSelectedRows(shouldBeSelectedRowIndexes);\r\n                    }\r\n                });\r\n            });\r\n            this._eventHandler.subscribe(this._grid.onSelectedRowsChanged, (e, args) => {\r\n                if (Array.isArray(args.rows) && Array.isArray(args.previousSelectedRows)) {\r\n                    const newSelectedRows = args.rows;\r\n                    const prevSelectedRows = args.previousSelectedRows;\r\n                    const newSelectedAdditions = newSelectedRows.filter((i) => prevSelectedRows.indexOf(i) < 0);\r\n                    const newSelectedDeletions = prevSelectedRows.filter((i) => newSelectedRows.indexOf(i) < 0);\r\n                    // deletion might happen when user is changing page, if that is the case then skip the deletion since it's only a visual deletion (current page)\r\n                    // if it's not a page change (when the flag is true), then proceed with the deletion in our global array of selected IDs\r\n                    if (this._wasRecheckedAfterPageChange && newSelectedDeletions.length > 0) {\r\n                        const toDeleteDataIds = this._dataView.mapRowsToIds(newSelectedDeletions) || [];\r\n                        toDeleteDataIds.forEach((removeId) => {\r\n                            this._selectedRowDataContextIds.splice(this._selectedRowDataContextIds.indexOf(removeId), 1);\r\n                        });\r\n                    }\r\n                    // if we have newly added selected row(s), let's update our global array of selected IDs\r\n                    if (newSelectedAdditions.length > 0) {\r\n                        const toAddDataIds = this._dataView.mapRowsToIds(newSelectedAdditions) || [];\r\n                        toAddDataIds.forEach((dataId) => {\r\n                            if (this._selectedRowDataContextIds.indexOf(dataId) === -1) {\r\n                                this._selectedRowDataContextIds.push(dataId);\r\n                            }\r\n                        });\r\n                    }\r\n                    // we set this flag which will be used on the 2nd time the \"onSelectedRowsChanged\" event is called\r\n                    // when it's the first time, we skip deletion and this is what this flag is for\r\n                    this._wasRecheckedAfterPageChange = true;\r\n                    // form our full selected row IDs, let's make sure these indexes are selected in the grid, if not then let's call a reselect\r\n                    // this could happen if the previous step was a page change\r\n                    const shouldBeSelectedRowIndexes = this._dataView.mapIdsToRows(this._selectedRowDataContextIds || []);\r\n                    const currentSelectedRowIndexes = this._grid.getSelectedRows();\r\n                    if (!isequal$1(shouldBeSelectedRowIndexes, currentSelectedRowIndexes)) {\r\n                        this._grid.setSelectedRows(shouldBeSelectedRowIndexes);\r\n                    }\r\n                    const filteredDataContextIds = this.refreshFilteredRowSelections();\r\n                    const newValues = { gridRowIndexes: this._grid.getSelectedRows(), dataContextIds: this._selectedRowDataContextIds, filteredDataContextIds };\r\n                    this.onGridStateChanged.next({ change: { newValues, type: GridStateType.rowSelection }, gridState: this.getCurrentGridState() });\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /** Check wether the grid has the Row Selection enabled */\r\n    hasRowSelectionEnabled() {\r\n        const selectionModel = this._grid.getSelectionModel();\r\n        const isRowSelectionEnabled = this._gridOptions.enableRowSelection || this._gridOptions.enableCheckboxSelector;\r\n        return (isRowSelectionEnabled && selectionModel);\r\n    }\r\n    reEvaluateRowSelectionAfterFilterChange() {\r\n        const currentSelectedRowIndexes = this._grid.getSelectedRows();\r\n        const previousSelectedFilteredRowDataContextIds = this._selectedFilteredRowDataContextIds.slice();\r\n        const filteredDataContextIds = this.refreshFilteredRowSelections();\r\n        // when selection changed, we'll send a Grid State event with the selection changes\r\n        if (!isequal$1(this._selectedFilteredRowDataContextIds, previousSelectedFilteredRowDataContextIds)) {\r\n            const newValues = { gridRowIndexes: currentSelectedRowIndexes, dataContextIds: this._selectedRowDataContextIds, filteredDataContextIds };\r\n            this.onGridStateChanged.next({ change: { newValues, type: GridStateType.rowSelection }, gridState: this.getCurrentGridState({ requestRefreshRowFilteredRow: false }) });\r\n        }\r\n    }\r\n    /** When a Filter is triggered or when user request it, we will refresh the filtered selection array and return it */\r\n    refreshFilteredRowSelections() {\r\n        let tmpFilteredArray = [];\r\n        const filteredDataset = this._dataView.getFilteredItems() || [];\r\n        if (Array.isArray(this._selectedRowDataContextIds)) {\r\n            const selectedFilteredRowDataContextIds = [...this._selectedRowDataContextIds]; // take a fresh copy of all selections before filtering the row ids\r\n            tmpFilteredArray = selectedFilteredRowDataContextIds.filter((selectedRowId) => {\r\n                return filteredDataset.findIndex((item) => item[this.datasetIdPropName] === selectedRowId) > -1;\r\n            });\r\n            this._selectedFilteredRowDataContextIds = tmpFilteredArray;\r\n        }\r\n        return tmpFilteredArray;\r\n    }\r\n};\r\nGridStateService = __decorate([\r\n    Injectable(),\r\n    __metadata(\"design:paramtypes\", [ExtensionService,\r\n        FilterService,\r\n        SharedService,\r\n        SortService])\r\n], GridStateService);\n\nlet highlightTimerEnd;\r\nconst GridServiceDeleteOptionDefaults = { triggerEvent: true };\r\nconst GridServiceInsertOptionDefaults = { highlightRow: true, position: 'top', resortGrid: false, selectRow: false, triggerEvent: true };\r\nconst GridServiceUpdateOptionDefaults = { highlightRow: true, selectRow: false, scrollRowIntoView: false, triggerEvent: true };\r\nlet GridService = class GridService {\r\n    constructor(extensionService, filterService, gridStateService, sortService) {\r\n        this.extensionService = extensionService;\r\n        this.filterService = filterService;\r\n        this.gridStateService = gridStateService;\r\n        this.sortService = sortService;\r\n        this.onItemAdded = new Subject();\r\n        this.onItemDeleted = new Subject();\r\n        this.onItemUpdated = new Subject();\r\n        this.onItemUpserted = new Subject();\r\n    }\r\n    /** Getter for the Grid Options pulled through the Grid Object */\r\n    get _gridOptions() {\r\n        return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};\r\n    }\r\n    init(grid, dataView) {\r\n        this._grid = grid;\r\n        this._dataView = dataView;\r\n    }\r\n    /** Clear all Filters & Sorts */\r\n    clearAllFiltersAndSorts() {\r\n        // call both clear Filters & Sort but only trigger the last one to avoid sending multiple backend queries\r\n        if (this.sortService && this.sortService.clearSorting) {\r\n            this.sortService.clearSorting(false); // skip event trigger on this one\r\n        }\r\n        if (this.filterService && this.filterService.clearFilters) {\r\n            this.filterService.clearFilters();\r\n        }\r\n    }\r\n    /**\r\n     * From a SlickGrid Event triggered get the Column Definition and Item Data Context\r\n     *\r\n     * For example the SlickGrid onClick will return cell arguments when subscribing to it.\r\n     * From these cellArgs, we want to get the Column Definition and Item Data\r\n     * @param cell event args\r\n     * @return object with columnDef and dataContext\r\n     */\r\n    getColumnFromEventArguments(args) {\r\n        if (!args || !args.grid || !args.grid.getColumns || !args.grid.getDataItem) {\r\n            throw new Error('To get the column definition and data, we need to have these arguments passed as objects (row, cell, grid)');\r\n        }\r\n        return {\r\n            row: args.row,\r\n            cell: args.cell,\r\n            columnDef: args.grid.getColumns()[args.cell],\r\n            dataContext: args.grid.getDataItem(args.row),\r\n            dataView: this._dataView,\r\n            grid: this._grid\r\n        };\r\n    }\r\n    /** Get data item by it's row index number */\r\n    getDataItemByRowNumber(rowNumber) {\r\n        if (!this._grid || typeof this._grid.getDataItem !== 'function') {\r\n            throw new Error(`We could not find SlickGrid Grid object or it's \"getDataItem\" method`);\r\n        }\r\n        return this._grid.getDataItem(rowNumber);\r\n    }\r\n    /** Chain the item Metadata with our implementation of Metadata at given row index */\r\n    getItemRowMetadataToHighlight(previousItemMetadata) {\r\n        return (rowNumber) => {\r\n            const item = this._dataView.getItem(rowNumber);\r\n            let meta = { cssClasses: '' };\r\n            if (typeof previousItemMetadata === 'function') {\r\n                meta = previousItemMetadata(rowNumber);\r\n            }\r\n            if (!meta) {\r\n                meta = { cssClasses: '' };\r\n            }\r\n            if (item && item._dirty) {\r\n                meta.cssClasses = (meta && meta.cssClasses || '') + ' dirty';\r\n            }\r\n            if (item && item.rowClass && meta) {\r\n                meta.cssClasses += ` ${item.rowClass}`;\r\n                meta.cssClasses += ` row${rowNumber}`;\r\n            }\r\n            return meta;\r\n        };\r\n    }\r\n    /**\r\n     * Highlight then fade a row for x seconds.\r\n     * The implementation follows this SO answer: https://stackoverflow.com/a/19985148/1212166\r\n     * @param rowNumber\r\n     * @param fadeDelay\r\n     */\r\n    highlightRow(rowNumber, fadeDelay = 1500, fadeOutDelay = 300) {\r\n        // create a SelectionModel if there's not one yet\r\n        if (!this._grid.getSelectionModel() && Slick && Slick.RowSelectionModel) {\r\n            const rowSelectionPlugin = new Slick.RowSelectionModel(this._gridOptions.rowSelectionOptions || {});\r\n            this._grid.setSelectionModel(rowSelectionPlugin);\r\n        }\r\n        if (Array.isArray(rowNumber)) {\r\n            rowNumber.forEach(row => this.highlightRowByMetadata(row, fadeDelay, fadeOutDelay));\r\n        }\r\n        else {\r\n            this.highlightRowByMetadata(rowNumber, fadeDelay, fadeOutDelay);\r\n        }\r\n    }\r\n    highlightRowByMetadata(rowNumber, fadeDelay = 1500, fadeOutDelay = 300) {\r\n        this._dataView.getItemMetadata = this.getItemRowMetadataToHighlight(this._dataView.getItemMetadata);\r\n        const item = this._dataView.getItem(rowNumber);\r\n        if (item && item.id) {\r\n            item.rowClass = 'highlight';\r\n            this._dataView.updateItem(item.id, item);\r\n            this.renderGrid();\r\n            // fade out\r\n            clearTimeout(highlightTimerEnd);\r\n            highlightTimerEnd = setTimeout(() => {\r\n                item.rowClass = 'highlight-end';\r\n                this._dataView.updateItem(item.id, item);\r\n                this.renderGrid();\r\n            }, fadeOutDelay);\r\n            // delete the row's CSS highlight classes once the delay is passed\r\n            setTimeout(() => {\r\n                if (item && item.id) {\r\n                    delete item.rowClass;\r\n                    if (this._dataView.getIdxById(item.id) !== undefined) {\r\n                        this._dataView.updateItem(item.id, item);\r\n                        this.renderGrid();\r\n                    }\r\n                }\r\n            }, fadeDelay + fadeOutDelay);\r\n        }\r\n    }\r\n    /** Get the Data Item from a grid row index */\r\n    getDataItemByRowIndex(index) {\r\n        if (!this._grid || typeof this._grid.getDataItem !== 'function') {\r\n            throw new Error('We could not find SlickGrid Grid object and/or \"getDataItem\" method');\r\n        }\r\n        return this._grid.getDataItem(index);\r\n    }\r\n    /** Get the Data Item from an array of grid row indexes */\r\n    getDataItemByRowIndexes(indexes) {\r\n        if (!this._grid || typeof this._grid.getDataItem !== 'function') {\r\n            throw new Error('We could not find SlickGrid Grid object and/or \"getDataItem\" method');\r\n        }\r\n        const dataItems = [];\r\n        if (Array.isArray(indexes)) {\r\n            indexes.forEach((idx) => {\r\n                dataItems.push(this._grid.getDataItem(idx));\r\n            });\r\n        }\r\n        return dataItems;\r\n    }\r\n    /** Get the currently selected row indexes */\r\n    getSelectedRows() {\r\n        if (!this._grid || typeof this._grid.getSelectedRows !== 'function') {\r\n            throw new Error('We could not find SlickGrid Grid object and/or \"getSelectedRows\" method');\r\n        }\r\n        return this._grid.getSelectedRows();\r\n    }\r\n    /** Get the currently selected rows item data */\r\n    getSelectedRowsDataItem() {\r\n        if (!this._grid || typeof this._grid.getSelectedRows !== 'function') {\r\n            throw new Error('We could not find SlickGrid Grid object and/or \"getSelectedRows\" method');\r\n        }\r\n        const selectedRowIndexes = this._grid.getSelectedRows();\r\n        return this.getDataItemByRowIndexes(selectedRowIndexes);\r\n    }\r\n    /** Select the selected row by a row index */\r\n    setSelectedRow(rowIndex) {\r\n        if (this._grid && this._grid.setSelectedRows) {\r\n            this._grid.setSelectedRows([rowIndex]);\r\n        }\r\n    }\r\n    /** Set selected rows with provided array of row indexes */\r\n    setSelectedRows(rowIndexes) {\r\n        if (this._grid && this._grid.setSelectedRows) {\r\n            this._grid.setSelectedRows(rowIndexes);\r\n        }\r\n    }\r\n    /** Re-Render the Grid */\r\n    renderGrid() {\r\n        if (this._grid && typeof this._grid.invalidate === 'function') {\r\n            this._grid.invalidate();\r\n            this._grid.render();\r\n        }\r\n    }\r\n    /**\r\n     * Reset the grid to it's original state (clear any filters, sorting & pagination if exists) .\r\n     * The column definitions could be passed as argument to reset (this can be used after a Grid State reset)\r\n     * The reset will clear the Filters & Sort, then will reset the Columns to their original state\r\n     */\r\n    resetGrid(columnDefinitions) {\r\n        // reset columns to original states & refresh the grid\r\n        if (this._grid && this._dataView) {\r\n            const originalColumns = this.extensionService.getAllColumns();\r\n            if (Array.isArray(originalColumns) && originalColumns.length > 0) {\r\n                // set the grid columns to it's original column definitions\r\n                this._grid.setColumns(originalColumns);\r\n                if (this._gridOptions && this._gridOptions.enableAutoSizeColumns) {\r\n                    this._grid.autosizeColumns();\r\n                }\r\n                this.gridStateService.resetColumns(columnDefinitions);\r\n            }\r\n        }\r\n        if (this.filterService && this.filterService.clearFilters) {\r\n            this.filterService.clearFilters();\r\n        }\r\n        if (this.sortService && this.sortService.clearSorting) {\r\n            this.sortService.clearSorting();\r\n        }\r\n    }\r\n    /** @deprecated please use \"addItem\" method instead */\r\n    addItemToDatagrid(item, shouldHighlightRow = true, shouldResortGrid = false, shouldTriggerEvent = true, shouldSelectRow = true) {\r\n        console.warn('[Angular-Slickgrid - GridService] please consider using the new \"addItem\" method since \"addItemToDatagrid\" will be deprecated in the future.');\r\n        return this.addItem(item, { highlightRow: shouldHighlightRow, resortGrid: shouldResortGrid, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });\r\n    }\r\n    /** @deprecated please use \"addItems\" method instead */\r\n    addItemsToDatagrid(items, shouldHighlightRow = true, shouldResortGrid = false, shouldTriggerEvent = true, shouldSelectRow = true) {\r\n        console.warn('[Angular-Slickgrid - GridService] please consider using the new \"addItems\" method since \"addItemsToDatagrid\" will be deprecated in the future.');\r\n        return this.addItems(items, { highlightRow: shouldHighlightRow, resortGrid: shouldResortGrid, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });\r\n    }\r\n    /**\r\n     * Add an item (data item) to the datagrid, by default it will highlight (flashing) the inserted row but we can disable it too\r\n     * @param item object which must contain a unique \"id\" property and any other suitable properties\r\n     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)\r\n     * @return rowIndex: typically index 0 when adding to position \"top\" or a different number when adding to the \"bottom\"\r\n     */\r\n    addItem(item, options) {\r\n        options = Object.assign({}, GridServiceInsertOptionDefaults, options);\r\n        if (!this._grid || !this._gridOptions || !this._dataView) {\r\n            throw new Error('We could not find SlickGrid Grid, DataView objects');\r\n        }\r\n        if (!item || !item.hasOwnProperty('id')) {\r\n            throw new Error(`Adding an item requires the item to include an \"id\" property`);\r\n        }\r\n        // insert position top/bottom, defaults to top\r\n        // when position is top we'll call insert at index 0, else call addItem which just push to the DataView array\r\n        if (options && options.position === 'bottom') {\r\n            this._dataView.addItem(item);\r\n        }\r\n        else {\r\n            this._dataView.insertItem(0, item); // insert at index 0\r\n        }\r\n        // row number in the grid, by default it will be on first row (top is the default)\r\n        let rowNumber = 0;\r\n        // do we want the item to be sorted in the grid, when set to False it will insert on first row (defaults to false)\r\n        if (options.resortGrid) {\r\n            this._dataView.reSort();\r\n            // find the row number in the grid and if user wanted to see highlighted row\r\n            // we need to do it here after resort and get each row number because it possibly changes after the sort\r\n            rowNumber = this._dataView.getRowById(item.id);\r\n        }\r\n        else {\r\n            // scroll to row index 0 when inserting on top else scroll to the bottom where it got inserted\r\n            rowNumber = (options && options.position === 'bottom') ? this._dataView.getRowById(item.id) : 0;\r\n            this._grid.scrollRowIntoView(rowNumber);\r\n        }\r\n        // if highlight is enabled, we'll highlight the row we just added\r\n        if (options.highlightRow) {\r\n            this.highlightRow(rowNumber);\r\n        }\r\n        // if row selection (checkbox selector) is enabled, we'll select the row in the grid\r\n        if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {\r\n            this.setSelectedRow(rowNumber);\r\n        }\r\n        // do we want to trigger an event after adding the item\r\n        if (options.triggerEvent) {\r\n            this.onItemAdded.next(item);\r\n        }\r\n        return rowNumber;\r\n    }\r\n    /**\r\n     * Add item array (data item) to the datagrid, by default it will highlight (flashing) the inserted row but we can disable it too\r\n     * @param item object arrays, which must contain unique \"id\" property and any other suitable properties\r\n     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)\r\n     */\r\n    addItems(items, options) {\r\n        options = Object.assign({}, GridServiceInsertOptionDefaults, options);\r\n        const rowNumbers = [];\r\n        // loop through all items to add\r\n        if (!Array.isArray(items)) {\r\n            return [this.addItem(items, options)];\r\n        }\r\n        else {\r\n            items.forEach((item) => this.addItem(item, Object.assign({}, options, { highlightRow: false, resortGrid: false, triggerEvent: false, selectRow: false })));\r\n        }\r\n        // do we want the item to be sorted in the grid, when set to False it will insert on first row (defaults to false)\r\n        if (options.resortGrid) {\r\n            this._dataView.reSort();\r\n        }\r\n        // scroll to row index 0 when inserting on top else scroll to the bottom where it got inserted\r\n        (options && options.position === 'bottom') ? this._grid.navigateBottom() : this._grid.navigateTop();\r\n        // get row numbers of all new inserted items\r\n        // we need to do it after resort and get each row number because it possibly changed after the sort\r\n        items.forEach((item) => rowNumbers.push(this._dataView.getRowById(item.id)));\r\n        // if user wanted to see highlighted row\r\n        if (options.highlightRow) {\r\n            this.highlightRow(rowNumbers);\r\n        }\r\n        // select the row in the grid\r\n        if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {\r\n            this.setSelectedRows(rowNumbers);\r\n        }\r\n        // do we want to trigger an event after adding the item\r\n        if (options.triggerEvent) {\r\n            this.onItemAdded.next(items);\r\n        }\r\n        return rowNumbers;\r\n    }\r\n    /** @deprecated please use \"deleteItem\" method instead */\r\n    deleteDataGridItem(item, shouldTriggerEvent = true) {\r\n        console.warn('[Angular-Slickgrid - GridService] please consider using the new \"deleteItem\" method since \"deleteDataGridItem\" will be deprecated in the future.');\r\n        this.deleteItem(item, { triggerEvent: shouldTriggerEvent });\r\n    }\r\n    /** @deprecated please use \"deleteItems\" method instead */\r\n    deleteDataGridItems(items, shouldTriggerEvent = true) {\r\n        console.warn('[Angular-Slickgrid - GridService] please consider using the new \"deleteItems\" method since \"deleteDataGridItems\" will be deprecated in the future.');\r\n        this.deleteItems(items, { triggerEvent: shouldTriggerEvent });\r\n    }\r\n    /** @deprecated please use \"deleteItemById\" method instead */\r\n    deleteDataGridItemById(itemId, shouldTriggerEvent = true) {\r\n        console.warn('[Angular-Slickgrid - GridService] please consider using the new \"deleteItemById\" method since \"deleteDataGridItemById\" will be deprecated in the future.');\r\n        this.deleteItemById(itemId, { triggerEvent: shouldTriggerEvent });\r\n    }\r\n    /** @deprecated please use \"deleteItemByIds\" method instead */\r\n    deleteDataGridItemByIds(itemIds, shouldTriggerEvent = true) {\r\n        console.warn('[Angular-Slickgrid - GridService] please consider using the new \"deleteItemByIds\" method since \"deleteDataGridItemByIds\" will be deprecated in the future.');\r\n        this.deleteItemByIds(itemIds, { triggerEvent: shouldTriggerEvent });\r\n    }\r\n    /**\r\n     * Delete an existing item from the datagrid (dataView)\r\n     * @param item object which must contain a unique \"id\" property and any other suitable properties\r\n     * @param options: provide the possibility to do certain actions after or during the upsert (triggerEvent)\r\n     * @return item id deleted\r\n     */\r\n    deleteItem(item, options) {\r\n        options = Object.assign({}, GridServiceDeleteOptionDefaults, options);\r\n        if (!item || !item.hasOwnProperty('id')) {\r\n            throw new Error(`Deleting an item requires the item to include an \"id\" property`);\r\n        }\r\n        return this.deleteItemById(item.id, options);\r\n    }\r\n    /**\r\n     * Delete an array of existing items from the datagrid\r\n     * @param item object which must contain a unique \"id\" property and any other suitable properties\r\n     * @param options: provide the possibility to do certain actions after or during the upsert (triggerEvent)\r\n     * @return item id deleted\r\n     */\r\n    deleteItems(items, options) {\r\n        options = Object.assign({}, GridServiceDeleteOptionDefaults, options);\r\n        // when it's not an array, we can call directly the single item delete\r\n        if (!Array.isArray(items)) {\r\n            this.deleteItem(items, options);\r\n            return [items.id];\r\n        }\r\n        const itemIds = [];\r\n        items.forEach((item) => {\r\n            if (item && item.id !== undefined) {\r\n                itemIds.push(item.id);\r\n            }\r\n            this.deleteItem(item, Object.assign({}, options, { triggerEvent: false }));\r\n        });\r\n        // do we want to trigger an event after deleting the item\r\n        if (options.triggerEvent) {\r\n            this.onItemDeleted.next(items);\r\n        }\r\n        return itemIds;\r\n    }\r\n    /**\r\n     * Delete an existing item from the datagrid (dataView) by it's id\r\n     * @param itemId: item unique id\r\n     * @param options: provide the possibility to do certain actions after or during the upsert (triggerEvent)\r\n     * @return item id deleted\r\n     */\r\n    deleteItemById(itemId, options) {\r\n        options = Object.assign({}, GridServiceDeleteOptionDefaults, options);\r\n        if (itemId === null || itemId === undefined) {\r\n            throw new Error(`Cannot delete a row without a valid \"id\"`);\r\n        }\r\n        // when user has row selection enabled, we should clear any selection to avoid confusion after a delete\r\n        const isSyncGridSelectionEnabled = this.gridStateService && this.gridStateService.needToPreserveRowSelection() || false;\r\n        if (!isSyncGridSelectionEnabled && this._grid && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {\r\n            this.setSelectedRows([]);\r\n        }\r\n        // delete the item from the dataView\r\n        this._dataView.deleteItem(itemId);\r\n        // do we want to trigger an event after deleting the item\r\n        if (options.triggerEvent) {\r\n            this.onItemDeleted.next(itemId);\r\n        }\r\n        return itemId;\r\n    }\r\n    /**\r\n     * Delete an array of existing items from the datagrid\r\n     * @param itemIds array of item unique IDs\r\n     * @param options: provide the possibility to do certain actions after or during the upsert (triggerEvent)\r\n     */\r\n    deleteItemByIds(itemIds, options) {\r\n        options = Object.assign({}, GridServiceDeleteOptionDefaults, options);\r\n        // when it's not an array, we can call directly the single item delete\r\n        if (Array.isArray(itemIds)) {\r\n            for (let i = 0; i < itemIds.length; i++) {\r\n                if (itemIds[i] !== null) {\r\n                    this.deleteItemById(itemIds[i], { triggerEvent: false });\r\n                }\r\n            }\r\n            // do we want to trigger an event after deleting the item\r\n            if (options.triggerEvent) {\r\n                this.onItemDeleted.next(itemIds);\r\n            }\r\n            return itemIds;\r\n        }\r\n        return [];\r\n    }\r\n    /** @deprecated please use \"updateItem\" method instead */\r\n    updateDataGridItem(item, shouldHighlightRow = true, shouldTriggerEvent = true, shouldSelectRow = true) {\r\n        console.warn('[Angular-Slickgrid - GridService] please consider using the new \"updateItem\" method since \"updateDataGridItem\" will be deprecated in the future.');\r\n        return this.updateItem(item, { highlightRow: shouldHighlightRow, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });\r\n    }\r\n    /** @deprecated please use \"updateItems\" method instead */\r\n    updateDataGridItems(items, shouldHighlightRow = true, shouldTriggerEvent = true, shouldSelectRow = true) {\r\n        console.warn('[Angular-Slickgrid - GridService] please consider using the new \"updateItems\" method since \"updateDataGridItems\" will be deprecated in the future.');\r\n        return this.updateItems(items, { highlightRow: shouldHighlightRow, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });\r\n    }\r\n    /** @deprecated please use \"updateItemById\" method instead */\r\n    updateDataGridItemById(itemId, item, shouldHighlightRow = true, shouldTriggerEvent = true, shouldSelectRow = true) {\r\n        console.warn('[Angular-Slickgrid - GridService] please consider using the new \"updateItemById\" method since \"updateDataGridItemById\" will be deprecated in the future.');\r\n        return this.updateItemById(itemId, item, { highlightRow: shouldHighlightRow, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });\r\n    }\r\n    /**\r\n     * Update an existing item with new properties inside the datagrid\r\n     * @param item object which must contain a unique \"id\" property and any other suitable properties\r\n     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, selectRow, triggerEvent)\r\n     * @return grid row index\r\n     */\r\n    updateItem(item, options) {\r\n        options = Object.assign({}, GridServiceUpdateOptionDefaults, options);\r\n        const itemId = (!item || !item.hasOwnProperty('id')) ? undefined : item.id;\r\n        if (itemId === undefined) {\r\n            throw new Error(`Calling Update of an item requires the item to include an \"id\" property`);\r\n        }\r\n        return this.updateItemById(itemId, item, options);\r\n    }\r\n    /**\r\n     * Update an array of existing items with new properties inside the datagrid\r\n     * @param item object arrays, which must contain unique \"id\" property and any other suitable properties\r\n     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, selectRow, triggerEvent)\r\n     * @return grid row indexes\r\n     */\r\n    updateItems(items, options) {\r\n        options = Object.assign({}, GridServiceUpdateOptionDefaults, options);\r\n        // when it's not an array, we can call directly the single item update\r\n        if (!Array.isArray(items)) {\r\n            return [this.updateItem(items, options)];\r\n        }\r\n        const gridRowNumbers = [];\r\n        items.forEach((item) => {\r\n            gridRowNumbers.push(this.updateItem(item, Object.assign({}, options, { highlightRow: false, selectRow: false, triggerEvent: false })));\r\n        });\r\n        // only highlight at the end, all at once\r\n        // we have to do this because doing highlight 1 by 1 would only re-select the last highlighted row which is wrong behavior\r\n        if (options.highlightRow) {\r\n            this.highlightRow(gridRowNumbers);\r\n        }\r\n        // select the row in the grid\r\n        if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {\r\n            this.setSelectedRows(gridRowNumbers);\r\n        }\r\n        // do we want to trigger an event after updating the item\r\n        if (options.triggerEvent) {\r\n            this.onItemUpdated.next(items);\r\n        }\r\n        return gridRowNumbers;\r\n    }\r\n    /**\r\n     * Update an existing item in the datagrid by it's id and new properties\r\n     * @param itemId: item unique id\r\n     * @param item object which must contain a unique \"id\" property and any other suitable properties\r\n     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, selectRow, triggerEvent)\r\n     * @return grid row number\r\n     */\r\n    updateItemById(itemId, item, options) {\r\n        options = Object.assign({}, GridServiceUpdateOptionDefaults, options);\r\n        if (itemId === undefined) {\r\n            throw new Error(`Cannot update a row without a valid \"id\"`);\r\n        }\r\n        const rowNumber = this._dataView.getRowById(itemId);\r\n        if (!item || rowNumber === undefined) {\r\n            throw new Error(`The item to update in the grid was not found with id: ${itemId}`);\r\n        }\r\n        if (this._dataView.getIdxById(itemId) !== undefined) {\r\n            // Update the item itself inside the dataView\r\n            this._dataView.updateItem(itemId, item);\r\n            this._grid.updateRow(rowNumber);\r\n            // do we want to scroll to the row so that it shows in the Viewport (UI)\r\n            if (options.scrollRowIntoView) {\r\n                this._grid.scrollRowIntoView(rowNumber);\r\n            }\r\n            // highlight the row we just updated, if defined\r\n            if (options.highlightRow) {\r\n                this.highlightRow(rowNumber);\r\n            }\r\n            // select the row in the grid\r\n            if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {\r\n                this.setSelectedRow(rowNumber);\r\n            }\r\n            // do we want to trigger an event after updating the item\r\n            if (options.triggerEvent) {\r\n                this.onItemUpdated.next(item);\r\n            }\r\n        }\r\n        return rowNumber;\r\n    }\r\n    /**\r\n     * Insert a row into the grid if it doesn't already exist or update if it does.\r\n     * @param item object which must contain a unique \"id\" property and any other suitable properties\r\n     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)\r\n     */\r\n    upsertItem(item, options) {\r\n        options = Object.assign({}, GridServiceInsertOptionDefaults, options);\r\n        const itemId = (!item || !item.hasOwnProperty('id')) ? undefined : item.id;\r\n        if (itemId === undefined) {\r\n            throw new Error(`Calling Upsert of an item requires the item to include an \"id\" property`);\r\n        }\r\n        return this.upsertItemById(itemId, item, options);\r\n    }\r\n    /**\r\n     * Update an array of existing items with new properties inside the datagrid\r\n     * @param item object arrays, which must contain unique \"id\" property and any other suitable properties\r\n     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)\r\n     * @return row numbers in the grid\r\n     */\r\n    upsertItems(items, options) {\r\n        options = Object.assign({}, GridServiceInsertOptionDefaults, options);\r\n        // when it's not an array, we can call directly the single item update\r\n        if (!Array.isArray(items)) {\r\n            return [this.upsertItem(items, options)];\r\n        }\r\n        const upsertedRows = [];\r\n        items.forEach((item) => {\r\n            upsertedRows.push(this.upsertItem(item, Object.assign({}, options, { highlightRow: false, resortGrid: false, selectRow: false, triggerEvent: false })));\r\n        });\r\n        const rowNumbers = upsertedRows.map((upsertRow) => upsertRow.added !== undefined ? upsertRow.added : upsertRow.updated);\r\n        // only highlight at the end, all at once\r\n        // we have to do this because doing highlight 1 by 1 would only re-select the last highlighted row which is wrong behavior\r\n        if (options.highlightRow) {\r\n            this.highlightRow(rowNumbers);\r\n        }\r\n        // select the row in the grid\r\n        if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {\r\n            this.setSelectedRows(rowNumbers);\r\n        }\r\n        // do we want to trigger an event after updating the item\r\n        if (options.triggerEvent) {\r\n            this.onItemUpserted.next(items);\r\n            const addedItems = upsertedRows.filter((upsertRow) => upsertRow.added !== undefined);\r\n            if (Array.isArray(addedItems) && addedItems.length > 0) {\r\n                this.onItemAdded.next(addedItems);\r\n            }\r\n            const updatedItems = upsertedRows.filter((upsertRow) => upsertRow.updated !== undefined);\r\n            if (Array.isArray(updatedItems) && updatedItems.length > 0) {\r\n                this.onItemUpdated.next(updatedItems);\r\n            }\r\n        }\r\n        return upsertedRows;\r\n    }\r\n    /**\r\n     * Update an existing item in the datagrid by it's id and new properties\r\n     * @param itemId: item unique id\r\n     * @param item object which must contain a unique \"id\" property and any other suitable properties\r\n     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)\r\n     * @return grid row number in the grid\r\n     */\r\n    upsertItemById(itemId, item, options) {\r\n        let isItemAdded = false;\r\n        options = Object.assign({}, GridServiceInsertOptionDefaults, options);\r\n        if (itemId === undefined) {\r\n            throw new Error(`Calling Upsert of an item requires the item to include a valid and unique \"id\" property`);\r\n        }\r\n        let rowNumberAdded;\r\n        let rowNumberUpdated;\r\n        if (this._dataView.getRowById(itemId) === undefined) {\r\n            rowNumberAdded = this.addItem(item, options);\r\n            isItemAdded = true;\r\n        }\r\n        else {\r\n            rowNumberUpdated = this.updateItem(item, { highlightRow: options.highlightRow, selectRow: options.selectRow, triggerEvent: options.triggerEvent });\r\n            isItemAdded = false;\r\n        }\r\n        // do we want to trigger an event after updating the item\r\n        if (options.triggerEvent) {\r\n            this.onItemUpserted.next(item);\r\n            isItemAdded ? this.onItemAdded.next(item) : this.onItemUpdated.next(item);\r\n        }\r\n        return { added: rowNumberAdded, updated: rowNumberUpdated };\r\n    }\r\n};\r\nGridService = __decorate([\r\n    Injectable(),\r\n    __metadata(\"design:paramtypes\", [ExtensionService,\r\n        FilterService,\r\n        GridStateService,\r\n        SortService])\r\n], GridService);\n\n// global constants, height/width are in pixels\r\nconst DATAGRID_MIN_HEIGHT = 180;\r\nconst DATAGRID_MIN_WIDTH = 300;\r\nconst DATAGRID_BOTTOM_PADDING = 20;\r\nconst DATAGRID_FOOTER_HEIGHT = 20;\r\nconst DATAGRID_PAGINATION_HEIGHT = 35;\r\nclass ResizerService {\r\n    constructor() {\r\n        this._resizePaused = false;\r\n        this.onGridAfterResize = new Subject();\r\n        this.onGridBeforeResize = new Subject();\r\n    }\r\n    /** Getter for the Grid Options pulled through the Grid Object */\r\n    get _gridOptions() {\r\n        return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};\r\n    }\r\n    get _gridUid() {\r\n        return (this._grid && this._grid.getUID) ? this._grid.getUID() : this._gridOptions && this._gridOptions.gridId;\r\n    }\r\n    init(grid, fixedDimensions) {\r\n        this._grid = grid;\r\n        if (fixedDimensions) {\r\n            this._fixedHeight = fixedDimensions.height;\r\n            this._fixedWidth = fixedDimensions.width;\r\n        }\r\n    }\r\n    /** Bind an auto resize trigger on the datagrid, if that is enable then it will resize itself to the available space\r\n     * Options: we could also provide a % factor to resize on each height/width independently\r\n     */\r\n    bindAutoResizeDataGrid(newSizes) {\r\n        // if we can't find the grid to resize, return without binding anything\r\n        const gridDomElm = $(`#${this._gridOptions && this._gridOptions.gridId ? this._gridOptions.gridId : 'grid1'}`);\r\n        if (gridDomElm === undefined || gridDomElm.offset() === undefined) {\r\n            return null;\r\n        }\r\n        // -- 1st resize the datagrid size at first load (we need this because the .on event is not triggered on first load)\r\n        // -- also we add a slight delay (in ms) so that we resize after the grid render is done\r\n        this.resizeGrid(10, newSizes);\r\n        // -- 2nd bind a trigger on the Window DOM element, so that it happens also when resizing after first load\r\n        // -- bind auto-resize to Window object only if it exist\r\n        $(window).on(`resize.grid.${this._gridUid}`, (event) => {\r\n            this.onGridBeforeResize.next(event);\r\n            if (!this._resizePaused) {\r\n                this.resizeGrid(0, newSizes);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Calculate the datagrid new height/width from the available space, also consider that a % factor might be applied to calculation\r\n     * object gridOptions\r\n     */\r\n    calculateGridNewDimensions(gridOptions) {\r\n        const gridDomElm = $(`#${gridOptions.gridId}`);\r\n        const autoResizeOptions = gridOptions && gridOptions.autoResize || {};\r\n        const containerElm = (autoResizeOptions && autoResizeOptions.containerId) ? $(`#${autoResizeOptions.containerId}`) : $(`#${gridOptions.gridContainerId}`);\r\n        if (!window || containerElm === undefined || gridDomElm === undefined || gridDomElm.offset() === undefined) {\r\n            return null;\r\n        }\r\n        // calculate bottom padding\r\n        // if using pagination, we need to add the pagination height to this bottom padding\r\n        let bottomPadding = (autoResizeOptions && autoResizeOptions.bottomPadding) ? autoResizeOptions.bottomPadding : DATAGRID_BOTTOM_PADDING;\r\n        if (bottomPadding && gridOptions.enablePagination) {\r\n            bottomPadding += DATAGRID_PAGINATION_HEIGHT;\r\n        }\r\n        // optionally show a custom footer with the data metrics (dataset length and last updated timestamp)\r\n        if (bottomPadding && gridOptions.showCustomFooter) {\r\n            bottomPadding += gridOptions.customFooterOptions && gridOptions.customFooterOptions.footerHeight || DATAGRID_FOOTER_HEIGHT;\r\n        }\r\n        let gridHeight = 0;\r\n        let gridOffsetTop = 0;\r\n        // which DOM element are we using to calculate the available size for the grid?\r\n        if (autoResizeOptions.calculateAvailableSizeBy === 'container') {\r\n            // uses the container's height to calculate grid height without any top offset\r\n            gridHeight = containerElm.height() || 0;\r\n        }\r\n        else {\r\n            // uses the browser's window height with its top offset to calculate grid height\r\n            gridHeight = window.innerHeight || 0;\r\n            const coordOffsetTop = gridDomElm.offset();\r\n            gridOffsetTop = (coordOffsetTop !== undefined) ? coordOffsetTop.top : 0;\r\n        }\r\n        const availableHeight = gridHeight - gridOffsetTop - bottomPadding;\r\n        const availableWidth = containerElm.width() || window.innerWidth || 0;\r\n        const maxHeight = autoResizeOptions && autoResizeOptions.maxHeight || undefined;\r\n        const minHeight = autoResizeOptions && autoResizeOptions.minHeight || DATAGRID_MIN_HEIGHT;\r\n        const maxWidth = autoResizeOptions && autoResizeOptions.maxWidth || undefined;\r\n        const minWidth = autoResizeOptions && autoResizeOptions.minWidth || DATAGRID_MIN_WIDTH;\r\n        let newHeight = availableHeight;\r\n        let newWidth = (autoResizeOptions && autoResizeOptions.sidePadding) ? availableWidth - autoResizeOptions.sidePadding : availableWidth;\r\n        // optionally (when defined), make sure that grid height & width are within their thresholds\r\n        if (newHeight < minHeight) {\r\n            newHeight = minHeight;\r\n        }\r\n        if (maxHeight && newHeight > maxHeight) {\r\n            newHeight = maxHeight;\r\n        }\r\n        if (newWidth < minWidth) {\r\n            newWidth = minWidth;\r\n        }\r\n        if (maxWidth && newWidth > maxWidth) {\r\n            newWidth = maxWidth;\r\n        }\r\n        // return the new dimensions unless a fixed height/width was defined\r\n        return {\r\n            height: this._fixedHeight || newHeight,\r\n            width: this._fixedWidth || newWidth\r\n        };\r\n    }\r\n    /**\r\n     * Dispose function when element is destroyed\r\n     */\r\n    dispose() {\r\n        $(window).off(`resize.grid.${this._gridUid}`);\r\n    }\r\n    /**\r\n     * For some reason this only seems to happen in Chrome and is sometime miscalculated by SlickGrid measureSrollbar() method\r\n     * When that happens we will compensate and resize the Grid Viewport to avoid seeing horizontal scrollbar\r\n     * Most of the time it happens, it's a tiny offset calculation of usually 3px (enough to show scrollbar)\r\n     * GitHub issue reference: https://github.com/6pac/SlickGrid/issues/275\r\n     */\r\n    compensateHorizontalScroll(grid, gridOptions) {\r\n        const gridElm = $(`#${gridOptions.gridId}`);\r\n        const scrollbarDimensions = grid && grid.getScrollbarDimensions();\r\n        const slickGridScrollbarWidth = scrollbarDimensions && scrollbarDimensions.width;\r\n        const calculatedScrollbarWidth = getScrollBarWidth();\r\n        // if scrollbar width is different from SlickGrid calculation to our custom calculation\r\n        // then resize the grid with the missing pixels to remove scroll (usually only 3px)\r\n        if (slickGridScrollbarWidth < calculatedScrollbarWidth) {\r\n            gridElm.width(gridElm.width() + (calculatedScrollbarWidth - slickGridScrollbarWidth));\r\n        }\r\n    }\r\n    /**\r\n     * Return the last resize dimensions used by the service\r\n     * @return last dimensions\r\n     */\r\n    getLastResizeDimensions() {\r\n        return this._lastDimensions;\r\n    }\r\n    /** Provide the possibility to pause the resizer for some time, until user decides to re-enabled it later if he wish to. */\r\n    pauseResizer(isResizePaused) {\r\n        this._resizePaused = isResizePaused;\r\n    }\r\n    /** Resize the datagrid to fit the browser height & width */\r\n    resizeGrid(delay = 10, newSizes) {\r\n        if (!this._grid || !this._gridOptions) {\r\n            throw new Error(`\r\n      Angular-Slickgrid resizer requires a valid Grid object and Grid Options defined.\r\n      You can fix this by setting your gridOption to use \"enableAutoResize\" or create an instance of the ResizerService by calling bindAutoResizeDataGrid()`);\r\n        }\r\n        return new Promise((resolve) => {\r\n            // because of the javascript async nature, we might want to delay the resize a little bit\r\n            delay = delay || 0;\r\n            if (delay > 0) {\r\n                clearTimeout(this._timer);\r\n                this._timer = setTimeout(() => resolve(this.resizeGridCallback(newSizes)), delay);\r\n            }\r\n            else {\r\n                resolve(this.resizeGridCallback(newSizes));\r\n            }\r\n        });\r\n    }\r\n    resizeGridCallback(newSizes) {\r\n        const lastDimensions = this.resizeGridWithDimensions(newSizes);\r\n        this.onGridAfterResize.next(lastDimensions);\r\n        return lastDimensions;\r\n    }\r\n    resizeGridWithDimensions(newSizes) {\r\n        // calculate the available sizes with minimum height defined as a constant\r\n        const availableDimensions = this.calculateGridNewDimensions(this._gridOptions);\r\n        const gridElm = $(`#${this._gridOptions.gridId}`) || {};\r\n        const gridContainerElm = $(`#${this._gridOptions.gridContainerId}`) || {};\r\n        if ((newSizes || availableDimensions) && gridElm.length > 0) {\r\n            // get the new sizes, if new sizes are passed (not 0), we will use them else use available space\r\n            // basically if user passes 1 of the dimension, let say he passes just the height,\r\n            // we will use the height as a fixed height but the width will be resized by it's available space\r\n            const newHeight = (newSizes && newSizes.height) ? newSizes.height : availableDimensions.height;\r\n            const newWidth = (newSizes && newSizes.width) ? newSizes.width : availableDimensions.width;\r\n            // apply these new height/width to the datagrid\r\n            if (!this._gridOptions.autoHeight) {\r\n                gridElm.height(newHeight);\r\n                gridContainerElm.height(newHeight);\r\n            }\r\n            gridElm.width(newWidth);\r\n            gridContainerElm.width(newWidth);\r\n            // resize the slickgrid canvas on all browser except some IE versions\r\n            // exclude all IE below IE11\r\n            // IE11 wants to be a better standard (W3C) follower (finally) they even changed their appName output to also have 'Netscape'\r\n            if (new RegExp('MSIE [6-8]').exec(navigator.userAgent) === null && this._grid && this._grid.resizeCanvas) {\r\n                this._grid.resizeCanvas();\r\n            }\r\n            // also call the grid auto-size columns so that it takes available when going bigger\r\n            if (this._gridOptions && this._gridOptions.enableAutoSizeColumns && this._grid.autosizeColumns) {\r\n                // make sure that the grid still exist (by looking if the Grid UID is found in the DOM tree) to avoid SlickGrid error \"missing stylesheet\"\r\n                if (this._gridUid && $(`.${this._gridUid}`).length > 0) {\r\n                    this._grid.autosizeColumns();\r\n                }\r\n                // compensate anytime SlickGrid measureScrollbar is incorrect\r\n                this.compensateHorizontalScroll(this._grid, this._gridOptions);\r\n            }\r\n            // keep last resized dimensions & resolve them to the Promise\r\n            this._lastDimensions = {\r\n                height: newHeight,\r\n                width: newWidth\r\n            };\r\n            if ((this._gridOptions.enablePagination || this._gridOptions.backendServiceApi)) {\r\n                this._lastDimensions.heightWithPagination = newHeight + DATAGRID_PAGINATION_HEIGHT;\r\n            }\r\n        }\r\n        return this._lastDimensions;\r\n    }\r\n}\n\nlet GroupingAndColspanService = class GroupingAndColspanService {\r\n    constructor(resizerService, translate) {\r\n        this.resizerService = resizerService;\r\n        this.translate = translate;\r\n        this._eventHandler = new Slick.EventHandler();\r\n    }\r\n    /** Getter of the SlickGrid Event Handler */\r\n    get eventHandler() {\r\n        return this._eventHandler;\r\n    }\r\n    /** Getter for the Grid Options pulled through the Grid Object */\r\n    get _gridOptions() {\r\n        return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};\r\n    }\r\n    /** Getter for the Column Definitions pulled through the Grid Object */\r\n    get _columnDefinitions() {\r\n        return (this._grid && this._grid.getColumns) ? this._grid.getColumns() : [];\r\n    }\r\n    init(grid, dataView) {\r\n        this._grid = grid;\r\n        if (grid && this._gridOptions) {\r\n            // When dealing with Pre-Header Grouping colspan, we need to re-create the pre-header in multiple occasions\r\n            // for all these events, we have to trigger a re-create\r\n            if (this._gridOptions.createPreHeaderPanel) {\r\n                // on all following events, call the\r\n                this._eventHandler.subscribe(grid.onSort, () => this.renderPreHeaderRowGroupingTitles());\r\n                this._eventHandler.subscribe(grid.onColumnsResized, () => this.renderPreHeaderRowGroupingTitles());\r\n                this._eventHandler.subscribe(grid.onColumnsReordered, () => this.renderPreHeaderRowGroupingTitles());\r\n                this._eventHandler.subscribe(dataView.onRowCountChanged, () => this.renderPreHeaderRowGroupingTitles());\r\n                this.resizerService.onGridAfterResize.subscribe(() => this.renderPreHeaderRowGroupingTitles());\r\n                // if we use Translation, we need to re-translate the keys after a language change\r\n                if (this._gridOptions.enableTranslate) {\r\n                    this.translate.onLangChange.subscribe(() => {\r\n                        const currentColumnDefinitions = this._grid.getColumns();\r\n                        this.translateItems(currentColumnDefinitions, 'columnGroupKey', 'columnGroup');\r\n                        this._grid.setColumns(currentColumnDefinitions);\r\n                        this.renderPreHeaderRowGroupingTitles();\r\n                    });\r\n                }\r\n                // also not sure why at this point, but it seems that I need to call the 1st create in a delayed execution\r\n                // probably some kind of timing issues and delaying it until the grid is fully ready does help\r\n                setTimeout(() => this.renderPreHeaderRowGroupingTitles(), 50);\r\n            }\r\n        }\r\n    }\r\n    dispose() {\r\n        // unsubscribe all SlickGrid events\r\n        this._eventHandler.unsubscribeAll();\r\n    }\r\n    /** Create or Render the Pre-Header Row Grouping Titles */\r\n    renderPreHeaderRowGroupingTitles() {\r\n        if (this._gridOptions && this._gridOptions.frozenColumn !== undefined && this._gridOptions.frozenColumn >= 0) {\r\n            // Add column groups to left panel\r\n            let $preHeaderPanel = $(this._grid.getPreHeaderPanelLeft());\r\n            this.renderHeaderGroups($preHeaderPanel, 0, this._gridOptions.frozenColumn + 1);\r\n            // Add column groups to right panel\r\n            $preHeaderPanel = $(this._grid.getPreHeaderPanelRight());\r\n            this.renderHeaderGroups($preHeaderPanel, this._gridOptions.frozenColumn + 1, this._columnDefinitions.length);\r\n        }\r\n        else {\r\n            // regular grid (not a frozen grid)\r\n            const $preHeaderPanel = $(this._grid.getPreHeaderPanel());\r\n            this.renderHeaderGroups($preHeaderPanel, 0, this._columnDefinitions.length);\r\n        }\r\n    }\r\n    renderHeaderGroups(preHeaderPanel, start, end) {\r\n        preHeaderPanel.empty()\r\n            .addClass('slick-header-columns')\r\n            .css('left', '-1000px')\r\n            .width(this._grid.getHeadersWidth());\r\n        preHeaderPanel.parent().addClass('slick-header');\r\n        const headerColumnWidthDiff = this._grid.getHeaderColumnWidthDiff();\r\n        let colDef;\r\n        let header;\r\n        let lastColumnGroup = '';\r\n        let widthTotal = 0;\r\n        for (let i = start; i < end; i++) {\r\n            colDef = this._columnDefinitions[i];\r\n            if (colDef) {\r\n                if (lastColumnGroup === colDef.columnGroup && i > 0) {\r\n                    widthTotal += colDef.width || 0;\r\n                    if (header && header.width) {\r\n                        header.width(widthTotal - headerColumnWidthDiff);\r\n                    }\r\n                }\r\n                else {\r\n                    widthTotal = colDef.width || 0;\r\n                    header = $(`<div class=\"ui-state-default slick-header-column\" />`)\r\n                        .html(`<span class=\"slick-column-name\">${colDef.columnGroup || ''}</span>`)\r\n                        .width(widthTotal - headerColumnWidthDiff)\r\n                        .appendTo(preHeaderPanel);\r\n                }\r\n                lastColumnGroup = colDef.columnGroup || '';\r\n            }\r\n        }\r\n    }\r\n    /** Translate the an array of items from an input key and assign to the output key */\r\n    translateItems(items, inputKey, outputKey) {\r\n        if (Array.isArray(items)) {\r\n            for (const item of items) {\r\n                if (item[inputKey]) {\r\n                    item[outputKey] = this.translate && this.translate && this.translate.instant && this.translate.instant(item[inputKey]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\nGroupingAndColspanService = __decorate([\r\n    Injectable(),\r\n    __param(1, Optional()),\r\n    __metadata(\"design:paramtypes\", [ResizerService, TranslateService])\r\n], GroupingAndColspanService);\n\nconst isequal$2 = isequal_; // patch to fix rollup to work\r\nlet PaginationService = class PaginationService {\r\n    /** Constructor */\r\n    constructor(filterService, gridService, sharedService) {\r\n        this.filterService = filterService;\r\n        this.gridService = gridService;\r\n        this.sharedService = sharedService;\r\n        this._initialized = false;\r\n        this._isLocalGrid = true;\r\n        this._dataFrom = 1;\r\n        this._dataTo = 1;\r\n        this._pageCount = 1;\r\n        this._pageNumber = 1;\r\n        this._totalItems = 0;\r\n        this._eventHandler = new Slick.EventHandler();\r\n        this._subscriptions = [];\r\n        this.onPaginationChanged = new Subject();\r\n        this.onPaginationVisibilityChanged = new Subject();\r\n    }\r\n    get paginationOptions() {\r\n        return this._paginationOptions;\r\n    }\r\n    set paginationOptions(paginationOptions) {\r\n        this._paginationOptions = paginationOptions;\r\n    }\r\n    get availablePageSizes() {\r\n        return this._availablePageSizes;\r\n    }\r\n    get dataFrom() {\r\n        return this._dataFrom;\r\n    }\r\n    get dataTo() {\r\n        return this._dataTo;\r\n    }\r\n    get itemsPerPage() {\r\n        return this._itemsPerPage;\r\n    }\r\n    get pageCount() {\r\n        return this._pageCount;\r\n    }\r\n    get pageNumber() {\r\n        return this._pageNumber;\r\n    }\r\n    set totalItems(totalItems) {\r\n        this._totalItems = totalItems;\r\n        if (this._initialized) {\r\n            this.refreshPagination();\r\n        }\r\n    }\r\n    get totalItems() {\r\n        return this._totalItems;\r\n    }\r\n    init(grid, dataView, paginationOptions, backendServiceApi) {\r\n        this._availablePageSizes = paginationOptions.pageSizes;\r\n        this.dataView = dataView;\r\n        this.grid = grid;\r\n        this._backendServiceApi = backendServiceApi;\r\n        this._paginationOptions = paginationOptions;\r\n        this._isLocalGrid = !backendServiceApi;\r\n        this._pageNumber = paginationOptions.pageNumber || 1;\r\n        if (backendServiceApi && (!backendServiceApi.service || !backendServiceApi.process)) {\r\n            throw new Error(`BackendServiceApi requires the following 2 properties \"process\" and \"service\" to be defined.`);\r\n        }\r\n        if (this._isLocalGrid && this.dataView) {\r\n            this.dataView.onPagingInfoChanged.subscribe((e, pagingInfo) => {\r\n                if (this._totalItems !== pagingInfo.totalRows) {\r\n                    this._totalItems = pagingInfo.totalRows;\r\n                    this._paginationOptions.totalItems = this._totalItems;\r\n                    this.refreshPagination(false, false);\r\n                }\r\n            });\r\n            dataView.setRefreshHints({ isFilterUnchanged: true });\r\n            dataView.setPagingOptions({ pageSize: this.paginationOptions.pageSize, pageNum: (this._pageNumber - 1) }); // dataView page starts at 0 instead of 1\r\n        }\r\n        // Subscribe to Filter Clear & Changed and go back to page 1 when that happen\r\n        this._subscriptions.push(this.filterService.onFilterChanged.subscribe(() => this.resetPagination()));\r\n        this._subscriptions.push(this.filterService.onFilterCleared.subscribe(() => this.resetPagination()));\r\n        // Subscribe to any dataview row count changed so that when Adding/Deleting item(s) through the DataView\r\n        // that would trigger a refresh of the pagination numbers\r\n        if (this.dataView) {\r\n            this._subscriptions.push(this.gridService.onItemAdded.subscribe((items) => this.processOnItemAddedOrRemoved(items, true)));\r\n            this._subscriptions.push(this.gridService.onItemDeleted.subscribe((items) => this.processOnItemAddedOrRemoved(items, false)));\r\n        }\r\n        this.refreshPagination(false, false);\r\n        this._initialized = true;\r\n    }\r\n    dispose() {\r\n        this._initialized = false;\r\n        // unsubscribe all SlickGrid events\r\n        this._eventHandler.unsubscribeAll();\r\n        // also unsubscribe all Angular Subscriptions\r\n        this._subscriptions = unsubscribeAllObservables(this._subscriptions);\r\n    }\r\n    getCurrentPageNumber() {\r\n        return this._pageNumber;\r\n    }\r\n    getCurrentPagination() {\r\n        return {\r\n            pageNumber: this._pageNumber,\r\n            pageSize: this._itemsPerPage,\r\n            pageSizes: this._availablePageSizes,\r\n        };\r\n    }\r\n    getFullPagination() {\r\n        return {\r\n            pageCount: this._pageCount,\r\n            pageNumber: this._pageNumber,\r\n            pageSize: this._itemsPerPage,\r\n            pageSizes: this._availablePageSizes,\r\n            totalItems: this._totalItems,\r\n            dataFrom: this._dataFrom,\r\n            dataTo: this._dataTo,\r\n        };\r\n    }\r\n    getCurrentItemPerPage() {\r\n        return this._itemsPerPage;\r\n    }\r\n    changeItemPerPage(itemsPerPage, event) {\r\n        this._pageNumber = 1;\r\n        this._pageCount = Math.ceil(this._totalItems / itemsPerPage);\r\n        this._itemsPerPage = itemsPerPage;\r\n        return this.processOnPageChanged(this._pageNumber, event);\r\n    }\r\n    goToFirstPage(event) {\r\n        this._pageNumber = 1;\r\n        return this.processOnPageChanged(this._pageNumber, event);\r\n    }\r\n    goToLastPage(event) {\r\n        this._pageNumber = this._pageCount || 1;\r\n        return this.processOnPageChanged(this._pageNumber, event);\r\n    }\r\n    goToNextPage(event) {\r\n        if (this._pageNumber < this._pageCount) {\r\n            this._pageNumber++;\r\n            return this.processOnPageChanged(this._pageNumber, event);\r\n        }\r\n        else {\r\n            return new Promise(resolve => resolve(false));\r\n        }\r\n    }\r\n    goToPageNumber(pageNumber, event) {\r\n        const previousPageNumber = this._pageNumber;\r\n        if (pageNumber < 1) {\r\n            this._pageNumber = 1;\r\n        }\r\n        else if (pageNumber > this._pageCount) {\r\n            this._pageNumber = this._pageCount;\r\n        }\r\n        else {\r\n            this._pageNumber = pageNumber;\r\n        }\r\n        if (this._pageNumber !== previousPageNumber) {\r\n            return this.processOnPageChanged(this._pageNumber, event);\r\n        }\r\n        else {\r\n            return new Promise(resolve => resolve(false));\r\n        }\r\n    }\r\n    goToPreviousPage(event) {\r\n        if (this._pageNumber > 1) {\r\n            this._pageNumber--;\r\n            return this.processOnPageChanged(this._pageNumber, event);\r\n        }\r\n        else {\r\n            return new Promise(resolve => resolve(false));\r\n        }\r\n    }\r\n    refreshPagination(isPageNumberReset = false, triggerChangedEvent = true) {\r\n        const previousPagination = Object.assign({}, this.getCurrentPagination());\r\n        if (this._paginationOptions) {\r\n            const pagination = this._paginationOptions;\r\n            // set the number of items per page if not already set\r\n            if (!this._itemsPerPage) {\r\n                if (this._isLocalGrid) {\r\n                    this._itemsPerPage = pagination.pageSize;\r\n                }\r\n                else {\r\n                    this._itemsPerPage = +((this._backendServiceApi && this._backendServiceApi.options && this._backendServiceApi.options.paginationOptions && this._backendServiceApi.options.paginationOptions.first) ? this._backendServiceApi.options.paginationOptions.first : pagination.pageSize);\r\n                }\r\n            }\r\n            // if totalItems changed, we should always go back to the first page and recalculation the From-To indexes\r\n            if (isPageNumberReset || this._totalItems !== pagination.totalItems) {\r\n                if (isPageNumberReset) {\r\n                    this._pageNumber = 1;\r\n                    this.paginationOptions.pageNumber = 1;\r\n                }\r\n                else if (!this._initialized && pagination.pageNumber && pagination.pageNumber > 1) {\r\n                    this._pageNumber = pagination.pageNumber || 1;\r\n                }\r\n                // when page number is set to 1 then also reset the \"offset\" of backend service\r\n                if (this._pageNumber === 1 && this._backendServiceApi) {\r\n                    this._backendServiceApi.service.resetPaginationOptions();\r\n                }\r\n            }\r\n            // calculate and refresh the multiple properties of the pagination UI\r\n            this._availablePageSizes = pagination.pageSizes;\r\n            if (!this._totalItems && pagination.totalItems) {\r\n                this._totalItems = pagination.totalItems;\r\n            }\r\n            this.recalculateFromToIndexes();\r\n        }\r\n        this._pageCount = Math.ceil(this._totalItems / this._itemsPerPage);\r\n        const currentPagination = this.getCurrentPagination();\r\n        this.sharedService.currentPagination = currentPagination;\r\n        if (triggerChangedEvent && !isequal$2(previousPagination, currentPagination)) {\r\n            this.onPaginationChanged.next(currentPagination);\r\n        }\r\n    }\r\n    processOnPageChanged(pageNumber, event) {\r\n        return new Promise((resolve, reject) => {\r\n            this.recalculateFromToIndexes();\r\n            if (this._isLocalGrid && this.dataView) {\r\n                this.dataView.setPagingOptions({ pageSize: this._itemsPerPage, pageNum: (pageNumber - 1) }); // dataView page starts at 0 instead of 1\r\n                this.onPaginationChanged.next(this.getFullPagination());\r\n            }\r\n            else {\r\n                const itemsPerPage = +this._itemsPerPage;\r\n                // keep start time & end timestamps & return it after process execution\r\n                const startTime = new Date();\r\n                // run any pre-process, if defined, for example a spinner\r\n                if (this._backendServiceApi.preProcess) {\r\n                    this._backendServiceApi.preProcess();\r\n                }\r\n                const query = this._backendServiceApi.service.processOnPaginationChanged(event, { newPage: pageNumber, pageSize: itemsPerPage });\r\n                // the processes can be Promises or an Observables (like HttpClient)\r\n                const process = this._backendServiceApi.process(query);\r\n                if (process instanceof Promise) {\r\n                    process\r\n                        .then((processResult) => {\r\n                        resolve(executeBackendProcessesCallback(startTime, processResult, this._backendServiceApi, this._totalItems));\r\n                    })\r\n                        .catch((error) => {\r\n                        onBackendError(error, this._backendServiceApi);\r\n                        reject(process);\r\n                    });\r\n                }\r\n                else if (isObservable(process)) {\r\n                    process.subscribe((processResult) => {\r\n                        resolve(executeBackendProcessesCallback(startTime, processResult, this._backendServiceApi, this._totalItems));\r\n                    }, (error) => {\r\n                        onBackendError(error, this._backendServiceApi);\r\n                        reject(process);\r\n                    });\r\n                }\r\n                this.onPaginationChanged.next(this.getFullPagination());\r\n            }\r\n        });\r\n    }\r\n    recalculateFromToIndexes() {\r\n        if (this._totalItems === 0) {\r\n            this._dataFrom = 0;\r\n            this._dataTo = 1;\r\n            this._pageNumber = 0;\r\n        }\r\n        else {\r\n            this._dataFrom = this._pageNumber > 1 ? ((this._pageNumber * this._itemsPerPage) - this._itemsPerPage + 1) : 1;\r\n            this._dataTo = (this._totalItems < this._itemsPerPage) ? this._totalItems : ((this._pageNumber || 1) * this._itemsPerPage);\r\n            if (this._dataTo > this._totalItems) {\r\n                this._dataTo = this._totalItems;\r\n            }\r\n        }\r\n        if (this._totalItems > 0 && this._pageNumber === 0) {\r\n            this._pageNumber = 1;\r\n        }\r\n        // do a final check on the From/To and make sure they are not over or below min/max acceptable values\r\n        if (this._dataTo > this._totalItems) {\r\n            this._dataTo = this._totalItems;\r\n        }\r\n        else if (this._totalItems < this._itemsPerPage) {\r\n            this._dataTo = this._totalItems;\r\n        }\r\n    }\r\n    /** Reset the Pagination to first page and recalculate necessary numbers */\r\n    resetPagination(triggerChangedEvent = true) {\r\n        if (this._isLocalGrid) {\r\n            // on a local grid we also need to reset the DataView paging to 1st page\r\n            this.dataView.setPagingOptions({ pageSize: this._itemsPerPage, pageNum: 0 });\r\n        }\r\n        this.refreshPagination(true, triggerChangedEvent);\r\n    }\r\n    /**\r\n     * Toggle the Pagination (show/hide), it will use the visible if defined else it will automatically inverse when called without argument\r\n     *\r\n     * IMPORTANT NOTE:\r\n     * The Pagination must be created on initial page load, then only after can you toggle it.\r\n     * Basically this method WILL NOT WORK to show the Pagination if it was not there from the start.\r\n     */\r\n    togglePaginationVisibility(visible) {\r\n        if (this.grid && this.sharedService && this.sharedService.gridOptions) {\r\n            const isVisible = visible !== undefined ? visible : !this.sharedService.gridOptions.enablePagination;\r\n            this.sharedService.gridOptions.enablePagination = isVisible;\r\n            this.onPaginationVisibilityChanged.next({ visible: isVisible });\r\n            // make sure to reset the Pagination and go back to first page to avoid any issues with Pagination being offset\r\n            if (isVisible) {\r\n                this.goToFirstPage();\r\n            }\r\n            // when using a local grid, we can reset the DataView pagination by changing its page size\r\n            // page size of 0 would show all, hence cancel the pagination\r\n            if (this._isLocalGrid) {\r\n                const pageSize = visible ? this._itemsPerPage : 0;\r\n                this.dataView.setPagingOptions({ pageSize, pageNum: 0 });\r\n            }\r\n        }\r\n    }\r\n    // --\r\n    // private functions\r\n    // --------------------\r\n    /**\r\n     * When item is added or removed, we will refresh the numbers on the pagination however we won't trigger a backend change\r\n     * This will have a side effect though, which is that the \"To\" count won't be matching the \"items per page\" count,\r\n     * that is a necessary side effect to avoid triggering a backend query just to refresh the paging,\r\n     * basically we assume that this offset is fine for the time being,\r\n     * until user does an action which will refresh the data hence the pagination which will then become normal again\r\n     */\r\n    processOnItemAddedOrRemoved(items, isItemAdded = true) {\r\n        if (items !== null) {\r\n            const previousDataTo = this._dataTo;\r\n            const itemCount = Array.isArray(items) ? items.length : 1;\r\n            const itemCountWithDirection = isItemAdded ? +itemCount : -itemCount;\r\n            // refresh the total count in the pagination and in the UI\r\n            this._totalItems += itemCountWithDirection;\r\n            this.recalculateFromToIndexes();\r\n            // finally refresh the \"To\" count and we know it might be different than the \"items per page\" count\r\n            // but this is necessary since we don't want an actual backend refresh\r\n            this._dataTo = previousDataTo + itemCountWithDirection;\r\n            this.onPaginationChanged.next(this.getFullPagination());\r\n        }\r\n    }\r\n};\r\nPaginationService = __decorate([\r\n    Injectable(),\r\n    __metadata(\"design:paramtypes\", [FilterService, GridService, SharedService])\r\n], PaginationService);\n\nclass AvgAggregator {\r\n    constructor(field) {\r\n        this._count = 0;\r\n        this._field = field;\r\n    }\r\n    init() {\r\n        this._count = 0;\r\n        this._nonNullCount = 0;\r\n        this._sum = 0;\r\n    }\r\n    accumulate(item) {\r\n        const val = (item && item.hasOwnProperty(this._field)) ? item[this._field] : null;\r\n        this._count++;\r\n        if (val != null && val !== '' && !isNaN(val)) {\r\n            this._nonNullCount++;\r\n            this._sum += parseFloat(val);\r\n        }\r\n    }\r\n    storeResult(groupTotals) {\r\n        if (!groupTotals || groupTotals.avg === undefined) {\r\n            groupTotals.avg = {};\r\n        }\r\n        if (this._nonNullCount !== 0) {\r\n            groupTotals.avg[this._field] = this._sum / this._nonNullCount;\r\n        }\r\n    }\r\n}\n\nclass MinAggregator {\r\n    constructor(field) {\r\n        this._field = field;\r\n    }\r\n    init() {\r\n        this._min = null;\r\n    }\r\n    accumulate(item) {\r\n        const val = (item && item.hasOwnProperty(this._field)) ? item[this._field] : null;\r\n        if (val != null && val !== '' && !isNaN(val)) {\r\n            if (this._min == null || val < this._min) {\r\n                this._min = parseFloat(val);\r\n            }\r\n        }\r\n    }\r\n    storeResult(groupTotals) {\r\n        if (!groupTotals || groupTotals.min === undefined) {\r\n            groupTotals.min = {};\r\n        }\r\n        groupTotals.min[this._field] = this._min;\r\n    }\r\n}\n\nclass MaxAggregator {\r\n    constructor(field) {\r\n        this._field = field;\r\n    }\r\n    init() {\r\n        this._max = null;\r\n    }\r\n    accumulate(item) {\r\n        const val = (item && item.hasOwnProperty(this._field)) ? item[this._field] : null;\r\n        if (val != null && val !== '' && !isNaN(val)) {\r\n            if (this._max == null || val > this._max) {\r\n                this._max = parseFloat(val);\r\n            }\r\n        }\r\n    }\r\n    storeResult(groupTotals) {\r\n        if (!groupTotals || groupTotals.max === undefined) {\r\n            groupTotals.max = {};\r\n        }\r\n        groupTotals.max[this._field] = this._max;\r\n    }\r\n}\n\nclass SumAggregator {\r\n    constructor(field) {\r\n        this._sum = 0;\r\n        this._field = field;\r\n    }\r\n    init() {\r\n        this._sum = 0;\r\n    }\r\n    accumulate(item) {\r\n        const val = (item && item.hasOwnProperty(this._field)) ? item[this._field] : null;\r\n        if (val != null && val !== '' && !isNaN(val)) {\r\n            this._sum += parseFloat(val);\r\n        }\r\n    }\r\n    storeResult(groupTotals) {\r\n        if (!groupTotals || groupTotals.sum === undefined) {\r\n            groupTotals.sum = {};\r\n        }\r\n        groupTotals.sum[this._field] = this._sum;\r\n    }\r\n}\n\n/** Provides a list of different Aggregators for the Group Formatter */\r\nconst Aggregators = {\r\n    Avg: AvgAggregator,\r\n    Min: MinAggregator,\r\n    Max: MaxAggregator,\r\n    Sum: SumAggregator\r\n};\n\n// minimum length of chars to type before starting to start querying\r\nconst MIN_LENGTH = 3;\r\n/*\r\n * An example of a 'detached' editor.\r\n * KeyDown events are also handled to provide handling for Tab, Shift-Tab, Esc and Ctrl-Enter.\r\n */\r\nclass AutoCompleteEditor {\r\n    constructor(args) {\r\n        this.args = args;\r\n        if (!args) {\r\n            throw new Error('[Angular-SlickGrid] Something is wrong with this grid, an Editor must always have valid arguments.');\r\n        }\r\n        this.grid = args.grid;\r\n        this.init();\r\n    }\r\n    /** Getter for the Autocomplete Option */\r\n    get autoCompleteOptions() {\r\n        return this._autoCompleteOptions || {};\r\n    }\r\n    /** Get the Collection */\r\n    get editorCollection() {\r\n        return this.columnDef && this.columnDef.internalColumnEditor && this.columnDef.internalColumnEditor.collection || [];\r\n    }\r\n    /** Get the Final Collection used in the AutoCompleted Source (this may vary from the \"collection\" especially when providing a customStructure) */\r\n    get elementCollection() {\r\n        return this._elementCollection;\r\n    }\r\n    /** Get Column Definition object */\r\n    get columnDef() {\r\n        return this.args && this.args.column;\r\n    }\r\n    /** Get Column Editor object */\r\n    get columnEditor() {\r\n        return this.columnDef && this.columnDef.internalColumnEditor || {};\r\n    }\r\n    /** Getter for the Custom Structure if exist */\r\n    get customStructure() {\r\n        return this.columnDef && this.columnDef.internalColumnEditor && this.columnDef.internalColumnEditor.customStructure;\r\n    }\r\n    get hasAutoCommitEdit() {\r\n        return this.grid.getOptions().autoCommitEdit;\r\n    }\r\n    /** Get the Validator function, can be passed in Editor property or Column Definition */\r\n    get validator() {\r\n        return this.columnEditor.validator || this.columnDef.validator;\r\n    }\r\n    get editorOptions() {\r\n        return this.columnEditor && this.columnEditor.editorOptions || {};\r\n    }\r\n    /** Get the Editor DOM Element */\r\n    get editorDomElement() {\r\n        return this._$editorElm;\r\n    }\r\n    init() {\r\n        this.labelName = this.customStructure && this.customStructure.label || 'label';\r\n        this.valueName = this.customStructure && this.customStructure.value || 'value';\r\n        // always render the DOM element, even if user passed a \"collectionAsync\",\r\n        const newCollection = this.columnEditor.collection || [];\r\n        this.renderDomElement(newCollection);\r\n    }\r\n    destroy() {\r\n        this._$editorElm.off('keydown.nav').remove();\r\n    }\r\n    focus() {\r\n        this._$editorElm.focus().select();\r\n    }\r\n    getValue() {\r\n        return this._$editorElm.val();\r\n    }\r\n    setValue(value) {\r\n        this._$editorElm.val(value);\r\n    }\r\n    applyValue(item, state) {\r\n        let newValue = state;\r\n        const fieldName = this.columnDef && this.columnDef.field;\r\n        // if we have a collection defined, we will try to find the string within the collection and return it\r\n        if (Array.isArray(this.editorCollection) && this.editorCollection.length > 0) {\r\n            newValue = findOrDefault(this.editorCollection, (collectionItem) => {\r\n                if (collectionItem && typeof state === 'object' && collectionItem.hasOwnProperty(this.labelName)) {\r\n                    return (collectionItem.hasOwnProperty(this.labelName) && collectionItem[this.labelName].toString()) === (state.hasOwnProperty(this.labelName) && state[this.labelName].toString());\r\n                }\r\n                else if (collectionItem && typeof state === 'string' && collectionItem.hasOwnProperty(this.labelName)) {\r\n                    return (collectionItem.hasOwnProperty(this.labelName) && collectionItem[this.labelName].toString()) === state;\r\n                }\r\n                return collectionItem && collectionItem.toString() === state;\r\n            });\r\n        }\r\n        // is the field a complex object, \"address.streetNumber\"\r\n        const isComplexObject = fieldName.indexOf('.') > 0;\r\n        // validate the value before applying it (if not valid we'll set an empty string)\r\n        const validation = this.validate(newValue);\r\n        newValue = (validation && validation.valid) ? newValue : '';\r\n        // set the new value to the item datacontext\r\n        if (isComplexObject) {\r\n            setDeepValue(item, fieldName, newValue);\r\n        }\r\n        else {\r\n            item[fieldName] = newValue;\r\n        }\r\n    }\r\n    isValueChanged() {\r\n        const lastEvent = this._lastInputEvent && this._lastInputEvent.keyCode;\r\n        if (this.columnEditor && this.columnEditor.alwaysSaveOnEnterKey && lastEvent === KeyCode.ENTER) {\r\n            return true;\r\n        }\r\n        return (!(this._$editorElm.val() === '' && this._defaultTextValue === null)) && (this._$editorElm.val() !== this._defaultTextValue);\r\n    }\r\n    loadValue(item) {\r\n        const fieldName = this.columnDef && this.columnDef.field;\r\n        // is the field a complex object, \"address.streetNumber\"\r\n        const isComplexObject = fieldName.indexOf('.') > 0;\r\n        if (item && this.columnDef && (item.hasOwnProperty(fieldName) || isComplexObject)) {\r\n            const data = (isComplexObject) ? getDescendantProperty(item, fieldName) : item[fieldName];\r\n            this._currentValue = data;\r\n            this._defaultTextValue = typeof data === 'string' ? data : data[this.labelName];\r\n            this._$editorElm.val(this._defaultTextValue);\r\n            this._$editorElm.select();\r\n        }\r\n    }\r\n    save() {\r\n        const validation = this.validate();\r\n        if (validation && validation.valid && this.isValueChanged()) {\r\n            if (this.hasAutoCommitEdit) {\r\n                this.grid.getEditorLock().commitCurrentEdit();\r\n            }\r\n            else {\r\n                this.args.commitChanges();\r\n            }\r\n        }\r\n    }\r\n    serializeValue() {\r\n        // if you want to add the autocomplete functionality but want the user to be able to input a new option\r\n        if (this.editorOptions.forceUserInput) {\r\n            const minLength = this.editorOptions && this.editorOptions.hasOwnProperty('minLength') ? this.editorOptions.minLength : MIN_LENGTH;\r\n            this._currentValue = this._$editorElm.val().length > minLength ? this._$editorElm.val() : this._currentValue;\r\n        }\r\n        // if user provided a custom structure, we will serialize the value returned from the object with custom structure\r\n        if (this.customStructure && this._currentValue && this._currentValue.hasOwnProperty(this.labelName)) {\r\n            return this._currentValue[this.labelName];\r\n        }\r\n        else if (this._currentValue && this._currentValue.label) {\r\n            if (this.columnDef.type === FieldType.object) {\r\n                return {\r\n                    [this.labelName]: this._currentValue.label,\r\n                    [this.valueName]: this._currentValue.value\r\n                };\r\n            }\r\n            return this._currentValue.label;\r\n        }\r\n        return this._currentValue;\r\n    }\r\n    validate(inputValue) {\r\n        const isRequired = this.columnEditor.required;\r\n        const elmValue = (inputValue !== undefined) ? inputValue : this._$editorElm && this._$editorElm.val && this._$editorElm.val();\r\n        const errorMsg = this.columnEditor.errorMessage;\r\n        if (this.validator) {\r\n            return this.validator(elmValue, this.args);\r\n        }\r\n        // by default the editor is almost always valid (except when it's required but not provided)\r\n        if (isRequired && elmValue === '') {\r\n            return {\r\n                valid: false,\r\n                msg: errorMsg || Constants.VALIDATION_REQUIRED_FIELD\r\n            };\r\n        }\r\n        return {\r\n            valid: true,\r\n            msg: null\r\n        };\r\n    }\r\n    //\r\n    // private functions\r\n    // ------------------\r\n    // this function should be PRIVATE but for unit tests purposes we'll make it public until a better solution is found\r\n    // a better solution would be to get the autocomplete DOM element to work with selection but I couldn't find how to do that in Jest\r\n    onSelect(event, ui) {\r\n        if (ui && ui.item) {\r\n            this._currentValue = ui && ui.item;\r\n            const itemLabel = typeof ui.item === 'string' ? ui.item : ui.item.label;\r\n            this.setValue(itemLabel);\r\n            if (this.hasAutoCommitEdit) {\r\n                // do not use args.commitChanges() as this sets the focus to the next row.\r\n                const validation = this.validate();\r\n                if (validation && validation.valid) {\r\n                    this.grid.getEditorLock().commitCurrentEdit();\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    renderDomElement(collection) {\r\n        if (!Array.isArray(collection)) {\r\n            throw new Error('The \"collection\" passed to the Autocomplete Editor is not a valid array.');\r\n        }\r\n        const columnId = this.columnDef && this.columnDef.id;\r\n        const placeholder = this.columnEditor && this.columnEditor.placeholder || '';\r\n        const title = this.columnEditor && this.columnEditor.title || '';\r\n        this._$editorElm = $(`<input type=\"text\" role=\"presentation\" autocomplete=\"off\" class=\"autocomplete editor-text editor-${columnId}\" placeholder=\"${placeholder}\" title=\"${title}\" />`)\r\n            .appendTo(this.args.container)\r\n            .on('keydown.nav', (event) => {\r\n            this._lastInputEvent = event;\r\n            if (event.keyCode === KeyCode.LEFT || event.keyCode === KeyCode.RIGHT) {\r\n                event.stopImmediatePropagation();\r\n            }\r\n        });\r\n        // user might pass his own autocomplete options\r\n        const autoCompleteOptions = this.columnEditor.editorOptions;\r\n        // assign the collection to a temp variable before filtering/sorting the collection\r\n        let finalCollection = collection;\r\n        // user might provide his own custom structure\r\n        // jQuery UI autocomplete requires a label/value pair, so we must remap them when user provide different ones\r\n        if (Array.isArray(finalCollection) && this.customStructure) {\r\n            finalCollection = finalCollection.map((item) => {\r\n                return { label: item[this.labelName], value: item[this.valueName] };\r\n            });\r\n        }\r\n        // keep the final source collection used in the AutoComplete as reference\r\n        this._elementCollection = finalCollection;\r\n        // when user passes it's own autocomplete options\r\n        // we still need to provide our own \"select\" callback implementation\r\n        if (autoCompleteOptions) {\r\n            autoCompleteOptions.select = (event, ui) => this.onSelect(event, ui);\r\n            this._autoCompleteOptions = Object.assign({}, autoCompleteOptions);\r\n            this._$editorElm.autocomplete(autoCompleteOptions);\r\n        }\r\n        else {\r\n            const definedOptions = {\r\n                source: finalCollection,\r\n                minLength: 0,\r\n                select: (event, ui) => this.onSelect(event, ui),\r\n            };\r\n            this._autoCompleteOptions = Object.assign({}, definedOptions, this.columnEditor.editorOptions);\r\n            this._$editorElm.autocomplete(this._autoCompleteOptions);\r\n        }\r\n        setTimeout(() => this.focus(), 50);\r\n    }\r\n}\n\n/*\r\n * An example of a 'detached' editor.\r\n * KeyDown events are also handled to provide handling for Tab, Shift-Tab, Esc and Ctrl-Enter.\r\n */\r\nclass CheckboxEditor {\r\n    constructor(args) {\r\n        this.args = args;\r\n        if (!args) {\r\n            throw new Error('[Angular-SlickGrid] Something is wrong with this grid, an Editor must always have valid arguments.');\r\n        }\r\n        this.grid = args.grid;\r\n        this.init();\r\n    }\r\n    /** Get Column Definition object */\r\n    get columnDef() {\r\n        return this.args && this.args.column;\r\n    }\r\n    /** Get Column Editor object */\r\n    get columnEditor() {\r\n        return this.columnDef && this.columnDef.internalColumnEditor || {};\r\n    }\r\n    /** Get the Editor DOM Element */\r\n    get editorDomElement() {\r\n        return this._$input;\r\n    }\r\n    get hasAutoCommitEdit() {\r\n        return this.args.grid.getOptions().autoCommitEdit;\r\n    }\r\n    /** Get the Validator function, can be passed in Editor property or Column Definition */\r\n    get validator() {\r\n        return this.columnEditor.validator || this.columnDef.validator;\r\n    }\r\n    init() {\r\n        const fieldId = this.columnDef && this.columnDef.id;\r\n        const title = this.columnEditor && this.columnEditor.title || '';\r\n        this._$input = $(`<input type=\"checkbox\" value=\"true\" class=\"editor-checkbox editor-${fieldId}\" title=\"${title}\" />`);\r\n        this._$input.appendTo(this.args.container);\r\n        this.focus();\r\n        // make the checkbox editor act like a regular checkbox that commit the value on click\r\n        if (this.hasAutoCommitEdit) {\r\n            this._$input.click(() => this.save());\r\n        }\r\n    }\r\n    destroy() {\r\n        this._$input.remove();\r\n    }\r\n    focus() {\r\n        this._$input.focus();\r\n    }\r\n    getValue() {\r\n        return this._$input.prop('checked');\r\n    }\r\n    setValue(val) {\r\n        const isChecked = val ? true : false;\r\n        this._$input.prop('checked', isChecked);\r\n    }\r\n    applyValue(item, state) {\r\n        const fieldName = this.columnDef && this.columnDef.field;\r\n        const isComplexObject = fieldName.indexOf('.') > 0; // is the field a complex object, \"address.streetNumber\"\r\n        // validate the value before applying it (if not valid we'll set an empty string)\r\n        const validation = this.validate(state);\r\n        const newValue = (validation && validation.valid) ? state : '';\r\n        // set the new value to the item datacontext\r\n        if (isComplexObject) {\r\n            setDeepValue(item, fieldName, newValue);\r\n        }\r\n        else {\r\n            item[fieldName] = newValue;\r\n        }\r\n    }\r\n    isValueChanged() {\r\n        return (this.serializeValue() !== this.originalValue);\r\n    }\r\n    loadValue(item) {\r\n        const fieldName = this.columnDef && this.columnDef.field;\r\n        // is the field a complex object, \"address.streetNumber\"\r\n        const isComplexObject = fieldName.indexOf('.') > 0;\r\n        if (item && this.columnDef && (item.hasOwnProperty(fieldName) || isComplexObject)) {\r\n            const value = (isComplexObject) ? getDescendantProperty(item, fieldName) : item[fieldName];\r\n            this.originalValue = value;\r\n            if (this.originalValue) {\r\n                this._$input.prop('checked', true);\r\n            }\r\n            else {\r\n                this._$input.prop('checked', false);\r\n            }\r\n        }\r\n    }\r\n    save() {\r\n        const validation = this.validate();\r\n        if (validation && validation.valid && this.isValueChanged() && this.hasAutoCommitEdit) {\r\n            this.grid.getEditorLock().commitCurrentEdit();\r\n        }\r\n    }\r\n    serializeValue() {\r\n        return this._$input.prop('checked');\r\n    }\r\n    validate(inputValue) {\r\n        const isRequired = this.columnEditor.required;\r\n        const isChecked = (inputValue !== undefined) ? inputValue : this._$input && this._$input.prop && this._$input.prop('checked');\r\n        const errorMsg = this.columnEditor.errorMessage;\r\n        if (this.validator) {\r\n            return this.validator(isChecked, this.args);\r\n        }\r\n        // by default the editor is almost always valid (except when it's required but not provided)\r\n        if (isRequired && !isChecked) {\r\n            return {\r\n                valid: false,\r\n                msg: errorMsg || Constants.VALIDATION_REQUIRED_FIELD\r\n            };\r\n        }\r\n        return {\r\n            valid: true,\r\n            msg: null\r\n        };\r\n    }\r\n}\n\nconst moment$5 = moment_; // patch to fix rollup \"moment has no default export\" issue, document here https://github.com/rollup/rollup/issues/670\r\nrequire('flatpickr');\r\n/*\r\n * An example of a date picker editor using Flatpickr\r\n * https://chmln.github.io/flatpickr\r\n */\r\nclass DateEditor {\r\n    constructor(args) {\r\n        this.args = args;\r\n        if (!args) {\r\n            throw new Error('[Angular-SlickGrid] Something is wrong with this grid, an Editor must always have valid arguments.');\r\n        }\r\n        this.grid = args.grid;\r\n        this.gridOptions = (args.grid && args.grid.getOptions() || {});\r\n        const options = this.gridOptions || this.args.column.params || {};\r\n        if (options && options.i18n instanceof TranslateService) {\r\n            this._translate = options.i18n;\r\n        }\r\n        this.init();\r\n    }\r\n    /** Get Column Definition object */\r\n    get columnDef() {\r\n        return this.args && this.args.column;\r\n    }\r\n    /** Get Column Editor object */\r\n    get columnEditor() {\r\n        return this.columnDef && this.columnDef.internalColumnEditor || {};\r\n    }\r\n    /** Get the Editor DOM Element */\r\n    get editorDomElement() {\r\n        return this._$input;\r\n    }\r\n    /** Get Flatpickr options passed to the editor by the user */\r\n    get editorOptions() {\r\n        return this.columnEditor.editorOptions || {};\r\n    }\r\n    get hasAutoCommitEdit() {\r\n        return this.grid.getOptions().autoCommitEdit;\r\n    }\r\n    /** Get the Validator function, can be passed in Editor property or Column Definition */\r\n    get validator() {\r\n        return this.columnEditor.validator || this.columnDef.validator;\r\n    }\r\n    init() {\r\n        if (this.args && this.columnDef) {\r\n            const columnId = this.columnDef && this.columnDef.id;\r\n            const placeholder = this.columnEditor && this.columnEditor.placeholder || '';\r\n            const title = this.columnEditor && this.columnEditor.title || '';\r\n            this.defaultDate = (this.args.item) ? this.args.item[this.columnDef.field] : null;\r\n            const inputFormat = mapFlatpickrDateFormatWithFieldType(this.columnDef.type || FieldType.dateIso);\r\n            const outputFormat = mapFlatpickrDateFormatWithFieldType(this.columnDef.outputType || FieldType.dateUtc);\r\n            let currentLocale = this._translate && this._translate.currentLang || this.gridOptions.locale || 'en';\r\n            if (currentLocale && currentLocale.length > 2) {\r\n                currentLocale = currentLocale.substring(0, 2);\r\n            }\r\n            const pickerOptions = {\r\n                defaultDate: this.defaultDate,\r\n                altInput: true,\r\n                altFormat: inputFormat,\r\n                dateFormat: outputFormat,\r\n                closeOnSelect: false,\r\n                locale: (currentLocale !== 'en') ? this.loadFlatpickrLocale(currentLocale) : 'en',\r\n                onChange: (selectedDates, dateStr, instance) => {\r\n                    this.save();\r\n                },\r\n            };\r\n            // merge options with optional user's custom options\r\n            const pickerMergedOptions = Object.assign({}, pickerOptions, this.editorOptions);\r\n            const inputCssClasses = `.editor-text.editor-${columnId}.flatpickr`;\r\n            if (pickerMergedOptions.altInput) {\r\n                pickerMergedOptions.altInputClass = 'flatpickr-alt-input editor-text';\r\n            }\r\n            this._$input = $(`<input type=\"text\" data-defaultDate=\"${this.defaultDate}\" class=\"${inputCssClasses.replace(/\\./g, ' ')}\" placeholder=\"${placeholder}\" title=\"${title}\" />`);\r\n            this._$input.appendTo(this.args.container);\r\n            this.flatInstance = (this._$input[0] && typeof this._$input[0].flatpickr === 'function') ? this._$input[0].flatpickr(pickerMergedOptions) : null;\r\n            // when we're using an alternate input to display data, we'll consider this input as the one to do the focus later on\r\n            // else just use the top one\r\n            this._$inputWithData = (pickerMergedOptions && pickerMergedOptions.altInput) ? $(`${inputCssClasses}.flatpickr-alt-input`) : this._$input;\r\n        }\r\n    }\r\n    destroy() {\r\n        this.hide();\r\n        this._$input.remove();\r\n        if (this._$inputWithData && typeof this._$inputWithData.remove === 'function') {\r\n            this._$inputWithData.remove();\r\n        }\r\n        if (this.flatInstance && typeof this.flatInstance.destroy === 'function') {\r\n            this.flatInstance.destroy();\r\n        }\r\n    }\r\n    focus() {\r\n        this._$input.focus();\r\n        if (this._$inputWithData && typeof this._$inputWithData.focus === 'function') {\r\n            this._$inputWithData.focus().select();\r\n        }\r\n    }\r\n    hide() {\r\n        if (this.flatInstance && typeof this.flatInstance.close === 'function') {\r\n            this.flatInstance.close();\r\n        }\r\n    }\r\n    show() {\r\n        if (this.flatInstance && typeof this.flatInstance.open === 'function') {\r\n            this.flatInstance.open();\r\n        }\r\n    }\r\n    getValue() {\r\n        return this._$input.val();\r\n    }\r\n    setValue(val) {\r\n        this.flatInstance.setDate(val);\r\n    }\r\n    applyValue(item, state) {\r\n        const fieldName = this.columnDef && this.columnDef.field;\r\n        const outputFormat = mapMomentDateFormatWithFieldType(this.columnDef.type || FieldType.dateIso);\r\n        const isComplexObject = fieldName.indexOf('.') > 0; // is the field a complex object, \"address.streetNumber\"\r\n        // validate the value before applying it (if not valid we'll set an empty string)\r\n        const validation = this.validate(state);\r\n        const newValue = (validation && validation.valid) ? moment$5(state, outputFormat).toDate() : '';\r\n        // set the new value to the item datacontext\r\n        if (isComplexObject) {\r\n            setDeepValue(item, fieldName, newValue);\r\n        }\r\n        else {\r\n            item[fieldName] = newValue;\r\n        }\r\n    }\r\n    isValueChanged() {\r\n        const elmValue = this._$input.val();\r\n        const outputFormat = mapMomentDateFormatWithFieldType(this.columnDef.type || FieldType.dateIso);\r\n        const elmDateStr = elmValue ? moment$5(elmValue).format(outputFormat) : '';\r\n        const orgDateStr = this.originalDate ? moment$5(this.originalDate).format(outputFormat) : '';\r\n        return (!(elmDateStr === '' && orgDateStr === '')) && (elmDateStr !== orgDateStr);\r\n    }\r\n    loadValue(item) {\r\n        const fieldName = this.columnDef && this.columnDef.field;\r\n        // is the field a complex object, \"address.streetNumber\"\r\n        const isComplexObject = fieldName.indexOf('.') > 0;\r\n        if (item && this.columnDef && (item.hasOwnProperty(fieldName) || isComplexObject)) {\r\n            const value = (isComplexObject) ? getDescendantProperty(item, fieldName) : item[fieldName];\r\n            this.originalDate = value;\r\n            this.flatInstance.setDate(value);\r\n            this.show();\r\n            this.focus();\r\n        }\r\n    }\r\n    save() {\r\n        // autocommit will not focus the next editor\r\n        const validation = this.validate();\r\n        if (validation && validation.valid && this.isValueChanged()) {\r\n            if (this.hasAutoCommitEdit) {\r\n                this.grid.getEditorLock().commitCurrentEdit();\r\n            }\r\n            else {\r\n                this.args.commitChanges();\r\n            }\r\n        }\r\n    }\r\n    serializeValue() {\r\n        const domValue = this._$input.val();\r\n        if (!domValue) {\r\n            return '';\r\n        }\r\n        const outputFormat = mapMomentDateFormatWithFieldType(this.columnDef.type || FieldType.dateIso);\r\n        const value = moment$5(domValue).format(outputFormat);\r\n        return value;\r\n    }\r\n    validate(inputValue) {\r\n        const isRequired = this.columnEditor.required;\r\n        const elmValue = (inputValue !== undefined) ? inputValue : this._$input && this._$input.val && this._$input.val();\r\n        const errorMsg = this.columnEditor.errorMessage;\r\n        if (this.validator) {\r\n            return this.validator(elmValue, this.args);\r\n        }\r\n        // by default the editor is almost always valid (except when it's required but not provided)\r\n        if (isRequired && elmValue === '') {\r\n            return {\r\n                valid: false,\r\n                msg: errorMsg || Constants.VALIDATION_REQUIRED_FIELD\r\n            };\r\n        }\r\n        return {\r\n            valid: true,\r\n            msg: null\r\n        };\r\n    }\r\n    //\r\n    // private functions\r\n    // ------------------\r\n    /** Load a different set of locales for Flatpickr to be localized */\r\n    loadFlatpickrLocale(language) {\r\n        let locales = 'en';\r\n        if (language !== 'en') {\r\n            // change locale if needed, Flatpickr reference: https://chmln.github.io/flatpickr/localization/\r\n            const localeDefault = require(`flatpickr/dist/l10n/${language}.js`).default;\r\n            locales = (localeDefault && localeDefault[language]) ? localeDefault[language] : 'en';\r\n        }\r\n        return locales;\r\n    }\r\n}\n\nconst defaultDecimalPlaces = 0;\r\n/*\r\n * An example of a 'detached' editor.\r\n * KeyDown events are also handled to provide handling for Tab, Shift-Tab, Esc and Ctrl-Enter.\r\n */\r\nclass FloatEditor {\r\n    constructor(args) {\r\n        this.args = args;\r\n        if (!args) {\r\n            throw new Error('[Angular-SlickGrid] Something is wrong with this grid, an Editor must always have valid arguments.');\r\n        }\r\n        this.grid = args.grid;\r\n        this.init();\r\n    }\r\n    /** Get Column Definition object */\r\n    get columnDef() {\r\n        return this.args && this.args.column;\r\n    }\r\n    /** Get Column Editor object */\r\n    get columnEditor() {\r\n        return this.columnDef && this.columnDef.internalColumnEditor || {};\r\n    }\r\n    /** Get the Editor DOM Element */\r\n    get editorDomElement() {\r\n        return this._$input;\r\n    }\r\n    get hasAutoCommitEdit() {\r\n        return this.grid && this.grid.getOptions && this.grid.getOptions().autoCommitEdit;\r\n    }\r\n    /** Get the Validator function, can be passed in Editor property or Column Definition */\r\n    get validator() {\r\n        return this.columnEditor.validator || this.columnDef.validator;\r\n    }\r\n    init() {\r\n        const columnId = this.columnDef && this.columnDef.id;\r\n        const placeholder = this.columnEditor && this.columnEditor.placeholder || '';\r\n        const title = this.columnEditor && this.columnEditor.title || '';\r\n        this._$input = $(`<input type=\"number\" role=\"presentation\" autocomplete=\"off\" class=\"editor-text editor-${columnId}\" placeholder=\"${placeholder}\" title=\"${title}\" step=\"${this.getInputDecimalSteps()}\" />`)\r\n            .appendTo(this.args.container)\r\n            .on('keydown.nav', (event) => {\r\n            this._lastInputEvent = event;\r\n            if (event.keyCode === KeyCode.LEFT || event.keyCode === KeyCode.RIGHT) {\r\n                event.stopImmediatePropagation();\r\n            }\r\n        });\r\n        // the lib does not get the focus out event for some reason\r\n        // so register it here\r\n        if (this.hasAutoCommitEdit) {\r\n            this._$input.on('focusout', () => this.save());\r\n        }\r\n        setTimeout(() => this.focus(), 50);\r\n    }\r\n    destroy() {\r\n        if (this._$input) {\r\n            this._$input.off('keydown.nav').remove();\r\n        }\r\n    }\r\n    focus() {\r\n        this._$input.focus();\r\n    }\r\n    getDecimalPlaces() {\r\n        // returns the number of fixed decimal places or null\r\n        let rtn = (this.columnEditor.params && this.columnEditor.params.hasOwnProperty('decimalPlaces')) ? this.columnEditor.params.decimalPlaces : undefined;\r\n        if (rtn === undefined) {\r\n            rtn = defaultDecimalPlaces;\r\n        }\r\n        return (!rtn && rtn !== 0 ? null : rtn);\r\n    }\r\n    getInputDecimalSteps() {\r\n        const decimals = this.getDecimalPlaces();\r\n        let zeroString = '';\r\n        for (let i = 1; i < decimals; i++) {\r\n            zeroString += '0';\r\n        }\r\n        if (decimals > 0) {\r\n            return `0.${zeroString}1`;\r\n        }\r\n        return '1';\r\n    }\r\n    getValue() {\r\n        return this._$input.val() || '';\r\n    }\r\n    setValue(value) {\r\n        this._$input.val(value);\r\n    }\r\n    applyValue(item, state) {\r\n        const fieldName = this.columnDef && this.columnDef.field;\r\n        const isComplexObject = fieldName.indexOf('.') > 0; // is the field a complex object, \"address.streetNumber\"\r\n        const validation = this.validate(state);\r\n        const newValue = (validation && validation.valid) ? state : '';\r\n        // set the new value to the item datacontext\r\n        if (isComplexObject) {\r\n            setDeepValue(item, fieldName, newValue);\r\n        }\r\n        else {\r\n            item[fieldName] = newValue;\r\n        }\r\n    }\r\n    isValueChanged() {\r\n        const elmValue = this._$input.val();\r\n        const lastEvent = this._lastInputEvent && this._lastInputEvent.keyCode;\r\n        if (this.columnEditor && this.columnEditor.alwaysSaveOnEnterKey && lastEvent === KeyCode.ENTER) {\r\n            return true;\r\n        }\r\n        return (!(elmValue === '' && this.originalValue === null)) && (elmValue !== this.originalValue);\r\n    }\r\n    loadValue(item) {\r\n        const fieldName = this.columnDef && this.columnDef.field;\r\n        // is the field a complex object, \"address.streetNumber\"\r\n        const isComplexObject = fieldName.indexOf('.') > 0;\r\n        if (item && this.columnDef && (item.hasOwnProperty(fieldName) || isComplexObject)) {\r\n            const value = (isComplexObject) ? getDescendantProperty(item, fieldName) : item[fieldName];\r\n            this.originalValue = value;\r\n            const decPlaces = this.getDecimalPlaces();\r\n            if (decPlaces !== null && (this.originalValue || this.originalValue === 0) && (+this.originalValue).toFixed) {\r\n                this.originalValue = (+this.originalValue).toFixed(decPlaces);\r\n            }\r\n            this._$input.val(this.originalValue);\r\n            this._$input.select();\r\n        }\r\n    }\r\n    save() {\r\n        const validation = this.validate();\r\n        if (validation && validation.valid && this.isValueChanged()) {\r\n            if (this.hasAutoCommitEdit) {\r\n                this.grid.getEditorLock().commitCurrentEdit();\r\n            }\r\n            else {\r\n                this.args.commitChanges();\r\n            }\r\n        }\r\n    }\r\n    serializeValue() {\r\n        const elmValue = this._$input.val();\r\n        if (elmValue === '' || isNaN(elmValue)) {\r\n            return elmValue;\r\n        }\r\n        let rtn = parseFloat(elmValue);\r\n        const decPlaces = this.getDecimalPlaces();\r\n        if (decPlaces !== null && (rtn || rtn === 0) && rtn.toFixed) {\r\n            rtn = parseFloat(rtn.toFixed(decPlaces));\r\n        }\r\n        return rtn;\r\n    }\r\n    validate(inputValue) {\r\n        const elmValue = (inputValue !== undefined) ? inputValue : this._$input && this._$input.val && this._$input.val();\r\n        const floatNumber = !isNaN(elmValue) ? parseFloat(elmValue) : null;\r\n        const decPlaces = this.getDecimalPlaces();\r\n        const isRequired = this.columnEditor.required;\r\n        const minValue = this.columnEditor.minValue;\r\n        const maxValue = this.columnEditor.maxValue;\r\n        const errorMsg = this.columnEditor.errorMessage;\r\n        const mapValidation = {\r\n            '{{minValue}}': minValue,\r\n            '{{maxValue}}': maxValue,\r\n            '{{minDecimal}}': 0,\r\n            '{{maxDecimal}}': decPlaces\r\n        };\r\n        let isValid = true;\r\n        let outputMsg = '';\r\n        if (this.validator) {\r\n            return this.validator(elmValue, this.args);\r\n        }\r\n        else if (isRequired && elmValue === '') {\r\n            isValid = false;\r\n            outputMsg = errorMsg || Constants.VALIDATION_REQUIRED_FIELD;\r\n        }\r\n        else if (isNaN(elmValue) || (decPlaces === 0 && !/^[-+]?(\\d+(\\.)?(\\d)*)$/.test(elmValue))) {\r\n            // when decimal value is 0 (which is the default), we accept 0 or more decimal values\r\n            isValid = false;\r\n            outputMsg = errorMsg || Constants.VALIDATION_EDITOR_VALID_NUMBER;\r\n        }\r\n        else if (minValue !== undefined && maxValue !== undefined && floatNumber !== null && (floatNumber < minValue || floatNumber > maxValue)) {\r\n            // MIN & MAX Values provided\r\n            // when decimal value is bigger than 0, we only accept the decimal values as that value set\r\n            // for example if we set decimalPlaces to 2, we will only accept numbers between 0 and 2 decimals\r\n            isValid = false;\r\n            outputMsg = errorMsg || Constants.VALIDATION_EDITOR_NUMBER_BETWEEN.replace(/{{minValue}}|{{maxValue}}/gi, (matched) => mapValidation[matched]);\r\n        }\r\n        else if (minValue !== undefined && floatNumber !== null && floatNumber <= minValue) {\r\n            // MIN VALUE ONLY\r\n            // when decimal value is bigger than 0, we only accept the decimal values as that value set\r\n            // for example if we set decimalPlaces to 2, we will only accept numbers between 0 and 2 decimals\r\n            isValid = false;\r\n            outputMsg = errorMsg || Constants.VALIDATION_EDITOR_NUMBER_MIN.replace(/{{minValue}}/gi, (matched) => mapValidation[matched]);\r\n        }\r\n        else if (maxValue !== undefined && floatNumber !== null && floatNumber >= maxValue) {\r\n            // MAX VALUE ONLY\r\n            // when decimal value is bigger than 0, we only accept the decimal values as that value set\r\n            // for example if we set decimalPlaces to 2, we will only accept numbers between 0 and 2 decimals\r\n            isValid = false;\r\n            outputMsg = errorMsg || Constants.VALIDATION_EDITOR_NUMBER_MAX.replace(/{{maxValue}}/gi, (matched) => mapValidation[matched]);\r\n        }\r\n        else if ((decPlaces > 0 && !new RegExp(`^[-+]?(\\\\d*(\\\\.)?(\\\\d){0,${decPlaces}})$`).test(elmValue))) {\r\n            // when decimal value is bigger than 0, we only accept the decimal values as that value set\r\n            // for example if we set decimalPlaces to 2, we will only accept numbers between 0 and 2 decimals\r\n            isValid = false;\r\n            outputMsg = errorMsg || Constants.VALIDATION_EDITOR_DECIMAL_BETWEEN.replace(/{{minDecimal}}|{{maxDecimal}}/gi, (matched) => mapValidation[matched]);\r\n        }\r\n        return {\r\n            valid: isValid,\r\n            msg: outputMsg\r\n        };\r\n    }\r\n}\n\n/*\r\n * An example of a 'detached' editor.\r\n * KeyDown events are also handled to provide handling for Tab, Shift-Tab, Esc and Ctrl-Enter.\r\n */\r\nclass IntegerEditor {\r\n    constructor(args) {\r\n        this.args = args;\r\n        if (!args) {\r\n            throw new Error('[Angular-SlickGrid] Something is wrong with this grid, an Editor must always have valid arguments.');\r\n        }\r\n        this.grid = args.grid;\r\n        this.init();\r\n    }\r\n    /** Get Column Definition object */\r\n    get columnDef() {\r\n        return this.args && this.args.column;\r\n    }\r\n    /** Get Column Editor object */\r\n    get columnEditor() {\r\n        return this.columnDef && this.columnDef.internalColumnEditor || {};\r\n    }\r\n    /** Get the Editor DOM Element */\r\n    get editorDomElement() {\r\n        return this._$input;\r\n    }\r\n    get hasAutoCommitEdit() {\r\n        return this.args && this.grid && this.grid.getOptions && this.grid.getOptions().autoCommitEdit;\r\n    }\r\n    /** Get the Validator function, can be passed in Editor property or Column Definition */\r\n    get validator() {\r\n        return this.columnEditor.validator || this.columnDef.validator;\r\n    }\r\n    init() {\r\n        const columnId = this.columnDef && this.columnDef.id;\r\n        const placeholder = this.columnEditor && this.columnEditor.placeholder || '';\r\n        const title = this.columnEditor && this.columnEditor.title || '';\r\n        this._$input = $(`<input type=\"number\" role=\"presentation\" autocomplete=\"off\" class=\"editor-text editor-${columnId}\" placeholder=\"${placeholder}\" title=\"${title}\" />`)\r\n            .appendTo(this.args.container)\r\n            .on('keydown.nav', (event) => {\r\n            this._lastInputEvent = event;\r\n            if (event.keyCode === KeyCode.LEFT || event.keyCode === KeyCode.RIGHT) {\r\n                event.stopImmediatePropagation();\r\n            }\r\n        });\r\n        // the lib does not get the focus out event for some reason\r\n        // so register it here\r\n        if (this.hasAutoCommitEdit) {\r\n            this._$input.on('focusout', () => this.save());\r\n        }\r\n        setTimeout(() => this.focus(), 50);\r\n    }\r\n    destroy() {\r\n        this._$input.off('keydown.nav focusout').remove();\r\n    }\r\n    focus() {\r\n        this._$input.focus();\r\n    }\r\n    getValue() {\r\n        return this._$input.val() || '';\r\n    }\r\n    setValue(value) {\r\n        this._$input.val(value);\r\n    }\r\n    applyValue(item, state) {\r\n        const fieldName = this.columnDef && this.columnDef.field;\r\n        const isComplexObject = fieldName.indexOf('.') > 0; // is the field a complex object, \"address.streetNumber\"\r\n        // validate the value before applying it (if not valid we'll set an empty string)\r\n        const validation = this.validate(state);\r\n        const newValue = (validation && validation.valid) ? state : '';\r\n        // set the new value to the item datacontext\r\n        if (isComplexObject) {\r\n            setDeepValue(item, fieldName, newValue);\r\n        }\r\n        else {\r\n            item[fieldName] = newValue;\r\n        }\r\n    }\r\n    isValueChanged() {\r\n        const elmValue = this._$input.val();\r\n        const lastEvent = this._lastInputEvent && this._lastInputEvent.keyCode;\r\n        if (this.columnEditor && this.columnEditor.alwaysSaveOnEnterKey && lastEvent === KeyCode.ENTER) {\r\n            return true;\r\n        }\r\n        return (!(elmValue === '' && this.originalValue === null)) && (elmValue !== this.originalValue);\r\n    }\r\n    loadValue(item) {\r\n        const fieldName = this.columnDef && this.columnDef.field;\r\n        // is the field a complex object, \"address.streetNumber\"\r\n        const isComplexObject = fieldName.indexOf('.') > 0;\r\n        if (item && this.columnDef && (item.hasOwnProperty(fieldName) || isComplexObject)) {\r\n            const value = (isComplexObject) ? getDescendantProperty(item, fieldName) : item[fieldName];\r\n            this.originalValue = (isNaN(value) || value === null || value === undefined) ? value : `${value}`;\r\n            this._$input.val(this.originalValue);\r\n            this._$input.select();\r\n        }\r\n    }\r\n    save() {\r\n        const validation = this.validate();\r\n        if (validation && validation.valid && this.isValueChanged()) {\r\n            if (this.hasAutoCommitEdit) {\r\n                this.grid.getEditorLock().commitCurrentEdit();\r\n            }\r\n            else {\r\n                this.args.commitChanges();\r\n            }\r\n        }\r\n    }\r\n    serializeValue() {\r\n        const elmValue = this._$input.val();\r\n        if (elmValue === '' || isNaN(elmValue)) {\r\n            return elmValue;\r\n        }\r\n        const output = isNaN(elmValue) ? elmValue : parseInt(elmValue, 10);\r\n        return isNaN(output) ? elmValue : output;\r\n    }\r\n    validate(inputValue) {\r\n        const elmValue = (inputValue !== undefined) ? inputValue : this.getValue();\r\n        let intNumber = !isNaN(elmValue) ? parseInt(elmValue, 10) : null;\r\n        if (isNaN(intNumber)) {\r\n            intNumber = null;\r\n        }\r\n        const errorMsg = this.columnEditor.errorMessage;\r\n        const isRequired = this.columnEditor.required;\r\n        const minValue = this.columnEditor.minValue;\r\n        const maxValue = this.columnEditor.maxValue;\r\n        const mapValidation = {\r\n            '{{minValue}}': minValue,\r\n            '{{maxValue}}': maxValue\r\n        };\r\n        let isValid = true;\r\n        let outputMsg = '';\r\n        if (this.validator) {\r\n            return this.validator(elmValue, this.args);\r\n        }\r\n        else if (isRequired && elmValue === '') {\r\n            isValid = false;\r\n            outputMsg = errorMsg || Constants.VALIDATION_REQUIRED_FIELD;\r\n        }\r\n        else if (elmValue && (isNaN(elmValue) || !/^[+-]?\\d+$/.test(elmValue))) {\r\n            isValid = false;\r\n            outputMsg = errorMsg || Constants.VALIDATION_EDITOR_VALID_INTEGER;\r\n        }\r\n        else if (minValue !== undefined && maxValue !== undefined && intNumber !== null && (intNumber < minValue || intNumber > maxValue)) {\r\n            // MIN & MAX Values provided\r\n            // when decimal value is bigger than 0, we only accept the decimal values as that value set\r\n            // for example if we set decimalPlaces to 2, we will only accept numbers between 0 and 2 decimals\r\n            isValid = false;\r\n            outputMsg = errorMsg || Constants.VALIDATION_EDITOR_INTEGER_BETWEEN.replace(/{{minValue}}|{{maxValue}}/gi, (matched) => mapValidation[matched]);\r\n        }\r\n        else if (minValue !== undefined && intNumber !== null && intNumber <= minValue) {\r\n            // MIN VALUE ONLY\r\n            // when decimal value is bigger than 0, we only accept the decimal values as that value set\r\n            // for example if we set decimalPlaces to 2, we will only accept numbers between 0 and 2 decimals\r\n            isValid = false;\r\n            outputMsg = errorMsg || Constants.VALIDATION_EDITOR_INTEGER_MIN.replace(/{{minValue}}/gi, (matched) => mapValidation[matched]);\r\n        }\r\n        else if (maxValue !== undefined && intNumber !== null && intNumber >= maxValue) {\r\n            // MAX VALUE ONLY\r\n            // when decimal value is bigger than 0, we only accept the decimal values as that value set\r\n            // for example if we set decimalPlaces to 2, we will only accept numbers between 0 and 2 decimals\r\n            isValid = false;\r\n            outputMsg = errorMsg || Constants.VALIDATION_EDITOR_INTEGER_MAX.replace(/{{maxValue}}/gi, (matched) => mapValidation[matched]);\r\n        }\r\n        return {\r\n            valid: isValid,\r\n            msg: outputMsg\r\n        };\r\n    }\r\n}\n\n/*\r\n * An example of a 'detached' editor.\r\n * The UI is added onto document BODY and .position(), .show() and .hide() are implemented.\r\n * KeyDown events are also handled to provide handling for Tab, Shift-Tab, Esc and Ctrl-Enter.\r\n */\r\nclass LongTextEditor {\r\n    constructor(args) {\r\n        this.args = args;\r\n        if (!args) {\r\n            throw new Error('[Angular-SlickGrid] Something is wrong with this grid, an Editor must always have valid arguments.');\r\n        }\r\n        this.grid = args.grid;\r\n        this.gridOptions = args.grid && args.grid.getOptions();\r\n        const options = this.gridOptions || this.args.column.params || {};\r\n        if (options && options.i18n instanceof TranslateService) {\r\n            this._translate = options.i18n;\r\n        }\r\n        // get locales provided by user in forRoot or else use default English locales via the Constants\r\n        this._locales = this.gridOptions && this.gridOptions.locales || Constants.locales;\r\n        this.init();\r\n    }\r\n    /** Get Column Definition object */\r\n    get columnDef() {\r\n        return this.args && this.args.column;\r\n    }\r\n    /** Get Column Editor object */\r\n    get columnEditor() {\r\n        return this.columnDef && this.columnDef.internalColumnEditor || {};\r\n    }\r\n    /** Get the Editor DOM Element */\r\n    get editorDomElement() {\r\n        return this._$textarea;\r\n    }\r\n    get hasAutoCommitEdit() {\r\n        return this.grid.getOptions().autoCommitEdit;\r\n    }\r\n    /** Get the Validator function, can be passed in Editor property or Column Definition */\r\n    get validator() {\r\n        return this.columnEditor.validator || this.columnDef.validator;\r\n    }\r\n    init() {\r\n        let cancelText = '';\r\n        let saveText = '';\r\n        if (this._translate && this._translate.instant && this._translate.currentLang) {\r\n            cancelText = this._translate.instant('CANCEL');\r\n            saveText = this._translate.instant('SAVE');\r\n        }\r\n        else {\r\n            cancelText = this._locales && this._locales.TEXT_CANCEL;\r\n            saveText = this._locales && this._locales.TEXT_SAVE;\r\n        }\r\n        const columnId = this.columnDef && this.columnDef.id;\r\n        const placeholder = this.columnEditor && this.columnEditor.placeholder || '';\r\n        const title = this.columnEditor && this.columnEditor.title || '';\r\n        const $container = $('body');\r\n        this._$wrapper = $(`<div class=\"slick-large-editor-text editor-${columnId}\" />`).appendTo($container);\r\n        this._$textarea = $(`<textarea hidefocus rows=\"5\" placeholder=\"${placeholder}\" title=\"${title}\">`).appendTo(this._$wrapper);\r\n        // the lib does not get the focus out event for some reason\r\n        // so register it here\r\n        if (this.hasAutoCommitEdit) {\r\n            this._$textarea.on('focusout', () => this.save());\r\n        }\r\n        $(`<div class=\"editor-footer\">\r\n          <button class=\"btn btn-save btn-primary btn-xs\">${saveText}</button>\r\n          <button class=\"btn btn-cancel btn-default btn-xs\">${cancelText}</button>\r\n      </div>`).appendTo(this._$wrapper);\r\n        this._$wrapper.find('.btn-save').on('click', () => this.save());\r\n        this._$wrapper.find('.btn-cancel').on('click', () => this.cancel());\r\n        this._$textarea.on('keydown', this.handleKeyDown.bind(this));\r\n        this.position(this.args && this.args.position);\r\n        this._$textarea.focus().select();\r\n    }\r\n    cancel() {\r\n        this._$textarea.val(this.defaultValue);\r\n        if (this.args && this.args.cancelChanges) {\r\n            this.args.cancelChanges();\r\n        }\r\n    }\r\n    hide() {\r\n        this._$wrapper.hide();\r\n    }\r\n    show() {\r\n        this._$wrapper.show();\r\n    }\r\n    destroy() {\r\n        this._$wrapper.off('keydown focusout').remove();\r\n    }\r\n    focus() {\r\n        this._$textarea.focus();\r\n    }\r\n    getValue() {\r\n        return this._$textarea.val();\r\n    }\r\n    setValue(val) {\r\n        this._$textarea.val(val);\r\n    }\r\n    applyValue(item, state) {\r\n        const fieldName = this.columnDef && this.columnDef.field;\r\n        const isComplexObject = fieldName.indexOf('.') > 0; // is the field a complex object, \"address.streetNumber\"\r\n        // validate the value before applying it (if not valid we'll set an empty string)\r\n        const validation = this.validate(state);\r\n        const newValue = (validation && validation.valid) ? state : '';\r\n        // set the new value to the item datacontext\r\n        if (isComplexObject) {\r\n            setDeepValue(item, fieldName, newValue);\r\n        }\r\n        else {\r\n            item[fieldName] = newValue;\r\n        }\r\n    }\r\n    isValueChanged() {\r\n        return (!(this._$textarea.val() === '' && this.defaultValue === null)) && (this._$textarea.val() !== this.defaultValue);\r\n    }\r\n    loadValue(item) {\r\n        const fieldName = this.columnDef && this.columnDef.field;\r\n        // is the field a complex object, \"address.streetNumber\"\r\n        const isComplexObject = fieldName.indexOf('.') > 0;\r\n        if (item && this.columnDef && (item.hasOwnProperty(fieldName) || isComplexObject)) {\r\n            const value = (isComplexObject) ? getDescendantProperty(item, fieldName) : item[fieldName];\r\n            this.defaultValue = value;\r\n            this._$textarea.val(this.defaultValue);\r\n            this._$textarea[0].defaultValue = this.defaultValue;\r\n            this._$textarea.select();\r\n        }\r\n    }\r\n    position(position) {\r\n        this._$wrapper\r\n            .css('top', (position.top || 0) - 5)\r\n            .css('left', (position.left || 0) - 5);\r\n    }\r\n    save() {\r\n        const validation = this.validate();\r\n        if (validation && validation.valid && this.isValueChanged()) {\r\n            if (this.hasAutoCommitEdit) {\r\n                this.grid.getEditorLock().commitCurrentEdit();\r\n            }\r\n            else {\r\n                this.args.commitChanges();\r\n            }\r\n        }\r\n    }\r\n    serializeValue() {\r\n        return this._$textarea.val();\r\n    }\r\n    validate(inputValue) {\r\n        const isRequired = this.columnEditor.required;\r\n        const elmValue = (inputValue !== undefined) ? inputValue : this._$textarea && this._$textarea.val && this._$textarea.val();\r\n        const errorMsg = this.columnEditor.errorMessage;\r\n        if (this.validator) {\r\n            return this.validator(elmValue, this.args);\r\n        }\r\n        // by default the editor is almost always valid (except when it's required but not provided)\r\n        if (isRequired && elmValue === '') {\r\n            return {\r\n                valid: false,\r\n                msg: errorMsg || Constants.VALIDATION_REQUIRED_FIELD\r\n            };\r\n        }\r\n        return {\r\n            valid: true,\r\n            msg: null\r\n        };\r\n    }\r\n    // --\r\n    // private functions\r\n    // ------------------\r\n    handleKeyDown(event) {\r\n        const keyCode = event.keyCode || event.code;\r\n        if (keyCode === KeyCode.ENTER && event.ctrlKey) {\r\n            this.save();\r\n        }\r\n        else if (keyCode === KeyCode.ESCAPE) {\r\n            event.preventDefault();\r\n            this.cancel();\r\n        }\r\n        else if (keyCode === KeyCode.TAB && event.shiftKey) {\r\n            event.preventDefault();\r\n            if (this.args && this.grid) {\r\n                this.grid.navigatePrev();\r\n            }\r\n        }\r\n        else if (keyCode === KeyCode.TAB) {\r\n            event.preventDefault();\r\n            if (this.args && this.grid) {\r\n                this.grid.navigateNext();\r\n            }\r\n        }\r\n    }\r\n}\n\nconst DOMPurify$2 = DOMPurify_; // patch to fix rollup to work\r\n/**\r\n * Slickgrid editor class for multiple/single select lists\r\n */\r\nclass SelectEditor {\r\n    constructor(args, isMultipleSelect) {\r\n        this.args = args;\r\n        this.isMultipleSelect = isMultipleSelect;\r\n        /** Observable Subscriptions */\r\n        this._subscriptions = [];\r\n        // flag to signal that the editor is destroying itself, helps prevent\r\n        // commit changes from being called twice and erroring\r\n        this._destroying = false;\r\n        if (!args) {\r\n            throw new Error('[Angular-SlickGrid] Something is wrong with this grid, an Editor must always have valid arguments.');\r\n        }\r\n        this.grid = args.grid;\r\n        this.gridOptions = (this.grid.getOptions() || {});\r\n        const options = this.gridOptions || this.args.column.params || {};\r\n        if (options && options.i18n instanceof TranslateService) {\r\n            this._translate = options.i18n;\r\n        }\r\n        // get locales provided by user in main file or else use default English locales via the Constants\r\n        this._locales = this.gridOptions.locales || Constants.locales;\r\n        // provide the name attribute to the DOM element which will be needed to auto-adjust drop position (dropup / dropdown)\r\n        const fieldId = this.columnDef && this.columnDef.id;\r\n        this.elementName = `editor-${fieldId}`;\r\n        const libOptions = {\r\n            autoAdjustDropHeight: true,\r\n            autoAdjustDropPosition: true,\r\n            autoAdjustDropWidthByTextSize: true,\r\n            container: 'body',\r\n            filter: false,\r\n            maxHeight: 275,\r\n            name: this.elementName,\r\n            single: true,\r\n            textTemplate: ($elm) => {\r\n                // render HTML code or not, by default it is sanitized and won't be rendered\r\n                const isRenderHtmlEnabled = this.columnDef && this.columnDef.internalColumnEditor && this.columnDef.internalColumnEditor.enableRenderHtml || false;\r\n                return isRenderHtmlEnabled ? $elm.text() : $elm.html();\r\n            },\r\n            onClose: () => this.save(),\r\n        };\r\n        if (isMultipleSelect) {\r\n            libOptions.single = false;\r\n            libOptions.addTitle = true;\r\n            libOptions.okButton = true;\r\n            libOptions.selectAllDelimiter = ['', ''];\r\n            if (this._translate && this._translate.instant && this._translate.currentLang) {\r\n                libOptions.countSelected = this._translate.instant('X_OF_Y_SELECTED');\r\n                libOptions.allSelected = this._translate.instant('ALL_SELECTED');\r\n                libOptions.selectAllText = this._translate.instant('SELECT_ALL');\r\n            }\r\n            else {\r\n                libOptions.countSelected = this._locales && this._locales.TEXT_X_OF_Y_SELECTED;\r\n                libOptions.allSelected = this._locales && this._locales.TEXT_ALL_SELECTED;\r\n                libOptions.selectAllText = this._locales && this._locales.TEXT_SELECT_ALL;\r\n                libOptions.okButtonText = this._locales && this._locales.TEXT_OK;\r\n            }\r\n        }\r\n        // assign the multiple select lib options\r\n        this.defaultOptions = libOptions;\r\n        this.init();\r\n    }\r\n    /** Get the Collection */\r\n    get collection() {\r\n        return this.columnDef && this.columnDef.internalColumnEditor.collection || [];\r\n    }\r\n    /** Getter for the Collection Options */\r\n    get collectionOptions() {\r\n        return this.columnDef && this.columnDef.internalColumnEditor && this.columnDef.internalColumnEditor.collectionOptions;\r\n    }\r\n    /** Get Column Definition object */\r\n    get columnDef() {\r\n        return this.args && this.args.column;\r\n    }\r\n    /** Get Column Editor object */\r\n    get columnEditor() {\r\n        return this.columnDef && this.columnDef.internalColumnEditor;\r\n    }\r\n    /** Get the Editor DOM Element */\r\n    get editorDomElement() {\r\n        return this.$editorElm;\r\n    }\r\n    /** Getter for the Custom Structure if exist */\r\n    get customStructure() {\r\n        return this.columnDef && this.columnDef.internalColumnEditor && this.columnDef.internalColumnEditor.customStructure;\r\n    }\r\n    get hasAutoCommitEdit() {\r\n        return this.grid.getOptions().autoCommitEdit;\r\n    }\r\n    /**\r\n     * The current selected values (multiple select) from the collection\r\n     */\r\n    get currentValues() {\r\n        const elmValue = this.$editorElm.val();\r\n        // collection of strings, just return the filtered string that are equals\r\n        if (this.collection.every(x => typeof x === 'string')) {\r\n            return this.collection.filter(c => elmValue.indexOf(c.toString()) !== -1);\r\n        }\r\n        // collection of label/value pair\r\n        const separatorBetweenLabels = this.collectionOptions && this.collectionOptions.separatorBetweenTextLabels || '';\r\n        const isIncludingPrefixSuffix = this.collectionOptions && this.collectionOptions.includePrefixSuffixToSelectedValues || false;\r\n        return this.collection\r\n            .filter(c => elmValue.indexOf(c.hasOwnProperty(this.valueName) && c[this.valueName].toString()) !== -1)\r\n            .map(c => {\r\n            const labelText = c[this.valueName];\r\n            let prefixText = c[this.labelPrefixName] || '';\r\n            let suffixText = c[this.labelSuffixName] || '';\r\n            // when it's a complex object, then pull the object name only, e.g.: \"user.firstName\" => \"user\"\r\n            const fieldName = this.columnDef && this.columnDef.field;\r\n            // is the field a complex object, \"address.streetNumber\"\r\n            const isComplexObject = fieldName.indexOf('.') > 0;\r\n            if (isComplexObject && typeof c === 'object') {\r\n                return c;\r\n            }\r\n            // also translate prefix/suffix if enableTranslateLabel is true and text is a string\r\n            prefixText = (this.enableTranslateLabel && prefixText && typeof prefixText === 'string') ? this._translate.instant(prefixText || ' ') : prefixText;\r\n            suffixText = (this.enableTranslateLabel && suffixText && typeof suffixText === 'string') ? this._translate.instant(suffixText || ' ') : suffixText;\r\n            if (isIncludingPrefixSuffix) {\r\n                const tmpOptionArray = [prefixText, labelText, suffixText].filter((text) => text); // add to a temp array for joining purpose and filter out empty text\r\n                return tmpOptionArray.join(separatorBetweenLabels);\r\n            }\r\n            return labelText;\r\n        });\r\n    }\r\n    /**\r\n     * The current selected values (single select) from the collection\r\n     */\r\n    get currentValue() {\r\n        const elmValue = this.$editorElm.val();\r\n        // collection of strings, just return the filtered string that are equals\r\n        if (this.collection.every(x => typeof x === 'string')) {\r\n            return findOrDefault(this.collection, (c) => c.toString() === elmValue);\r\n        }\r\n        // collection of label/value pair\r\n        const separatorBetweenLabels = this.collectionOptions && this.collectionOptions.separatorBetweenTextLabels || '';\r\n        const isIncludingPrefixSuffix = this.collectionOptions && this.collectionOptions.includePrefixSuffixToSelectedValues || false;\r\n        const itemFound = findOrDefault(this.collection, (c) => c.hasOwnProperty(this.valueName) && c[this.valueName].toString() === elmValue);\r\n        // is the field a complex object, \"address.streetNumber\"\r\n        const fieldName = this.columnDef && this.columnDef.field;\r\n        const isComplexObject = fieldName.indexOf('.') > 0;\r\n        if (isComplexObject && typeof itemFound === 'object') {\r\n            return itemFound;\r\n        }\r\n        else if (itemFound && itemFound.hasOwnProperty(this.valueName)) {\r\n            const labelText = itemFound[this.valueName];\r\n            if (isIncludingPrefixSuffix) {\r\n                let prefixText = itemFound[this.labelPrefixName] || '';\r\n                let suffixText = itemFound[this.labelSuffixName] || '';\r\n                // also translate prefix/suffix if enableTranslateLabel is true and text is a string\r\n                prefixText = (this.enableTranslateLabel && prefixText && typeof prefixText === 'string') ? this._translate.instant(prefixText || ' ') : prefixText;\r\n                suffixText = (this.enableTranslateLabel && suffixText && typeof suffixText === 'string') ? this._translate.instant(suffixText || ' ') : suffixText;\r\n                // add to a temp array for joining purpose and filter out empty text\r\n                const tmpOptionArray = [prefixText, labelText, suffixText].filter((text) => text);\r\n                return tmpOptionArray.join(separatorBetweenLabels);\r\n            }\r\n            return labelText;\r\n        }\r\n        return '';\r\n    }\r\n    /** Get the Validator function, can be passed in Editor property or Column Definition */\r\n    get validator() {\r\n        return this.columnEditor.validator || this.columnDef.validator;\r\n    }\r\n    init() {\r\n        if (!this.columnDef || !this.columnDef.internalColumnEditor || (!this.columnDef.internalColumnEditor.collection && !this.columnDef.internalColumnEditor.collectionAsync)) {\r\n            throw new Error(`[Angular-SlickGrid] You need to pass a \"collection\" (or \"collectionAsync\") inside Column Definition Editor for the MultipleSelect/SingleSelect Editor to work correctly.\r\n      Also each option should include a value/label pair (or value/labelKey when using Locale).\r\n      For example: { editor: { collection: [{ value: true, label: 'True' },{ value: false, label: 'False'}] } }`);\r\n        }\r\n        this._collectionService = new CollectionService(this._translate);\r\n        this.enableTranslateLabel = (this.columnDef.internalColumnEditor.enableTranslateLabel) ? this.columnDef.internalColumnEditor.enableTranslateLabel : false;\r\n        this.labelName = this.customStructure && this.customStructure.label || 'label';\r\n        this.labelPrefixName = this.customStructure && this.customStructure.labelPrefix || 'labelPrefix';\r\n        this.labelSuffixName = this.customStructure && this.customStructure.labelSuffix || 'labelSuffix';\r\n        this.optionLabel = this.customStructure && this.customStructure.optionLabel || 'value';\r\n        this.valueName = this.customStructure && this.customStructure.value || 'value';\r\n        if (this.enableTranslateLabel && (!this._translate || typeof this._translate.instant !== 'function')) {\r\n            throw new Error('[Angular-Slickgrid] requires \"ngx-translate\" to be installed and configured when the grid option \"enableTranslate\" is enabled.');\r\n        }\r\n        // always render the Select (dropdown) DOM element, even if user passed a \"collectionAsync\",\r\n        // if that is the case, the Select will simply be without any options but we still have to render it (else SlickGrid would throw an error)\r\n        this.renderDomElement(this.collection);\r\n    }\r\n    getValue() {\r\n        return (this.isMultipleSelect) ? this.currentValues : this.currentValue;\r\n    }\r\n    setValue(value) {\r\n        if (this.isMultipleSelect && Array.isArray(value)) {\r\n            this.loadMultipleValues(value);\r\n        }\r\n        else {\r\n            this.loadSingleValue(value);\r\n        }\r\n    }\r\n    hide() {\r\n        if (this.$editorElm && typeof this.$editorElm.multipleSelect === 'function') {\r\n            this.$editorElm.multipleSelect('close');\r\n        }\r\n    }\r\n    show() {\r\n        if (this.$editorElm && typeof this.$editorElm.multipleSelect === 'function') {\r\n            this.$editorElm.multipleSelect('open');\r\n        }\r\n    }\r\n    applyValue(item, state) {\r\n        const fieldName = this.columnDef && this.columnDef.field;\r\n        const fieldType = this.columnDef && this.columnDef.type;\r\n        let newValue = state;\r\n        // when the provided user defined the column field type as a possible number then try parsing the state value as that\r\n        if (fieldType === FieldType.number || fieldType === FieldType.integer || fieldType === FieldType.boolean) {\r\n            newValue = parseFloat(state);\r\n        }\r\n        // when set as a multiple selection, we can assume that the 3rd party lib multiple-select will return a CSV string\r\n        // we need to re-split that into an array to be the same as the original column\r\n        if (this.isMultipleSelect && typeof state === 'string' && state.indexOf(',') >= 0) {\r\n            newValue = state.split(',');\r\n        }\r\n        // is the field a complex object, \"user.address.streetNumber\"\r\n        const isComplexObject = fieldName.indexOf('.') > 0;\r\n        // validate the value before applying it (if not valid we'll set an empty string)\r\n        const validation = this.validate(newValue);\r\n        newValue = (validation && validation.valid) ? newValue : '';\r\n        // set the new value to the item datacontext\r\n        if (isComplexObject) {\r\n            // when it's a complex object, user could override the object path (where the editable object is located)\r\n            // else we use the path provided in the Field Column Definition\r\n            const objectPath = this.columnEditor && this.columnEditor.complexObjectPath || fieldName;\r\n            setDeepValue(item, objectPath, newValue);\r\n        }\r\n        else {\r\n            item[fieldName] = newValue;\r\n        }\r\n    }\r\n    destroy() {\r\n        this._destroying = true;\r\n        if (this.$editorElm && typeof this.$editorElm.multipleSelect === 'function') {\r\n            this.$editorElm.multipleSelect('destroy');\r\n            const elementClassName = this.elementName.toString().replace('.', '\\\\.'); // make sure to escape any dot \".\" from CSS class to avoid console error\r\n            $(`[name=${elementClassName}].ms-drop`).remove();\r\n        }\r\n        if (this.$editorElm && typeof this.$editorElm.remove === 'function') {\r\n            this.$editorElm.remove();\r\n        }\r\n        this._subscriptions = unsubscribeAllObservables(this._subscriptions);\r\n    }\r\n    loadValue(item) {\r\n        const fieldName = this.columnDef && this.columnDef.field;\r\n        // is the field a complex object, \"address.streetNumber\"\r\n        const isComplexObject = fieldName.indexOf('.') > 0;\r\n        if (item && this.columnDef && (item.hasOwnProperty(fieldName) || isComplexObject)) {\r\n            // when it's a complex object, user could override the object path (where the editable object is located)\r\n            // else we use the path provided in the Field Column Definition\r\n            const objectPath = this.columnEditor && this.columnEditor.complexObjectPath || fieldName;\r\n            const currentValue = (isComplexObject) ? getDescendantProperty(item, objectPath) : item[fieldName];\r\n            const value = (isComplexObject && currentValue.hasOwnProperty(this.valueName)) ? currentValue[this.valueName] : currentValue;\r\n            if (this.isMultipleSelect && Array.isArray(value)) {\r\n                this.loadMultipleValues(value);\r\n            }\r\n            else {\r\n                this.loadSingleValue(value);\r\n            }\r\n            this.refresh();\r\n        }\r\n    }\r\n    loadMultipleValues(currentValues) {\r\n        // convert to string because that is how the DOM will return these values\r\n        if (Array.isArray(currentValues)) {\r\n            // keep the default values in memory for references\r\n            this.originalValue = currentValues.map((i) => i);\r\n            // compare all the array values but as string type since multiple-select always return string\r\n            const currentStringValues = currentValues.map((i) => i.toString());\r\n            this.$editorElm.find('option').each((i, $e) => {\r\n                $e.selected = (currentStringValues.indexOf($e.value) !== -1);\r\n            });\r\n        }\r\n    }\r\n    loadSingleValue(currentValue) {\r\n        // keep the default value in memory for references\r\n        this.originalValue = typeof currentValue === 'number' ? `${currentValue}` : currentValue;\r\n        this.$editorElm.val(currentValue);\r\n        // make sure the prop exists first\r\n        this.$editorElm.find('option').each((i, $e) => {\r\n            // check equality after converting originalValue to string since the DOM value will always be of type string\r\n            const strValue = currentValue && currentValue.toString && currentValue.toString();\r\n            $e.selected = (strValue === $e.value);\r\n        });\r\n    }\r\n    save() {\r\n        // autocommit will not focus the next editor\r\n        const validation = this.validate();\r\n        if (validation && validation.valid && this.isValueChanged()) {\r\n            if (!this._destroying && this.hasAutoCommitEdit) {\r\n                // do not use args.commitChanges() as this sets the focus to the next\r\n                // row. Also the select list will stay shown when clicking off the grid\r\n                this.grid.getEditorLock().commitCurrentEdit();\r\n            }\r\n        }\r\n    }\r\n    serializeValue() {\r\n        return (this.isMultipleSelect) ? this.currentValues : this.currentValue;\r\n    }\r\n    focus() {\r\n        if (this.$editorElm && this.$editorElm.multipleSelect) {\r\n            this.$editorElm.multipleSelect('focus');\r\n        }\r\n    }\r\n    isValueChanged() {\r\n        if (this.isMultipleSelect) {\r\n            return !charArraysEqual(this.$editorElm.val(), this.originalValue);\r\n        }\r\n        return this.$editorElm.val() !== this.originalValue;\r\n    }\r\n    validate(inputValue) {\r\n        const isRequired = this.columnEditor.required;\r\n        const elmValue = (inputValue !== undefined) ? inputValue : this.$editorElm && this.$editorElm.val && this.$editorElm.val();\r\n        const errorMsg = this.columnEditor.errorMessage;\r\n        if (this.validator) {\r\n            const value = (inputValue !== undefined) ? inputValue : (this.isMultipleSelect ? this.currentValues : this.currentValue);\r\n            return this.validator(value, this.args);\r\n        }\r\n        // by default the editor is almost always valid (except when it's required but not provided)\r\n        if (isRequired && (elmValue === '' || (Array.isArray(elmValue) && elmValue.length === 0))) {\r\n            return {\r\n                valid: false,\r\n                msg: errorMsg || Constants.VALIDATION_REQUIRED_FIELD\r\n            };\r\n        }\r\n        return {\r\n            valid: true,\r\n            msg: null\r\n        };\r\n    }\r\n    //\r\n    // protected functions\r\n    // ------------------\r\n    /**\r\n     * user might want to filter certain items of the collection\r\n     * @param inputCollection\r\n     * @return outputCollection filtered and/or sorted collection\r\n     */\r\n    filterCollection(inputCollection) {\r\n        let outputCollection = inputCollection;\r\n        // user might want to filter certain items of the collection\r\n        if (this.columnEditor && this.columnEditor.collectionFilterBy) {\r\n            const filterBy = this.columnEditor.collectionFilterBy;\r\n            const filterCollectionBy = this.columnEditor.collectionOptions && this.columnEditor.collectionOptions.filterResultAfterEachPass || null;\r\n            outputCollection = this._collectionService.filterCollection(outputCollection, filterBy, filterCollectionBy);\r\n        }\r\n        return outputCollection;\r\n    }\r\n    /**\r\n     * user might want to sort the collection in a certain way\r\n     * @param inputCollection\r\n     * @return outputCollection sorted collection\r\n     */\r\n    sortCollection(inputCollection) {\r\n        let outputCollection = inputCollection;\r\n        // user might want to sort the collection\r\n        if (this.columnDef.internalColumnEditor && this.columnDef.internalColumnEditor.collectionSortBy) {\r\n            const sortBy = this.columnDef.internalColumnEditor.collectionSortBy;\r\n            outputCollection = this._collectionService.sortCollection(this.columnDef, outputCollection, sortBy, this.enableTranslateLabel);\r\n        }\r\n        return outputCollection;\r\n    }\r\n    renderDomElement(collection) {\r\n        if (!Array.isArray(collection) && this.collectionOptions && (this.collectionOptions.collectionInsideObjectProperty || this.collectionOptions.collectionInObjectProperty)) {\r\n            const collectionInsideObjectProperty = this.collectionOptions.collectionInsideObjectProperty || this.collectionOptions.collectionInObjectProperty;\r\n            collection = getDescendantProperty(collection, collectionInsideObjectProperty);\r\n        }\r\n        if (!Array.isArray(collection)) {\r\n            throw new Error('The \"collection\" passed to the Select Editor is not a valid array.');\r\n        }\r\n        // user can optionally add a blank entry at the beginning of the collection\r\n        if (this.collectionOptions && this.collectionOptions.addBlankEntry) {\r\n            collection.unshift(this.createBlankEntry());\r\n        }\r\n        let newCollection = collection || [];\r\n        // user might want to filter and/or sort certain items of the collection\r\n        newCollection = this.filterCollection(newCollection);\r\n        newCollection = this.sortCollection(newCollection);\r\n        // step 1, create HTML string template\r\n        const editorTemplate = this.buildTemplateHtmlString(newCollection);\r\n        // step 2, create the DOM Element of the editor\r\n        // also subscribe to the onClose event\r\n        this.createDomElement(editorTemplate);\r\n    }\r\n    buildTemplateHtmlString(collection) {\r\n        let options = '';\r\n        const fieldId = this.columnDef && this.columnDef.id;\r\n        const separatorBetweenLabels = this.collectionOptions && this.collectionOptions.separatorBetweenTextLabels || '';\r\n        const isRenderHtmlEnabled = this.columnDef.internalColumnEditor.enableRenderHtml || false;\r\n        const sanitizedOptions = this.gridOptions && this.gridOptions.sanitizeHtmlOptions || {};\r\n        // collection could be an Array of Strings OR Objects\r\n        if (collection.every(x => typeof x === 'string')) {\r\n            collection.forEach((option) => {\r\n                options += `<option value=\"${option}\" label=\"${option}\">${option}</option>`;\r\n            });\r\n        }\r\n        else {\r\n            // array of objects will require a label/value pair unless a customStructure is passed\r\n            collection.forEach((option) => {\r\n                if (!option || (option[this.labelName] === undefined && option.labelKey === undefined)) {\r\n                    throw new Error(`[select-editor] A collection with value/label (or value/labelKey when using Locale) is required to populate the Select list, for example: { collection: [ { value: '1', label: 'One' } ])`);\r\n                }\r\n                const labelKey = (option.labelKey || option[this.labelName]);\r\n                const labelText = ((option.labelKey || this.enableTranslateLabel) && labelKey) ? this._translate.instant(labelKey || ' ') : labelKey;\r\n                let prefixText = option[this.labelPrefixName] || '';\r\n                let suffixText = option[this.labelSuffixName] || '';\r\n                let optionLabel = option[this.optionLabel] || '';\r\n                optionLabel = optionLabel.toString().replace(/\\\"/g, '\\''); // replace double quotes by single quotes to avoid interfering with regular html\r\n                // also translate prefix/suffix if enableTranslateLabel is true and text is a string\r\n                prefixText = (this.enableTranslateLabel && prefixText && typeof prefixText === 'string') ? this._translate.instant(prefixText || ' ') : prefixText;\r\n                suffixText = (this.enableTranslateLabel && suffixText && typeof suffixText === 'string') ? this._translate.instant(suffixText || ' ') : suffixText;\r\n                optionLabel = (this.enableTranslateLabel && optionLabel && typeof optionLabel === 'string') ? this._translate.instant(optionLabel || ' ') : optionLabel;\r\n                // add to a temp array for joining purpose and filter out empty text\r\n                const tmpOptionArray = [prefixText, labelText, suffixText].filter(text => (text !== undefined && text !== ''));\r\n                let optionText = tmpOptionArray.join(separatorBetweenLabels);\r\n                // if user specifically wants to render html text, he needs to opt-in else it will stripped out by default\r\n                // also, the 3rd party lib will saninitze any html code unless it's encoded, so we'll do that\r\n                if (isRenderHtmlEnabled) {\r\n                    // sanitize any unauthorized html tags like script and others\r\n                    // for the remaining allowed tags we'll permit all attributes\r\n                    const sanitizedText = (DOMPurify$2.sanitize(optionText, sanitizedOptions) || '').toString();\r\n                    optionText = htmlEncode(sanitizedText);\r\n                }\r\n                options += `<option value=\"${option[this.valueName]}\" label=\"${optionLabel}\">${optionText}</option>`;\r\n            });\r\n        }\r\n        return `<select id=\"${this.elementName}\" class=\"ms-filter search-filter editor-${fieldId}\" ${this.isMultipleSelect ? 'multiple=\"multiple\"' : ''}>${options}</select>`;\r\n    }\r\n    /** Create a blank entry that can be added to the collection. It will also reuse the same customStructure if need be */\r\n    createBlankEntry() {\r\n        const blankEntry = {\r\n            [this.labelName]: '',\r\n            [this.valueName]: ''\r\n        };\r\n        if (this.labelPrefixName) {\r\n            blankEntry[this.labelPrefixName] = '';\r\n        }\r\n        if (this.labelSuffixName) {\r\n            blankEntry[this.labelSuffixName] = '';\r\n        }\r\n        return blankEntry;\r\n    }\r\n    /** Build the template HTML string */\r\n    createDomElement(editorTemplate) {\r\n        this.$editorElm = $(editorTemplate);\r\n        if (this.$editorElm && typeof this.$editorElm.appendTo === 'function') {\r\n            this.$editorElm.appendTo(this.args.container);\r\n        }\r\n        // add placeholder when found\r\n        const placeholder = this.columnEditor && this.columnEditor.placeholder || '';\r\n        this.defaultOptions.placeholder = placeholder || '';\r\n        if (typeof this.$editorElm.multipleSelect === 'function') {\r\n            const elementOptions = (this.columnDef.internalColumnEditor) ? this.columnDef.internalColumnEditor.elementOptions : {};\r\n            const editorOptions = (this.columnDef && this.columnDef.internalColumnEditor) ? this.columnDef.internalColumnEditor.editorOptions : {};\r\n            this.editorElmOptions = Object.assign({}, this.defaultOptions, elementOptions, editorOptions);\r\n            this.$editorElm = this.$editorElm.multipleSelect(this.editorElmOptions);\r\n            setTimeout(() => this.show());\r\n        }\r\n    }\r\n    // refresh the jquery object because the selected checkboxes were already set\r\n    // prior to this method being called\r\n    refresh() {\r\n        if (typeof this.$editorElm.multipleSelect === 'function') {\r\n            this.$editorElm.multipleSelect('refresh');\r\n        }\r\n    }\r\n}\n\nclass MultipleSelectEditor extends SelectEditor {\r\n    /**\r\n     * Initialize the Editor\r\n     */\r\n    constructor(args) {\r\n        super(args, true);\r\n        this.args = args;\r\n    }\r\n}\n\nclass SingleSelectEditor extends SelectEditor {\r\n    /**\r\n     * Initialize the Editor\r\n     */\r\n    constructor(args) {\r\n        super(args, false);\r\n        this.args = args;\r\n    }\r\n}\n\nconst DEFAULT_MIN_VALUE$3 = 0;\r\nconst DEFAULT_MAX_VALUE$3 = 100;\r\nconst DEFAULT_STEP$3 = 1;\r\nclass SliderEditor {\r\n    constructor(args) {\r\n        this.args = args;\r\n        if (!args) {\r\n            throw new Error('[Angular-SlickGrid] Something is wrong with this grid, an Editor must always have valid arguments.');\r\n        }\r\n        this.grid = args.grid;\r\n        this.init();\r\n    }\r\n    /** Get Column Definition object */\r\n    get columnDef() {\r\n        return this.args && this.args.column;\r\n    }\r\n    /** Get Column Editor object */\r\n    get columnEditor() {\r\n        return this.columnDef && this.columnDef.internalColumnEditor || {};\r\n    }\r\n    /** Get the Editor DOM Element */\r\n    get editorDomElement() {\r\n        return this._$input;\r\n    }\r\n    get hasAutoCommitEdit() {\r\n        return this.grid && this.grid.getOptions && this.grid.getOptions().autoCommitEdit;\r\n    }\r\n    /** Getter for the Editor Generic Params */\r\n    get editorParams() {\r\n        return this.columnEditor.params || {};\r\n    }\r\n    /** Get the Validator function, can be passed in Editor property or Column Definition */\r\n    get validator() {\r\n        return this.columnEditor.validator || this.columnDef.validator;\r\n    }\r\n    init() {\r\n        const container = this.args && this.args.container;\r\n        // define the input & slider number IDs\r\n        const itemId = this.args && this.args.item && this.args.item.id;\r\n        this._elementRangeInputId = `rangeInput_${this.columnDef.field}_${itemId}`;\r\n        this._elementRangeOutputId = `rangeOutput_${this.columnDef.field}_${itemId}`;\r\n        // create HTML string template\r\n        const editorTemplate = this.buildTemplateHtmlString();\r\n        this._$editorElm = $(editorTemplate);\r\n        this._$input = this._$editorElm.children('input');\r\n        this.$sliderNumber = this._$editorElm.children('div.input-group-addon.input-group-append').children();\r\n        this.focus();\r\n        // watch on change event\r\n        this._$editorElm\r\n            .appendTo(container)\r\n            .on('mouseup', () => this.save());\r\n        // if user chose to display the slider number on the right side, then update it every time it changes\r\n        // we need to use both \"input\" and \"change\" event to be all cross-browser\r\n        if (!this.editorParams.hideSliderNumber) {\r\n            this._$editorElm.on('input change', (event) => {\r\n                const value = event && event.target && event.target.value || '';\r\n                if (value) {\r\n                    const elements = document.getElementsByClassName(this._elementRangeOutputId);\r\n                    if (elements.length) {\r\n                        elements[0].innerHTML = event.target.value;\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n    cancel() {\r\n        this._$input.val(this.originalValue);\r\n        this.args.cancelChanges();\r\n    }\r\n    destroy() {\r\n        this._$editorElm.off('input change mouseup').remove();\r\n    }\r\n    focus() {\r\n        this._$editorElm.focus();\r\n    }\r\n    getValue() {\r\n        return this._$input.val() || '';\r\n    }\r\n    setValue(value) {\r\n        this._$input.val(value);\r\n    }\r\n    applyValue(item, state) {\r\n        const fieldName = this.columnDef && this.columnDef.field;\r\n        const isComplexObject = fieldName.indexOf('.') > 0; // is the field a complex object, \"address.streetNumber\"\r\n        const validation = this.validate(state);\r\n        const newValue = (validation && validation.valid) ? state : '';\r\n        // set the new value to the item datacontext\r\n        if (isComplexObject) {\r\n            setDeepValue(item, fieldName, newValue);\r\n        }\r\n        else {\r\n            item[fieldName] = newValue;\r\n        }\r\n    }\r\n    isValueChanged() {\r\n        const elmValue = this._$input.val();\r\n        return (!(elmValue === '' && this.originalValue === undefined)) && (+elmValue !== this.originalValue);\r\n    }\r\n    loadValue(item) {\r\n        const fieldName = this.columnDef && this.columnDef.field;\r\n        // is the field a complex object, \"address.streetNumber\"\r\n        const isComplexObject = fieldName.indexOf('.') > 0;\r\n        if (item && this.columnDef && (item.hasOwnProperty(fieldName) || isComplexObject)) {\r\n            let value = (isComplexObject) ? getDescendantProperty(item, fieldName) : item[fieldName];\r\n            if (value === '' || value === null || value === undefined) {\r\n                value = this.defaultValue; // load default value when item doesn't have any value\r\n            }\r\n            this.originalValue = +value;\r\n            this._$input.val(value);\r\n            this.$sliderNumber.html(value);\r\n        }\r\n    }\r\n    save() {\r\n        const validation = this.validate();\r\n        if (validation && validation.valid && this.isValueChanged()) {\r\n            if (this.hasAutoCommitEdit) {\r\n                this.args.grid.getEditorLock().commitCurrentEdit();\r\n            }\r\n            else {\r\n                this.args.commitChanges();\r\n            }\r\n        }\r\n    }\r\n    serializeValue() {\r\n        const elmValue = this._$input.val();\r\n        return elmValue !== '' ? parseInt(elmValue, 10) : this.originalValue;\r\n    }\r\n    validate(inputValue) {\r\n        const elmValue = (inputValue !== undefined) ? inputValue : this._$input && this._$input.val && this._$input.val();\r\n        const isRequired = this.columnEditor.required;\r\n        const minValue = this.columnEditor.minValue;\r\n        const maxValue = this.columnEditor.maxValue;\r\n        const errorMsg = this.columnEditor.errorMessage;\r\n        const mapValidation = {\r\n            '{{minValue}}': minValue,\r\n            '{{maxValue}}': maxValue\r\n        };\r\n        if (this.validator) {\r\n            return this.validator(elmValue, this.args);\r\n        }\r\n        else if (isRequired && elmValue === '') {\r\n            return {\r\n                valid: false,\r\n                msg: errorMsg || Constants.VALIDATION_REQUIRED_FIELD\r\n            };\r\n        }\r\n        else if (minValue !== undefined && maxValue !== undefined && elmValue !== null && (elmValue < minValue || elmValue > maxValue)) {\r\n            // when decimal value is bigger than 0, we only accept the decimal values as that value set\r\n            // for example if we set decimalPlaces to 2, we will only accept numbers between 0 and 2 decimals\r\n            return {\r\n                valid: false,\r\n                msg: errorMsg || Constants.VALIDATION_EDITOR_NUMBER_BETWEEN.replace(/{{minValue}}|{{maxValue}}/gi, (matched) => {\r\n                    return mapValidation[matched];\r\n                })\r\n            };\r\n        }\r\n        return {\r\n            valid: true,\r\n            msg: null\r\n        };\r\n    }\r\n    //\r\n    // private functions\r\n    // ------------------\r\n    /**\r\n     * Create the HTML template as a string\r\n     */\r\n    buildTemplateHtmlString() {\r\n        const fieldId = this.columnDef && this.columnDef.id;\r\n        const title = this.columnEditor && this.columnEditor.title || '';\r\n        const minValue = this.columnEditor.hasOwnProperty('minValue') ? this.columnEditor.minValue : DEFAULT_MIN_VALUE$3;\r\n        const maxValue = this.columnEditor.hasOwnProperty('maxValue') ? this.columnEditor.maxValue : DEFAULT_MAX_VALUE$3;\r\n        const defaultValue = this.editorParams.hasOwnProperty('sliderStartValue') ? this.editorParams.sliderStartValue : minValue;\r\n        const step = this.columnEditor.hasOwnProperty('valueStep') ? this.columnEditor.valueStep : DEFAULT_STEP$3;\r\n        this.defaultValue = defaultValue;\r\n        if (this.editorParams.hideSliderNumber) {\r\n            return `\r\n      <div class=\"slider-container slider-editor\">\r\n        <input type=\"range\" name=\"${this._elementRangeInputId}\" title=\"${title}\"\r\n          defaultValue=\"${defaultValue}\" value=\"${defaultValue}\"\r\n          min=\"${minValue}\" max=\"${maxValue}\" step=\"${step}\"\r\n          class=\"form-control slider-editor-input editor-${fieldId} range ${this._elementRangeInputId}\" />\r\n      </div>`;\r\n        }\r\n        return `\r\n      <div class=\"input-group slider-container slider-editor\">\r\n        <input type=\"range\" name=\"${this._elementRangeInputId}\" title=\"${title}\"\r\n          defaultValue=\"${defaultValue}\" value=\"${defaultValue}\"\r\n          min=\"${minValue}\" max=\"${maxValue}\" step=\"${step}\"\r\n          class=\"form-control slider-editor-input editor-${fieldId} range ${this._elementRangeInputId}\" />\r\n        <div class=\"input-group-addon input-group-append slider-value\"><span class=\"input-group-text ${this._elementRangeOutputId}\">${defaultValue}</span></div>\r\n      </div>`;\r\n    }\r\n}\n\n/*\r\n * An example of a 'detached' editor.\r\n * KeyDown events are also handled to provide handling for Tab, Shift-Tab, Esc and Ctrl-Enter.\r\n */\r\nclass TextEditor {\r\n    constructor(args) {\r\n        this.args = args;\r\n        if (!args) {\r\n            throw new Error('[Angular-SlickGrid] Something is wrong with this grid, an Editor must always have valid arguments.');\r\n        }\r\n        this.grid = args.grid;\r\n        this.init();\r\n    }\r\n    /** Get Column Definition object */\r\n    get columnDef() {\r\n        return this.args && this.args.column;\r\n    }\r\n    /** Get Column Editor object */\r\n    get columnEditor() {\r\n        return this.columnDef && this.columnDef.internalColumnEditor || {};\r\n    }\r\n    /** Get the Editor DOM Element */\r\n    get editorDomElement() {\r\n        return this._$input;\r\n    }\r\n    get hasAutoCommitEdit() {\r\n        return this.grid.getOptions().autoCommitEdit;\r\n    }\r\n    /** Get the Validator function, can be passed in Editor property or Column Definition */\r\n    get validator() {\r\n        return this.columnEditor.validator || this.columnDef.validator;\r\n    }\r\n    init() {\r\n        const columnId = this.columnDef && this.columnDef.id;\r\n        const placeholder = this.columnEditor && this.columnEditor.placeholder || '';\r\n        const title = this.columnEditor && this.columnEditor.title || '';\r\n        this._$input = $(`<input type=\"text\" role=\"presentation\"  autocomplete=\"off\" class=\"editor-text editor-${columnId}\" placeholder=\"${placeholder}\" title=\"${title}\" />`)\r\n            .appendTo(this.args.container)\r\n            .on('keydown.nav', (event) => {\r\n            this._lastInputEvent = event;\r\n            if (event.keyCode === KeyCode.LEFT || event.keyCode === KeyCode.RIGHT) {\r\n                event.stopImmediatePropagation();\r\n            }\r\n        });\r\n        // the lib does not get the focus out event for some reason\r\n        // so register it here\r\n        if (this.hasAutoCommitEdit) {\r\n            this._$input.on('focusout', () => this.save());\r\n        }\r\n        setTimeout(() => this.focus(), 50);\r\n    }\r\n    destroy() {\r\n        this._$input.off('keydown.nav focusout').remove();\r\n    }\r\n    focus() {\r\n        this._$input.focus();\r\n    }\r\n    getValue() {\r\n        return this._$input.val();\r\n    }\r\n    setValue(val) {\r\n        this._$input.val(val);\r\n    }\r\n    applyValue(item, state) {\r\n        const fieldName = this.columnDef && this.columnDef.field;\r\n        const isComplexObject = fieldName.indexOf('.') > 0; // is the field a complex object, \"address.streetNumber\"\r\n        // validate the value before applying it (if not valid we'll set an empty string)\r\n        const validation = this.validate(state);\r\n        const newValue = (validation && validation.valid) ? state : '';\r\n        // set the new value to the item datacontext\r\n        if (isComplexObject) {\r\n            setDeepValue(item, fieldName, newValue);\r\n        }\r\n        else {\r\n            item[fieldName] = newValue;\r\n        }\r\n    }\r\n    isValueChanged() {\r\n        const elmValue = this._$input.val();\r\n        const lastEvent = this._lastInputEvent && this._lastInputEvent.keyCode;\r\n        if (this.columnEditor && this.columnEditor.alwaysSaveOnEnterKey && lastEvent === KeyCode.ENTER) {\r\n            return true;\r\n        }\r\n        return (!(elmValue === '' && this.originalValue === null)) && (elmValue !== this.originalValue);\r\n    }\r\n    loadValue(item) {\r\n        const fieldName = this.columnDef && this.columnDef.field;\r\n        // is the field a complex object, \"address.streetNumber\"\r\n        const isComplexObject = fieldName.indexOf('.') > 0;\r\n        if (item && this.columnDef && (item.hasOwnProperty(fieldName) || isComplexObject)) {\r\n            const value = (isComplexObject) ? getDescendantProperty(item, fieldName) : item[fieldName];\r\n            this.originalValue = value;\r\n            this._$input.val(this.originalValue);\r\n            this._$input.select();\r\n        }\r\n    }\r\n    save() {\r\n        const validation = this.validate();\r\n        if (validation && validation.valid && this.isValueChanged()) {\r\n            if (this.hasAutoCommitEdit) {\r\n                this.grid.getEditorLock().commitCurrentEdit();\r\n            }\r\n            else {\r\n                this.args.commitChanges();\r\n            }\r\n        }\r\n    }\r\n    serializeValue() {\r\n        return this._$input.val();\r\n    }\r\n    validate(inputValue) {\r\n        const isRequired = this.columnEditor.required;\r\n        const elmValue = (inputValue !== undefined) ? inputValue : this._$input && this._$input.val && this._$input.val();\r\n        const errorMsg = this.columnEditor.errorMessage;\r\n        if (this.validator) {\r\n            return this.validator(elmValue, this.args);\r\n        }\r\n        // by default the editor is almost always valid (except when it's required but not provided)\r\n        if (isRequired && elmValue === '') {\r\n            return {\r\n                valid: false,\r\n                msg: errorMsg || Constants.VALIDATION_REQUIRED_FIELD\r\n            };\r\n        }\r\n        return {\r\n            valid: true,\r\n            msg: null\r\n        };\r\n    }\r\n}\n\nconst Editors = {\r\n    /** AutoComplete Editor (using jQuery UI autocomplete feature) */\r\n    autoComplete: AutoCompleteEditor,\r\n    /** Checkbox Editor (uses native checkbox DOM element) */\r\n    checkbox: CheckboxEditor,\r\n    /** Date Picker Editor (which uses 3rd party lib \"flatpickr\") */\r\n    date: DateEditor,\r\n    /** Float Number Editor */\r\n    float: FloatEditor,\r\n    /** Integer Editor */\r\n    integer: IntegerEditor,\r\n    /** Long Text Editor (uses a textarea) */\r\n    longText: LongTextEditor,\r\n    /** Multiple Select editor (which uses 3rd party lib \"multiple-select.js\") */\r\n    multipleSelect: MultipleSelectEditor,\r\n    /** Single Select editor (which uses 3rd party lib \"multiple-select.js\") */\r\n    singleSelect: SingleSelectEditor,\r\n    /** Slider Editor */\r\n    slider: SliderEditor,\r\n    /** Text Editor */\r\n    text: TextEditor\r\n};\n\nconst moment$6 = moment_; // patch to fix rollup \"moment has no default export\" issue, document here https://github.com/rollup/rollup/issues/670\r\n/**\r\n * Find the option value from the following (in order of execution)\r\n * 1- Column Definition \"params\"\r\n * 2- Grid Options \"formatterOptions\"\r\n * 3- nothing found, return default value provided\r\n */\r\nfunction getValueFromParamsOrFormatterOptions(optionName, columnDef, grid, defaultValue) {\r\n    const gridOptions = ((grid && typeof grid.getOptions === 'function') ? grid.getOptions() : {});\r\n    const params = columnDef && columnDef.params;\r\n    if (params && params.hasOwnProperty(optionName)) {\r\n        return params[optionName];\r\n    }\r\n    else if (gridOptions.formatterOptions && gridOptions.formatterOptions.hasOwnProperty(optionName)) {\r\n        return gridOptions.formatterOptions[optionName];\r\n    }\r\n    return defaultValue;\r\n}\r\n/** From a FieldType, return the associated date Formatter */\r\nfunction getAssociatedDateFormatter(fieldType, defaultSeparator) {\r\n    const defaultDateFormat = mapMomentDateFormatWithFieldType(fieldType);\r\n    return (row, cell, value, columnDef, dataContext, grid) => {\r\n        const gridOptions = ((grid && typeof grid.getOptions === 'function') ? grid.getOptions() : {});\r\n        const customSeparator = gridOptions && gridOptions.formatterOptions && gridOptions.formatterOptions.dateSeparator || defaultSeparator;\r\n        const isDateValid = moment$6(value, defaultDateFormat, false).isValid();\r\n        let outputDate = (value && isDateValid) ? moment$6(value).format(defaultDateFormat) : value;\r\n        // user can customize the separator through the \"formatterOptions\"\r\n        // if that is the case we need to replace the default \"/\" to the new separator\r\n        if (outputDate && customSeparator !== defaultSeparator) {\r\n            const regex = new RegExp(defaultSeparator, 'ig'); // find separator globally\r\n            outputDate = outputDate.replace(regex, customSeparator);\r\n        }\r\n        return outputDate;\r\n    };\r\n}\n\nconst arrayObjectToCsvFormatter = (row, cell, value, columnDef, dataContext) => {\r\n    const columnParams = columnDef && columnDef.params || {};\r\n    const propertyNames = columnParams.propertyNames;\r\n    let parentObjectKeyName = columnParams.dataContextProperty;\r\n    if (!parentObjectKeyName) {\r\n        parentObjectKeyName = columnDef && columnDef.field && columnDef.field.split('.')[0]; // e.g. \"users.roles\" would be \"users\"\r\n    }\r\n    if (!propertyNames || !Array.isArray(propertyNames) || !parentObjectKeyName) {\r\n        throw new Error(`Formatters.arrayObjectToCsv requires you to pass an array of \"propertyNames\" (declared in \"params\") that you want to pull the data from.\r\n      For example, if we have an array of user objects that have the property of firstName & lastName then we need to pass in your column definition:: { params: { propertyNames: ['firtName'] }}.\r\n      Optionally, you can also pass the \"dataContextProperty\" if you wish to run this on another completely different field of the dataContext object.`);\r\n    }\r\n    // the dataContext holds all the data, so we can find the values we want even when \"value\" argument might be null\r\n    // e.g. if we want to use the propertyNames of ['firstName', 'lastName'] from the \"users\" array of objects\r\n    if (dataContext[parentObjectKeyName] && Array.isArray(dataContext[parentObjectKeyName])) {\r\n        // we will 1st get the object from the dataContext, then\r\n        if (Array.isArray(dataContext[parentObjectKeyName]) && dataContext[parentObjectKeyName].length > 0) {\r\n            const outputStrings = [];\r\n            dataContext[parentObjectKeyName].forEach((data) => {\r\n                const strings = [];\r\n                // 2nd from that data loop through all propertyNames we want to use (e.g.: ['firstName', 'lastName'])\r\n                propertyNames.forEach((prop) => {\r\n                    strings.push(data[prop]);\r\n                });\r\n                // we will join these strings with spaces (e.g. 'John Doe' where 'John' was firstName and 'Doe' was lastName)\r\n                outputStrings.push(strings.join(' '));\r\n            });\r\n            // finally join all the output strings by CSV (e.g.: 'John Doe, Jane Doe')\r\n            const output = outputStrings.join(', ');\r\n            return `<span title=\"${output}\">${output}</span>`;\r\n        }\r\n    }\r\n    return value;\r\n};\n\nconst arrayToCsvFormatter = (row, cell, value, columnDef, dataContext) => {\r\n    if (value && Array.isArray(value) && value.length > 0) {\r\n        const values = value.join(', ');\r\n        return `<span title=\"${values}\">${values}</span>`;\r\n    }\r\n    return value;\r\n};\n\nconst boldFormatter = (row, cell, value, columnDef, dataContext) => {\r\n    return value ? `<b>${value}</b>` : '';\r\n};\n\nconst checkboxFormatter = (row, cell, value, columnDef, dataContext) => value ? '&#x2611;' : '';\n\nconst checkmarkFormatter = (row, cell, value, columnDef, dataContext) => {\r\n    let isChecked = false;\r\n    const isNumber = (value === null || value === undefined || value === '') ? false : !isNaN(+value);\r\n    if (isNumber) {\r\n        value = +value; // convert to number before doing next condition\r\n    }\r\n    if (value === true || (isNumber && +value > 0) || (typeof value === 'string' && value.length > 0 && value.toLowerCase() !== 'false' && value !== '0')) {\r\n        isChecked = true;\r\n    }\r\n    return isChecked ? `<i class=\"fa fa-check checkmark-icon\" aria-hidden=\"true\"></i>` : '';\r\n};\n\n/**\r\n * A formatter to show the label property value of a params collection\r\n */\r\nconst collectionFormatter = (row, cell, value, columnDef, dataContext) => {\r\n    if (!value || !columnDef || !columnDef.params || !columnDef.params.collection\r\n        || !columnDef.params.collection.length) {\r\n        return value;\r\n    }\r\n    const { params, params: { collection } } = columnDef;\r\n    const labelName = (params.customStructure) ? params.customStructure.label : 'label';\r\n    const valueName = (params.customStructure) ? params.customStructure.value : 'value';\r\n    if (Array.isArray(value)) {\r\n        return arrayToCsvFormatter(row, cell, value.map((v) => findOrDefault(collection, (c) => c[valueName] === v)[labelName]));\r\n    }\r\n    return findOrDefault(collection, (c) => c[valueName] === value)[labelName] || '';\r\n};\n\n/**\r\n * A formatter to show the label property value of an editor collection\r\n */\r\nconst collectionEditorFormatter = (row, cell, value, columnDef, dataContext) => {\r\n    if (!value || !columnDef || !columnDef.internalColumnEditor || !columnDef.internalColumnEditor.collection\r\n        || !columnDef.internalColumnEditor.collection.length) {\r\n        return value;\r\n    }\r\n    const { internalColumnEditor, internalColumnEditor: { collection } } = columnDef;\r\n    const labelName = (internalColumnEditor.customStructure) ? internalColumnEditor.customStructure.label : 'label';\r\n    const valueName = (internalColumnEditor.customStructure) ? internalColumnEditor.customStructure.value : 'value';\r\n    if (Array.isArray(value)) {\r\n        if (collection.every(x => typeof x === 'string')) {\r\n            return arrayToCsvFormatter(row, cell, value.map((v) => findOrDefault(collection, (c) => c === v)));\r\n        }\r\n        else {\r\n            return arrayToCsvFormatter(row, cell, value.map((v) => findOrDefault(collection, (c) => c[valueName] === v)[labelName]));\r\n        }\r\n    }\r\n    return findOrDefault(collection, (c) => c[valueName] === value)[labelName] || '';\r\n};\n\nconst complexObjectFormatter = (row, cell, cellValue, columnDef, dataContext) => {\r\n    if (!columnDef) {\r\n        return '';\r\n    }\r\n    const columnParams = columnDef.params || {};\r\n    const complexFieldLabel = columnParams && columnParams.complexFieldLabel || columnDef.field;\r\n    if (!complexFieldLabel) {\r\n        throw new Error(`For the Formatters.complexObject to work properly, you need to tell it which property of the complex object to use.\r\n      There are 3 ways to provide it:\r\n      1- via the generic \"params\" with a \"complexFieldLabel\" property on your Column Definition, example: this.columnDefs = [{ id: 'user', field: 'user', params: { complexFieldLabel: 'user.firstName' } }]\r\n      2- via the generic \"params\" with a \"complexFieldLabel\" and a \"labelKey\" property on your Column Definition, example: this.columnDefs = [{ id: 'user', field: 'user', labelKey: 'firstName' params: { complexFieldLabel: 'user' } }]\r\n      3- via the field name that includes a dot notation, example: this.columnDefs = [{ id: 'user', field: 'user.firstName'}] `);\r\n    }\r\n    if (columnDef.labelKey && dataContext.hasOwnProperty(complexFieldLabel)) {\r\n        return dataContext[complexFieldLabel] && dataContext[complexFieldLabel][columnDef.labelKey];\r\n    }\r\n    // when complexFieldLabel includes the dot \".\", we will do the split and get the value from the complex object\r\n    // however we also need to make sure that the complex objet exist, else we'll return the cell value (original value)\r\n    if (typeof complexFieldLabel === 'string' && complexFieldLabel.indexOf('.') > 0) {\r\n        return complexFieldLabel.split('.').reduce((obj, i) => (obj && obj.hasOwnProperty(i) ? obj[i] : cellValue), dataContext);\r\n    }\r\n    return cellValue;\r\n};\n\nconst decimalFormatter = (row, cell, value, columnDef, dataContext, grid) => {\r\n    const isNumber = (value === null || value === undefined || value === '') ? false : !isNaN(+value);\r\n    const params = columnDef.params || {};\r\n    let minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid, 2);\r\n    let maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid, 2);\r\n    const decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');\r\n    const thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');\r\n    const displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);\r\n    // @deprecated: decimalPlaces, minDecimalPlaces, maxDecimalPlaces\r\n    // add these extra checks to support previous way of passing the decimal count\r\n    if ((params.minDecimalPlaces !== null && params.minDecimalPlaces) || (params.decimalPlaces !== null && params.decimalPlaces)) {\r\n        console.warn('[Angular-Slickgrid] please consider using \"minDecimal\" (instead of \"minDecimalPlaces\" or \"decimalPlaces\").');\r\n        minDecimal = (params.minDecimalPlaces !== null && params.minDecimalPlaces) || (params.decimalPlaces !== null && params.decimalPlaces);\r\n    }\r\n    if (params.maxDecimalPlaces !== null && params.maxDecimalPlaces) {\r\n        console.warn('[Angular-Slickgrid] please consider using \"maxDecimal\" (instead of \"maxDecimalPlaces\").');\r\n        maxDecimal = (params.maxDecimalPlaces !== null && params.maxDecimalPlaces);\r\n    }\r\n    if (isNumber) {\r\n        return formatNumber(value, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '', '', decimalSeparator, thousandSeparator);\r\n    }\r\n    return value;\r\n};\n\nconst deleteIconFormatter = (row, cell, value, columnDef, dataContext) => `<i class=\"fa fa-trash pointer delete-icon\" aria-hidden=\"true\"></i>`;\n\nconst dollarColoredBoldFormatter = (row, cell, value, columnDef, dataContext, grid) => {\r\n    const isNumber = (value === null || value === undefined || value === '') ? false : !isNaN(+value);\r\n    const minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid, 2);\r\n    const maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid, 4);\r\n    const decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');\r\n    const thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');\r\n    const displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);\r\n    if (isNumber) {\r\n        const colorStyle = (value >= 0) ? 'green' : 'red';\r\n        const formattedNumber = formatNumber(value, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '$', '', decimalSeparator, thousandSeparator);\r\n        return `<span style=\"color:${colorStyle}; font-weight:bold;\">${formattedNumber}</span>`;\r\n    }\r\n    return value;\r\n};\n\nconst dollarColoredFormatter = (row, cell, value, columnDef, dataContext, grid) => {\r\n    const isNumber = (value === null || value === undefined || value === '') ? false : !isNaN(+value);\r\n    const minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid, 2);\r\n    const maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid, 4);\r\n    const decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');\r\n    const thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');\r\n    const displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);\r\n    if (isNumber) {\r\n        const colorStyle = (value >= 0) ? 'green' : 'red';\r\n        const formattedNumber = formatNumber(value, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '$', '', decimalSeparator, thousandSeparator);\r\n        return `<span style=\"color:${colorStyle}\">${formattedNumber}</span>`;\r\n    }\r\n    return value;\r\n};\n\nconst dollarFormatter = (row, cell, value, columnDef, dataContext, grid) => {\r\n    const isNumber = (value === null || value === undefined || value === '') ? false : !isNaN(+value);\r\n    const minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid, 2);\r\n    const maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid, 4);\r\n    const decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');\r\n    const thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');\r\n    const displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);\r\n    if (isNumber) {\r\n        return formatNumber(value, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '$', '', decimalSeparator, thousandSeparator);\r\n    }\r\n    return value;\r\n};\n\nconst editIconFormatter = (row, cell, value, columnDef, dataContext) => `<i class=\"fa fa-pencil pointer edit-icon\" aria-hidden=\"true\"></i>`;\n\nconst DOMPurify$3 = DOMPurify_; // patch to fix rollup to work\r\n/**\r\n * Takes an hyperlink cell value and transforms it into a real hyperlink, given that the value starts with 1 of these (http|ftp|https).\r\n * The structure will be \"<a href=\"hyperlink\">hyperlink</a>\"\r\n *\r\n * You can optionally change the hyperlink text displayed by using the generic params \"hyperlinkText\" in the column definition\r\n * For example: { id: 'link', field: 'link', params: { hyperlinkText: 'Company Website' } } will display \"<a href=\"link\">Company Website</a>\"\r\n *\r\n * You can also optionally provide the hyperlink URL by using the generic params \"hyperlinkUrl\" in the column definition\r\n * For example: { id: 'link', field: 'link', params: {  hyperlinkText: 'Company Website', hyperlinkUrl: 'http://www.somewhere.com' } } will display \"<a href=\"http://www.somewhere.com\">Company Website</a>\"\r\n */\r\nconst hyperlinkFormatter = (row, cell, value, columnDef, dataContext) => {\r\n    const columnParams = columnDef && columnDef.params || {};\r\n    let displayedText = columnParams.hyperlinkText ? columnParams.hyperlinkText : value;\r\n    displayedText = DOMPurify$3.sanitize(displayedText || '');\r\n    let outputLink = columnParams.hyperlinkUrl ? columnParams.hyperlinkUrl : value;\r\n    outputLink = DOMPurify$3.sanitize(outputLink || '');\r\n    const matchUrl = outputLink.match(/^(http|ftp|https):\\/\\/[\\w\\-_]+(\\.[\\w\\-_]+)+([\\w\\-\\.,@?^=%&amp;:\\/~\\+#]*[\\w\\-\\@?^=%&amp;\\/~\\+#])?/i);\r\n    if (matchUrl && Array.isArray(matchUrl) && matchUrl.length > 0) {\r\n        const finalUrl = matchUrl[0];\r\n        return `<a href=\"${finalUrl}\">${displayedText}</a>`;\r\n    }\r\n    return value;\r\n};\n\nconst iconFormatter = (row, cell, value, columnDef, dataContext) => {\r\n    const columnParams = columnDef && columnDef.params || {};\r\n    const icon = columnParams.icon || columnParams.formatterIcon;\r\n    if (!icon) {\r\n        throw new Error(`You must provide the \"icon\" or \"formatterIcon\" via the generic \"params\" options (e.g.: { formatter: Formatters.icon, params: { formatterIcon: 'fa fa-search' }}`);\r\n    }\r\n    return `<i class=\"${icon}\" aria-hidden=\"true\"></i>`;\r\n};\n\nconst infoIconFormatter = (row, cell, value, columnDef, dataContext) => `<i class=\"fa fa-info-circle pointer info-icon\" aria-hidden=\"true\"></i>`;\n\nconst italicFormatter = (row, cell, value, columnDef, dataContext) => {\r\n    return value ? `<i>${value}</i>` : '';\r\n};\n\nconst lowercaseFormatter = (row, cell, value, columnDef, dataContext) => {\r\n    // make sure the value is a string\r\n    if (value !== undefined && typeof value !== 'string') {\r\n        value = value + '';\r\n    }\r\n    return value ? value.toLowerCase() : '';\r\n};\n\n/**\r\n * Takes a value display it according to a mask provided\r\n * e.: 1234567890 with mask \"(000) 000-0000\" will display \"(123) 456-7890\"\r\n */\r\nconst maskFormatter = (row, cell, value, columnDef, dataContext) => {\r\n    const params = columnDef.params || {};\r\n    const mask = params.mask;\r\n    if (!mask) {\r\n        throw new Error(`You must provide a \"mask\" via the generic \"params\" options (e.g.: { formatter: Formatters.mask, params: { mask: '000-000' }}`);\r\n    }\r\n    if (value) {\r\n        let i = 0;\r\n        const v = value.toString();\r\n        return mask.replace(/[09A]/gi, () => v[i++] || '');\r\n    }\r\n    return value;\r\n};\n\nconst multipleFormatter = (row, cell, value, columnDef, dataContext, grid) => {\r\n    const params = columnDef.params || {};\r\n    if (!params.formatters || !Array.isArray(params.formatters)) {\r\n        throw new Error(`The multiple formatter requires the \"formatters\" to be provided as a column params.\r\n    For example: this.columnDefinitions = [{ id: title, field: title, formatter: Formatters.multiple, params: { formatters: [Formatters.lowercase, Formatters.uppercase] }`);\r\n    }\r\n    const formatters = params.formatters;\r\n    // loop through all Formatters, the value of 1st formatter will be used by 2nd formatter and so on.\r\n    // they are piped and executed in sequences\r\n    let currentValue = value;\r\n    for (const formatter of formatters) {\r\n        currentValue = formatter(row, cell, currentValue, columnDef, dataContext, grid);\r\n    }\r\n    return currentValue;\r\n};\n\nconst percentFormatter = (row, cell, value, columnDef, dataContext, grid) => {\r\n    const isNumber = (value === null || value === undefined || value === '') ? false : !isNaN(+value);\r\n    const minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid);\r\n    const maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid);\r\n    const decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');\r\n    const thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');\r\n    const displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);\r\n    if (isNumber) {\r\n        const percentValue = value * 100;\r\n        return formatNumber(percentValue, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '', '%', decimalSeparator, thousandSeparator);\r\n    }\r\n    return value;\r\n};\n\nconst percentCompleteBarFormatter = (row, cell, value, columnDef, dataContext) => {\r\n    const isNumber = (value === null || value === undefined || value === '') ? false : !isNaN(+value);\r\n    if (!isNumber) {\r\n        return '';\r\n    }\r\n    let color = '';\r\n    let inputNumber = parseFloat(value);\r\n    if (inputNumber > 100) {\r\n        inputNumber = 100;\r\n    }\r\n    if (inputNumber < 30) {\r\n        color = 'red';\r\n    }\r\n    else if (inputNumber < 70) {\r\n        color = 'silver';\r\n    }\r\n    else {\r\n        color = 'green';\r\n    }\r\n    return `<span class=\"percent-complete-bar\" style=\"background:${color}; width:${inputNumber}%\"></span>`;\r\n};\n\nconst percentCompleteFormatter = (row, cell, value, columnDef, dataContext, grid) => {\r\n    const isNumber = (value === null || value === undefined || value === '') ? false : !isNaN(+value);\r\n    const minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid);\r\n    const maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid);\r\n    const decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');\r\n    const thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');\r\n    const displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);\r\n    if (isNumber) {\r\n        const colorStyle = (value < 50) ? 'red' : 'green';\r\n        const formattedNumber = formatNumber(value, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '', '%', decimalSeparator, thousandSeparator);\r\n        const outputFormattedValue = value > 100 ? '100%' : formattedNumber;\r\n        return `<span style='color:${colorStyle}'>${outputFormattedValue}</span>`;\r\n    }\r\n    return value;\r\n};\n\nconst percentSymbolFormatter = (row, cell, value, columnDef, dataContext, grid) => {\r\n    const isNumber = (value === null || value === undefined || value === '') ? false : !isNaN(+value);\r\n    const minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid);\r\n    const maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid);\r\n    const decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');\r\n    const thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');\r\n    const displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);\r\n    if (isNumber) {\r\n        return formatNumber(value, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '', '%', decimalSeparator, thousandSeparator);\r\n    }\r\n    return value;\r\n};\n\nconst progressBarFormatter = (row, cell, value, columnDef, dataContext) => {\r\n    const isNumber = (value === null || value === undefined || value === '') ? false : !isNaN(+value);\r\n    if (!isNumber) {\r\n        return '';\r\n    }\r\n    let color = '';\r\n    let inputNumber = parseFloat(value);\r\n    if (inputNumber > 100) {\r\n        inputNumber = 100;\r\n    }\r\n    if (inputNumber < 30) {\r\n        color = 'danger';\r\n    }\r\n    else if (inputNumber < 70) {\r\n        color = 'warning';\r\n    }\r\n    else {\r\n        color = 'success';\r\n    }\r\n    const output = `<div class=\"progress\">\r\n    <div class=\"progress-bar progress-bar-${color} bg-${color}\" role=\"progressbar\" aria-valuenow=\"${inputNumber}\" aria-valuemin=\"0\" aria-valuemax=\"100\" style=\"min-width: 2em; width: ${inputNumber}%;\">\r\n    ${inputNumber}%\r\n    </div>\r\n  </div>`;\r\n    return output.replace(/\\s{2,}/g, ' ').trim();\r\n};\n\n/** Takes a cell value and translates it with the \"ngx-translate\" service */\r\nconst translateFormatter = (row, cell, value, columnDef, dataContext, grid) => {\r\n    const gridOptions = (grid && typeof grid.getOptions === 'function') ? grid.getOptions() : {};\r\n    const translate = gridOptions.i18n || (columnDef && columnDef.params && columnDef.params.i18n);\r\n    if (!translate || typeof translate.instant !== 'function') {\r\n        throw new Error(`The translate formatter requires the \"ngx-translate\" Service to be provided as a Grid Options or Column Definition \"i18n\".\r\n    For example: this.gridOptions = { enableTranslate: true, i18n: this.translate }`);\r\n    }\r\n    // make sure the value is a string (for example a boolean value would throw an error)\r\n    if (value !== undefined && value !== null && typeof value !== 'string') {\r\n        value = value + '';\r\n    }\r\n    return value ? translate.instant(value) : '';\r\n};\n\n/** Takes a boolean value, cast it to upperCase string and finally translates it with the \"ngx-translate\" service */\r\nconst translateBooleanFormatter = (row, cell, value, columnDef, dataContext, grid) => {\r\n    const gridOptions = (grid && typeof grid.getOptions === 'function') ? grid.getOptions() : {};\r\n    const translate = gridOptions.i18n || (columnDef && columnDef.params && columnDef.params.i18n);\r\n    if (!translate || typeof translate.instant !== 'function') {\r\n        throw new Error(`The translate formatter requires the \"ngx-translate\" Service to be provided as a Grid Options or Column Definition \"i18n\".\r\n    For example: this.gridOptions = { enableTranslate: true, i18n: this.translate }`);\r\n    }\r\n    // make sure the value is a string (for example a boolean value would throw an error)\r\n    if (value !== undefined && value !== null && typeof value !== 'string') {\r\n        value = value + '';\r\n    }\r\n    return value ? translate.instant(value.toUpperCase()) : '';\r\n};\n\nconst uppercaseFormatter = (row, cell, value, columnDef, dataContext) => {\r\n    // make sure the value is a string\r\n    if (value !== undefined && typeof value !== 'string') {\r\n        value = value + '';\r\n    }\r\n    return value ? value.toUpperCase() : '';\r\n};\n\nconst yesNoFormatter = (row, cell, value, columnDef, dataContext) => value ? 'Yes' : 'No';\n\nconst bsDropdownFormatter = (row, cell, value, columnDef, dataContext) => {\r\n    const columnParams = columnDef && columnDef.params || {};\r\n    const label = columnParams.label || columnParams.formatterLabel;\r\n    if (!label) {\r\n        throw new Error(`You must provide the \"label\" or \"formatterLabel\" via the generic \"params\" options (e.g.: { formatter: Formatters.bsDropdown, params: { formatterLabel: 'Label' }}`);\r\n    }\r\n    return `<div id=\"myDrop-r${row}-c${cell}\" class=\"dropdown pointer\">\r\n    <a class=\"dropdown-toggle\">\r\n      ${label}\r\n      <span class=\"caret\"></span>\r\n    </a>\r\n  </div>`;\r\n};\n\n/** Provides a list of different Formatters that will change the cell value displayed in the UI */\r\nconst Formatters = {\r\n    /**\r\n     * Takes an array of complex objects converts it to a comma delimited string.\r\n     * Requires to pass an array of \"propertyNames\" in the column definition the generic \"params\" property\r\n     * For example, if we have an array of user objects that have the property of firstName & lastName then we need to pass in your column definition::\r\n     * params: { propertyNames: ['firtName', 'lastName'] } => 'John Doe, Jane Doe'\r\n     */\r\n    arrayObjectToCsv: arrayObjectToCsvFormatter,\r\n    /** Takes an array of string and converts it to a comma delimited string */\r\n    arrayToCsv: arrayToCsvFormatter,\r\n    /** show value in bold font weight */\r\n    bold: boldFormatter,\r\n    /** boostrap dropdown formatter */\r\n    bsDropdown: bsDropdownFormatter,\r\n    /** When value is filled (true), it will display a checkbox Unicode icon */\r\n    checkbox: checkboxFormatter,\r\n    /**\r\n     * When value is filled, or if the value is a number and is bigger than 0, it will display a Font-Awesome icon (fa-check).\r\n     * The icon will NOT be displayed when the value is any of the following (\"false\", false, \"0\", 0, -0.5, null, undefined)\r\n     * Anything else than the condition specified will display the icon, so a text with \"00123\" will display the icon but \"0\" will not.\r\n     * Also note that a string (\"null\", \"undefined\") will display the icon but (null, undefined) will not, so the typeof is also important\r\n     */\r\n    checkmark: checkmarkFormatter,\r\n    /**\r\n     * Takes a complex data object and return the data under that property (for example: \"user.firstName\" will return the first name \"John\")\r\n     * You can pass the complex structure in the \"field\" or the \"params: { complexField: string }\" properties.\r\n     * For example::\r\n     * this.columnDefs = [{ id: 'username', field: 'user.firstName', ... }]\r\n     * OR this.columnDefs = [{ id: 'username', field: 'user', params: { complexField: 'user.firstName' }, ... }]\r\n     */\r\n    complexObject: complexObjectFormatter,\r\n    /**\r\n     * Looks up values from the columnDefinition.params.collection property and displays the label in CSV or string format\r\n     * @example\r\n     * // the grid will display 'foo' and 'bar' and not 1 and 2 from your dataset\r\n     * { params: { collection: [{ value: 1, label: 'foo'}, {value: 2, label: 'bar' }] }}\r\n     * const dataset = [1, 2];\r\n     */\r\n    collection: collectionFormatter,\r\n    /**\r\n     * Roughly the same as the \"collectionFormatter\" except that it\r\n     * looks up values from the columnDefinition.editor.collection (instead of params) property and displays the label in CSV or string format\r\n     * @example\r\n     * // the grid will display 'foo' and 'bar' and not 1 and 2 from your dataset\r\n     * { editor: { collection: [{ value: 1, label: 'foo'}, {value: 2, label: 'bar' }] }}\r\n     * const dataset = [1, 2];\r\n     */\r\n    collectionEditor: collectionEditorFormatter,\r\n    /** Takes a Date object and displays it as an ISO Date format (YYYY-MM-DD) */\r\n    dateIso: getAssociatedDateFormatter(FieldType.dateIso, '-'),\r\n    /** Takes a Date object and displays it as an ISO Date+Time format (YYYY-MM-DD HH:mm:ss) */\r\n    dateTimeIso: getAssociatedDateFormatter(FieldType.dateTimeIso, '-'),\r\n    /** Takes a Date object and displays it as an ISO Date+Time (without seconds) format (YYYY-MM-DD HH:mm) */\r\n    dateTimeShortIso: getAssociatedDateFormatter(FieldType.dateTimeShortIso, '-'),\r\n    /** Takes a Date object and displays it as an ISO Date+Time+(am/pm) format (YYYY-MM-DD h:mm:ss a) */\r\n    dateTimeIsoAmPm: getAssociatedDateFormatter(FieldType.dateTimeIsoAmPm, '-'),\r\n    /** Takes a Date object and displays it as an Euro Date format (DD/MM/YYYY) */\r\n    dateEuro: getAssociatedDateFormatter(FieldType.dateEuro, '/'),\r\n    /** Takes a Date object and displays it as an Euro Date+Time format (DD/MM/YYYY HH:mm:ss) */\r\n    dateTimeEuro: getAssociatedDateFormatter(FieldType.dateTimeEuro, '/'),\r\n    /** Takes a Date object and displays it as an Euro Date+Time (without seconds) format (DD/MM/YYYY HH:mm) */\r\n    dateTimeShortEuro: getAssociatedDateFormatter(FieldType.dateTimeShortEuro, '/'),\r\n    /** Takes a Date object and displays it as an Euro Date+Time+(am/pm) format (DD/MM/YYYY hh:mm:ss a) */\r\n    dateTimeEuroAmPm: getAssociatedDateFormatter(FieldType.dateTimeEuroAmPm, '/'),\r\n    /** Takes a Date object and displays it as an US Date format (MM/DD/YYYY) */\r\n    dateUs: getAssociatedDateFormatter(FieldType.dateUs, '/'),\r\n    /** Takes a Date object and displays it as an US Date+Time format (MM/DD/YYYY HH:mm:ss) */\r\n    dateTimeUs: getAssociatedDateFormatter(FieldType.dateTimeUs, '/'),\r\n    /** Takes a Date object and displays it as an US Date+Time (without seconds) format (MM/DD/YYYY HH:mm:ss) */\r\n    dateTimeShortUs: getAssociatedDateFormatter(FieldType.dateTimeShortUs, '/'),\r\n    /** Takes a Date object and displays it as an US Date+Time+(am/pm) format (MM/DD/YYYY hh:mm:ss a) */\r\n    dateTimeUsAmPm: getAssociatedDateFormatter(FieldType.dateTimeUsAmPm, '/'),\r\n    /** Displays a Font-Awesome delete icon (fa-trash) */\r\n    deleteIcon: deleteIconFormatter,\r\n    /**\r\n     * Display the value as x decimals formatted, defaults to 2 decimals.\r\n     * You can pass \"decimalPlaces\" or \"minDecimalPlaces\" and/or \"maxDecimalPlaces\" to the \"params\" property.\r\n     * For example:: `{ formatter: Formatters.decimal, params: { decimalPlaces: 3 }}`\r\n     * The property \"decimalPlaces\" is an alias of \"minDecimalPlaces\"\r\n     */\r\n    decimal: decimalFormatter,\r\n    /** Display the value as 2 decimals formatted with dollar sign '$' at the end of of the value */\r\n    dollar: dollarFormatter,\r\n    /** Display the value as 2 decimals formatted with dollar sign '$' at the end of of the value, change color of text to red/green on negative/positive value */\r\n    dollarColored: dollarColoredFormatter,\r\n    /** Display the value as 2 decimals formatted with dollar sign '$' at the end of of the value, change color of text to red/green on negative/positive value, show it in bold font weight as well */\r\n    dollarColoredBold: dollarColoredBoldFormatter,\r\n    /** Displays a Font-Awesome edit icon (fa-pencil) */\r\n    editIcon: editIconFormatter,\r\n    /**\r\n     * Takes an hyperlink cell value and transforms it into a real hyperlink, given that the value starts with 1 of these (http|ftp|https).\r\n     * The structure will be \"<a href=\"hyperlink\">hyperlink</a>\"\r\n     *\r\n     * You can optionally change the hyperlink text displayed by using the generic params \"hyperlinkText\" in the column definition\r\n     * For example: { id: 'link', field: 'link', params: { hyperlinkText: 'Company Website' } } will display \"<a href=\"link\">Company Website</a>\"\r\n     *\r\n     * You can also optionally provide the hyperlink URL by using the generic params \"hyperlinkUrl\" in the column definition\r\n     * For example: { id: 'link', field: 'link', params: {  hyperlinkText: 'Company Website', hyperlinkUrl: 'http://www.somewhere.com' } } will display \"<a href=\"http://www.somewhere.com\">Company Website</a>\"\r\n     */\r\n    hyperlink: hyperlinkFormatter,\r\n    /** Display whichever icon you want (library agnostic, it could be Font-Awesome or any other) */\r\n    icon: iconFormatter,\r\n    /** Displays a Font-Awesome edit icon (fa-info-circle) */\r\n    infoIcon: infoIconFormatter,\r\n    /** show input text value as italic text */\r\n    italic: italicFormatter,\r\n    /** Takes a value and displays it all lowercase */\r\n    lowercase: lowercaseFormatter,\r\n    /**\r\n     * Takes a value display it according to a mask provided\r\n     * e.: 1234567890 with mask \"(000) 000-0000\" will display \"(123) 456-7890\"\r\n     */\r\n    mask: maskFormatter,\r\n    /**\r\n     * You can pipe multiple formatters (executed in sequence), use params to pass the list of formatters.\r\n     * Requires to pass an array of \"formatters\" in the column definition the generic \"params\" property\r\n     * For example::\r\n     * { field: 'title', formatter: Formatters.multiple, params: { formatters: [ Formatters.lowercase, Formatters.uppercase ] }\r\n     */\r\n    multiple: multipleFormatter,\r\n    /** Takes a cell value number (between 0.0-1.0) and displays a red (<50) or green (>=50) bar */\r\n    percent: percentFormatter,\r\n    /** Takes a cell value number (between 0.0-100) and displays a red (<50) or green (>=50) bar */\r\n    percentComplete: percentCompleteFormatter,\r\n    /** Takes a cell value number (between 0-100) and displays Bootstrap \"percent-complete-bar\" a red (<30), silver (>30 & <70) or green (>=70) bar */\r\n    percentCompleteBar: percentCompleteBarFormatter,\r\n    /** Takes a cell value number (between 0-100) and add the \"%\" after the number */\r\n    percentSymbol: percentSymbolFormatter,\r\n    /** Takes a cell value number (between 0-100) and displays Bootstrap \"progress-bar\" a red (<30), silver (>30 & <70) or green (>=70) bar */\r\n    progressBar: progressBarFormatter,\r\n    /** Takes a cell value and translates it (i18n). Requires an instance of the Translate Service:: `i18n: this.translate */\r\n    translate: translateFormatter,\r\n    /** Takes a boolean value, cast it to upperCase string and finally translates it (i18n). */\r\n    translateBoolean: translateBooleanFormatter,\r\n    /** Takes a value and displays it all uppercase */\r\n    uppercase: uppercaseFormatter,\r\n    /** Takes a boolean value and display a string 'Yes' or 'No' */\r\n    yesNo: yesNoFormatter\r\n};\n\nconst avgTotalsPercentageFormatter = (totals, columnDef, grid) => {\r\n    const field = columnDef.field || '';\r\n    let val = totals.avg && totals.avg[field];\r\n    const params = columnDef && columnDef.params;\r\n    let prefix = params && params.groupFormatterPrefix || '';\r\n    const suffix = params && params.groupFormatterSuffix || '';\r\n    const minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid);\r\n    const maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid);\r\n    const decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');\r\n    const thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');\r\n    const displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);\r\n    if (val != null && !isNaN(+val)) {\r\n        if (val < 0) {\r\n            val = Math.abs(val);\r\n            if (!displayNegativeNumberWithParentheses) {\r\n                prefix += '-';\r\n            }\r\n            else {\r\n                if (isNaN(minDecimal) && isNaN(maxDecimal)) {\r\n                    const outputVal = thousandSeparatorFormatted(Math.round(val), thousandSeparator);\r\n                    return `${prefix}(${outputVal}%)${suffix}`;\r\n                }\r\n                return `${prefix}(${decimalFormatted(val, minDecimal, maxDecimal, decimalSeparator, thousandSeparator)}%)${suffix}`;\r\n            }\r\n        }\r\n        if (isNaN(minDecimal) && isNaN(maxDecimal)) {\r\n            const outputVal = thousandSeparatorFormatted(Math.round(val), thousandSeparator);\r\n            return `${prefix}${outputVal}%${suffix}`;\r\n        }\r\n        return `${prefix}${decimalFormatted(val, minDecimal, maxDecimal, decimalSeparator, thousandSeparator)}%${suffix}`;\r\n    }\r\n    return '';\r\n};\n\nconst avgTotalsDollarFormatter = (totals, columnDef, grid) => {\r\n    const field = columnDef.field || '';\r\n    const val = totals.avg && totals.avg[field];\r\n    const params = columnDef && columnDef.params;\r\n    const prefix = params && params.groupFormatterPrefix || '';\r\n    const suffix = params && params.groupFormatterSuffix || '';\r\n    const minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid, 2);\r\n    const maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid, 4);\r\n    const decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');\r\n    const thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');\r\n    const displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);\r\n    if (val != null && !isNaN(+val)) {\r\n        const formattedNumber = formatNumber(val, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '$', '', decimalSeparator, thousandSeparator);\r\n        return `${prefix}${formattedNumber}${suffix}`;\r\n    }\r\n    return '';\r\n};\n\nconst avgTotalsFormatter = (totals, columnDef, grid) => {\r\n    const field = columnDef.field || '';\r\n    let val = totals.avg && totals.avg[field];\r\n    const params = columnDef && columnDef.params;\r\n    let prefix = params && params.groupFormatterPrefix || '';\r\n    const suffix = params && params.groupFormatterSuffix || '';\r\n    const minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid);\r\n    const maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid);\r\n    const decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');\r\n    const thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');\r\n    const displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);\r\n    if (val != null && !isNaN(+val)) {\r\n        if (val < 0) {\r\n            val = Math.abs(val);\r\n            if (!displayNegativeNumberWithParentheses) {\r\n                prefix += '-';\r\n            }\r\n            else {\r\n                if (isNaN(minDecimal) && isNaN(maxDecimal)) {\r\n                    const outputVal = thousandSeparatorFormatted(Math.round(val), thousandSeparator);\r\n                    return `${prefix}(${outputVal})${suffix}`;\r\n                }\r\n                return `${prefix}(${decimalFormatted(val, minDecimal, maxDecimal, decimalSeparator, thousandSeparator)})${suffix}`;\r\n            }\r\n        }\r\n        if (isNaN(minDecimal) && isNaN(maxDecimal)) {\r\n            const outputVal = thousandSeparatorFormatted(Math.round(val), thousandSeparator);\r\n            return `${prefix}${outputVal}${suffix}`;\r\n        }\r\n        return `${prefix}${decimalFormatted(val, minDecimal, maxDecimal, decimalSeparator, thousandSeparator)}${suffix}`;\r\n    }\r\n    return '';\r\n};\n\nconst minTotalsFormatter = (totals, columnDef, grid) => {\r\n    const field = columnDef.field || '';\r\n    const val = totals.min && totals.min[field];\r\n    const params = columnDef && columnDef.params;\r\n    const prefix = params && params.groupFormatterPrefix || '';\r\n    const suffix = params && params.groupFormatterSuffix || '';\r\n    const minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid);\r\n    const maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid);\r\n    const decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');\r\n    const thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');\r\n    const displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);\r\n    if (val != null && !isNaN(+val)) {\r\n        const formattedNumber = formatNumber(val, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '', '', decimalSeparator, thousandSeparator);\r\n        return `${prefix}${formattedNumber}${suffix}`;\r\n    }\r\n    return '';\r\n};\n\nconst maxTotalsFormatter = (totals, columnDef, grid) => {\r\n    const field = columnDef.field || '';\r\n    const val = totals.max && totals.max[field];\r\n    const params = columnDef && columnDef.params;\r\n    const prefix = params && params.groupFormatterPrefix || '';\r\n    const suffix = params && params.groupFormatterSuffix || '';\r\n    const minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid);\r\n    const maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid);\r\n    const decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');\r\n    const thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');\r\n    const displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);\r\n    if (val != null && !isNaN(+val)) {\r\n        const formattedNumber = formatNumber(val, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '', '', decimalSeparator, thousandSeparator);\r\n        return `${prefix}${formattedNumber}${suffix}`;\r\n    }\r\n    return '';\r\n};\n\nconst sumTotalsColoredFormatter = (totals, columnDef, grid) => {\r\n    const field = columnDef.field || '';\r\n    const val = totals.sum && totals.sum[field];\r\n    const params = columnDef && columnDef.params;\r\n    const prefix = params && params.groupFormatterPrefix || '';\r\n    const suffix = params && params.groupFormatterSuffix || '';\r\n    const minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid);\r\n    const maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid);\r\n    const decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');\r\n    const thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');\r\n    const displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);\r\n    if (val != null && !isNaN(+val)) {\r\n        const colorStyle = (val >= 0) ? 'green' : 'red';\r\n        const formattedNumber = formatNumber(val, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '', '', decimalSeparator, thousandSeparator);\r\n        return `<span style=\"color:${colorStyle}\">${prefix}${formattedNumber}${suffix}</span>`;\r\n    }\r\n    return '';\r\n};\n\nconst sumTotalsDollarColoredBoldFormatter = (totals, columnDef, grid) => {\r\n    const field = columnDef.field || '';\r\n    const val = totals.sum && totals.sum[field];\r\n    const params = columnDef && columnDef.params;\r\n    const prefix = params && params.groupFormatterPrefix || '';\r\n    const suffix = params && params.groupFormatterSuffix || '';\r\n    const minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid, 2);\r\n    const maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid, 4);\r\n    const decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');\r\n    const thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');\r\n    const displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);\r\n    if (val != null && !isNaN(+val)) {\r\n        const colorStyle = (val >= 0) ? 'green' : 'red';\r\n        const formattedNumber = formatNumber(val, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '$', '', decimalSeparator, thousandSeparator);\r\n        return `<span style=\"color:${colorStyle}; font-weight: bold;\">${prefix}${formattedNumber}${suffix}</span>`;\r\n    }\r\n    return '';\r\n};\n\nconst sumTotalsDollarColoredFormatter = (totals, columnDef, grid) => {\r\n    const field = columnDef.field || '';\r\n    const val = totals.sum && totals.sum[field];\r\n    const params = columnDef && columnDef.params;\r\n    const prefix = params && params.groupFormatterPrefix || '';\r\n    const suffix = params && params.groupFormatterSuffix || '';\r\n    const minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid, 2);\r\n    const maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid, 4);\r\n    const decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');\r\n    const thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');\r\n    const displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);\r\n    if (val != null && !isNaN(+val)) {\r\n        const colorStyle = (val >= 0) ? 'green' : 'red';\r\n        const formattedNumber = formatNumber(val, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '$', '', decimalSeparator, thousandSeparator);\r\n        return `<span style=\"color:${colorStyle}\">${prefix}${formattedNumber}${suffix}</span>`;\r\n    }\r\n    return '';\r\n};\n\nconst sumTotalsDollarBoldFormatter = (totals, columnDef, grid) => {\r\n    const field = columnDef.field || '';\r\n    const val = totals.sum && totals.sum[field];\r\n    const params = columnDef && columnDef.params;\r\n    const prefix = params && params.groupFormatterPrefix || '';\r\n    const suffix = params && params.groupFormatterSuffix || '';\r\n    const minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid, 2);\r\n    const maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid, 4);\r\n    const decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');\r\n    const thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');\r\n    const displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);\r\n    if (val != null && !isNaN(+val)) {\r\n        const formattedNumber = formatNumber(val, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '$', '', decimalSeparator, thousandSeparator);\r\n        return `<b>${prefix}${formattedNumber}${suffix}</b>`;\r\n    }\r\n    return '';\r\n};\n\nconst sumTotalsDollarFormatter = (totals, columnDef, grid) => {\r\n    const field = columnDef.field || '';\r\n    const val = totals.sum && totals.sum[field];\r\n    const params = columnDef && columnDef.params;\r\n    const prefix = params && params.groupFormatterPrefix || '';\r\n    const suffix = params && params.groupFormatterSuffix || '';\r\n    const minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid, 2);\r\n    const maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid, 4);\r\n    const decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');\r\n    const thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');\r\n    const displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);\r\n    if (val != null && !isNaN(+val)) {\r\n        const formattedNumber = formatNumber(val, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '$', '', decimalSeparator, thousandSeparator);\r\n        return `${prefix}${formattedNumber}${suffix}`;\r\n    }\r\n    return '';\r\n};\n\nconst sumTotalsFormatter = (totals, columnDef, grid) => {\r\n    const field = columnDef.field || '';\r\n    const val = totals.sum && totals.sum[field];\r\n    const params = columnDef && columnDef.params;\r\n    const prefix = params && params.groupFormatterPrefix || '';\r\n    const suffix = params && params.groupFormatterSuffix || '';\r\n    const minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid);\r\n    const maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid);\r\n    const decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');\r\n    const thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');\r\n    const displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);\r\n    if (val != null && !isNaN(+val)) {\r\n        const formattedNumber = formatNumber(val, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '', '', decimalSeparator, thousandSeparator);\r\n        return `${prefix}${formattedNumber}${suffix}`;\r\n    }\r\n    return '';\r\n};\n\nconst sumTotalsBoldFormatter = (totals, columnDef, grid) => {\r\n    const field = columnDef.field || '';\r\n    const val = totals.sum && totals.sum[field];\r\n    const params = columnDef && columnDef.params;\r\n    const prefix = params && params.groupFormatterPrefix || '';\r\n    const suffix = params && params.groupFormatterSuffix || '';\r\n    const minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid);\r\n    const maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid);\r\n    const decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');\r\n    const thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');\r\n    const displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);\r\n    if (val != null && !isNaN(+val)) {\r\n        const formattedNumber = formatNumber(val, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '', '', decimalSeparator, thousandSeparator);\r\n        return `<b>${prefix}${formattedNumber}${suffix}</b>`;\r\n    }\r\n    return '';\r\n};\n\n/** Provides a list of different Formatters that will change the cell value displayed in the UI */\r\nconst GroupTotalFormatters = {\r\n    /**\r\n     * Average all the column totals\r\n     * Extra options available in \"params\":: \"groupFormatterPrefix\" and \"groupFormatterSuffix\", e.g.: params: { groupFormatterPrefix: '<i>Total</i>: ', groupFormatterSuffix: '$' }\r\n     */\r\n    avgTotals: avgTotalsFormatter,\r\n    /**\r\n     * Average all the column totals and display '$' at the end of the value\r\n     * Extra options available in \"params\":: \"groupFormatterPrefix\" and \"groupFormatterSuffix\", e.g.: params: { groupFormatterPrefix: '<i>Total</i>: ', groupFormatterSuffix: '$' }\r\n     */\r\n    avgTotalsDollar: avgTotalsDollarFormatter,\r\n    /**\r\n     * Average all the column totals and display '%' at the end of the value\r\n     * Extra options available in \"params\":: \"groupFormatterPrefix\" and \"groupFormatterSuffix\", e.g.: params: { groupFormatterPrefix: '<i>Total</i>: ', groupFormatterSuffix: '$' }\r\n     */\r\n    avgTotalsPercentage: avgTotalsPercentageFormatter,\r\n    /**\r\n     * Show max value of all the column totals\r\n     * Extra options available in \"params\":: \"groupFormatterPrefix\" and \"groupFormatterSuffix\", e.g.: params: { groupFormatterPrefix: '<i>Total</i>: ', groupFormatterSuffix: '$' }\r\n     */\r\n    maxTotals: maxTotalsFormatter,\r\n    /**\r\n     * Show min value of all the column totals\r\n     * Extra options available in \"params\":: \"groupFormatterPrefix\" and \"groupFormatterSuffix\", e.g.: params: { groupFormatterPrefix: '<i>Total</i>: ', groupFormatterSuffix: '$' }\r\n     */\r\n    minTotals: minTotalsFormatter,\r\n    /**\r\n     * Sums up all the column totals\r\n     * Extra options available in \"params\":: \"groupFormatterPrefix\" and \"groupFormatterSuffix\", e.g.: params: { groupFormatterPrefix: '<i>Total</i>: ', groupFormatterSuffix: '$' }\r\n     */\r\n    sumTotals: sumTotalsFormatter,\r\n    /**\r\n     * Sums up all the column totals and display it in bold font weight\r\n     * Extra options available in \"params\":: \"groupFormatterPrefix\" and \"groupFormatterSuffix\", e.g: params: { groupFormatterPrefix: '<i>Total</i>: ', groupFormatterSuffix: '$' }\r\n     */\r\n    sumTotalsBold: sumTotalsBoldFormatter,\r\n    /**\r\n     * Sums up all the column totals, change color of text to red/green on negative/positive value\r\n     * Extra options available in \"params\":: \"groupFormatterPrefix\" and \"groupFormatterSuffix\", e.g: params: { groupFormatterPrefix: '<i>Total</i>: ', groupFormatterSuffix: '$' }\r\n     */\r\n    sumTotalsColored: sumTotalsColoredFormatter,\r\n    /**\r\n     * Sums up all the column totals and display dollar sign\r\n     * Extra options available in \"params\":: \"groupFormatterPrefix\" and \"groupFormatterSuffix\", e.g: params: { groupFormatterPrefix: '<i>Total</i>: ', groupFormatterSuffix: '$' }\r\n     */\r\n    sumTotalsDollar: sumTotalsDollarFormatter,\r\n    /**\r\n     * Sums up all the column totals and display dollar sign and show it in bold font weight\r\n     * Extra options available in \"params\":: \"groupFormatterPrefix\" and \"groupFormatterSuffix\", e.g: params: { groupFormatterPrefix: '<i>Total</i>: ', groupFormatterSuffix: '$' }\r\n     */\r\n    sumTotalsDollarBold: sumTotalsDollarBoldFormatter,\r\n    /**\r\n     * Sums up all the column totals, change color of text to red/green on negative/positive value\r\n     * Extra options available in \"params\":: \"groupFormatterPrefix\" and \"groupFormatterSuffix\", e.g: params: { groupFormatterPrefix: '<i>Total</i>: ', groupFormatterSuffix: '$' }\r\n     */\r\n    sumTotalsDollarColored: sumTotalsDollarColoredFormatter,\r\n    /**\r\n     * Sums up all the column totals, change color of text to red/green on negative/positive value, show it in bold font weight as well\r\n     * Extra options available in \"params\":: \"groupFormatterPrefix\" and \"groupFormatterSuffix\", e.g: params: { groupFormatterPrefix: '<i>Total</i>: ', groupFormatterSuffix: '$' }\r\n     */\r\n    sumTotalsDollarColoredBold: sumTotalsDollarColoredBoldFormatter,\r\n};\n\nlet SlickPaginationComponent = class SlickPaginationComponent {\r\n    /** Constructor */\r\n    constructor(paginationService, translate) {\r\n        this.paginationService = paginationService;\r\n        this.translate = translate;\r\n        this.subscriptions = [];\r\n        this._enableTranslate = false;\r\n        // text translations (handled by ngx-translate or by custom locale)\r\n        this.textItemsPerPage = 'items per page';\r\n        this.textItems = 'items';\r\n        this.textOf = 'of';\r\n        this.textPage = 'Page';\r\n    }\r\n    get availablePageSizes() {\r\n        return this.paginationService.availablePageSizes;\r\n    }\r\n    get dataFrom() {\r\n        return this.paginationService.dataFrom;\r\n    }\r\n    get dataTo() {\r\n        return this.paginationService.dataTo;\r\n    }\r\n    get itemsPerPage() {\r\n        return this.paginationService.itemsPerPage;\r\n    }\r\n    get pageCount() {\r\n        return this.paginationService.pageCount;\r\n    }\r\n    get pageNumber() {\r\n        return this.paginationService.pageNumber;\r\n    }\r\n    set pageNumber(page) {\r\n        // the setter has to be declared but we won't use it, instead we will use the \"changeToCurrentPage()\" to only update the value after ENTER keydown event\r\n    }\r\n    get totalItems() {\r\n        return this.paginationService.totalItems;\r\n    }\r\n    ngOnDestroy() {\r\n        this.dispose();\r\n    }\r\n    ngOnInit() {\r\n        const gridOptions = this.gridOptions || {};\r\n        this._enableTranslate = gridOptions && gridOptions.enableTranslate || false;\r\n        this._locales = gridOptions && gridOptions.locales || Constants.locales;\r\n        if (this._enableTranslate && !this.translate) {\r\n            throw new Error('[Angular-Slickgrid] requires \"ngx-translate\" to be installed and configured when the grid option \"enableTranslate\" is enabled.');\r\n        }\r\n        this.translateAllUiTexts(this._locales);\r\n        // translate all the text using ngx-translate or custom locales\r\n        if (this._enableTranslate && this.translate && this.translate.onLangChange) {\r\n            this.subscriptions.push(this.translate.onLangChange.subscribe(() => this.translateAllUiTexts(this._locales)));\r\n        }\r\n    }\r\n    changeToFirstPage(event) {\r\n        this.paginationService.goToFirstPage(event);\r\n    }\r\n    changeToLastPage(event) {\r\n        this.paginationService.goToLastPage(event);\r\n    }\r\n    changeToNextPage(event) {\r\n        this.paginationService.goToNextPage(event);\r\n    }\r\n    changeToPreviousPage(event) {\r\n        this.paginationService.goToPreviousPage(event);\r\n    }\r\n    changeToCurrentPage(event) {\r\n        let pageNumber = 1;\r\n        if (event && event.currentTarget && event.currentTarget.value) {\r\n            pageNumber = +(event.currentTarget.value);\r\n        }\r\n        this.paginationService.goToPageNumber(pageNumber, event);\r\n    }\r\n    changeItemPerPage(event) {\r\n        let itemsPerPage = 1;\r\n        if (event && event.currentTarget && event.currentTarget.value) {\r\n            itemsPerPage = +(event.currentTarget.value);\r\n        }\r\n        this.paginationService.changeItemPerPage(itemsPerPage, event);\r\n    }\r\n    dispose() {\r\n        this.paginationService.dispose();\r\n        // also unsubscribe all Angular Subscriptions\r\n        this.subscriptions = unsubscribeAllObservables(this.subscriptions);\r\n    }\r\n    // --\r\n    // private functions\r\n    // --------------------\r\n    /** Translate all the texts shown in the UI, use ngx-translate service when available or custom locales when service is null */\r\n    translateAllUiTexts(locales) {\r\n        if (this._enableTranslate && this.translate && this.translate.instant && this.translate.currentLang) {\r\n            this.textItemsPerPage = this.translate.instant('ITEMS_PER_PAGE');\r\n            this.textItems = this.translate.instant('ITEMS');\r\n            this.textOf = this.translate.instant('OF');\r\n            this.textPage = this.translate.instant('PAGE');\r\n        }\r\n        else if (locales) {\r\n            this.textItemsPerPage = locales.TEXT_ITEMS_PER_PAGE || 'TEXT_ITEMS_PER_PAGE';\r\n            this.textItems = locales.TEXT_ITEMS || 'TEXT_ITEMS';\r\n            this.textOf = locales.TEXT_OF || 'TEXT_OF';\r\n            this.textPage = locales.TEXT_PAGE || 'TEXT_PAGE';\r\n        }\r\n    }\r\n};\r\n__decorate([\r\n    Input(),\r\n    __metadata(\"design:type\", Object)\r\n], SlickPaginationComponent.prototype, \"gridOptions\", void 0);\r\nSlickPaginationComponent = __decorate([\r\n    Component({\r\n        selector: 'slick-pagination',\r\n        template: \"<div class=\\\"slick-pagination\\\">\\r\\n  <div class=\\\"slick-pagination-nav\\\">\\r\\n    <nav aria-label=\\\"Page navigation\\\">\\r\\n      <ul class=\\\"pagination\\\">\\r\\n        <li class=\\\"page-item\\\" [ngClass]=\\\"(pageNumber === 1 || totalItems === 0) ? 'disabled' : ''\\\">\\r\\n          <a class=\\\"page-link icon-seek-first fa fa-angle-double-left\\\" aria-label=\\\"First\\\"\\r\\n            (click)=\\\"changeToFirstPage($event)\\\">\\r\\n          </a>\\r\\n        </li>\\r\\n        <li class=\\\"page-item\\\" [ngClass]=\\\"(pageNumber === 1 || totalItems === 0) ? 'disabled' : ''\\\">\\r\\n          <a class=\\\"page-link icon-seek-prev fa fa-angle-left\\\" aria-label=\\\"Previous\\\"\\r\\n            (click)=\\\"changeToPreviousPage($event)\\\">\\r\\n          </a>\\r\\n        </li>\\r\\n      </ul>\\r\\n    </nav>\\r\\n\\r\\n    <div class=\\\"slick-page-number\\\">\\r\\n      <span>{{textPage}}</span>\\r\\n      <input type=\\\"text\\\" class=\\\"form-control\\\" data-test=\\\"page-number-input\\\" [value]=\\\"pageNumber\\\" size=\\\"1\\\"\\r\\n        [readOnly]=\\\"totalItems === 0\\\" (change)=\\\"changeToCurrentPage($event)\\\">\\r\\n      <span>{{textOf}}</span><span data-test=\\\"page-count\\\"> {{pageCount}}</span>\\r\\n    </div>\\r\\n\\r\\n    <nav aria-label=\\\"Page navigation\\\">\\r\\n      <ul class=\\\"pagination\\\">\\r\\n        <li class=\\\"page-item\\\" [ngClass]=\\\"(pageNumber === pageCount || totalItems === 0) ? 'disabled' : ''\\\">\\r\\n          <a class=\\\"page-link icon-seek-next text-center fa fa-lg fa-angle-right\\\" aria-label=\\\"Next\\\"\\r\\n            (click)=\\\"changeToNextPage($event)\\\">\\r\\n          </a>\\r\\n        </li>\\r\\n        <li class=\\\"page-item\\\" [ngClass]=\\\"(pageNumber === pageCount || totalItems === 0) ? 'disabled' : ''\\\">\\r\\n          <a class=\\\"page-link icon-seek-end fa fa-lg fa-angle-double-right\\\" aria-label=\\\"Last\\\"\\r\\n            (click)=\\\"changeToLastPage($event)\\\">\\r\\n          </a>\\r\\n        </li>\\r\\n      </ul>\\r\\n    </nav>\\r\\n  </div>\\r\\n  <span class=\\\"slick-pagination-settings\\\">\\r\\n    <select id=\\\"items-per-page-label\\\" [value]=\\\"itemsPerPage\\\" (change)=\\\"changeItemPerPage($event)\\\">\\r\\n      <option value=\\\"{{pageSize}}\\\" *ngFor=\\\"let pageSize of availablePageSizes\\\">{{pageSize}}</option>\\r\\n    </select>\\r\\n    <span>{{textItemsPerPage}}</span>,\\r\\n    <span class=\\\"slick-pagination-count\\\">\\r\\n      <span *ngIf=\\\"totalItems\\\">\\r\\n        <span class=\\\"page-info-from-to\\\">\\r\\n          <span data-test=\\\"item-from\\\">{{dataFrom}}</span>-<span data-test=\\\"item-to\\\">{{dataTo}}</span>\\r\\n          {{textOf}}\\r\\n        </span>\\r\\n      </span>\\r\\n      <span class=\\\"page-info-total-items\\\">\\r\\n        <span data-test=\\\"total-items\\\">{{totalItems}}</span> {{textItems}}\\r\\n      </span>\\r\\n    </span>\\r\\n  </span>\\r\\n</div>\\r\\n\"\r\n    }),\r\n    __param(1, Optional()),\r\n    __metadata(\"design:paramtypes\", [PaginationService, TranslateService])\r\n], SlickPaginationComponent);\n\nconst slickgridEventPrefix = 'sg';\r\nlet AngularSlickgridComponent = class AngularSlickgridComponent {\r\n    constructor(cd, elm, excelExportService, exportService, extensionService, extensionUtility, filterService, gridEventService, gridService, gridStateService, groupingAndColspanService, paginationService, resizer, sharedService, sortService, translate, forRootConfig) {\r\n        this.cd = cd;\r\n        this.elm = elm;\r\n        this.excelExportService = excelExportService;\r\n        this.exportService = exportService;\r\n        this.extensionService = extensionService;\r\n        this.extensionUtility = extensionUtility;\r\n        this.filterService = filterService;\r\n        this.gridEventService = gridEventService;\r\n        this.gridService = gridService;\r\n        this.gridStateService = gridStateService;\r\n        this.groupingAndColspanService = groupingAndColspanService;\r\n        this.paginationService = paginationService;\r\n        this.resizer = resizer;\r\n        this.sharedService = sharedService;\r\n        this.sortService = sortService;\r\n        this.translate = translate;\r\n        this.forRootConfig = forRootConfig;\r\n        this._eventHandler = new Slick.EventHandler();\r\n        this._hideHeaderRowAfterPageLoad = false;\r\n        this._isGridInitialized = false;\r\n        this._isDatasetInitialized = false;\r\n        this._isPaginationInitialized = false;\r\n        this._isLocalGrid = true;\r\n        this.groupingDefinition = {};\r\n        this.showCustomFooter = false;\r\n        this.showPagination = false;\r\n        this.totalItems = 0;\r\n        this.subscriptions = [];\r\n        this.onAngularGridCreated = new EventEmitter();\r\n        this.onDataviewCreated = new EventEmitter();\r\n        this.onGridCreated = new EventEmitter();\r\n        this.onGridInitialized = new EventEmitter();\r\n        this.onBeforeGridCreate = new EventEmitter();\r\n        this.onBeforeGridDestroy = new EventEmitter();\r\n        this.onAfterGridDestroyed = new EventEmitter();\r\n        this.onGridStateChanged = new EventEmitter();\r\n        this.onGridBeforeExportToFile = this.exportService.onGridBeforeExportToFile;\r\n        this.onGridAfterExportToFile = this.exportService.onGridAfterExportToFile;\r\n        this.onGridBeforeExportToExcel = this.excelExportService.onGridBeforeExportToExcel;\r\n        this.onGridAfterExportToExcel = this.excelExportService.onGridAfterExportToExcel;\r\n    }\r\n    set gridHeight(height) {\r\n        this._fixedHeight = height;\r\n    }\r\n    set gridWidth(width) {\r\n        this._fixedWidth = width;\r\n    }\r\n    set columnDefinitions(columnDefinitions) {\r\n        this._columnDefinitions = columnDefinitions;\r\n        if (this._isGridInitialized) {\r\n            this.updateColumnDefinitionsList(columnDefinitions);\r\n        }\r\n    }\r\n    get columnDefinitions() {\r\n        return this._columnDefinitions;\r\n    }\r\n    set dataset(dataset) {\r\n        this._dataset = dataset;\r\n        this.refreshGridData(dataset);\r\n    }\r\n    get dataset() {\r\n        return this.dataView.getItems();\r\n    }\r\n    get elementRef() {\r\n        return this.elm;\r\n    }\r\n    ngAfterViewInit() {\r\n        this.initialization();\r\n        this._isGridInitialized = true;\r\n        // user must provide a \"gridHeight\" or use \"autoResize: true\" in the grid options\r\n        if (!this._fixedHeight && !this.gridOptions.enableAutoResize) {\r\n            throw new Error(`[Angular-Slickgrid] requires a \"grid-height\" or the \"enableAutoResize\" grid option to be enabled.\n        Without that the grid will seem empty while in fact it just does not have any height define.`);\r\n        }\r\n    }\r\n    ngOnInit() {\r\n        this.onBeforeGridCreate.emit(true);\r\n        if (this.gridOptions && !this.gridOptions.enableAutoResize && (this._fixedHeight || this._fixedWidth)) {\r\n            this.gridHeightString = `${this._fixedHeight}px`;\r\n            this.gridWidthString = `${this._fixedWidth}px`;\r\n        }\r\n    }\r\n    ngOnDestroy() {\r\n        this.onBeforeGridDestroy.emit(this.grid);\r\n        this.destroy();\r\n        this.onAfterGridDestroyed.emit(true);\r\n    }\r\n    destroy(shouldEmptyDomElementContainer = false) {\r\n        this.dataView = undefined;\r\n        this.gridOptions = {};\r\n        this.extensionService.dispose();\r\n        this.filterService.dispose();\r\n        this.gridEventService.dispose();\r\n        this.gridStateService.dispose();\r\n        this.groupingAndColspanService.dispose();\r\n        this.paginationService.dispose();\r\n        this.resizer.dispose();\r\n        this.sortService.dispose();\r\n        if (this._eventHandler && this._eventHandler.unsubscribeAll) {\r\n            this._eventHandler.unsubscribeAll();\r\n        }\r\n        if (this.grid && this.grid.destroy) {\r\n            this.grid.destroy();\r\n        }\r\n        // we could optionally also empty the content of the grid container DOM element\r\n        if (shouldEmptyDomElementContainer) {\r\n            this.destroyGridContainerElm();\r\n        }\r\n        // also unsubscribe all RxJS subscriptions\r\n        this.subscriptions = unsubscribeAllObservables(this.subscriptions);\r\n    }\r\n    destroyGridContainerElm() {\r\n        const gridContainerId = this.gridOptions && this.gridOptions.gridContainerId || 'grid1';\r\n        $(gridContainerId).empty();\r\n    }\r\n    /** Dispatch of Custom Event, which by default will bubble & is cancelable */\r\n    dispatchCustomEvent(eventName, data, isBubbling = true, isCancelable = true) {\r\n        const eventInit = { bubbles: isBubbling, cancelable: isCancelable };\r\n        if (data) {\r\n            eventInit.detail = data;\r\n        }\r\n        return this.elm.nativeElement.dispatchEvent(new CustomEvent(eventName, eventInit));\r\n    }\r\n    /**\r\n     * Define our internal Post Process callback, it will execute internally after we get back result from the Process backend call\r\n     * For now, this is GraphQL Service ONLY feature and it will basically refresh the Dataset & Pagination without having the user to create his own PostProcess every time\r\n     */\r\n    createBackendApiInternalPostProcessCallback(gridOptions) {\r\n        const backendApi = gridOptions && gridOptions.backendServiceApi;\r\n        if (backendApi && backendApi.service) {\r\n            // internalPostProcess only works (for now) with a GraphQL Service, so make sure it is of that type\r\n            if (backendApi.service instanceof GraphqlService || typeof backendApi.service.getDatasetName === 'function') {\r\n                backendApi.internalPostProcess = (processResult) => {\r\n                    const datasetName = (backendApi && backendApi.service && typeof backendApi.service.getDatasetName === 'function') ? backendApi.service.getDatasetName() : '';\r\n                    this._dataset = [];\r\n                    if (processResult && processResult.data && processResult.data[datasetName]) {\r\n                        this._dataset = processResult.data[datasetName].hasOwnProperty('nodes') ? processResult.data[datasetName].nodes : processResult.data[datasetName];\r\n                        const totalCount = processResult.data[datasetName].hasOwnProperty('totalCount') ? processResult.data[datasetName].totalCount : processResult.data[datasetName].length;\r\n                        this.refreshGridData(this._dataset, totalCount || 0);\r\n                    }\r\n                };\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * On a Pagination changed, we will trigger a Grid State changed with the new pagination info\r\n     * Also if we use Row Selection or the Checkbox Selector, we need to reset any selection\r\n     */\r\n    paginationChanged(pagination) {\r\n        const isSyncGridSelectionEnabled = this.gridStateService && this.gridStateService.needToPreserveRowSelection() || false;\r\n        if (!isSyncGridSelectionEnabled && (this.gridOptions.enableRowSelection || this.gridOptions.enableCheckboxSelector)) {\r\n            this.gridService.setSelectedRows([]);\r\n        }\r\n        const { pageNumber, pageSize } = pagination;\r\n        if (this.sharedService) {\r\n            if (pageSize) {\r\n                this.sharedService.currentPagination = { pageNumber, pageSize };\r\n            }\r\n        }\r\n        this.gridStateService.onGridStateChanged.next({\r\n            change: { newValues: { pageNumber, pageSize }, type: GridStateType.pagination },\r\n            gridState: this.gridStateService.getCurrentGridState()\r\n        });\r\n    }\r\n    /**\r\n     * When dataset changes, we need to refresh the entire grid UI & possibly resize it as well\r\n     * @param dataset\r\n     */\r\n    refreshGridData(dataset, totalCount) {\r\n        if (Array.isArray(dataset) && this.grid && this.dataView && typeof this.dataView.setItems === 'function') {\r\n            this.dataView.setItems(dataset, this.gridOptions.datasetIdPropertyName);\r\n            if (!this.gridOptions.backendServiceApi) {\r\n                this.dataView.reSort();\r\n            }\r\n            if (dataset.length > 0) {\r\n                if (!this._isDatasetInitialized && this.gridOptions.enableCheckboxSelector) {\r\n                    this.loadRowSelectionPresetWhenExists();\r\n                }\r\n                this._isDatasetInitialized = true;\r\n            }\r\n            if (dataset) {\r\n                this.grid.invalidate();\r\n                this.grid.render();\r\n            }\r\n            // display the Pagination component only after calling this refresh data first, we call it here so that if we preset pagination page number it will be shown correctly\r\n            this.showPagination = (this.gridOptions && (this.gridOptions.enablePagination || (this.gridOptions.backendServiceApi && this.gridOptions.enablePagination === undefined))) ? true : false;\r\n            if (this.gridOptions && this.gridOptions.backendServiceApi && this.gridOptions.pagination) {\r\n                const paginationOptions = this.setPaginationOptionsWhenPresetDefined(this.gridOptions, this.paginationOptions);\r\n                // when we have a totalCount use it, else we'll take it from the pagination object\r\n                // only update the total items if it's different to avoid refreshing the UI\r\n                const totalRecords = totalCount !== undefined ? totalCount : (this.gridOptions && this.gridOptions.pagination && this.gridOptions.pagination.totalItems);\r\n                if (totalRecords !== this.totalItems) {\r\n                    this.totalItems = totalRecords;\r\n                }\r\n                // initialize the Pagination Service with new pagination options (which might have presets)\r\n                if (!this._isPaginationInitialized) {\r\n                    this.initializePaginationService(paginationOptions);\r\n                }\r\n                else {\r\n                    // update the pagination service with the new total\r\n                    this.paginationService.totalItems = this.totalItems;\r\n                }\r\n            }\r\n            // resize the grid inside a slight timeout, in case other DOM element changed prior to the resize (like a filter/pagination changed)\r\n            if (this.grid && this.gridOptions.enableAutoResize) {\r\n                const delay = this.gridOptions.autoResize && this.gridOptions.autoResize.delay;\r\n                this.resizer.resizeGrid(delay || 10);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Check if there's any Pagination Presets defined in the Grid Options,\r\n     * if there are then load them in the paginationOptions object\r\n     */\r\n    setPaginationOptionsWhenPresetDefined(gridOptions, paginationOptions) {\r\n        if (gridOptions.presets && gridOptions.presets.pagination && gridOptions.pagination) {\r\n            paginationOptions.pageSize = gridOptions.presets.pagination.pageSize;\r\n            paginationOptions.pageNumber = gridOptions.presets.pagination.pageNumber;\r\n        }\r\n        return paginationOptions;\r\n    }\r\n    /**\r\n     * Dynamically change or update the column definitions list.\r\n     * We will re-render the grid so that the new header and data shows up correctly.\r\n     * If using i18n, we also need to trigger a re-translate of the column headers\r\n     */\r\n    updateColumnDefinitionsList(newColumnDefinitions) {\r\n        // map/swap the internal library Editor to the SlickGrid Editor factory\r\n        newColumnDefinitions = this.swapInternalEditorToSlickGridFactoryEditor(newColumnDefinitions);\r\n        if (this.gridOptions.enableTranslate) {\r\n            this.extensionService.translateColumnHeaders(false, newColumnDefinitions);\r\n        }\r\n        else {\r\n            this.extensionService.renderColumnHeaders(newColumnDefinitions);\r\n        }\r\n        if (this.gridOptions && this.gridOptions.enableAutoSizeColumns) {\r\n            this.grid.autosizeColumns();\r\n        }\r\n    }\r\n    /**\r\n     * Show the filter row displayed on first row, we can optionally pass false to hide it.\r\n     * @param showing\r\n     */\r\n    showHeaderRow(showing = true) {\r\n        this.grid.setHeaderRowVisibility(showing);\r\n        return showing;\r\n    }\r\n    //\r\n    // private functions\r\n    // ------------------\r\n    bindDifferentHooks(grid, gridOptions, dataView) {\r\n        // on locale change, we have to manually translate the Headers, GridMenu\r\n        if (this.translate && this.translate.onLangChange) {\r\n            // translate some of them on first load, then on each language change\r\n            if (gridOptions.enableTranslate) {\r\n                this.translateColumnHeaderTitleKeys();\r\n                this.translateColumnGroupKeys();\r\n                this.translateCustomFooterTexts();\r\n            }\r\n            this.subscriptions.push(this.translate.onLangChange.subscribe(() => {\r\n                if (gridOptions.enableTranslate) {\r\n                    this.extensionService.translateCellMenu();\r\n                    this.extensionService.translateColumnHeaders();\r\n                    this.extensionService.translateColumnPicker();\r\n                    this.extensionService.translateContextMenu();\r\n                    this.extensionService.translateGridMenu();\r\n                    this.extensionService.translateHeaderMenu();\r\n                    this.translateCustomFooterTexts();\r\n                    this.translateColumnHeaderTitleKeys();\r\n                    this.translateColumnGroupKeys();\r\n                }\r\n            }));\r\n        }\r\n        // if user entered some Columns \"presets\", we need to reflect them all in the grid\r\n        if (gridOptions.presets && Array.isArray(gridOptions.presets.columns) && gridOptions.presets.columns.length > 0) {\r\n            const gridColumns = this.gridStateService.getAssociatedGridColumns(grid, gridOptions.presets.columns);\r\n            if (gridColumns && Array.isArray(gridColumns) && gridColumns.length > 0) {\r\n                // make sure that the checkbox selector is also visible if it is enabled\r\n                if (gridOptions.enableCheckboxSelector) {\r\n                    const checkboxColumn = (Array.isArray(this._columnDefinitions) && this._columnDefinitions.length > 0) ? this._columnDefinitions[0] : null;\r\n                    if (checkboxColumn && checkboxColumn.id === '_checkbox_selector' && gridColumns[0].id !== '_checkbox_selector') {\r\n                        gridColumns.unshift(checkboxColumn);\r\n                    }\r\n                }\r\n                // finally set the new presets columns (including checkbox selector if need be)\r\n                grid.setColumns(gridColumns);\r\n            }\r\n        }\r\n        // bind external sorting (backend) when available or default onSort (dataView)\r\n        if (gridOptions.enableSorting && !this.customDataView) {\r\n            // bind external sorting (backend) unless specified to use the local one\r\n            if (gridOptions.backendServiceApi && !gridOptions.backendServiceApi.useLocalSorting) {\r\n                this.sortService.bindBackendOnSort(grid, dataView);\r\n            }\r\n            else {\r\n                this.sortService.bindLocalOnSort(grid, dataView);\r\n            }\r\n        }\r\n        // bind external filter (backend) when available or default onFilter (dataView)\r\n        if (gridOptions.enableFiltering && !this.customDataView) {\r\n            this.filterService.init(grid);\r\n            // if user entered some Filter \"presets\", we need to reflect them all in the DOM\r\n            if (gridOptions.presets && Array.isArray(gridOptions.presets.filters) && gridOptions.presets.filters.length > 0) {\r\n                this.filterService.populateColumnFilterSearchTermPresets(gridOptions.presets.filters);\r\n            }\r\n            // bind external filter (backend) unless specified to use the local one\r\n            if (gridOptions.backendServiceApi && !gridOptions.backendServiceApi.useLocalFiltering) {\r\n                this.filterService.bindBackendOnFilter(grid, this.dataView);\r\n            }\r\n            else {\r\n                this.filterService.bindLocalOnFilter(grid, this.dataView);\r\n            }\r\n        }\r\n        // if user set an onInit Backend, we'll run it right away (and if so, we also need to run preProcess, internalPostProcess & postProcess)\r\n        if (gridOptions.backendServiceApi) {\r\n            const backendApi = gridOptions.backendServiceApi;\r\n            if (backendApi && backendApi.service && backendApi.service.init) {\r\n                backendApi.service.init(backendApi.options, gridOptions.pagination, this.grid);\r\n            }\r\n        }\r\n        // expose all Slick Grid Events through dispatch\r\n        for (const prop in grid) {\r\n            if (grid.hasOwnProperty(prop) && prop.startsWith('on')) {\r\n                this._eventHandler.subscribe(grid[prop], (event, args) => {\r\n                    return this.dispatchCustomEvent(`${slickgridEventPrefix}${titleCase(prop)}`, { eventData: event, args });\r\n                });\r\n            }\r\n        }\r\n        // expose all Slick DataView Events through dispatch\r\n        for (const prop in dataView) {\r\n            if (dataView.hasOwnProperty(prop) && prop.startsWith('on')) {\r\n                this._eventHandler.subscribe(dataView[prop], (event, args) => {\r\n                    return this.dispatchCustomEvent(`${slickgridEventPrefix}${titleCase(prop)}`, { eventData: event, args });\r\n                });\r\n            }\r\n        }\r\n        // expose GridState Service changes event through dispatch\r\n        this.subscriptions.push(this.gridStateService.onGridStateChanged.subscribe((gridStateChange) => {\r\n            this.onGridStateChanged.emit(gridStateChange);\r\n        }));\r\n        // on cell click, mainly used with the columnDef.action callback\r\n        this.gridEventService.bindOnCellChange(grid, dataView);\r\n        this.gridEventService.bindOnClick(grid, dataView);\r\n        if (dataView && grid) {\r\n            this._eventHandler.subscribe(dataView.onRowCountChanged, (e, args) => {\r\n                grid.invalidate();\r\n                this.metrics = {\r\n                    startTime: new Date(),\r\n                    endTime: new Date(),\r\n                    itemCount: args && args.current || 0,\r\n                    totalItemCount: Array.isArray(this.dataset) ? this.dataset.length : 0\r\n                };\r\n            });\r\n            // without this, filtering data with local dataset will not always show correctly\r\n            // also don't use \"invalidateRows\" since it destroys the entire row and as bad user experience when updating a row\r\n            // see commit: https://github.com/ghiscoding/Angular-Slickgrid/commit/bb62c0aa2314a5d61188ff005ccb564577f08805\r\n            if (gridOptions && gridOptions.enableFiltering && !gridOptions.enableRowDetailView) {\r\n                this._eventHandler.subscribe(dataView.onRowsChanged, (e, args) => {\r\n                    if (args && args.rows && Array.isArray(args.rows)) {\r\n                        args.rows.forEach((row) => grid.updateRow(row));\r\n                        grid.render();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        // does the user have a colspan callback?\r\n        if (gridOptions && gridOptions.colspanCallback && dataView && dataView.getItem && dataView.getItemMetadata) {\r\n            dataView.getItemMetadata = (rowNumber) => {\r\n                let callbackResult = null;\r\n                if (gridOptions.colspanCallback && gridOptions.colspanCallback) {\r\n                    callbackResult = gridOptions.colspanCallback(dataView.getItem(rowNumber));\r\n                }\r\n                return callbackResult;\r\n            };\r\n        }\r\n    }\r\n    bindBackendCallbackFunctions(gridOptions) {\r\n        const backendApi = gridOptions.backendServiceApi;\r\n        const backendApiService = backendApi && backendApi.service;\r\n        const serviceOptions = backendApiService && backendApiService.options || {};\r\n        const isExecuteCommandOnInit = (!serviceOptions) ? false : ((serviceOptions && serviceOptions.hasOwnProperty('executeProcessCommandOnInit')) ? serviceOptions['executeProcessCommandOnInit'] : true);\r\n        if (backendApiService) {\r\n            // update backend filters (if need be) BEFORE the query runs (via the onInit command a few lines below)\r\n            // if user entered some any \"presets\", we need to reflect them all in the grid\r\n            if (gridOptions && gridOptions.presets) {\r\n                // Filters \"presets\"\r\n                if (backendApiService.updateFilters && Array.isArray(gridOptions.presets.filters) && gridOptions.presets.filters.length > 0) {\r\n                    backendApiService.updateFilters(gridOptions.presets.filters, true);\r\n                }\r\n                // Sorters \"presets\"\r\n                if (backendApiService.updateSorters && Array.isArray(gridOptions.presets.sorters) && gridOptions.presets.sorters.length > 0) {\r\n                    backendApiService.updateSorters(undefined, gridOptions.presets.sorters);\r\n                }\r\n                // Pagination \"presets\"\r\n                if (backendApiService.updatePagination && gridOptions.presets.pagination) {\r\n                    const { pageNumber, pageSize } = gridOptions.presets.pagination;\r\n                    backendApiService.updatePagination(pageNumber, pageSize);\r\n                }\r\n            }\r\n            else {\r\n                const columnFilters = this.filterService.getColumnFilters();\r\n                if (columnFilters && backendApiService.updateFilters) {\r\n                    backendApiService.updateFilters(columnFilters, false);\r\n                }\r\n            }\r\n            // execute onInit command when necessary\r\n            if (backendApi && backendApiService && (backendApi.onInit || isExecuteCommandOnInit)) {\r\n                const query = (typeof backendApiService.buildQuery === 'function') ? backendApiService.buildQuery() : '';\r\n                const process = (isExecuteCommandOnInit) ? (backendApi.process && backendApi.process(query) || null) : (backendApi.onInit && backendApi.onInit(query) || null);\r\n                // wrap this inside a setTimeout to avoid timing issue since the gridOptions needs to be ready before running this onInit\r\n                setTimeout(() => {\r\n                    // keep start time & end timestamps then return these metrics after the process execution\r\n                    const startTime = new Date();\r\n                    // run any pre-process, if defined, for example a spinner\r\n                    if (backendApi.preProcess) {\r\n                        backendApi.preProcess();\r\n                    }\r\n                    // the processes can be Promises or Observables (like Angular HttpClient)\r\n                    const totalItems = this.gridOptions && this.gridOptions.pagination && this.gridOptions.pagination.totalItems;\r\n                    if (process instanceof Promise && process.then) {\r\n                        process.then((processResult) => executeBackendProcessesCallback(startTime, processResult, backendApi, totalItems))\r\n                            .catch((error) => onBackendError(error, backendApi));\r\n                    }\r\n                    else if (isObservable(process)) {\r\n                        process.subscribe((processResult) => executeBackendProcessesCallback(startTime, processResult, backendApi, totalItems), (error) => onBackendError(error, backendApi));\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n    bindResizeHook(grid, options) {\r\n        // expand/autofit columns on first page load\r\n        if (grid && options.autoFitColumnsOnFirstLoad && options.enableAutoSizeColumns) {\r\n            grid.autosizeColumns();\r\n            // compensate anytime SlickGrid measureScrollbar is incorrect (only seems to happen in Chrome 1/5 computers)\r\n            this.resizer.compensateHorizontalScroll(this.grid, this.gridOptions);\r\n        }\r\n        // auto-resize grid on browser resize\r\n        if (this._fixedHeight || this._fixedWidth) {\r\n            this.resizer.init(grid, { height: this._fixedHeight, width: this._fixedWidth });\r\n        }\r\n        else {\r\n            this.resizer.init(grid);\r\n        }\r\n        if (options.enableAutoResize) {\r\n            this.resizer.bindAutoResizeDataGrid();\r\n            if (grid && options.autoFitColumnsOnFirstLoad && options.enableAutoSizeColumns) {\r\n                grid.autosizeColumns();\r\n            }\r\n        }\r\n    }\r\n    executeAfterDataviewCreated(grid, gridOptions, dataView) {\r\n        // if user entered some Sort \"presets\", we need to reflect them all in the DOM\r\n        if (gridOptions.enableSorting) {\r\n            if (gridOptions.presets && Array.isArray(gridOptions.presets.sorters) && gridOptions.presets.sorters.length > 0) {\r\n                this.sortService.loadGridSorters(gridOptions.presets.sorters);\r\n            }\r\n        }\r\n    }\r\n    initializePaginationService(paginationOptions) {\r\n        if (this.gridOptions) {\r\n            this.paginationData = {\r\n                gridOptions: this.gridOptions,\r\n            };\r\n            this.paginationService.totalItems = this.totalItems;\r\n            this.paginationService.init(this.grid, this.dataView, paginationOptions, this.backendServiceApi);\r\n            this.subscriptions.push(this.paginationService.onPaginationChanged.subscribe((changes) => this.paginationChanged(changes)), this.paginationService.onPaginationVisibilityChanged.subscribe((visibility) => {\r\n                this.showPagination = visibility && visibility.visible || false;\r\n                if (this.gridOptions && this.gridOptions.backendServiceApi) {\r\n                    refreshBackendDataset();\r\n                }\r\n            }));\r\n            this._isPaginationInitialized = true;\r\n        }\r\n        this.cd.detectChanges();\r\n    }\r\n    initialization() {\r\n        // make sure the dataset is initialized (if not it will throw an error that it cannot getLength of null)\r\n        this._dataset = this._dataset || [];\r\n        this.gridOptions = this.mergeGridOptions(this.gridOptions);\r\n        this.paginationOptions = this.gridOptions.pagination;\r\n        this.locales = this.gridOptions && this.gridOptions.locales || Constants.locales;\r\n        this.backendServiceApi = this.gridOptions && this.gridOptions.backendServiceApi;\r\n        this.createBackendApiInternalPostProcessCallback(this.gridOptions);\r\n        this._isLocalGrid = !this.backendServiceApi; // considered a local grid if it doesn't have a backend service set\r\n        if (!this.customDataView) {\r\n            if (this.gridOptions.draggableGrouping || this.gridOptions.enableGrouping) {\r\n                this.extensionUtility.loadExtensionDynamically(ExtensionName.groupItemMetaProvider);\r\n                this.groupItemMetadataProvider = new Slick.Data.GroupItemMetadataProvider();\r\n                this.sharedService.groupItemMetadataProvider = this.groupItemMetadataProvider;\r\n                this.dataView = new Slick.Data.DataView({ groupItemMetadataProvider: this.groupItemMetadataProvider });\r\n            }\r\n            else {\r\n                this.dataView = new Slick.Data.DataView();\r\n            }\r\n        }\r\n        // for convenience to the user, we provide the property \"editor\" as an Angular-Slickgrid editor complex object\r\n        // however \"editor\" is used internally by SlickGrid for it's own Editor Factory\r\n        // so in our lib we will swap \"editor\" and copy it into a new property called \"internalColumnEditor\"\r\n        // then take back \"editor.model\" and make it the new \"editor\" so that SlickGrid Editor Factory still works\r\n        this._columnDefinitions = this.swapInternalEditorToSlickGridFactoryEditor(this._columnDefinitions);\r\n        // save reference for all columns before they optionally become hidden/visible\r\n        this.sharedService.allColumns = this._columnDefinitions;\r\n        this.sharedService.visibleColumns = this._columnDefinitions;\r\n        this.extensionService.createExtensionsBeforeGridCreation(this._columnDefinitions, this.gridOptions);\r\n        // build SlickGrid Grid, also user might optionally pass a custom dataview (e.g. remote model)\r\n        this.grid = new Slick.Grid(`#${this.gridId}`, this.customDataView || this.dataView, this._columnDefinitions, this.gridOptions);\r\n        this.sharedService.dataView = this.dataView;\r\n        this.sharedService.grid = this.grid;\r\n        this.extensionService.bindDifferentExtensions();\r\n        this.bindDifferentHooks(this.grid, this.gridOptions, this.dataView);\r\n        // emit the Grid & DataView object to make them available in parent component\r\n        this.onGridCreated.emit(this.grid);\r\n        // initialize the SlickGrid grid\r\n        this.grid.init();\r\n        if (!this.customDataView && (this.dataView && this.dataView.beginUpdate && this.dataView.setItems && this.dataView.endUpdate)) {\r\n            this.onDataviewCreated.emit(this.dataView);\r\n            this.dataView.beginUpdate();\r\n            this.dataView.setItems(this._dataset, this.gridOptions.datasetIdPropertyName);\r\n            this.dataView.endUpdate();\r\n            // if you don't want the items that are not visible (due to being filtered out or being on a different page)\r\n            // to stay selected, pass 'false' to the second arg\r\n            const selectionModel = this.grid && this.grid.getSelectionModel();\r\n            if (selectionModel && this.gridOptions && this.gridOptions.dataView && this.gridOptions.dataView.hasOwnProperty('syncGridSelection')) {\r\n                // if we are using a Backend Service, we will do an extra flag check, the reason is because it might have some unintended behaviors\r\n                // with the BackendServiceApi because technically the data in the page changes the DataView on every page change.\r\n                let preservedRowSelectionWithBackend = false;\r\n                if (this.gridOptions.backendServiceApi && this.gridOptions.dataView.hasOwnProperty('syncGridSelectionWithBackendService')) {\r\n                    preservedRowSelectionWithBackend = this.gridOptions.dataView.syncGridSelectionWithBackendService;\r\n                }\r\n                const syncGridSelection = this.gridOptions.dataView.syncGridSelection;\r\n                if (typeof syncGridSelection === 'boolean') {\r\n                    let preservedRowSelection = syncGridSelection;\r\n                    if (!this._isLocalGrid) {\r\n                        // when using BackendServiceApi, we'll be using the \"syncGridSelectionWithBackendService\" flag BUT \"syncGridSelection\" must also be set to True\r\n                        preservedRowSelection = syncGridSelection && preservedRowSelectionWithBackend;\r\n                    }\r\n                    this.dataView.syncGridSelection(this.grid, preservedRowSelection);\r\n                }\r\n                else if (typeof syncGridSelection === 'object') {\r\n                    this.dataView.syncGridSelection(this.grid, syncGridSelection.preserveHidden, syncGridSelection.preserveHiddenOnSelectionChange);\r\n                }\r\n            }\r\n            if (this._dataset.length > 0) {\r\n                if (!this._isDatasetInitialized && (this.gridOptions.enableCheckboxSelector || this.gridOptions.enableRowSelection)) {\r\n                    this.loadRowSelectionPresetWhenExists();\r\n                }\r\n                this._isDatasetInitialized = true;\r\n            }\r\n        }\r\n        // user might want to hide the header row on page load but still have `enableFiltering: true`\r\n        // if that is the case, we need to hide the headerRow ONLY AFTER all filters got created & dataView exist\r\n        if (this._hideHeaderRowAfterPageLoad) {\r\n            this.showHeaderRow(false);\r\n        }\r\n        // after the DataView is created & updated execute some processes\r\n        this.executeAfterDataviewCreated(this.grid, this.gridOptions, this.dataView);\r\n        // bind resize ONLY after the dataView is ready\r\n        this.bindResizeHook(this.grid, this.gridOptions);\r\n        // bind & initialize grouping and header grouping colspan service\r\n        if (this.gridOptions.createPreHeaderPanel && !this.gridOptions.enableDraggableGrouping) {\r\n            this.groupingAndColspanService.init(this.grid, this.dataView);\r\n        }\r\n        // bind & initialize the grid service\r\n        this.gridService.init(this.grid, this.dataView);\r\n        // when user enables translation, we need to translate Headers on first pass & subsequently in the bindDifferentHooks\r\n        if (this.gridOptions.enableTranslate) {\r\n            this.extensionService.translateColumnHeaders();\r\n        }\r\n        // if Export is enabled, initialize the service with the necessary grid and other objects\r\n        if (this.gridOptions.enableExport) {\r\n            this.exportService.init(this.grid, this.dataView);\r\n        }\r\n        // if Excel Export is enabled, initialize the service with the necessary grid and other objects\r\n        if (this.gridOptions.enableExcelExport && this.sharedService) {\r\n            this.excelExportService.init(this.grid, this.dataView);\r\n        }\r\n        // once all hooks are in placed and the grid is initialized, we can emit an event\r\n        this.onGridInitialized.emit(this.grid);\r\n        // bind the Backend Service API callback functions only after the grid is initialized\r\n        // because the preProcess() and onInit() might get triggered\r\n        if (this.gridOptions && this.gridOptions.backendServiceApi) {\r\n            this.bindBackendCallbackFunctions(this.gridOptions);\r\n        }\r\n        this.gridStateService.init(this.grid, this.dataView);\r\n        // local grid, check if we need to show the Pagination\r\n        // if so then also check if there's any presets and finally initialize the PaginationService\r\n        // a local grid with Pagination presets will potentially have a different total of items, we'll need to get it from the DataView and update our total\r\n        if (this.gridOptions && this.gridOptions.enablePagination && this._isLocalGrid) {\r\n            this.showPagination = true;\r\n            this.loadLocalGridPagination();\r\n        }\r\n        this.onAngularGridCreated.emit({\r\n            // Slick Grid & DataView objects\r\n            dataView: this.dataView,\r\n            slickGrid: this.grid,\r\n            // public methods\r\n            destroy: this.destroy.bind(this),\r\n            // return all available Services (non-singleton)\r\n            backendService: this.gridOptions && this.gridOptions.backendServiceApi && this.gridOptions.backendServiceApi.service,\r\n            excelExportService: this.excelExportService,\r\n            exportService: this.exportService,\r\n            extensionService: this.extensionService,\r\n            filterService: this.filterService,\r\n            gridEventService: this.gridEventService,\r\n            gridStateService: this.gridStateService,\r\n            gridService: this.gridService,\r\n            groupingService: this.groupingAndColspanService,\r\n            paginationService: this.paginationService,\r\n            resizerService: this.resizer,\r\n            sortService: this.sortService,\r\n            /** @deprecated please use \"extensionService\" instead */\r\n            pluginService: this.extensionService,\r\n        });\r\n        // user could show a custom footer with the data metrics (dataset length and last updated timestamp)\r\n        this.optionallyShowCustomFooterWithMetrics();\r\n    }\r\n    /** Load the Editor Collection asynchronously and replace the \"collection\" property when Observable resolves */\r\n    loadEditorCollectionAsync(column) {\r\n        const collectionAsync = column && column.editor && column.editor.collectionAsync;\r\n        if (collectionAsync instanceof Observable) {\r\n            this.subscriptions.push(collectionAsync.subscribe((resolvedCollection) => this.updateEditorCollection(column, resolvedCollection)));\r\n        }\r\n    }\r\n    /**\r\n     * local grid, check if we need to show the Pagination\r\n     * if so then also check if there's any presets and finally initialize the PaginationService\r\n     * a local grid with Pagination presets will potentially have a different total of items, we'll need to get it from the DataView and update our total\r\n     */\r\n    loadLocalGridPagination() {\r\n        if (this.gridOptions) {\r\n            this.totalItems = Array.isArray(this.dataset) ? this.dataset.length : 0;\r\n            if (this.paginationOptions && this.dataView && this.dataView.getPagingInfo) {\r\n                const slickPagingInfo = this.dataView.getPagingInfo() || {};\r\n                if (slickPagingInfo.hasOwnProperty('totalRows') && this.paginationOptions.totalItems !== slickPagingInfo.totalRows) {\r\n                    this.totalItems = slickPagingInfo.totalRows;\r\n                }\r\n            }\r\n            this.paginationOptions.totalItems = this.totalItems;\r\n            const paginationOptions = this.setPaginationOptionsWhenPresetDefined(this.gridOptions, this.paginationOptions);\r\n            this.initializePaginationService(paginationOptions);\r\n        }\r\n    }\r\n    /** Load any Row Selections into the DataView that were presets by the user */\r\n    loadRowSelectionPresetWhenExists() {\r\n        // if user entered some Row Selections \"presets\"\r\n        const presets = this.gridOptions && this.gridOptions.presets;\r\n        const selectionModel = this.grid && this.grid.getSelectionModel();\r\n        const enableRowSelection = this.gridOptions && (this.gridOptions.enableCheckboxSelector || this.gridOptions.enableRowSelection);\r\n        if (enableRowSelection && selectionModel && presets && presets.rowSelection && (Array.isArray(presets.rowSelection.gridRowIndexes) || Array.isArray(presets.rowSelection.dataContextIds))) {\r\n            let dataContextIds = presets.rowSelection.dataContextIds;\r\n            let gridRowIndexes = presets.rowSelection.gridRowIndexes;\r\n            // maps the IDs to the Grid Rows and vice versa, the \"dataContextIds\" has precedence over the other\r\n            if (Array.isArray(dataContextIds) && dataContextIds.length > 0) {\r\n                gridRowIndexes = this.dataView.mapIdsToRows(dataContextIds) || [];\r\n            }\r\n            else if (Array.isArray(gridRowIndexes) && gridRowIndexes.length > 0) {\r\n                dataContextIds = this.dataView.mapRowsToIds(gridRowIndexes) || [];\r\n            }\r\n            this.gridStateService.selectedRowDataContextIds = dataContextIds;\r\n            // change the selected rows except UNLESS it's a Local Grid with Pagination\r\n            // local Pagination uses the DataView and that also trigger a change/refresh\r\n            // and we don't want to trigger 2 Grid State changes just 1\r\n            if ((this._isLocalGrid && !this.gridOptions.enablePagination) || !this._isLocalGrid) {\r\n                setTimeout(() => this.grid.setSelectedRows(gridRowIndexes));\r\n            }\r\n        }\r\n    }\r\n    mergeGridOptions(gridOptions) {\r\n        gridOptions.gridId = this.gridId;\r\n        gridOptions.gridContainerId = `slickGridContainer-${this.gridId}`;\r\n        // if we have a backendServiceApi and the enablePagination is undefined, we'll assume that we do want to see it, else get that defined value\r\n        // @deprecated TODO remove this check in the future, user should explicitely enable the Pagination since this feature is now optional (you can now call OData/GraphQL without Pagination which is a new feature)\r\n        gridOptions.enablePagination = ((gridOptions.backendServiceApi && gridOptions.enablePagination === undefined) ? true : gridOptions.enablePagination) || false;\r\n        // use jquery extend to deep merge & copy to avoid immutable properties being changed in GlobalGridOptions after a route change\r\n        const options = $.extend(true, {}, GlobalGridOptions, this.forRootConfig, gridOptions);\r\n        // using jQuery extend to do a deep clone has an unwanted side on objects and pageSizes but ES6 spread has other worst side effects\r\n        // so we will just overwrite the pageSizes when needed, this is the only one causing issues so far.\r\n        // jQuery wrote this on their docs:: On a deep extend, Object and Array are extended, but object wrappers on primitive types such as String, Boolean, and Number are not.\r\n        if (gridOptions && gridOptions.backendServiceApi) {\r\n            if (gridOptions.pagination && Array.isArray(gridOptions.pagination.pageSizes) && gridOptions.pagination.pageSizes.length > 0) {\r\n                options.pagination.pageSizes = gridOptions.pagination.pageSizes;\r\n            }\r\n        }\r\n        // also make sure to show the header row if user have enabled filtering\r\n        this._hideHeaderRowAfterPageLoad = (options.showHeaderRow === false);\r\n        if (options.enableFiltering && !options.showHeaderRow) {\r\n            options.showHeaderRow = options.enableFiltering;\r\n        }\r\n        // when we use Pagination on Local Grid, it doesn't seem to work without enableFiltering\r\n        // so we'll enable the filtering but we'll keep the header row hidden\r\n        if (!options.enableFiltering && options.enablePagination && this._isLocalGrid) {\r\n            options.enableFiltering = true;\r\n            options.showHeaderRow = false;\r\n        }\r\n        return options;\r\n    }\r\n    /**\r\n     * We could optionally display a custom footer below the grid to show some metrics (last update, item count with/without filters)\r\n     * It's an opt-in, user has to enable \"showCustomFooter\" and it cannot be used when there's already a Pagination since they display the same kind of info\r\n     */\r\n    optionallyShowCustomFooterWithMetrics() {\r\n        if (this.gridOptions) {\r\n            if ((this.gridOptions.enableTranslate || this.gridOptions.i18n)) {\r\n                this.translateCustomFooterTexts();\r\n            }\r\n            else if (this.gridOptions.customFooterOptions) {\r\n                const customFooterOptions = this.gridOptions.customFooterOptions;\r\n                customFooterOptions.metricTexts = customFooterOptions.metricTexts || {};\r\n                customFooterOptions.metricTexts.lastUpdate = this.locales && this.locales.TEXT_LAST_UPDATE || 'TEXT_LAST_UPDATE';\r\n                customFooterOptions.metricTexts.items = this.locales && this.locales.TEXT_ITEMS || 'TEXT_ITEMS';\r\n                customFooterOptions.metricTexts.of = this.locales && this.locales.TEXT_OF || 'TEXT_OF';\r\n            }\r\n            // we will display the custom footer only when there's no Pagination\r\n            if (!this.gridOptions.enablePagination) {\r\n                this.showCustomFooter = this.gridOptions.hasOwnProperty('showCustomFooter') ? this.gridOptions.showCustomFooter : false;\r\n                this.customFooterOptions = this.gridOptions.customFooterOptions || {};\r\n            }\r\n            this.cd.detectChanges();\r\n        }\r\n    }\r\n    /**\r\n     * For convenience to the user, we provide the property \"editor\" as an Angular-Slickgrid editor complex object\r\n     * however \"editor\" is used internally by SlickGrid for it's own Editor Factory\r\n     * so in our lib we will swap \"editor\" and copy it into a new property called \"internalColumnEditor\"\r\n     * then take back \"editor.model\" and make it the new \"editor\" so that SlickGrid Editor Factory still works\r\n     */\r\n    swapInternalEditorToSlickGridFactoryEditor(columnDefinitions) {\r\n        return columnDefinitions.map((column) => {\r\n            // on every Editor that have a \"collectionAsync\", resolve the data and assign it to the \"collection\" property\r\n            if (column.editor && column.editor.collectionAsync) {\r\n                this.loadEditorCollectionAsync(column);\r\n            }\r\n            return Object.assign({}, column, { editor: column.editor && column.editor.model, internalColumnEditor: Object.assign({}, column.editor) });\r\n        });\r\n    }\r\n    /** Translate all Custom Footer Texts (footer with metrics) */\r\n    translateCustomFooterTexts() {\r\n        if (this.translate && this.translate.instant && this.translate.currentLang) {\r\n            const customFooterOptions = this.gridOptions && this.gridOptions.customFooterOptions || {};\r\n            customFooterOptions.metricTexts = customFooterOptions.metricTexts || {};\r\n            for (const propName of Object.keys(customFooterOptions.metricTexts)) {\r\n                if (propName.lastIndexOf('Key') > 0) {\r\n                    const propNameWithoutKey = propName.substring(0, propName.lastIndexOf('Key'));\r\n                    customFooterOptions.metricTexts[propNameWithoutKey] = this.translate.instant(customFooterOptions.metricTexts[propName] || ' ');\r\n                }\r\n            }\r\n        }\r\n    }\r\n    translateColumnHeaderTitleKeys() {\r\n        // translate all columns (including hidden columns)\r\n        // eventually deprecate the \"headerKey\" and use only the \"nameKey\"\r\n        this.extensionUtility.translateItems(this.sharedService.allColumns, 'headerKey', 'name');\r\n        this.extensionUtility.translateItems(this.sharedService.allColumns, 'nameKey', 'name');\r\n    }\r\n    translateColumnGroupKeys() {\r\n        // translate all column groups (including hidden columns)\r\n        this.extensionUtility.translateItems(this.sharedService.allColumns, 'columnGroupKey', 'columnGroup');\r\n    }\r\n    /**\r\n     * Update the Editor \"collection\" property from an async call resolved\r\n     * Since this is called after the async call resolves, the pointer will not be the same as the \"column\" argument passed.\r\n     * Once we found the new pointer, we will reassign the \"editor\" and \"collection\" to the \"internalColumnEditor\" so it has newest collection\r\n     */\r\n    updateEditorCollection(column, newCollection) {\r\n        column.editor.collection = newCollection;\r\n        // find the new column reference pointer\r\n        const columns = this.grid.getColumns();\r\n        if (Array.isArray(columns)) {\r\n            const columnRef = columns.find((col) => col.id === column.id);\r\n            columnRef.internalColumnEditor = column.editor;\r\n        }\r\n    }\r\n};\r\n__decorate([\r\n    Output(),\r\n    __metadata(\"design:type\", Object)\r\n], AngularSlickgridComponent.prototype, \"onAngularGridCreated\", void 0);\r\n__decorate([\r\n    Output(),\r\n    __metadata(\"design:type\", Object)\r\n], AngularSlickgridComponent.prototype, \"onDataviewCreated\", void 0);\r\n__decorate([\r\n    Output(),\r\n    __metadata(\"design:type\", Object)\r\n], AngularSlickgridComponent.prototype, \"onGridCreated\", void 0);\r\n__decorate([\r\n    Output(),\r\n    __metadata(\"design:type\", Object)\r\n], AngularSlickgridComponent.prototype, \"onGridInitialized\", void 0);\r\n__decorate([\r\n    Output(),\r\n    __metadata(\"design:type\", Object)\r\n], AngularSlickgridComponent.prototype, \"onBeforeGridCreate\", void 0);\r\n__decorate([\r\n    Output(),\r\n    __metadata(\"design:type\", Object)\r\n], AngularSlickgridComponent.prototype, \"onBeforeGridDestroy\", void 0);\r\n__decorate([\r\n    Output(),\r\n    __metadata(\"design:type\", Object)\r\n], AngularSlickgridComponent.prototype, \"onAfterGridDestroyed\", void 0);\r\n__decorate([\r\n    Output(),\r\n    __metadata(\"design:type\", Object)\r\n], AngularSlickgridComponent.prototype, \"onGridStateChanged\", void 0);\r\n__decorate([\r\n    Output(),\r\n    __metadata(\"design:type\", Object)\r\n], AngularSlickgridComponent.prototype, \"onGridBeforeExportToFile\", void 0);\r\n__decorate([\r\n    Output(),\r\n    __metadata(\"design:type\", Object)\r\n], AngularSlickgridComponent.prototype, \"onGridAfterExportToFile\", void 0);\r\n__decorate([\r\n    Output(),\r\n    __metadata(\"design:type\", Object)\r\n], AngularSlickgridComponent.prototype, \"onGridBeforeExportToExcel\", void 0);\r\n__decorate([\r\n    Output(),\r\n    __metadata(\"design:type\", Object)\r\n], AngularSlickgridComponent.prototype, \"onGridAfterExportToExcel\", void 0);\r\n__decorate([\r\n    Input(),\r\n    __metadata(\"design:type\", Object)\r\n], AngularSlickgridComponent.prototype, \"customDataView\", void 0);\r\n__decorate([\r\n    Input(),\r\n    __metadata(\"design:type\", String)\r\n], AngularSlickgridComponent.prototype, \"gridId\", void 0);\r\n__decorate([\r\n    Input(),\r\n    __metadata(\"design:type\", Object)\r\n], AngularSlickgridComponent.prototype, \"gridOptions\", void 0);\r\n__decorate([\r\n    Input(),\r\n    __metadata(\"design:type\", Number),\r\n    __metadata(\"design:paramtypes\", [Number])\r\n], AngularSlickgridComponent.prototype, \"gridHeight\", null);\r\n__decorate([\r\n    Input(),\r\n    __metadata(\"design:type\", Number),\r\n    __metadata(\"design:paramtypes\", [Number])\r\n], AngularSlickgridComponent.prototype, \"gridWidth\", null);\r\n__decorate([\r\n    Input(),\r\n    __metadata(\"design:type\", Array),\r\n    __metadata(\"design:paramtypes\", [Array])\r\n], AngularSlickgridComponent.prototype, \"columnDefinitions\", null);\r\n__decorate([\r\n    Input(),\r\n    __metadata(\"design:type\", Array),\r\n    __metadata(\"design:paramtypes\", [Array])\r\n], AngularSlickgridComponent.prototype, \"dataset\", null);\r\nAngularSlickgridComponent = __decorate([\r\n    Component({\r\n        selector: 'angular-slickgrid',\r\n        template: \"<div id=\\\"slickGridContainer-{{gridId}}\\\" class=\\\"gridPane\\\" [style.width]=\\\"gridWidthString\\\">\\r\\n  <div attr.id='{{gridId}}' class=\\\"slickgrid-container\\\" style=\\\"width: 100%\\\" [style.height]=\\\"gridHeightString\\\">\\r\\n  </div>\\r\\n\\r\\n  <!-- Pagination section under the grid -->\\r\\n  <slick-pagination id=\\\"slickPagingContainer-{{gridId}}\\\" *ngIf=\\\"showPagination\\\" [gridOptions]=\\\"gridOptions\\\">\\r\\n  </slick-pagination>\\r\\n\\r\\n  <!-- Custom Footer section under the grid -->\\r\\n  <div *ngIf=\\\"showCustomFooter && customFooterOptions\\\" class=\\\"slick-custom-footer row\\\" style=\\\"width: 100%;\\\"\\r\\n    [style.height]=\\\"customFooterOptions?.footerHeight || 20\\\">\\r\\n    <div class=\\\"left-footer\\\" [ngClass]=\\\"customFooterOptions.leftContainerClass\\\">\\r\\n      {{customFooterOptions.leftFooterText}}\\r\\n    </div>\\r\\n\\r\\n    <div class=\\\"right-footer metrics\\\" [ngClass]=\\\"customFooterOptions.rightContainerClass\\\"\\r\\n      *ngIf=\\\"metrics && !customFooterOptions.hideMetrics\\\">\\r\\n      <span *ngIf=\\\"!customFooterOptions.hideLastUpdateTimestamp\\\">\\r\\n        <span>{{customFooterOptions.metricTexts?.lastUpdate}}</span>\\r\\n\\r\\n        {{metrics.endTime | date: customFooterOptions.dateFormat}}\\r\\n        <span class=\\\"separator\\\">{{customFooterOptions.metricSeparator}}</span>\\r\\n      </span>\\r\\n\\r\\n      {{metrics.itemCount}}\\r\\n      <span *ngIf=\\\"!customFooterOptions.hideTotalItemCount\\\">{{customFooterOptions.metricTexts?.of}}\\r\\n        {{metrics.totalItemCount}}\\r\\n      </span>\\r\\n      {{customFooterOptions.metricTexts?.items}}\\r\\n    </div>\\r\\n  </div>\\r\\n</div>\\r\\n\",\r\n        providers: [\r\n            // make everything transient (non-singleton)\r\n            AngularUtilService,\r\n            AutoTooltipExtension,\r\n            CellExternalCopyManagerExtension,\r\n            CellMenuExtension,\r\n            CheckboxSelectorExtension,\r\n            ColumnPickerExtension,\r\n            ContextMenuExtension,\r\n            DraggableGroupingExtension,\r\n            ExcelExportService,\r\n            ExtensionService,\r\n            ExportService,\r\n            ExtensionUtility,\r\n            FilterFactory,\r\n            FilterService,\r\n            GraphqlService,\r\n            GridEventService,\r\n            GridMenuExtension,\r\n            GridService,\r\n            GridStateService,\r\n            GroupingAndColspanService,\r\n            GroupItemMetaProviderExtension,\r\n            HeaderButtonExtension,\r\n            HeaderMenuExtension,\r\n            PaginationService,\r\n            ResizerService,\r\n            RowDetailViewExtension,\r\n            RowMoveManagerExtension,\r\n            RowSelectionExtension,\r\n            SharedService,\r\n            SortService,\r\n            SlickgridConfig\r\n        ]\r\n    }),\r\n    __param(15, Optional()),\r\n    __param(16, Inject('config')),\r\n    __metadata(\"design:paramtypes\", [ChangeDetectorRef,\r\n        ElementRef,\r\n        ExcelExportService,\r\n        ExportService,\r\n        ExtensionService,\r\n        ExtensionUtility,\r\n        FilterService,\r\n        GridEventService,\r\n        GridService,\r\n        GridStateService,\r\n        GroupingAndColspanService,\r\n        PaginationService,\r\n        ResizerService,\r\n        SharedService,\r\n        SortService,\r\n        TranslateService, Object])\r\n], AngularSlickgridComponent);\n\nvar AngularSlickgridModule_1;\r\nlet AngularSlickgridModule = AngularSlickgridModule_1 = class AngularSlickgridModule {\r\n    static forRoot(config = {}) {\r\n        return {\r\n            ngModule: AngularSlickgridModule_1,\r\n            providers: [\r\n                { provide: 'config', useValue: config },\r\n                AngularUtilService,\r\n                BsDropDownService,\r\n                CollectionService,\r\n                FilterFactory,\r\n                GraphqlService,\r\n                GridOdataService,\r\n            ]\r\n        };\r\n    }\r\n};\r\nAngularSlickgridModule = AngularSlickgridModule_1 = __decorate([\r\n    NgModule({\r\n        imports: [\r\n            CommonModule,\r\n            TranslateModule\r\n        ],\r\n        declarations: [\r\n            AngularSlickgridComponent,\r\n            SlickPaginationComponent\r\n        ],\r\n        exports: [\r\n            AngularSlickgridComponent,\r\n            SlickPaginationComponent\r\n        ],\r\n        entryComponents: [AngularSlickgridComponent]\r\n    })\r\n], AngularSlickgridModule);\n\nexport { Aggregators, AngularSlickgridComponent, AngularSlickgridModule, AngularUtilService, AutoTooltipExtension, BsDropDownService, CaseType, CellExternalCopyManagerExtension, CellMenuExtension, CheckboxSelectorExtension, CollectionService, ColumnPickerExtension, ContextMenuExtension, DelimiterType, DraggableGroupingExtension, Editors, EmitterType, ExcelExportService, ExportService, ExtensionName, ExtensionService, ExtensionUtility, FieldType, FileType, FilterConditions, FilterFactory, FilterMultiplePassType, FilterService, Filters, Formatters, GraphqlService, GridEventService, GridMenuExtension, GridOdataService, GridService, GridStateService, GridStateType, GroupItemMetaProviderExtension, GroupTotalFormatters, GroupingAndColspanService, HeaderButtonExtension, HeaderMenuExtension, KeyCode, OdataQueryBuilderService, OperatorType, PaginationService, ResizerService, RowDetailViewExtension, RowMoveManagerExtension, RowSelectionExtension, SharedService, SlickPaginationComponent, SlickgridConfig, SortDirection, SortDirectionNumber, SortService, Sorters, addToArrayWhenNotExists, addWhiteSpaces, castToPromise, charArraysEqual, decimalFormatted, executeBackendCallback, executeBackendProcessesCallback, findOrDefault, formatNumber, getDescendantProperty, getScrollBarWidth, htmlDecode, htmlEncode, htmlEntityDecode, htmlEntityEncode, mapFlatpickrDateFormatWithFieldType, mapMomentDateFormatWithFieldType, mapOperatorByFieldType, mapOperatorToShorthandDesignation, mapOperatorType, onBackendError, parseBoolean, parseUtcDate, refreshBackendDataset, sanitizeHtmlToText, setDeepValue, thousandSeparatorFormatted, titleCase, toCamelCase, toKebabCase, toSnakeCase, uniqueArray, uniqueObjectArray, unsubscribeAllObservables, AvgAggregator as a, MinAggregator as b, CompoundSliderFilter as ba, DateRangeFilter as bb, InputFilter as bc, InputMaskFilter as bd, InputNumberFilter as be, InputPasswordFilter as bf, MultipleSelectFilter as bg, SelectFilter as bh, NativeSelectFilter as bi, SingleSelectFilter as bj, SliderFilter as bk, SliderRangeFilter as bl, arrayObjectToCsvFormatter as bm, arrayToCsvFormatter as bn, boldFormatter as bo, bsDropdownFormatter as bp, checkboxFormatter as bq, checkmarkFormatter as br, complexObjectFormatter as bs, collectionFormatter as bt, collectionEditorFormatter as bu, getAssociatedDateFormatter as bv, deleteIconFormatter as bw, decimalFormatter as bx, dollarFormatter as by, dollarColoredFormatter as bz, MaxAggregator as c, dollarColoredBoldFormatter as ca, editIconFormatter as cb, hyperlinkFormatter as cc, iconFormatter as cd, infoIconFormatter as ce, italicFormatter as cf, lowercaseFormatter as cg, maskFormatter as ch, multipleFormatter as ci, percentFormatter as cj, percentCompleteFormatter as ck, percentCompleteBarFormatter as cl, percentSymbolFormatter as cm, progressBarFormatter as cn, translateFormatter as co, translateBooleanFormatter as cp, uppercaseFormatter as cq, yesNoFormatter as cr, avgTotalsFormatter as cs, avgTotalsDollarFormatter as ct, avgTotalsPercentageFormatter as cu, maxTotalsFormatter as cv, minTotalsFormatter as cw, sumTotalsFormatter as cx, sumTotalsBoldFormatter as cy, sumTotalsColoredFormatter as cz, SumAggregator as d, sumTotalsDollarFormatter as da, sumTotalsDollarBoldFormatter as db, sumTotalsDollarColoredFormatter as dc, sumTotalsDollarColoredBoldFormatter as dd, getAssociatedDateSorter as de, numericSorter as df, objectStringSorter as dg, stringSorter as dh, AutoCompleteEditor as e, CheckboxEditor as f, DateEditor as g, FloatEditor as h, IntegerEditor as i, LongTextEditor as j, MultipleSelectEditor as k, SelectEditor as l, SingleSelectEditor as m, SliderEditor as n, TextEditor as o, executeMappedCondition as p, booleanFilterCondition as q, collectionSearchFilterCondition as r, numberFilterCondition as s, stringFilterCondition as t, testFilterCondition as u, AutoCompleteFilter as v, CompoundDateFilter as w, CompoundInputFilter as x, CompoundInputNumberFilter as y, CompoundInputPasswordFilter as z };\n"]}