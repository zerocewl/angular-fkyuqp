import * as tslib_1 from "tslib";
import * as isequal_ from 'lodash.isequal';
const isequal = isequal_; // patch to fix rollup to work
import { ExtensionName, GridStateType, } from './../models/index';
import { ExtensionService } from './extension.service';
import { FilterService } from './filter.service';
import { SortService } from './sort.service';
import { Subject } from 'rxjs';
import { unsubscribeAllObservables } from './utilities';
import { SharedService } from './shared.service';
import { Injectable } from '@angular/core';
let GridStateService = class GridStateService {
    constructor(extensionService, filterService, sharedService, sortService) {
        this.extensionService = extensionService;
        this.filterService = filterService;
        this.sharedService = sharedService;
        this.sortService = sortService;
        this._columns = [];
        this._currentColumns = [];
        this._subscriptions = [];
        this._selectedRowDataContextIds = []; // used with row selection
        this._selectedFilteredRowDataContextIds = []; // used with row selection
        this._wasRecheckedAfterPageChange = true; // used with row selection & pagination
        this.onGridStateChanged = new Subject();
        this._eventHandler = new Slick.EventHandler();
    }
    /** Getter for the Grid Options pulled through the Grid Object */
    get _gridOptions() {
        return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
    }
    get datasetIdPropName() {
        return this._gridOptions.datasetIdPropertyName || 'id';
    }
    /** Getter of the selected data context object IDs */
    get selectedRowDataContextIds() {
        return this._selectedRowDataContextIds;
    }
    /** Setter of the selected data context object IDs */
    set selectedRowDataContextIds(dataContextIds) {
        this._selectedRowDataContextIds = dataContextIds;
        // since this is coming from a preset, we also need to update the filtered IDs
        this._selectedFilteredRowDataContextIds = dataContextIds;
    }
    /**
     * Initialize the Grid State Service
     * @param grid
     */
    init(grid, dataView) {
        this._grid = grid;
        this._dataView = dataView;
        this.subscribeToAllGridChanges(grid);
    }
    /** Dispose of all the SlickGrid & Angular subscriptions */
    dispose() {
        // unsubscribe all SlickGrid events
        this._eventHandler.unsubscribeAll();
        // also unsubscribe all Angular Subscriptions
        this._subscriptions = unsubscribeAllObservables(this._subscriptions);
        this._currentColumns = [];
        this._columns = [];
    }
    /**
     * Get the current grid state (filters/sorters/pagination)
     * @return grid state
     */
    getCurrentGridState(args) {
        const gridState = {
            columns: this.getCurrentColumns(),
            filters: this.getCurrentFilters(),
            sorters: this.getCurrentSorters(),
        };
        const currentPagination = this.getCurrentPagination();
        if (currentPagination) {
            gridState.pagination = currentPagination;
        }
        if (this.hasRowSelectionEnabled()) {
            const currentRowSelection = this.getCurrentRowSelections(args && args.requestRefreshRowFilteredRow);
            if (currentRowSelection) {
                gridState.rowSelection = currentRowSelection;
            }
        }
        return gridState;
    }
    /**
     * Get the Columns (and their state: visibility/position) that are currently applied in the grid
     * @return current columns
     */
    getColumns() {
        return this._columns;
    }
    /**
     * From an array of Grid Column Definitions, get the associated Current Columns
     * @param gridColumns
     */
    getAssociatedCurrentColumns(gridColumns) {
        const currentColumns = [];
        if (gridColumns && Array.isArray(gridColumns)) {
            gridColumns.forEach((column, index) => {
                if (column && column.id) {
                    currentColumns.push({
                        columnId: column.id,
                        cssClass: column.cssClass || '',
                        headerCssClass: column.headerCssClass || '',
                        width: column.width || 0
                    });
                }
            });
        }
        this._currentColumns = currentColumns;
        return currentColumns;
    }
    /**
     * From an array of Current Columns, get the associated Grid Column Definitions
     * @param grid
     * @param currentColumns
     */
    getAssociatedGridColumns(grid, currentColumns) {
        const columns = [];
        const gridColumns = grid.getColumns();
        if (currentColumns && Array.isArray(currentColumns)) {
            currentColumns.forEach((currentColumn, index) => {
                const gridColumn = gridColumns.find((c) => c.id === currentColumn.columnId);
                if (gridColumn && gridColumn.id) {
                    columns.push(Object.assign({}, gridColumn, { cssClass: currentColumn.cssClass, headerCssClass: currentColumn.headerCssClass, width: currentColumn.width }));
                }
            });
        }
        this._columns = columns;
        return columns;
    }
    /**
     * Get the Columns (and their state: visibility/position) that are currently applied in the grid
     * @return current columns
     */
    getCurrentColumns() {
        let currentColumns = [];
        if (this._currentColumns && Array.isArray(this._currentColumns) && this._currentColumns.length > 0) {
            currentColumns = this._currentColumns;
        }
        else {
            currentColumns = this.getAssociatedCurrentColumns(this._grid.getColumns());
        }
        return currentColumns;
    }
    /**
     * Get the Filters (and their state, columnId, searchTerm(s)) that are currently applied in the grid
     * @return current filters
     */
    getCurrentFilters() {
        if (this._gridOptions && this._gridOptions.backendServiceApi) {
            const backendService = this._gridOptions.backendServiceApi.service;
            if (backendService && backendService.getCurrentFilters) {
                return backendService.getCurrentFilters();
            }
        }
        else if (this.filterService && this.filterService.getCurrentLocalFilters) {
            return this.filterService.getCurrentLocalFilters();
        }
        return null;
    }
    /**
     * Get current Pagination (and it's state, pageNumber, pageSize) that are currently applied in the grid
     * @return current pagination state
     */
    getCurrentPagination() {
        if (this._gridOptions.enablePagination) {
            if (this._gridOptions && this._gridOptions.backendServiceApi) {
                const backendService = this._gridOptions.backendServiceApi.service;
                if (backendService && backendService.getCurrentPagination) {
                    return backendService.getCurrentPagination();
                }
            }
            else {
                return this.sharedService.currentPagination;
            }
        }
        return null;
    }
    /**
     * Get the current Sorters (and their state, columnId, direction) that are currently applied in the grid
     * @return current sorters
     */
    getCurrentRowSelections(requestRefreshFilteredRow = true) {
        if (this._grid && this._gridOptions && this._dataView && this.hasRowSelectionEnabled()) {
            if (this._grid.getSelectedRows && this._dataView.mapRowsToIds) {
                let filteredDataContextIds = [];
                const gridRowIndexes = this._dataView.mapIdsToRows(this._selectedRowDataContextIds || []); // note that this will return only what is visible in current page
                const dataContextIds = this._selectedRowDataContextIds;
                // user might request to refresh the filtered selection dataset
                // typically always True, except when "reEvaluateRowSelectionAfterFilterChange" is called and we don't need to refresh the filtered dataset twice
                if (requestRefreshFilteredRow === true) {
                    filteredDataContextIds = this.refreshFilteredRowSelections();
                }
                filteredDataContextIds = this._selectedFilteredRowDataContextIds;
                return { gridRowIndexes, dataContextIds, filteredDataContextIds };
            }
        }
        return null;
    }
    /**
     * Get the current Sorters (and their state, columnId, direction) that are currently applied in the grid
     * @return current sorters
     */
    getCurrentSorters() {
        if (this._gridOptions && this._gridOptions.backendServiceApi) {
            const backendService = this._gridOptions.backendServiceApi.service;
            if (backendService && backendService.getCurrentSorters) {
                return backendService.getCurrentSorters();
            }
        }
        else if (this.sortService && this.sortService.getCurrentLocalSorters) {
            return this.sortService.getCurrentLocalSorters();
        }
        return null;
    }
    /** Check whether the row selection needs to be preserved */
    needToPreserveRowSelection() {
        let preservedRowSelection = false;
        if (this._gridOptions && this._gridOptions.dataView && this._gridOptions.dataView.hasOwnProperty('syncGridSelection')) {
            const syncGridSelection = this._gridOptions.dataView.syncGridSelection;
            if (typeof syncGridSelection === 'boolean') {
                preservedRowSelection = this._gridOptions.dataView.syncGridSelection;
            }
            else {
                preservedRowSelection = syncGridSelection.preserveHidden;
            }
            // if the result is True but the grid is using a Backend Service, we will do an extra flag check the reason is because it might have some unintended behaviors
            // with the BackendServiceApi because technically the data in the page changes the DataView on every page.
            if (preservedRowSelection && this._gridOptions.backendServiceApi && this._gridOptions.dataView.hasOwnProperty('syncGridSelectionWithBackendService')) {
                preservedRowSelection = this._gridOptions.dataView.syncGridSelectionWithBackendService;
            }
        }
        return preservedRowSelection;
    }
    resetColumns(columnDefinitions) {
        const columns = columnDefinitions || this._columns;
        const currentColumns = this.getAssociatedCurrentColumns(columns);
        this.onGridStateChanged.next({ change: { newValues: currentColumns, type: GridStateType.columns }, gridState: this.getCurrentGridState() });
    }
    /** if we use Row Selection or the Checkbox Selector, we need to reset any selection */
    resetRowSelectionWhenRequired() {
        if (!this.needToPreserveRowSelection() && (this._gridOptions.enableRowSelection || this._gridOptions.enableCheckboxSelector)) {
            // this also requires the Row Selection Model to be registered as well
            const rowSelectionExtension = this.extensionService && this.extensionService.getExtensionByName && this.extensionService.getExtensionByName(ExtensionName.rowSelection);
            if (rowSelectionExtension && rowSelectionExtension.instance) {
                this._grid.setSelectedRows([]);
            }
        }
    }
    /**
     * Subscribe to all necessary SlickGrid or Service Events that deals with a Grid change,
     * when triggered, we will publish a Grid State Event with current Grid State
     */
    subscribeToAllGridChanges(grid) {
        // Subscribe to Event Emitter of Filter changed
        this._subscriptions.push(this.filterService.onFilterChanged.subscribe((currentFilters) => {
            this.resetRowSelectionWhenRequired();
            // trigger a Grid State filter change, however don't reevaluate the filtered row selections, we'll do that on the next Grid State change below
            this.onGridStateChanged.next({ change: { newValues: currentFilters, type: GridStateType.filter }, gridState: this.getCurrentGridState({ requestRefreshRowFilteredRow: !this.hasRowSelectionEnabled() }) });
            // when Row Selection is enabled, we also need to re-evaluate the row selection with the leftover filtered dataset
            if (this.hasRowSelectionEnabled()) {
                this.reEvaluateRowSelectionAfterFilterChange();
            }
        }));
        // Subscribe to Event Emitter of Filter cleared
        this._subscriptions.push(this.filterService.onFilterCleared.subscribe(() => {
            this.resetRowSelectionWhenRequired();
            this.onGridStateChanged.next({ change: { newValues: [], type: GridStateType.filter }, gridState: this.getCurrentGridState() });
        }));
        // Subscribe to Event Emitter of Sort changed
        this._subscriptions.push(this.sortService.onSortChanged.subscribe((currentSorters) => {
            this.resetRowSelectionWhenRequired();
            this.onGridStateChanged.next({ change: { newValues: currentSorters, type: GridStateType.sorter }, gridState: this.getCurrentGridState() });
        }));
        // Subscribe to Event Emitter of Sort cleared
        this._subscriptions.push(this.sortService.onSortCleared.subscribe(() => {
            this.resetRowSelectionWhenRequired();
            this.onGridStateChanged.next({ change: { newValues: [], type: GridStateType.sorter }, gridState: this.getCurrentGridState() });
        }));
        // Subscribe to ColumnPicker and/or GridMenu for show/hide Columns visibility changes
        this.bindExtensionAddonEventToGridStateChange(ExtensionName.columnPicker, 'onColumnsChanged');
        this.bindExtensionAddonEventToGridStateChange(ExtensionName.gridMenu, 'onColumnsChanged');
        // subscribe to Column Resize & Reordering
        this.bindSlickGridColumnChangeEventToGridStateChange('onColumnsReordered', grid);
        this.bindSlickGridColumnChangeEventToGridStateChange('onColumnsResized', grid);
        // subscribe to Row Selection changes (when enabled)
        if (this._gridOptions.enableRowSelection || this._gridOptions.enableCheckboxSelector) {
            this.bindSlickGridRowSelectionToGridStateChange();
        }
        // subscribe to HeaderMenu (hide column)
        this._subscriptions.push(this.sharedService.onColumnsChanged.subscribe((visibleColumns) => {
            const currentColumns = this.getAssociatedCurrentColumns(visibleColumns);
            this.onGridStateChanged.next({ change: { newValues: currentColumns, type: GridStateType.columns }, gridState: this.getCurrentGridState() });
        }));
    }
    // --
    // private methods
    // ------------------
    /**
     * Bind a SlickGrid Extension Event to a Grid State change event
     * @param extension name
     * @param grid
     */
    bindExtensionAddonEventToGridStateChange(extensionName, eventName) {
        const extension = this.extensionService && this.extensionService.getExtensionByName && this.extensionService.getExtensionByName(extensionName);
        const slickEvent = extension && extension.instance && extension.instance[eventName];
        if (slickEvent && slickEvent.subscribe) {
            this._eventHandler.subscribe(slickEvent, (e, args) => {
                const columns = args && args.columns;
                const currentColumns = this.getAssociatedCurrentColumns(columns);
                this.onGridStateChanged.next({ change: { newValues: currentColumns, type: GridStateType.columns }, gridState: this.getCurrentGridState() });
            });
        }
    }
    /**
     * Bind a Grid Event (of Column changes) to a Grid State change event
     * @param event name
     * @param grid
     */
    bindSlickGridColumnChangeEventToGridStateChange(eventName, grid) {
        const slickGridEvent = grid && grid[eventName];
        if (slickGridEvent && slickGridEvent.subscribe) {
            this._eventHandler.subscribe(slickGridEvent, () => {
                const columns = grid.getColumns();
                const currentColumns = this.getAssociatedCurrentColumns(columns);
                this.onGridStateChanged.next({ change: { newValues: currentColumns, type: GridStateType.columns }, gridState: this.getCurrentGridState() });
            });
        }
    }
    /**
     * Bind a Grid Event of Row Selection change to a Grid State change event
     * For the row selection, we can't just use the getSelectedRows() since this will only return the visible rows shown in the UI which is not enough.
     * The process is much more complex, what we have to do instead is the following
     * 1. when changing a row selection, we'll add the new selection if it's not yet in the global array of selected IDs
     * 2. when deleting a row selection, we'll remove the selection from our global array of selected IDs (unless it came from a page change)
     * 3. if we use Pagination and we change page, we'll keep track with a flag (this flag will be used to skip any deletion when we're changing page)
     * 4. after the Page or DataView is changed or updated, we'll do an extra (and delayed) check to make sure that what we have in our global array of selected IDs is displayed on screen
     */
    bindSlickGridRowSelectionToGridStateChange() {
        if (this._grid && this._gridOptions && this._dataView) {
            this._eventHandler.subscribe(this._dataView.onBeforePagingInfoChanged, () => {
                this._wasRecheckedAfterPageChange = false; // reset the page check flag, to skip deletions on page change (used in code below)
            });
            this._eventHandler.subscribe(this._dataView.onPagingInfoChanged, () => {
                // when user changes page, the selected row indexes might not show up
                // we can check to make sure it is but it has to be in a delay so it happens after the first "onSelectedRowsChanged" is triggered
                setTimeout(() => {
                    const shouldBeSelectedRowIndexes = this._dataView.mapIdsToRows(this._selectedRowDataContextIds || []);
                    const currentSelectedRowIndexes = this._grid.getSelectedRows();
                    if (!isequal(shouldBeSelectedRowIndexes, currentSelectedRowIndexes)) {
                        this._grid.setSelectedRows(shouldBeSelectedRowIndexes);
                    }
                });
            });
            this._eventHandler.subscribe(this._grid.onSelectedRowsChanged, (e, args) => {
                if (Array.isArray(args.rows) && Array.isArray(args.previousSelectedRows)) {
                    const newSelectedRows = args.rows;
                    const prevSelectedRows = args.previousSelectedRows;
                    const newSelectedAdditions = newSelectedRows.filter((i) => prevSelectedRows.indexOf(i) < 0);
                    const newSelectedDeletions = prevSelectedRows.filter((i) => newSelectedRows.indexOf(i) < 0);
                    // deletion might happen when user is changing page, if that is the case then skip the deletion since it's only a visual deletion (current page)
                    // if it's not a page change (when the flag is true), then proceed with the deletion in our global array of selected IDs
                    if (this._wasRecheckedAfterPageChange && newSelectedDeletions.length > 0) {
                        const toDeleteDataIds = this._dataView.mapRowsToIds(newSelectedDeletions) || [];
                        toDeleteDataIds.forEach((removeId) => {
                            this._selectedRowDataContextIds.splice(this._selectedRowDataContextIds.indexOf(removeId), 1);
                        });
                    }
                    // if we have newly added selected row(s), let's update our global array of selected IDs
                    if (newSelectedAdditions.length > 0) {
                        const toAddDataIds = this._dataView.mapRowsToIds(newSelectedAdditions) || [];
                        toAddDataIds.forEach((dataId) => {
                            if (this._selectedRowDataContextIds.indexOf(dataId) === -1) {
                                this._selectedRowDataContextIds.push(dataId);
                            }
                        });
                    }
                    // we set this flag which will be used on the 2nd time the "onSelectedRowsChanged" event is called
                    // when it's the first time, we skip deletion and this is what this flag is for
                    this._wasRecheckedAfterPageChange = true;
                    // form our full selected row IDs, let's make sure these indexes are selected in the grid, if not then let's call a reselect
                    // this could happen if the previous step was a page change
                    const shouldBeSelectedRowIndexes = this._dataView.mapIdsToRows(this._selectedRowDataContextIds || []);
                    const currentSelectedRowIndexes = this._grid.getSelectedRows();
                    if (!isequal(shouldBeSelectedRowIndexes, currentSelectedRowIndexes)) {
                        this._grid.setSelectedRows(shouldBeSelectedRowIndexes);
                    }
                    const filteredDataContextIds = this.refreshFilteredRowSelections();
                    const newValues = { gridRowIndexes: this._grid.getSelectedRows(), dataContextIds: this._selectedRowDataContextIds, filteredDataContextIds };
                    this.onGridStateChanged.next({ change: { newValues, type: GridStateType.rowSelection }, gridState: this.getCurrentGridState() });
                }
            });
        }
    }
    /** Check wether the grid has the Row Selection enabled */
    hasRowSelectionEnabled() {
        const selectionModel = this._grid.getSelectionModel();
        const isRowSelectionEnabled = this._gridOptions.enableRowSelection || this._gridOptions.enableCheckboxSelector;
        return (isRowSelectionEnabled && selectionModel);
    }
    reEvaluateRowSelectionAfterFilterChange() {
        const currentSelectedRowIndexes = this._grid.getSelectedRows();
        const previousSelectedFilteredRowDataContextIds = this._selectedFilteredRowDataContextIds.slice();
        const filteredDataContextIds = this.refreshFilteredRowSelections();
        // when selection changed, we'll send a Grid State event with the selection changes
        if (!isequal(this._selectedFilteredRowDataContextIds, previousSelectedFilteredRowDataContextIds)) {
            const newValues = { gridRowIndexes: currentSelectedRowIndexes, dataContextIds: this._selectedRowDataContextIds, filteredDataContextIds };
            this.onGridStateChanged.next({ change: { newValues, type: GridStateType.rowSelection }, gridState: this.getCurrentGridState({ requestRefreshRowFilteredRow: false }) });
        }
    }
    /** When a Filter is triggered or when user request it, we will refresh the filtered selection array and return it */
    refreshFilteredRowSelections() {
        let tmpFilteredArray = [];
        const filteredDataset = this._dataView.getFilteredItems() || [];
        if (Array.isArray(this._selectedRowDataContextIds)) {
            const selectedFilteredRowDataContextIds = [...this._selectedRowDataContextIds]; // take a fresh copy of all selections before filtering the row ids
            tmpFilteredArray = selectedFilteredRowDataContextIds.filter((selectedRowId) => {
                return filteredDataset.findIndex((item) => item[this.datasetIdPropName] === selectedRowId) > -1;
            });
            this._selectedFilteredRowDataContextIds = tmpFilteredArray;
        }
        return tmpFilteredArray;
    }
};
GridStateService = tslib_1.__decorate([
    Injectable(),
    tslib_1.__metadata("design:paramtypes", [ExtensionService,
        FilterService,
        SharedService,
        SortService])
], GridStateService);
export { GridStateService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZFN0YXRlLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyLXNsaWNrZ3JpZC8iLCJzb3VyY2VzIjpbImFwcC9tb2R1bGVzL2FuZ3VsYXItc2xpY2tncmlkL3NlcnZpY2VzL2dyaWRTdGF0ZS5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEtBQUssUUFBUSxNQUFNLGdCQUFnQixDQUFDO0FBQzNDLE1BQU0sT0FBTyxHQUFHLFFBQVEsQ0FBQyxDQUFDLDhCQUE4QjtBQUV4RCxPQUFPLEVBT0wsYUFBYSxFQUliLGFBQWEsR0FFZCxNQUFNLG1CQUFtQixDQUFDO0FBQzNCLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUNqRCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDN0MsT0FBTyxFQUFFLE9BQU8sRUFBZ0IsTUFBTSxNQUFNLENBQUM7QUFDN0MsT0FBTyxFQUFFLHlCQUF5QixFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQ3hELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUNqRCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBTTNDLElBQWEsZ0JBQWdCLEdBQTdCLE1BQWEsZ0JBQWdCO0lBWTNCLFlBQ1UsZ0JBQWtDLEVBQ2xDLGFBQTRCLEVBQzVCLGFBQTRCLEVBQzVCLFdBQXdCO1FBSHhCLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBa0I7UUFDbEMsa0JBQWEsR0FBYixhQUFhLENBQWU7UUFDNUIsa0JBQWEsR0FBYixhQUFhLENBQWU7UUFDNUIsZ0JBQVcsR0FBWCxXQUFXLENBQWE7UUFkMUIsYUFBUSxHQUFhLEVBQUUsQ0FBQztRQUN4QixvQkFBZSxHQUFvQixFQUFFLENBQUM7UUFHdEMsbUJBQWMsR0FBbUIsRUFBRSxDQUFDO1FB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TSxDQUFDLENBQUMsYUFBOEIsRUFBRSxFQUFFO2dCQUM3RixPQUFPLGVBQWUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFTLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsS0FBSyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUN2RyxDQUFDLENBQUMsQ0FBQztZQUNILElBQUksQ0FBQyxrQ0FBa0MsR0FBRyxnQkFBZ0IsQ0FBQztTQUM1RDtRQUNELE9BQU8sZ0JBQWdCLENBQUM7SUFDMUIsQ0FBQztDQUNGLENBQUE7QUFwZVksZ0JBQWdCO0lBRDVCLFVBQVUsRUFBRTs2Q0FjaUIsZ0JBQWdCO1FBQ25CLGFBQWE7UUFDYixhQUFhO1FBQ2YsV0FBVztHQWhCdkIsZ0JBQWdCLENBb2U1QjtTQXBlWSxnQkFBZ0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBpc2VxdWFsXyBmcm9tICdsb2Rhc2guaXNlcXVhbCc7XHJcbmNvbnN0IGlzZXF1YWwgPSBpc2VxdWFsXzsgLy8gcGF0Y2ggdG8gZml4IHJvbGx1cCB0byB3b3JrXHJcblxyXG5pbXBvcnQge1xyXG4gIENvbHVtbixcclxuICBDdXJyZW50Q29sdW1uLFxyXG4gIEN1cnJlbnRGaWx0ZXIsXHJcbiAgQ3VycmVudFBhZ2luYXRpb24sXHJcbiAgQ3VycmVudFJvd1NlbGVjdGlvbixcclxuICBDdXJyZW50U29ydGVyLFxyXG4gIEV4dGVuc2lvbk5hbWUsXHJcbiAgR3JpZE9wdGlvbixcclxuICBHcmlkU3RhdGUsXHJcbiAgR3JpZFN0YXRlQ2hhbmdlLFxyXG4gIEdyaWRTdGF0ZVR5cGUsXHJcbiAgU2xpY2tFdmVudEhhbmRsZXIsXHJcbn0gZnJvbSAnLi8uLi9tb2RlbHMvaW5kZXgnO1xyXG5pbXBvcnQgeyBFeHRlbnNpb25TZXJ2aWNlIH0gZnJvbSAnLi9leHRlbnNpb24uc2VydmljZSc7XHJcbmltcG9ydCB7IEZpbHRlclNlcnZpY2UgfSBmcm9tICcuL2ZpbHRlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgU29ydFNlcnZpY2UgfSBmcm9tICcuL3NvcnQuc2VydmljZSc7XHJcbmltcG9ydCB7IFN1YmplY3QsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyB1bnN1YnNjcmliZUFsbE9ic2VydmFibGVzIH0gZnJvbSAnLi91dGlsaXRpZXMnO1xyXG5pbXBvcnQgeyBTaGFyZWRTZXJ2aWNlIH0gZnJvbSAnLi9zaGFyZWQuc2VydmljZSc7XHJcbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbi8vIHVzaW5nIGV4dGVybmFsIG5vbi10eXBlZCBqcyBsaWJyYXJpZXNcclxuZGVjbGFyZSB2YXIgU2xpY2s6IGFueTtcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEdyaWRTdGF0ZVNlcnZpY2Uge1xyXG4gIHByaXZhdGUgX2V2ZW50SGFuZGxlcjogU2xpY2tFdmVudEhhbmRsZXI7XHJcbiAgcHJpdmF0ZSBfY29sdW1uczogQ29sdW1uW10gPSBbXTtcclxuICBwcml2YXRlIF9jdXJyZW50Q29sdW1uczogQ3VycmVudENvbHVtbltdID0gW107XHJcbiAgcHJpdmF0ZSBfZGF0YVZpZXc6IGFueTtcclxuICBwcml2YXRlIF9ncmlkOiBhbnk7XHJcbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcclxuICBwcml2YXRlIF9zZWxlY3RlZFJvd0RhdGFDb250ZXh0SWRzOiBBcnJheTxudW1iZXIgfCBzdHJpbmc+IHwgdW5kZWZpbmVkID0gW107IC8vIHVzZWQgd2l0aCByb3cgc2VsZWN0aW9uXHJcbiAgcHJpdmF0ZSBfc2VsZWN0ZWRGaWx0ZXJlZFJvd0RhdGFDb250ZXh0SWRzOiBBcnJheTxudW1iZXIgfCBzdHJpbmc+IHwgdW5kZWZpbmVkID0gW107IC8vIHVzZWQgd2l0aCByb3cgc2VsZWN0aW9uXHJcbiAgcHJpdmF0ZSBfd2FzUmVjaGVja2VkQWZ0ZXJQYWdlQ2hhbmdlID0gdHJ1ZTsgLy8gdXNlZCB3aXRoIHJvdyBzZWxlY3Rpb24gJiBwYWdpbmF0aW9uXHJcbiAgb25HcmlkU3RhdGVDaGFuZ2VkID0gbmV3IFN1YmplY3Q8R3JpZFN0YXRlQ2hhbmdlPigpO1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByaXZhdGUgZXh0ZW5zaW9uU2VydmljZTogRXh0ZW5zaW9uU2VydmljZSxcclxuICAgIHByaXZhdGUgZmlsdGVyU2VydmljZTogRmlsdGVyU2VydmljZSxcclxuICAgIHByaXZhdGUgc2hhcmVkU2VydmljZTogU2hhcmVkU2VydmljZSxcclxuICAgIHByaXZhdGUgc29ydFNlcnZpY2U6IFNvcnRTZXJ2aWNlXHJcbiAgKSB7XHJcbiAgICB0aGlzLl9ldmVudEhhbmRsZXIgPSBuZXcgU2xpY2suRXZlbnRIYW5kbGVyKCk7XHJcbiAgfVxyXG5cclxuICAvKiogR2V0dGVyIGZvciB0aGUgR3JpZCBPcHRpb25zIHB1bGxlZCB0aHJvdWdoIHRoZSBHcmlkIE9iamVjdCAqL1xyXG4gIHByaXZhdGUgZ2V0IF9ncmlkT3B0aW9ucygpOiBHcmlkT3B0aW9uIHtcclxuICAgIHJldHVybiAodGhpcy5fZ3JpZCAmJiB0aGlzLl9ncmlkLmdldE9wdGlvbnMpID8gdGhpcy5fZ3JpZC5nZXRPcHRpb25zKCkgOiB7fTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2V0IGRhdGFzZXRJZFByb3BOYW1lKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGhpcy5fZ3JpZE9wdGlvbnMuZGF0YXNldElkUHJvcGVydHlOYW1lIHx8ICdpZCc7XHJcbiAgfVxyXG5cclxuICAvKiogR2V0dGVyIG9mIHRoZSBzZWxlY3RlZCBkYXRhIGNvbnRleHQgb2JqZWN0IElEcyAqL1xyXG4gIGdldCBzZWxlY3RlZFJvd0RhdGFDb250ZXh0SWRzKCk6IEFycmF5PG51bWJlciB8IHN0cmluZz4gfCB1bmRlZmluZWQge1xyXG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkUm93RGF0YUNvbnRleHRJZHM7XHJcbiAgfVxyXG5cclxuICAvKiogU2V0dGVyIG9mIHRoZSBzZWxlY3RlZCBkYXRhIGNvbnRleHQgb2JqZWN0IElEcyAqL1xyXG4gIHNldCBzZWxlY3RlZFJvd0RhdGFDb250ZXh0SWRzKGRhdGFDb250ZXh0SWRzOiBBcnJheTxudW1iZXIgfCBzdHJpbmc+IHwgdW5kZWZpbmVkKSB7XHJcbiAgICB0aGlzLl9zZWxlY3RlZFJvd0RhdGFDb250ZXh0SWRzID0gZGF0YUNvbnRleHRJZHM7XHJcblxyXG4gICAgLy8gc2luY2UgdGhpcyBpcyBjb21pbmcgZnJvbSBhIHByZXNldCwgd2UgYWxzbyBuZWVkIHRvIHVwZGF0ZSB0aGUgZmlsdGVyZWQgSURzXHJcbiAgICB0aGlzLl9zZWxlY3RlZEZpbHRlcmVkUm93RGF0YUNvbnRleHRJZHMgPSBkYXRhQ29udGV4dElkcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgdGhlIEdyaWQgU3RhdGUgU2VydmljZVxyXG4gICAqIEBwYXJhbSBncmlkXHJcbiAgICovXHJcbiAgaW5pdChncmlkOiBhbnksIGRhdGFWaWV3OiBhbnkpOiB2b2lkIHtcclxuICAgIHRoaXMuX2dyaWQgPSBncmlkO1xyXG4gICAgdGhpcy5fZGF0YVZpZXcgPSBkYXRhVmlldztcclxuICAgIHRoaXMuc3Vic2NyaWJlVG9BbGxHcmlkQ2hhbmdlcyhncmlkKTtcclxuICB9XHJcblxyXG4gIC8qKiBEaXNwb3NlIG9mIGFsbCB0aGUgU2xpY2tHcmlkICYgQW5ndWxhciBzdWJzY3JpcHRpb25zICovXHJcbiAgZGlzcG9zZSgpIHtcclxuICAgIC8vIHVuc3Vic2NyaWJlIGFsbCBTbGlja0dyaWQgZXZlbnRzXHJcbiAgICB0aGlzLl9ldmVudEhhbmRsZXIudW5zdWJzY3JpYmVBbGwoKTtcclxuXHJcbiAgICAvLyBhbHNvIHVuc3Vic2NyaWJlIGFsbCBBbmd1bGFyIFN1YnNjcmlwdGlvbnNcclxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSB1bnN1YnNjcmliZUFsbE9ic2VydmFibGVzKHRoaXMuX3N1YnNjcmlwdGlvbnMpO1xyXG5cclxuICAgIHRoaXMuX2N1cnJlbnRDb2x1bW5zID0gW107XHJcbiAgICB0aGlzLl9jb2x1bW5zID0gW107XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIGN1cnJlbnQgZ3JpZCBzdGF0ZSAoZmlsdGVycy9zb3J0ZXJzL3BhZ2luYXRpb24pXHJcbiAgICogQHJldHVybiBncmlkIHN0YXRlXHJcbiAgICovXHJcbiAgZ2V0Q3VycmVudEdyaWRTdGF0ZShhcmdzPzogeyByZXF1ZXN0UmVmcmVzaFJvd0ZpbHRlcmVkUm93PzogYm9vbGVhbiB9KTogR3JpZFN0YXRlIHtcclxuICAgIGNvbnN0IGdyaWRTdGF0ZTogR3JpZFN0YXRlID0ge1xyXG4gICAgICBjb2x1bW5zOiB0aGlzLmdldEN1cnJlbnRDb2x1bW5zKCksXHJcbiAgICAgIGZpbHRlcnM6IHRoaXMuZ2V0Q3VycmVudEZpbHRlcnMoKSxcclxuICAgICAgc29ydGVyczogdGhpcy5nZXRDdXJyZW50U29ydGVycygpLFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBjdXJyZW50UGFnaW5hdGlvbiA9IHRoaXMuZ2V0Q3VycmVudFBhZ2luYXRpb24oKTtcclxuICAgIGlmIChjdXJyZW50UGFnaW5hdGlvbikge1xyXG4gICAgICBncmlkU3RhdGUucGFnaW5hdGlvbiA9IGN1cnJlbnRQYWdpbmF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmhhc1Jvd1NlbGVjdGlvbkVuYWJsZWQoKSkge1xyXG4gICAgICBjb25zdCBjdXJyZW50Um93U2VsZWN0aW9uID0gdGhpcy5nZXRDdXJyZW50Um93U2VsZWN0aW9ucyhhcmdzICYmIGFyZ3MucmVxdWVzdFJlZnJlc2hSb3dGaWx0ZXJlZFJvdyk7XHJcbiAgICAgIGlmIChjdXJyZW50Um93U2VsZWN0aW9uKSB7XHJcbiAgICAgICAgZ3JpZFN0YXRlLnJvd1NlbGVjdGlvbiA9IGN1cnJlbnRSb3dTZWxlY3Rpb247XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBncmlkU3RhdGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIENvbHVtbnMgKGFuZCB0aGVpciBzdGF0ZTogdmlzaWJpbGl0eS9wb3NpdGlvbikgdGhhdCBhcmUgY3VycmVudGx5IGFwcGxpZWQgaW4gdGhlIGdyaWRcclxuICAgKiBAcmV0dXJuIGN1cnJlbnQgY29sdW1uc1xyXG4gICAqL1xyXG4gIGdldENvbHVtbnMoKTogQ29sdW1uW10ge1xyXG4gICAgcmV0dXJuIHRoaXMuX2NvbHVtbnM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGcm9tIGFuIGFycmF5IG9mIEdyaWQgQ29sdW1uIERlZmluaXRpb25zLCBnZXQgdGhlIGFzc29jaWF0ZWQgQ3VycmVudCBDb2x1bW5zXHJcbiAgICogQHBhcmFtIGdyaWRDb2x1bW5zXHJcbiAgICovXHJcbiAgZ2V0QXNzb2NpYXRlZEN1cnJlbnRDb2x1bW5zKGdyaWRDb2x1bW5zOiBDb2x1bW5bXSk6IEN1cnJlbnRDb2x1bW5bXSB7XHJcbiAgICBjb25zdCBjdXJyZW50Q29sdW1uczogQ3VycmVudENvbHVtbltdID0gW107XHJcblxyXG4gICAgaWYgKGdyaWRDb2x1bW5zICYmIEFycmF5LmlzQXJyYXkoZ3JpZENvbHVtbnMpKSB7XHJcbiAgICAgIGdyaWRDb2x1bW5zLmZvckVhY2goKGNvbHVtbjogQ29sdW1uLCBpbmRleDogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgaWYgKGNvbHVtbiAmJiBjb2x1bW4uaWQpIHtcclxuICAgICAgICAgIGN1cnJlbnRDb2x1bW5zLnB1c2goe1xyXG4gICAgICAgICAgICBjb2x1bW5JZDogY29sdW1uLmlkIGFzIHN0cmluZyxcclxuICAgICAgICAgICAgY3NzQ2xhc3M6IGNvbHVtbi5jc3NDbGFzcyB8fCAnJyxcclxuICAgICAgICAgICAgaGVhZGVyQ3NzQ2xhc3M6IGNvbHVtbi5oZWFkZXJDc3NDbGFzcyB8fCAnJyxcclxuICAgICAgICAgICAgd2lkdGg6IGNvbHVtbi53aWR0aCB8fCAwXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fY3VycmVudENvbHVtbnMgPSBjdXJyZW50Q29sdW1ucztcclxuICAgIHJldHVybiBjdXJyZW50Q29sdW1ucztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZyb20gYW4gYXJyYXkgb2YgQ3VycmVudCBDb2x1bW5zLCBnZXQgdGhlIGFzc29jaWF0ZWQgR3JpZCBDb2x1bW4gRGVmaW5pdGlvbnNcclxuICAgKiBAcGFyYW0gZ3JpZFxyXG4gICAqIEBwYXJhbSBjdXJyZW50Q29sdW1uc1xyXG4gICAqL1xyXG4gIGdldEFzc29jaWF0ZWRHcmlkQ29sdW1ucyhncmlkOiBhbnksIGN1cnJlbnRDb2x1bW5zOiBDdXJyZW50Q29sdW1uW10pOiBDb2x1bW5bXSB7XHJcbiAgICBjb25zdCBjb2x1bW5zOiBDb2x1bW5bXSA9IFtdO1xyXG4gICAgY29uc3QgZ3JpZENvbHVtbnM6IENvbHVtbltdID0gZ3JpZC5nZXRDb2x1bW5zKCk7XHJcblxyXG4gICAgaWYgKGN1cnJlbnRDb2x1bW5zICYmIEFycmF5LmlzQXJyYXkoY3VycmVudENvbHVtbnMpKSB7XHJcbiAgICAgIGN1cnJlbnRDb2x1bW5zLmZvckVhY2goKGN1cnJlbnRDb2x1bW46IEN1cnJlbnRDb2x1bW4sIGluZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgICBjb25zdCBncmlkQ29sdW1uOiBDb2x1bW4gPSBncmlkQ29sdW1ucy5maW5kKChjOiBDb2x1bW4pID0+IGMuaWQgPT09IGN1cnJlbnRDb2x1bW4uY29sdW1uSWQpO1xyXG4gICAgICAgIGlmIChncmlkQ29sdW1uICYmIGdyaWRDb2x1bW4uaWQpIHtcclxuICAgICAgICAgIGNvbHVtbnMucHVzaCh7XHJcbiAgICAgICAgICAgIC4uLmdyaWRDb2x1bW4sXHJcbiAgICAgICAgICAgIGNzc0NsYXNzOiBjdXJyZW50Q29sdW1uLmNzc0NsYXNzLFxyXG4gICAgICAgICAgICBoZWFkZXJDc3NDbGFzczogY3VycmVudENvbHVtbi5oZWFkZXJDc3NDbGFzcyxcclxuICAgICAgICAgICAgd2lkdGg6IGN1cnJlbnRDb2x1bW4ud2lkdGhcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9jb2x1bW5zID0gY29sdW1ucztcclxuICAgIHJldHVybiBjb2x1bW5zO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBDb2x1bW5zIChhbmQgdGhlaXIgc3RhdGU6IHZpc2liaWxpdHkvcG9zaXRpb24pIHRoYXQgYXJlIGN1cnJlbnRseSBhcHBsaWVkIGluIHRoZSBncmlkXHJcbiAgICogQHJldHVybiBjdXJyZW50IGNvbHVtbnNcclxuICAgKi9cclxuICBnZXRDdXJyZW50Q29sdW1ucygpOiBDdXJyZW50Q29sdW1uW10ge1xyXG4gICAgbGV0IGN1cnJlbnRDb2x1bW5zOiBDdXJyZW50Q29sdW1uW10gPSBbXTtcclxuICAgIGlmICh0aGlzLl9jdXJyZW50Q29sdW1ucyAmJiBBcnJheS5pc0FycmF5KHRoaXMuX2N1cnJlbnRDb2x1bW5zKSAmJiB0aGlzLl9jdXJyZW50Q29sdW1ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGN1cnJlbnRDb2x1bW5zID0gdGhpcy5fY3VycmVudENvbHVtbnM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjdXJyZW50Q29sdW1ucyA9IHRoaXMuZ2V0QXNzb2NpYXRlZEN1cnJlbnRDb2x1bW5zKHRoaXMuX2dyaWQuZ2V0Q29sdW1ucygpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY3VycmVudENvbHVtbnM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIEZpbHRlcnMgKGFuZCB0aGVpciBzdGF0ZSwgY29sdW1uSWQsIHNlYXJjaFRlcm0ocykpIHRoYXQgYXJlIGN1cnJlbnRseSBhcHBsaWVkIGluIHRoZSBncmlkXHJcbiAgICogQHJldHVybiBjdXJyZW50IGZpbHRlcnNcclxuICAgKi9cclxuICBnZXRDdXJyZW50RmlsdGVycygpOiBDdXJyZW50RmlsdGVyW10gfCBudWxsIHtcclxuICAgIGlmICh0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5iYWNrZW5kU2VydmljZUFwaSkge1xyXG4gICAgICBjb25zdCBiYWNrZW5kU2VydmljZSA9IHRoaXMuX2dyaWRPcHRpb25zLmJhY2tlbmRTZXJ2aWNlQXBpLnNlcnZpY2U7XHJcbiAgICAgIGlmIChiYWNrZW5kU2VydmljZSAmJiBiYWNrZW5kU2VydmljZS5nZXRDdXJyZW50RmlsdGVycykge1xyXG4gICAgICAgIHJldHVybiBiYWNrZW5kU2VydmljZS5nZXRDdXJyZW50RmlsdGVycygpIGFzIEN1cnJlbnRGaWx0ZXJbXTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0aGlzLmZpbHRlclNlcnZpY2UgJiYgdGhpcy5maWx0ZXJTZXJ2aWNlLmdldEN1cnJlbnRMb2NhbEZpbHRlcnMpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyU2VydmljZS5nZXRDdXJyZW50TG9jYWxGaWx0ZXJzKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBjdXJyZW50IFBhZ2luYXRpb24gKGFuZCBpdCdzIHN0YXRlLCBwYWdlTnVtYmVyLCBwYWdlU2l6ZSkgdGhhdCBhcmUgY3VycmVudGx5IGFwcGxpZWQgaW4gdGhlIGdyaWRcclxuICAgKiBAcmV0dXJuIGN1cnJlbnQgcGFnaW5hdGlvbiBzdGF0ZVxyXG4gICAqL1xyXG4gIGdldEN1cnJlbnRQYWdpbmF0aW9uKCk6IEN1cnJlbnRQYWdpbmF0aW9uIHwgbnVsbCB7XHJcbiAgICBpZiAodGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlUGFnaW5hdGlvbikge1xyXG4gICAgICBpZiAodGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuYmFja2VuZFNlcnZpY2VBcGkpIHtcclxuICAgICAgICBjb25zdCBiYWNrZW5kU2VydmljZSA9IHRoaXMuX2dyaWRPcHRpb25zLmJhY2tlbmRTZXJ2aWNlQXBpLnNlcnZpY2U7XHJcbiAgICAgICAgaWYgKGJhY2tlbmRTZXJ2aWNlICYmIGJhY2tlbmRTZXJ2aWNlLmdldEN1cnJlbnRQYWdpbmF0aW9uKSB7XHJcbiAgICAgICAgICByZXR1cm4gYmFja2VuZFNlcnZpY2UuZ2V0Q3VycmVudFBhZ2luYXRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcmVkU2VydmljZS5jdXJyZW50UGFnaW5hdGlvbjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIGN1cnJlbnQgU29ydGVycyAoYW5kIHRoZWlyIHN0YXRlLCBjb2x1bW5JZCwgZGlyZWN0aW9uKSB0aGF0IGFyZSBjdXJyZW50bHkgYXBwbGllZCBpbiB0aGUgZ3JpZFxyXG4gICAqIEByZXR1cm4gY3VycmVudCBzb3J0ZXJzXHJcbiAgICovXHJcbiAgZ2V0Q3VycmVudFJvd1NlbGVjdGlvbnMocmVxdWVzdFJlZnJlc2hGaWx0ZXJlZFJvdyA9IHRydWUpOiBDdXJyZW50Um93U2VsZWN0aW9uIHwgbnVsbCB7XHJcbiAgICBpZiAodGhpcy5fZ3JpZCAmJiB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9kYXRhVmlldyAmJiB0aGlzLmhhc1Jvd1NlbGVjdGlvbkVuYWJsZWQoKSkge1xyXG4gICAgICBpZiAodGhpcy5fZ3JpZC5nZXRTZWxlY3RlZFJvd3MgJiYgdGhpcy5fZGF0YVZpZXcubWFwUm93c1RvSWRzKSB7XHJcbiAgICAgICAgbGV0IGZpbHRlcmVkRGF0YUNvbnRleHRJZHM6IEFycmF5PG51bWJlciB8IHN0cmluZz4gfCB1bmRlZmluZWQgPSBbXTtcclxuICAgICAgICBjb25zdCBncmlkUm93SW5kZXhlczogbnVtYmVyW10gPSB0aGlzLl9kYXRhVmlldy5tYXBJZHNUb1Jvd3ModGhpcy5fc2VsZWN0ZWRSb3dEYXRhQ29udGV4dElkcyB8fCBbXSk7IC8vIG5vdGUgdGhhdCB0aGlzIHdpbGwgcmV0dXJuIG9ubHkgd2hhdCBpcyB2aXNpYmxlIGluIGN1cnJlbnQgcGFnZVxyXG4gICAgICAgIGNvbnN0IGRhdGFDb250ZXh0SWRzOiBBcnJheTxudW1iZXIgfCBzdHJpbmc+IHwgdW5kZWZpbmVkID0gdGhpcy5fc2VsZWN0ZWRSb3dEYXRhQ29udGV4dElkcztcclxuXHJcbiAgICAgICAgLy8gdXNlciBtaWdodCByZXF1ZXN0IHRvIHJlZnJlc2ggdGhlIGZpbHRlcmVkIHNlbGVjdGlvbiBkYXRhc2V0XHJcbiAgICAgICAgLy8gdHlwaWNhbGx5IGFsd2F5cyBUcnVlLCBleGNlcHQgd2hlbiBcInJlRXZhbHVhdGVSb3dTZWxlY3Rpb25BZnRlckZpbHRlckNoYW5nZVwiIGlzIGNhbGxlZCBhbmQgd2UgZG9uJ3QgbmVlZCB0byByZWZyZXNoIHRoZSBmaWx0ZXJlZCBkYXRhc2V0IHR3aWNlXHJcbiAgICAgICAgaWYgKHJlcXVlc3RSZWZyZXNoRmlsdGVyZWRSb3cgPT09IHRydWUpIHtcclxuICAgICAgICAgIGZpbHRlcmVkRGF0YUNvbnRleHRJZHMgPSB0aGlzLnJlZnJlc2hGaWx0ZXJlZFJvd1NlbGVjdGlvbnMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmlsdGVyZWREYXRhQ29udGV4dElkcyA9IHRoaXMuX3NlbGVjdGVkRmlsdGVyZWRSb3dEYXRhQ29udGV4dElkcztcclxuXHJcbiAgICAgICAgcmV0dXJuIHsgZ3JpZFJvd0luZGV4ZXMsIGRhdGFDb250ZXh0SWRzLCBmaWx0ZXJlZERhdGFDb250ZXh0SWRzIH07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBjdXJyZW50IFNvcnRlcnMgKGFuZCB0aGVpciBzdGF0ZSwgY29sdW1uSWQsIGRpcmVjdGlvbikgdGhhdCBhcmUgY3VycmVudGx5IGFwcGxpZWQgaW4gdGhlIGdyaWRcclxuICAgKiBAcmV0dXJuIGN1cnJlbnQgc29ydGVyc1xyXG4gICAqL1xyXG4gIGdldEN1cnJlbnRTb3J0ZXJzKCk6IEN1cnJlbnRTb3J0ZXJbXSB8IG51bGwge1xyXG4gICAgaWYgKHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLmJhY2tlbmRTZXJ2aWNlQXBpKSB7XHJcbiAgICAgIGNvbnN0IGJhY2tlbmRTZXJ2aWNlID0gdGhpcy5fZ3JpZE9wdGlvbnMuYmFja2VuZFNlcnZpY2VBcGkuc2VydmljZTtcclxuICAgICAgaWYgKGJhY2tlbmRTZXJ2aWNlICYmIGJhY2tlbmRTZXJ2aWNlLmdldEN1cnJlbnRTb3J0ZXJzKSB7XHJcbiAgICAgICAgcmV0dXJuIGJhY2tlbmRTZXJ2aWNlLmdldEN1cnJlbnRTb3J0ZXJzKCkgYXMgQ3VycmVudFNvcnRlcltdO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuc29ydFNlcnZpY2UgJiYgdGhpcy5zb3J0U2VydmljZS5nZXRDdXJyZW50TG9jYWxTb3J0ZXJzKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNvcnRTZXJ2aWNlLmdldEN1cnJlbnRMb2NhbFNvcnRlcnMoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqIENoZWNrIHdoZXRoZXIgdGhlIHJvdyBzZWxlY3Rpb24gbmVlZHMgdG8gYmUgcHJlc2VydmVkICovXHJcbiAgbmVlZFRvUHJlc2VydmVSb3dTZWxlY3Rpb24oKTogYm9vbGVhbiB7XHJcbiAgICBsZXQgcHJlc2VydmVkUm93U2VsZWN0aW9uID0gZmFsc2U7XHJcbiAgICBpZiAodGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuZGF0YVZpZXcgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuZGF0YVZpZXcuaGFzT3duUHJvcGVydHkoJ3N5bmNHcmlkU2VsZWN0aW9uJykpIHtcclxuICAgICAgY29uc3Qgc3luY0dyaWRTZWxlY3Rpb24gPSB0aGlzLl9ncmlkT3B0aW9ucy5kYXRhVmlldy5zeW5jR3JpZFNlbGVjdGlvbjtcclxuICAgICAgaWYgKHR5cGVvZiBzeW5jR3JpZFNlbGVjdGlvbiA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgcHJlc2VydmVkUm93U2VsZWN0aW9uID0gdGhpcy5fZ3JpZE9wdGlvbnMuZGF0YVZpZXcuc3luY0dyaWRTZWxlY3Rpb24gYXMgYm9vbGVhbjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwcmVzZXJ2ZWRSb3dTZWxlY3Rpb24gPSBzeW5jR3JpZFNlbGVjdGlvbi5wcmVzZXJ2ZUhpZGRlbjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gaWYgdGhlIHJlc3VsdCBpcyBUcnVlIGJ1dCB0aGUgZ3JpZCBpcyB1c2luZyBhIEJhY2tlbmQgU2VydmljZSwgd2Ugd2lsbCBkbyBhbiBleHRyYSBmbGFnIGNoZWNrIHRoZSByZWFzb24gaXMgYmVjYXVzZSBpdCBtaWdodCBoYXZlIHNvbWUgdW5pbnRlbmRlZCBiZWhhdmlvcnNcclxuICAgICAgLy8gd2l0aCB0aGUgQmFja2VuZFNlcnZpY2VBcGkgYmVjYXVzZSB0ZWNobmljYWxseSB0aGUgZGF0YSBpbiB0aGUgcGFnZSBjaGFuZ2VzIHRoZSBEYXRhVmlldyBvbiBldmVyeSBwYWdlLlxyXG4gICAgICBpZiAocHJlc2VydmVkUm93U2VsZWN0aW9uICYmIHRoaXMuX2dyaWRPcHRpb25zLmJhY2tlbmRTZXJ2aWNlQXBpICYmIHRoaXMuX2dyaWRPcHRpb25zLmRhdGFWaWV3Lmhhc093blByb3BlcnR5KCdzeW5jR3JpZFNlbGVjdGlvbldpdGhCYWNrZW5kU2VydmljZScpKSB7XHJcbiAgICAgICAgcHJlc2VydmVkUm93U2VsZWN0aW9uID0gdGhpcy5fZ3JpZE9wdGlvbnMuZGF0YVZpZXcuc3luY0dyaWRTZWxlY3Rpb25XaXRoQmFja2VuZFNlcnZpY2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwcmVzZXJ2ZWRSb3dTZWxlY3Rpb247XHJcbiAgfVxyXG5cclxuICByZXNldENvbHVtbnMoY29sdW1uRGVmaW5pdGlvbnM/OiBDb2x1bW5bXSkge1xyXG4gICAgY29uc3QgY29sdW1uczogQ29sdW1uW10gPSBjb2x1bW5EZWZpbml0aW9ucyB8fCB0aGlzLl9jb2x1bW5zO1xyXG4gICAgY29uc3QgY3VycmVudENvbHVtbnM6IEN1cnJlbnRDb2x1bW5bXSA9IHRoaXMuZ2V0QXNzb2NpYXRlZEN1cnJlbnRDb2x1bW5zKGNvbHVtbnMpO1xyXG4gICAgdGhpcy5vbkdyaWRTdGF0ZUNoYW5nZWQubmV4dCh7IGNoYW5nZTogeyBuZXdWYWx1ZXM6IGN1cnJlbnRDb2x1bW5zLCB0eXBlOiBHcmlkU3RhdGVUeXBlLmNvbHVtbnMgfSwgZ3JpZFN0YXRlOiB0aGlzLmdldEN1cnJlbnRHcmlkU3RhdGUoKSB9KTtcclxuICB9XHJcblxyXG4gIC8qKiBpZiB3ZSB1c2UgUm93IFNlbGVjdGlvbiBvciB0aGUgQ2hlY2tib3ggU2VsZWN0b3IsIHdlIG5lZWQgdG8gcmVzZXQgYW55IHNlbGVjdGlvbiAqL1xyXG4gIHJlc2V0Um93U2VsZWN0aW9uV2hlblJlcXVpcmVkKCkge1xyXG4gICAgaWYgKCF0aGlzLm5lZWRUb1ByZXNlcnZlUm93U2VsZWN0aW9uKCkgJiYgKHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZVJvd1NlbGVjdGlvbiB8fCB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVDaGVja2JveFNlbGVjdG9yKSkge1xyXG4gICAgICAvLyB0aGlzIGFsc28gcmVxdWlyZXMgdGhlIFJvdyBTZWxlY3Rpb24gTW9kZWwgdG8gYmUgcmVnaXN0ZXJlZCBhcyB3ZWxsXHJcbiAgICAgIGNvbnN0IHJvd1NlbGVjdGlvbkV4dGVuc2lvbiA9IHRoaXMuZXh0ZW5zaW9uU2VydmljZSAmJiB0aGlzLmV4dGVuc2lvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uQnlOYW1lICYmIHRoaXMuZXh0ZW5zaW9uU2VydmljZS5nZXRFeHRlbnNpb25CeU5hbWUoRXh0ZW5zaW9uTmFtZS5yb3dTZWxlY3Rpb24pO1xyXG4gICAgICBpZiAocm93U2VsZWN0aW9uRXh0ZW5zaW9uICYmIHJvd1NlbGVjdGlvbkV4dGVuc2lvbi5pbnN0YW5jZSkge1xyXG4gICAgICAgIHRoaXMuX2dyaWQuc2V0U2VsZWN0ZWRSb3dzKFtdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3Vic2NyaWJlIHRvIGFsbCBuZWNlc3NhcnkgU2xpY2tHcmlkIG9yIFNlcnZpY2UgRXZlbnRzIHRoYXQgZGVhbHMgd2l0aCBhIEdyaWQgY2hhbmdlLFxyXG4gICAqIHdoZW4gdHJpZ2dlcmVkLCB3ZSB3aWxsIHB1Ymxpc2ggYSBHcmlkIFN0YXRlIEV2ZW50IHdpdGggY3VycmVudCBHcmlkIFN0YXRlXHJcbiAgICovXHJcbiAgc3Vic2NyaWJlVG9BbGxHcmlkQ2hhbmdlcyhncmlkOiBhbnkpIHtcclxuICAgIC8vIFN1YnNjcmliZSB0byBFdmVudCBFbWl0dGVyIG9mIEZpbHRlciBjaGFuZ2VkXHJcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnB1c2goXHJcbiAgICAgIHRoaXMuZmlsdGVyU2VydmljZS5vbkZpbHRlckNoYW5nZWQuc3Vic2NyaWJlKChjdXJyZW50RmlsdGVyczogQ3VycmVudEZpbHRlcltdKSA9PiB7XHJcbiAgICAgICAgdGhpcy5yZXNldFJvd1NlbGVjdGlvbldoZW5SZXF1aXJlZCgpO1xyXG5cclxuICAgICAgICAvLyB0cmlnZ2VyIGEgR3JpZCBTdGF0ZSBmaWx0ZXIgY2hhbmdlLCBob3dldmVyIGRvbid0IHJlZXZhbHVhdGUgdGhlIGZpbHRlcmVkIHJvdyBzZWxlY3Rpb25zLCB3ZSdsbCBkbyB0aGF0IG9uIHRoZSBuZXh0IEdyaWQgU3RhdGUgY2hhbmdlIGJlbG93XHJcbiAgICAgICAgdGhpcy5vbkdyaWRTdGF0ZUNoYW5nZWQubmV4dCh7IGNoYW5nZTogeyBuZXdWYWx1ZXM6IGN1cnJlbnRGaWx0ZXJzLCB0eXBlOiBHcmlkU3RhdGVUeXBlLmZpbHRlciB9LCBncmlkU3RhdGU6IHRoaXMuZ2V0Q3VycmVudEdyaWRTdGF0ZSh7IHJlcXVlc3RSZWZyZXNoUm93RmlsdGVyZWRSb3c6ICF0aGlzLmhhc1Jvd1NlbGVjdGlvbkVuYWJsZWQoKSB9KSB9KTtcclxuXHJcbiAgICAgICAgLy8gd2hlbiBSb3cgU2VsZWN0aW9uIGlzIGVuYWJsZWQsIHdlIGFsc28gbmVlZCB0byByZS1ldmFsdWF0ZSB0aGUgcm93IHNlbGVjdGlvbiB3aXRoIHRoZSBsZWZ0b3ZlciBmaWx0ZXJlZCBkYXRhc2V0XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzUm93U2VsZWN0aW9uRW5hYmxlZCgpKSB7XHJcbiAgICAgICAgICB0aGlzLnJlRXZhbHVhdGVSb3dTZWxlY3Rpb25BZnRlckZpbHRlckNoYW5nZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgICk7XHJcblxyXG4gICAgLy8gU3Vic2NyaWJlIHRvIEV2ZW50IEVtaXR0ZXIgb2YgRmlsdGVyIGNsZWFyZWRcclxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMucHVzaChcclxuICAgICAgdGhpcy5maWx0ZXJTZXJ2aWNlLm9uRmlsdGVyQ2xlYXJlZC5zdWJzY3JpYmUoKCkgPT4ge1xyXG4gICAgICAgIHRoaXMucmVzZXRSb3dTZWxlY3Rpb25XaGVuUmVxdWlyZWQoKTtcclxuICAgICAgICB0aGlzLm9uR3JpZFN0YXRlQ2hhbmdlZC5uZXh0KHsgY2hhbmdlOiB7IG5ld1ZhbHVlczogW10sIHR5cGU6IEdyaWRTdGF0ZVR5cGUuZmlsdGVyIH0sIGdyaWRTdGF0ZTogdGhpcy5nZXRDdXJyZW50R3JpZFN0YXRlKCkgfSk7XHJcbiAgICAgIH0pXHJcbiAgICApO1xyXG5cclxuICAgIC8vIFN1YnNjcmliZSB0byBFdmVudCBFbWl0dGVyIG9mIFNvcnQgY2hhbmdlZFxyXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5wdXNoKFxyXG4gICAgICB0aGlzLnNvcnRTZXJ2aWNlLm9uU29ydENoYW5nZWQuc3Vic2NyaWJlKChjdXJyZW50U29ydGVyczogQ3VycmVudFNvcnRlcltdKSA9PiB7XHJcbiAgICAgICAgdGhpcy5yZXNldFJvd1NlbGVjdGlvbldoZW5SZXF1aXJlZCgpO1xyXG4gICAgICAgIHRoaXMub25HcmlkU3RhdGVDaGFuZ2VkLm5leHQoeyBjaGFuZ2U6IHsgbmV3VmFsdWVzOiBjdXJyZW50U29ydGVycywgdHlwZTogR3JpZFN0YXRlVHlwZS5zb3J0ZXIgfSwgZ3JpZFN0YXRlOiB0aGlzLmdldEN1cnJlbnRHcmlkU3RhdGUoKSB9KTtcclxuICAgICAgfSlcclxuICAgICk7XHJcblxyXG4gICAgLy8gU3Vic2NyaWJlIHRvIEV2ZW50IEVtaXR0ZXIgb2YgU29ydCBjbGVhcmVkXHJcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnB1c2goXHJcbiAgICAgIHRoaXMuc29ydFNlcnZpY2Uub25Tb3J0Q2xlYXJlZC5zdWJzY3JpYmUoKCkgPT4ge1xyXG4gICAgICAgIHRoaXMucmVzZXRSb3dTZWxlY3Rpb25XaGVuUmVxdWlyZWQoKTtcclxuICAgICAgICB0aGlzLm9uR3JpZFN0YXRlQ2hhbmdlZC5uZXh0KHsgY2hhbmdlOiB7IG5ld1ZhbHVlczogW10sIHR5cGU6IEdyaWRTdGF0ZVR5cGUuc29ydGVyIH0sIGdyaWRTdGF0ZTogdGhpcy5nZXRDdXJyZW50R3JpZFN0YXRlKCkgfSk7XHJcbiAgICAgIH0pXHJcbiAgICApO1xyXG5cclxuICAgIC8vIFN1YnNjcmliZSB0byBDb2x1bW5QaWNrZXIgYW5kL29yIEdyaWRNZW51IGZvciBzaG93L2hpZGUgQ29sdW1ucyB2aXNpYmlsaXR5IGNoYW5nZXNcclxuICAgIHRoaXMuYmluZEV4dGVuc2lvbkFkZG9uRXZlbnRUb0dyaWRTdGF0ZUNoYW5nZShFeHRlbnNpb25OYW1lLmNvbHVtblBpY2tlciwgJ29uQ29sdW1uc0NoYW5nZWQnKTtcclxuICAgIHRoaXMuYmluZEV4dGVuc2lvbkFkZG9uRXZlbnRUb0dyaWRTdGF0ZUNoYW5nZShFeHRlbnNpb25OYW1lLmdyaWRNZW51LCAnb25Db2x1bW5zQ2hhbmdlZCcpO1xyXG5cclxuICAgIC8vIHN1YnNjcmliZSB0byBDb2x1bW4gUmVzaXplICYgUmVvcmRlcmluZ1xyXG4gICAgdGhpcy5iaW5kU2xpY2tHcmlkQ29sdW1uQ2hhbmdlRXZlbnRUb0dyaWRTdGF0ZUNoYW5nZSgnb25Db2x1bW5zUmVvcmRlcmVkJywgZ3JpZCk7XHJcbiAgICB0aGlzLmJpbmRTbGlja0dyaWRDb2x1bW5DaGFuZ2VFdmVudFRvR3JpZFN0YXRlQ2hhbmdlKCdvbkNvbHVtbnNSZXNpemVkJywgZ3JpZCk7XHJcblxyXG4gICAgLy8gc3Vic2NyaWJlIHRvIFJvdyBTZWxlY3Rpb24gY2hhbmdlcyAod2hlbiBlbmFibGVkKVxyXG4gICAgaWYgKHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZVJvd1NlbGVjdGlvbiB8fCB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVDaGVja2JveFNlbGVjdG9yKSB7XHJcbiAgICAgIHRoaXMuYmluZFNsaWNrR3JpZFJvd1NlbGVjdGlvblRvR3JpZFN0YXRlQ2hhbmdlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc3Vic2NyaWJlIHRvIEhlYWRlck1lbnUgKGhpZGUgY29sdW1uKVxyXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5wdXNoKFxyXG4gICAgICB0aGlzLnNoYXJlZFNlcnZpY2Uub25Db2x1bW5zQ2hhbmdlZC5zdWJzY3JpYmUoKHZpc2libGVDb2x1bW5zOiBDb2x1bW5bXSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRDb2x1bW5zOiBDdXJyZW50Q29sdW1uW10gPSB0aGlzLmdldEFzc29jaWF0ZWRDdXJyZW50Q29sdW1ucyh2aXNpYmxlQ29sdW1ucyk7XHJcbiAgICAgICAgdGhpcy5vbkdyaWRTdGF0ZUNoYW5nZWQubmV4dCh7IGNoYW5nZTogeyBuZXdWYWx1ZXM6IGN1cnJlbnRDb2x1bW5zLCB0eXBlOiBHcmlkU3RhdGVUeXBlLmNvbHVtbnMgfSwgZ3JpZFN0YXRlOiB0aGlzLmdldEN1cnJlbnRHcmlkU3RhdGUoKSB9KTtcclxuICAgICAgfSlcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvLyAtLVxyXG4gIC8vIHByaXZhdGUgbWV0aG9kc1xyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvKipcclxuICAgKiBCaW5kIGEgU2xpY2tHcmlkIEV4dGVuc2lvbiBFdmVudCB0byBhIEdyaWQgU3RhdGUgY2hhbmdlIGV2ZW50XHJcbiAgICogQHBhcmFtIGV4dGVuc2lvbiBuYW1lXHJcbiAgICogQHBhcmFtIGdyaWRcclxuICAgKi9cclxuICBwcml2YXRlIGJpbmRFeHRlbnNpb25BZGRvbkV2ZW50VG9HcmlkU3RhdGVDaGFuZ2UoZXh0ZW5zaW9uTmFtZTogRXh0ZW5zaW9uTmFtZSwgZXZlbnROYW1lOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRoaXMuZXh0ZW5zaW9uU2VydmljZSAmJiB0aGlzLmV4dGVuc2lvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uQnlOYW1lICYmIHRoaXMuZXh0ZW5zaW9uU2VydmljZS5nZXRFeHRlbnNpb25CeU5hbWUoZXh0ZW5zaW9uTmFtZSk7XHJcbiAgICBjb25zdCBzbGlja0V2ZW50ID0gZXh0ZW5zaW9uICYmIGV4dGVuc2lvbi5pbnN0YW5jZSAmJiBleHRlbnNpb24uaW5zdGFuY2VbZXZlbnROYW1lXTtcclxuXHJcbiAgICBpZiAoc2xpY2tFdmVudCAmJiBzbGlja0V2ZW50LnN1YnNjcmliZSkge1xyXG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIuc3Vic2NyaWJlKHNsaWNrRXZlbnQsIChlOiBFdmVudCwgYXJnczogYW55KSA9PiB7XHJcbiAgICAgICAgY29uc3QgY29sdW1uczogQ29sdW1uW10gPSBhcmdzICYmIGFyZ3MuY29sdW1ucztcclxuICAgICAgICBjb25zdCBjdXJyZW50Q29sdW1uczogQ3VycmVudENvbHVtbltdID0gdGhpcy5nZXRBc3NvY2lhdGVkQ3VycmVudENvbHVtbnMoY29sdW1ucyk7XHJcbiAgICAgICAgdGhpcy5vbkdyaWRTdGF0ZUNoYW5nZWQubmV4dCh7IGNoYW5nZTogeyBuZXdWYWx1ZXM6IGN1cnJlbnRDb2x1bW5zLCB0eXBlOiBHcmlkU3RhdGVUeXBlLmNvbHVtbnMgfSwgZ3JpZFN0YXRlOiB0aGlzLmdldEN1cnJlbnRHcmlkU3RhdGUoKSB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCaW5kIGEgR3JpZCBFdmVudCAob2YgQ29sdW1uIGNoYW5nZXMpIHRvIGEgR3JpZCBTdGF0ZSBjaGFuZ2UgZXZlbnRcclxuICAgKiBAcGFyYW0gZXZlbnQgbmFtZVxyXG4gICAqIEBwYXJhbSBncmlkXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBiaW5kU2xpY2tHcmlkQ29sdW1uQ2hhbmdlRXZlbnRUb0dyaWRTdGF0ZUNoYW5nZShldmVudE5hbWU6IHN0cmluZywgZ3JpZDogYW55KSB7XHJcbiAgICBjb25zdCBzbGlja0dyaWRFdmVudCA9IGdyaWQgJiYgZ3JpZFtldmVudE5hbWVdO1xyXG5cclxuICAgIGlmIChzbGlja0dyaWRFdmVudCAmJiBzbGlja0dyaWRFdmVudC5zdWJzY3JpYmUpIHtcclxuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyLnN1YnNjcmliZShzbGlja0dyaWRFdmVudCwgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNvbHVtbnM6IENvbHVtbltdID0gZ3JpZC5nZXRDb2x1bW5zKCk7XHJcbiAgICAgICAgY29uc3QgY3VycmVudENvbHVtbnM6IEN1cnJlbnRDb2x1bW5bXSA9IHRoaXMuZ2V0QXNzb2NpYXRlZEN1cnJlbnRDb2x1bW5zKGNvbHVtbnMpO1xyXG4gICAgICAgIHRoaXMub25HcmlkU3RhdGVDaGFuZ2VkLm5leHQoeyBjaGFuZ2U6IHsgbmV3VmFsdWVzOiBjdXJyZW50Q29sdW1ucywgdHlwZTogR3JpZFN0YXRlVHlwZS5jb2x1bW5zIH0sIGdyaWRTdGF0ZTogdGhpcy5nZXRDdXJyZW50R3JpZFN0YXRlKCkgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQmluZCBhIEdyaWQgRXZlbnQgb2YgUm93IFNlbGVjdGlvbiBjaGFuZ2UgdG8gYSBHcmlkIFN0YXRlIGNoYW5nZSBldmVudFxyXG4gICAqIEZvciB0aGUgcm93IHNlbGVjdGlvbiwgd2UgY2FuJ3QganVzdCB1c2UgdGhlIGdldFNlbGVjdGVkUm93cygpIHNpbmNlIHRoaXMgd2lsbCBvbmx5IHJldHVybiB0aGUgdmlzaWJsZSByb3dzIHNob3duIGluIHRoZSBVSSB3aGljaCBpcyBub3QgZW5vdWdoLlxyXG4gICAqIFRoZSBwcm9jZXNzIGlzIG11Y2ggbW9yZSBjb21wbGV4LCB3aGF0IHdlIGhhdmUgdG8gZG8gaW5zdGVhZCBpcyB0aGUgZm9sbG93aW5nXHJcbiAgICogMS4gd2hlbiBjaGFuZ2luZyBhIHJvdyBzZWxlY3Rpb24sIHdlJ2xsIGFkZCB0aGUgbmV3IHNlbGVjdGlvbiBpZiBpdCdzIG5vdCB5ZXQgaW4gdGhlIGdsb2JhbCBhcnJheSBvZiBzZWxlY3RlZCBJRHNcclxuICAgKiAyLiB3aGVuIGRlbGV0aW5nIGEgcm93IHNlbGVjdGlvbiwgd2UnbGwgcmVtb3ZlIHRoZSBzZWxlY3Rpb24gZnJvbSBvdXIgZ2xvYmFsIGFycmF5IG9mIHNlbGVjdGVkIElEcyAodW5sZXNzIGl0IGNhbWUgZnJvbSBhIHBhZ2UgY2hhbmdlKVxyXG4gICAqIDMuIGlmIHdlIHVzZSBQYWdpbmF0aW9uIGFuZCB3ZSBjaGFuZ2UgcGFnZSwgd2UnbGwga2VlcCB0cmFjayB3aXRoIGEgZmxhZyAodGhpcyBmbGFnIHdpbGwgYmUgdXNlZCB0byBza2lwIGFueSBkZWxldGlvbiB3aGVuIHdlJ3JlIGNoYW5naW5nIHBhZ2UpXHJcbiAgICogNC4gYWZ0ZXIgdGhlIFBhZ2Ugb3IgRGF0YVZpZXcgaXMgY2hhbmdlZCBvciB1cGRhdGVkLCB3ZSdsbCBkbyBhbiBleHRyYSAoYW5kIGRlbGF5ZWQpIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGF0IHdoYXQgd2UgaGF2ZSBpbiBvdXIgZ2xvYmFsIGFycmF5IG9mIHNlbGVjdGVkIElEcyBpcyBkaXNwbGF5ZWQgb24gc2NyZWVuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBiaW5kU2xpY2tHcmlkUm93U2VsZWN0aW9uVG9HcmlkU3RhdGVDaGFuZ2UoKSB7XHJcbiAgICBpZiAodGhpcy5fZ3JpZCAmJiB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9kYXRhVmlldykge1xyXG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIuc3Vic2NyaWJlKHRoaXMuX2RhdGFWaWV3Lm9uQmVmb3JlUGFnaW5nSW5mb0NoYW5nZWQsICgpID0+IHtcclxuICAgICAgICB0aGlzLl93YXNSZWNoZWNrZWRBZnRlclBhZ2VDaGFuZ2UgPSBmYWxzZTsgLy8gcmVzZXQgdGhlIHBhZ2UgY2hlY2sgZmxhZywgdG8gc2tpcCBkZWxldGlvbnMgb24gcGFnZSBjaGFuZ2UgKHVzZWQgaW4gY29kZSBiZWxvdylcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIuc3Vic2NyaWJlKHRoaXMuX2RhdGFWaWV3Lm9uUGFnaW5nSW5mb0NoYW5nZWQsICgpID0+IHtcclxuICAgICAgICAvLyB3aGVuIHVzZXIgY2hhbmdlcyBwYWdlLCB0aGUgc2VsZWN0ZWQgcm93IGluZGV4ZXMgbWlnaHQgbm90IHNob3cgdXBcclxuICAgICAgICAvLyB3ZSBjYW4gY2hlY2sgdG8gbWFrZSBzdXJlIGl0IGlzIGJ1dCBpdCBoYXMgdG8gYmUgaW4gYSBkZWxheSBzbyBpdCBoYXBwZW5zIGFmdGVyIHRoZSBmaXJzdCBcIm9uU2VsZWN0ZWRSb3dzQ2hhbmdlZFwiIGlzIHRyaWdnZXJlZFxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgY29uc3Qgc2hvdWxkQmVTZWxlY3RlZFJvd0luZGV4ZXMgPSB0aGlzLl9kYXRhVmlldy5tYXBJZHNUb1Jvd3ModGhpcy5fc2VsZWN0ZWRSb3dEYXRhQ29udGV4dElkcyB8fCBbXSk7XHJcbiAgICAgICAgICBjb25zdCBjdXJyZW50U2VsZWN0ZWRSb3dJbmRleGVzID0gdGhpcy5fZ3JpZC5nZXRTZWxlY3RlZFJvd3MoKTtcclxuICAgICAgICAgIGlmICghaXNlcXVhbChzaG91bGRCZVNlbGVjdGVkUm93SW5kZXhlcywgY3VycmVudFNlbGVjdGVkUm93SW5kZXhlcykpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ3JpZC5zZXRTZWxlY3RlZFJvd3Moc2hvdWxkQmVTZWxlY3RlZFJvd0luZGV4ZXMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlci5zdWJzY3JpYmUodGhpcy5fZ3JpZC5vblNlbGVjdGVkUm93c0NoYW5nZWQsIChlLCBhcmdzKSA9PiB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncy5yb3dzKSAmJiBBcnJheS5pc0FycmF5KGFyZ3MucHJldmlvdXNTZWxlY3RlZFJvd3MpKSB7XHJcbiAgICAgICAgICBjb25zdCBuZXdTZWxlY3RlZFJvd3MgPSBhcmdzLnJvd3MgYXMgbnVtYmVyW107XHJcbiAgICAgICAgICBjb25zdCBwcmV2U2VsZWN0ZWRSb3dzID0gYXJncy5wcmV2aW91c1NlbGVjdGVkUm93cyBhcyBudW1iZXJbXTtcclxuXHJcbiAgICAgICAgICBjb25zdCBuZXdTZWxlY3RlZEFkZGl0aW9ucyA9IG5ld1NlbGVjdGVkUm93cy5maWx0ZXIoKGkpID0+IHByZXZTZWxlY3RlZFJvd3MuaW5kZXhPZihpKSA8IDApO1xyXG4gICAgICAgICAgY29uc3QgbmV3U2VsZWN0ZWREZWxldGlvbnMgPSBwcmV2U2VsZWN0ZWRSb3dzLmZpbHRlcigoaSkgPT4gbmV3U2VsZWN0ZWRSb3dzLmluZGV4T2YoaSkgPCAwKTtcclxuXHJcbiAgICAgICAgICAvLyBkZWxldGlvbiBtaWdodCBoYXBwZW4gd2hlbiB1c2VyIGlzIGNoYW5naW5nIHBhZ2UsIGlmIHRoYXQgaXMgdGhlIGNhc2UgdGhlbiBza2lwIHRoZSBkZWxldGlvbiBzaW5jZSBpdCdzIG9ubHkgYSB2aXN1YWwgZGVsZXRpb24gKGN1cnJlbnQgcGFnZSlcclxuICAgICAgICAgIC8vIGlmIGl0J3Mgbm90IGEgcGFnZSBjaGFuZ2UgKHdoZW4gdGhlIGZsYWcgaXMgdHJ1ZSksIHRoZW4gcHJvY2VlZCB3aXRoIHRoZSBkZWxldGlvbiBpbiBvdXIgZ2xvYmFsIGFycmF5IG9mIHNlbGVjdGVkIElEc1xyXG4gICAgICAgICAgaWYgKHRoaXMuX3dhc1JlY2hlY2tlZEFmdGVyUGFnZUNoYW5nZSAmJiBuZXdTZWxlY3RlZERlbGV0aW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvRGVsZXRlRGF0YUlkczogQXJyYXk8bnVtYmVyIHwgc3RyaW5nPiB8IHVuZGVmaW5lZCA9IHRoaXMuX2RhdGFWaWV3Lm1hcFJvd3NUb0lkcyhuZXdTZWxlY3RlZERlbGV0aW9ucykgfHwgW107XHJcbiAgICAgICAgICAgIHRvRGVsZXRlRGF0YUlkcy5mb3JFYWNoKChyZW1vdmVJZDogbnVtYmVyIHwgc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRSb3dEYXRhQ29udGV4dElkcy5zcGxpY2UoKHRoaXMuX3NlbGVjdGVkUm93RGF0YUNvbnRleHRJZHMgYXMgQXJyYXk8bnVtYmVyIHwgc3RyaW5nPiB8IHVuZGVmaW5lZCkuaW5kZXhPZihyZW1vdmVJZCksIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBpZiB3ZSBoYXZlIG5ld2x5IGFkZGVkIHNlbGVjdGVkIHJvdyhzKSwgbGV0J3MgdXBkYXRlIG91ciBnbG9iYWwgYXJyYXkgb2Ygc2VsZWN0ZWQgSURzXHJcbiAgICAgICAgICBpZiAobmV3U2VsZWN0ZWRBZGRpdGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCB0b0FkZERhdGFJZHM6IEFycmF5PG51bWJlciB8IHN0cmluZz4gfCB1bmRlZmluZWQgPSB0aGlzLl9kYXRhVmlldy5tYXBSb3dzVG9JZHMobmV3U2VsZWN0ZWRBZGRpdGlvbnMpIHx8IFtdO1xyXG4gICAgICAgICAgICB0b0FkZERhdGFJZHMuZm9yRWFjaCgoZGF0YUlkOiBudW1iZXIgfCBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICBpZiAoKHRoaXMuX3NlbGVjdGVkUm93RGF0YUNvbnRleHRJZHMgYXMgQXJyYXk8bnVtYmVyIHwgc3RyaW5nPiB8IHVuZGVmaW5lZCkuaW5kZXhPZihkYXRhSWQpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgKHRoaXMuX3NlbGVjdGVkUm93RGF0YUNvbnRleHRJZHMgYXMgQXJyYXk8bnVtYmVyIHwgc3RyaW5nPiB8IHVuZGVmaW5lZCkucHVzaChkYXRhSWQpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gd2Ugc2V0IHRoaXMgZmxhZyB3aGljaCB3aWxsIGJlIHVzZWQgb24gdGhlIDJuZCB0aW1lIHRoZSBcIm9uU2VsZWN0ZWRSb3dzQ2hhbmdlZFwiIGV2ZW50IGlzIGNhbGxlZFxyXG4gICAgICAgICAgLy8gd2hlbiBpdCdzIHRoZSBmaXJzdCB0aW1lLCB3ZSBza2lwIGRlbGV0aW9uIGFuZCB0aGlzIGlzIHdoYXQgdGhpcyBmbGFnIGlzIGZvclxyXG4gICAgICAgICAgdGhpcy5fd2FzUmVjaGVja2VkQWZ0ZXJQYWdlQ2hhbmdlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAvLyBmb3JtIG91ciBmdWxsIHNlbGVjdGVkIHJvdyBJRHMsIGxldCdzIG1ha2Ugc3VyZSB0aGVzZSBpbmRleGVzIGFyZSBzZWxlY3RlZCBpbiB0aGUgZ3JpZCwgaWYgbm90IHRoZW4gbGV0J3MgY2FsbCBhIHJlc2VsZWN0XHJcbiAgICAgICAgICAvLyB0aGlzIGNvdWxkIGhhcHBlbiBpZiB0aGUgcHJldmlvdXMgc3RlcCB3YXMgYSBwYWdlIGNoYW5nZVxyXG4gICAgICAgICAgY29uc3Qgc2hvdWxkQmVTZWxlY3RlZFJvd0luZGV4ZXMgPSB0aGlzLl9kYXRhVmlldy5tYXBJZHNUb1Jvd3ModGhpcy5fc2VsZWN0ZWRSb3dEYXRhQ29udGV4dElkcyB8fCBbXSk7XHJcbiAgICAgICAgICBjb25zdCBjdXJyZW50U2VsZWN0ZWRSb3dJbmRleGVzID0gdGhpcy5fZ3JpZC5nZXRTZWxlY3RlZFJvd3MoKTtcclxuICAgICAgICAgIGlmICghaXNlcXVhbChzaG91bGRCZVNlbGVjdGVkUm93SW5kZXhlcywgY3VycmVudFNlbGVjdGVkUm93SW5kZXhlcykpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ3JpZC5zZXRTZWxlY3RlZFJvd3Moc2hvdWxkQmVTZWxlY3RlZFJvd0luZGV4ZXMpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkRGF0YUNvbnRleHRJZHMgPSB0aGlzLnJlZnJlc2hGaWx0ZXJlZFJvd1NlbGVjdGlvbnMoKTtcclxuICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlcyA9IHsgZ3JpZFJvd0luZGV4ZXM6IHRoaXMuX2dyaWQuZ2V0U2VsZWN0ZWRSb3dzKCksIGRhdGFDb250ZXh0SWRzOiB0aGlzLl9zZWxlY3RlZFJvd0RhdGFDb250ZXh0SWRzLCBmaWx0ZXJlZERhdGFDb250ZXh0SWRzIH0gYXMgQ3VycmVudFJvd1NlbGVjdGlvbjtcclxuICAgICAgICAgIHRoaXMub25HcmlkU3RhdGVDaGFuZ2VkLm5leHQoeyBjaGFuZ2U6IHsgbmV3VmFsdWVzLCB0eXBlOiBHcmlkU3RhdGVUeXBlLnJvd1NlbGVjdGlvbiB9LCBncmlkU3RhdGU6IHRoaXMuZ2V0Q3VycmVudEdyaWRTdGF0ZSgpIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogQ2hlY2sgd2V0aGVyIHRoZSBncmlkIGhhcyB0aGUgUm93IFNlbGVjdGlvbiBlbmFibGVkICovXHJcbiAgcHJpdmF0ZSBoYXNSb3dTZWxlY3Rpb25FbmFibGVkKCkge1xyXG4gICAgY29uc3Qgc2VsZWN0aW9uTW9kZWwgPSB0aGlzLl9ncmlkLmdldFNlbGVjdGlvbk1vZGVsKCk7XHJcbiAgICBjb25zdCBpc1Jvd1NlbGVjdGlvbkVuYWJsZWQgPSB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVSb3dTZWxlY3Rpb24gfHwgdGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlQ2hlY2tib3hTZWxlY3RvcjtcclxuICAgIHJldHVybiAoaXNSb3dTZWxlY3Rpb25FbmFibGVkICYmIHNlbGVjdGlvbk1vZGVsKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcmVFdmFsdWF0ZVJvd1NlbGVjdGlvbkFmdGVyRmlsdGVyQ2hhbmdlKCkge1xyXG4gICAgY29uc3QgY3VycmVudFNlbGVjdGVkUm93SW5kZXhlcyA9IHRoaXMuX2dyaWQuZ2V0U2VsZWN0ZWRSb3dzKCk7XHJcbiAgICBjb25zdCBwcmV2aW91c1NlbGVjdGVkRmlsdGVyZWRSb3dEYXRhQ29udGV4dElkcyA9IHRoaXMuX3NlbGVjdGVkRmlsdGVyZWRSb3dEYXRhQ29udGV4dElkcy5zbGljZSgpO1xyXG4gICAgY29uc3QgZmlsdGVyZWREYXRhQ29udGV4dElkcyA9IHRoaXMucmVmcmVzaEZpbHRlcmVkUm93U2VsZWN0aW9ucygpO1xyXG5cclxuICAgIC8vIHdoZW4gc2VsZWN0aW9uIGNoYW5nZWQsIHdlJ2xsIHNlbmQgYSBHcmlkIFN0YXRlIGV2ZW50IHdpdGggdGhlIHNlbGVjdGlvbiBjaGFuZ2VzXHJcbiAgICBpZiAoIWlzZXF1YWwodGhpcy5fc2VsZWN0ZWRGaWx0ZXJlZFJvd0RhdGFDb250ZXh0SWRzLCBwcmV2aW91c1NlbGVjdGVkRmlsdGVyZWRSb3dEYXRhQ29udGV4dElkcykpIHtcclxuICAgICAgY29uc3QgbmV3VmFsdWVzID0geyBncmlkUm93SW5kZXhlczogY3VycmVudFNlbGVjdGVkUm93SW5kZXhlcywgZGF0YUNvbnRleHRJZHM6IHRoaXMuX3NlbGVjdGVkUm93RGF0YUNvbnRleHRJZHMsIGZpbHRlcmVkRGF0YUNvbnRleHRJZHMgfSBhcyBDdXJyZW50Um93U2VsZWN0aW9uO1xyXG4gICAgICB0aGlzLm9uR3JpZFN0YXRlQ2hhbmdlZC5uZXh0KHsgY2hhbmdlOiB7IG5ld1ZhbHVlcywgdHlwZTogR3JpZFN0YXRlVHlwZS5yb3dTZWxlY3Rpb24gfSwgZ3JpZFN0YXRlOiB0aGlzLmdldEN1cnJlbnRHcmlkU3RhdGUoeyByZXF1ZXN0UmVmcmVzaFJvd0ZpbHRlcmVkUm93OiBmYWxzZSB9KSB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBXaGVuIGEgRmlsdGVyIGlzIHRyaWdnZXJlZCBvciB3aGVuIHVzZXIgcmVxdWVzdCBpdCwgd2Ugd2lsbCByZWZyZXNoIHRoZSBmaWx0ZXJlZCBzZWxlY3Rpb24gYXJyYXkgYW5kIHJldHVybiBpdCAqL1xyXG4gIHByaXZhdGUgcmVmcmVzaEZpbHRlcmVkUm93U2VsZWN0aW9ucygpOiBBcnJheTxudW1iZXIgfCBzdHJpbmc+IHwgdW5kZWZpbmVkIHtcclxuICAgIGxldCB0bXBGaWx0ZXJlZEFycmF5ID0gW107XHJcbiAgICBjb25zdCBmaWx0ZXJlZERhdGFzZXQgPSB0aGlzLl9kYXRhVmlldy5nZXRGaWx0ZXJlZEl0ZW1zKCkgfHwgW107XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLl9zZWxlY3RlZFJvd0RhdGFDb250ZXh0SWRzKSkge1xyXG4gICAgICBjb25zdCBzZWxlY3RlZEZpbHRlcmVkUm93RGF0YUNvbnRleHRJZHMgPSBbLi4udGhpcy5fc2VsZWN0ZWRSb3dEYXRhQ29udGV4dElkc107IC8vIHRha2UgYSBmcmVzaCBjb3B5IG9mIGFsbCBzZWxlY3Rpb25zIGJlZm9yZSBmaWx0ZXJpbmcgdGhlIHJvdyBpZHNcclxuICAgICAgdG1wRmlsdGVyZWRBcnJheSA9IHNlbGVjdGVkRmlsdGVyZWRSb3dEYXRhQ29udGV4dElkcy5maWx0ZXIoKHNlbGVjdGVkUm93SWQ6IG51bWJlciB8IHN0cmluZykgPT4ge1xyXG4gICAgICAgIHJldHVybiBmaWx0ZXJlZERhdGFzZXQuZmluZEluZGV4KChpdGVtOiBhbnkpID0+IGl0ZW1bdGhpcy5kYXRhc2V0SWRQcm9wTmFtZV0gPT09IHNlbGVjdGVkUm93SWQpID4gLTE7XHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLl9zZWxlY3RlZEZpbHRlcmVkUm93RGF0YUNvbnRleHRJZHMgPSB0bXBGaWx0ZXJlZEFycmF5O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRtcEZpbHRlcmVkQXJyYXk7XHJcbiAgfVxyXG59XHJcbiJdfQ==