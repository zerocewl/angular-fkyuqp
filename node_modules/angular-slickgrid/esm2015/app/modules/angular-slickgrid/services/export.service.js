import * as tslib_1 from "tslib";
import { Injectable, Optional } from '@angular/core';
import { TranslateService } from '@ngx-translate/core';
import { TextEncoder } from 'text-encoding-utf-8';
import { Subject } from 'rxjs';
import { FileType, } from './../models/index';
import { Constants } from './../constants';
import { exportWithFormatterWhenDefined } from './export-utilities';
import { addWhiteSpaces, htmlEntityDecode, sanitizeHtmlToText, titleCase } from './../services/utilities';
let ExportService = class ExportService {
    constructor(translate) {
        this.translate = translate;
        this._delimiter = ',';
        this._fileFormat = FileType.csv;
        this._lineCarriageReturn = '\n';
        this._exportQuoteWrapper = '';
        this._hasGroupedItems = false;
        this.onGridBeforeExportToFile = new Subject();
        this.onGridAfterExportToFile = new Subject();
    }
    get datasetIdName() {
        return this._gridOptions && this._gridOptions.datasetIdPropertyName || 'id';
    }
    /** Getter for the Grid Options pulled through the Grid Object */
    get _gridOptions() {
        return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
    }
    /**
     * Initialize the Export Service
     * @param grid
     * @param gridOptions
     * @param dataView
     */
    init(grid, dataView) {
        this._grid = grid;
        this._dataView = dataView;
        // get locales provided by user in forRoot or else use default English locales via the Constants
        this._locales = this._gridOptions && this._gridOptions.locales || Constants.locales;
        if (this._gridOptions.enableTranslate && (!this.translate || !this.translate.instant)) {
            throw new Error('[Angular-Slickgrid] requires "ngx-translate" to be installed and configured when the grid option "enableTranslate" is enabled.');
        }
    }
    /**
     * Function to export the Grid result to an Excel CSV format using javascript for it to produce the CSV file.
     * This is a WYSIWYG export to file output (What You See is What You Get)
     *
     * NOTES: The column position needs to match perfectly the JSON Object position because of the way we are pulling the data,
     * which means that if any column(s) got moved in the UI, it has to be reflected in the JSON array output as well
     *
     * Example: exportToFile({ format: FileType.csv, delimiter: DelimiterType.comma })
     */
    exportToFile(options) {
        if (!this._grid || !this._dataView) {
            throw new Error('[Angular-Slickgrid] it seems that the SlickGrid & DataView objects are not initialized did you forget to enable the grid option flag "enableExcelExport"?');
        }
        return new Promise((resolve, reject) => {
            this.onGridBeforeExportToFile.next(true);
            this._exportOptions = $.extend(true, {}, this._gridOptions.exportOptions, options);
            this._delimiter = this._exportOptions.delimiterOverride || this._exportOptions.delimiter || '';
            this._fileFormat = this._exportOptions.format || FileType.csv;
            // get the CSV output from the grid data
            const dataOutput = this.getDataOutput();
            // trigger a download file
            // wrap it into a setTimeout so that the EventAggregator has enough time to start a pre-process like showing a spinner
            setTimeout(() => {
                try {
                    const downloadOptions = {
                        filename: `${this._exportOptions.filename}.${this._fileFormat}`,
                        format: this._fileFormat,
                        useUtf8WithBom: this._exportOptions.hasOwnProperty('useUtf8WithBom') ? this._exportOptions.useUtf8WithBom : true
                    };
                    // start downloading but add the content property only on the start download not on the event itself
                    this.startDownloadFile(Object.assign({}, downloadOptions, { content: dataOutput })); // add content property
                    this.onGridAfterExportToFile.next(downloadOptions);
                    resolve(true);
                }
                catch (error) {
                    reject(error);
                }
            }, 0);
        });
    }
    /**
     * Triggers download file with file format.
     * IE(6-10) are not supported
     * All other browsers will use plain javascript on client side to produce a file download.
     * @param options
     */
    startDownloadFile(options) {
        // IE(6-10) don't support javascript download and our service doesn't support either so throw an error, we have to make a round trip to the Web Server for exporting
        if (navigator.appName === 'Microsoft Internet Explorer') {
            throw new Error('Microsoft Internet Explorer 6 to 10 do not support javascript export to CSV. Please upgrade your browser.');
        }
        // set the correct MIME type
        const mimeType = (options.format === FileType.csv) ? 'text/csv' : 'text/plain';
        // make sure no html entities exist in the data
        const dataContent = htmlEntityDecode(options.content);
        // dealing with Excel CSV export and UTF-8 is a little tricky.. We will use Option #2 to cover older Excel versions
        // Option #1: we need to make Excel knowing that it's dealing with an UTF-8, A correctly formatted UTF8 file can have a Byte Order Mark as its first three octets
        // reference: http://stackoverflow.com/questions/155097/microsoft-excel-mangles-diacritics-in-csv-files
        // Option#2: use a 3rd party extension to javascript encode into UTF-16
        let outputData;
        if (options.format === FileType.csv) {
            outputData = new TextEncoder('utf-8').encode(dataContent);
        }
        else {
            outputData = dataContent;
        }
        // create a Blob object for the download
        const blob = new Blob([options.useUtf8WithBom ? '\uFEFF' : '', outputData], {
            type: `${mimeType};charset=utf-8;`
        });
        // when using IE/Edge, then use different download call
        if (typeof navigator.msSaveOrOpenBlob === 'function') {
            navigator.msSaveOrOpenBlob(blob, options.filename);
        }
        else {
            // this trick will generate a temp <a /> tag
            // the code will then trigger a hidden click for it to start downloading
            const link = document.createElement('a');
            const csvUrl = URL.createObjectURL(blob);
            link.textContent = 'download';
            link.href = csvUrl;
            link.setAttribute('download', options.filename);
            // set the visibility to hidden so there is no effect on your web-layout
            link.style.visibility = 'hidden';
            // this part will append the anchor tag, trigger a click (for download to start) and finally remove the tag once completed
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    }
    // -----------------------
    // Private functions
    // -----------------------
    getDataOutput() {
        const columns = this._grid.getColumns() || [];
        // Group By text, it could be set in the export options or from translation or if nothing is found then use the English constant text
        let groupByColumnHeader = this._exportOptions.groupingColumnHeaderTitle;
        if (!groupByColumnHeader && this._gridOptions.enableTranslate && this.translate && this.translate.currentLang && this.translate.instant) {
            groupByColumnHeader = this.translate.instant('GROUP_BY');
        }
        else if (!groupByColumnHeader) {
            groupByColumnHeader = this._locales && this._locales.TEXT_GROUP_BY;
        }
        // a CSV needs double quotes wrapper, the other types do not need any wrapper
        this._exportQuoteWrapper = (this._fileFormat === FileType.csv) ? '"' : '';
        // data variable which will hold all the fields data of a row
        let outputDataString = '';
        // get grouped column titles and if found, we will add a "Group by" column at the first column index
        // if it's a CSV format, we'll escape the text in double quotes
        const grouping = this._dataView.getGrouping();
        if (grouping && Array.isArray(grouping) && grouping.length > 0) {
            this._hasGroupedItems = true;
            outputDataString += (this._fileFormat === FileType.csv) ? `"${groupByColumnHeader}"${this._delimiter}` : `${groupByColumnHeader}${this._delimiter}`;
        }
        else {
            this._hasGroupedItems = false;
        }
        // get all column headers
        this._columnHeaders = this.getColumnHeaders(columns) || [];
        if (this._columnHeaders && Array.isArray(this._columnHeaders) && this._columnHeaders.length > 0) {
            // add the header row + add a new line at the end of the row
            const outputHeaderTitles = this._columnHeaders.map((header) => {
                return this._exportQuoteWrapper + header.title + this._exportQuoteWrapper;
            });
            outputDataString += (outputHeaderTitles.join(this._delimiter) + this._lineCarriageReturn);
        }
        // Populate the rest of the Grid Data
        outputDataString += this.getAllGridRowData(columns, this._lineCarriageReturn);
        return outputDataString;
    }
    /**
     * Get all the grid row data and return that as an output string
     */
    getAllGridRowData(columns, lineCarriageReturn) {
        const outputDataStrings = [];
        const lineCount = this._dataView.getLength();
        // loop through all the grid rows of data
        for (let rowNumber = 0; rowNumber < lineCount; rowNumber++) {
            const itemObj = this._dataView.getItem(rowNumber);
            if (itemObj != null) {
                // Normal row (not grouped by anything) would have an ID which was predefined in the Grid Columns definition
                if (itemObj[this.datasetIdName] != null) {
                    // get regular row item data
                    outputDataStrings.push(this.readRegularRowData(columns, rowNumber, itemObj));
                }
                else if (this._hasGroupedItems && itemObj.__groupTotals === undefined) {
                    // get the group row
                    outputDataStrings.push(this.readGroupedTitleRow(itemObj));
                }
                else if (itemObj.__groupTotals) {
                    // else if the row is a Group By and we have agreggators, then a property of '__groupTotals' would exist under that object
                    outputDataStrings.push(this.readGroupedTotalRow(columns, itemObj));
                }
            }
        }
        return outputDataStrings.join(lineCarriageReturn);
    }
    /**
     * Get all header titles and their keys, translate the title when required.
     * @param columns of the grid
     */
    getColumnHeaders(columns) {
        if (!columns || !Array.isArray(columns) || columns.length === 0) {
            return null;
        }
        const columnHeaders = [];
        // Populate the Column Header, pull the name defined
        columns.forEach((columnDef) => {
            let headerTitle = '';
            if ((columnDef.headerKey || columnDef.nameKey) && this._gridOptions.enableTranslate && this.translate && this.translate.currentLang && this.translate.instant) {
                headerTitle = this.translate.instant((columnDef.headerKey || columnDef.nameKey));
            }
            else {
                headerTitle = columnDef.name || titleCase(columnDef.field);
            }
            const skippedField = columnDef.excludeFromExport || false;
            // if column width is 0, then we consider that field as a hidden field and should not be part of the export
            if ((columnDef.width === undefined || columnDef.width > 0) && !skippedField) {
                columnHeaders.push({
                    key: columnDef.field || columnDef.id,
                    title: headerTitle
                });
            }
        });
        return columnHeaders;
    }
    /**
     * Get the data of a regular row (a row without grouping)
     * @param row
     * @param itemObj
     */
    readRegularRowData(columns, row, itemObj) {
        let idx = 0;
        const rowOutputStrings = [];
        const exportQuoteWrapper = this._exportQuoteWrapper;
        for (let col = 0, ln = columns.length; col < ln; col++) {
            const columnDef = columns[col];
            // skip excluded column
            if (columnDef.excludeFromExport) {
                continue;
            }
            // if we are grouping and are on 1st column index, we need to skip this column since it will be used later by the grouping text:: Group by [columnX]
            if (this._hasGroupedItems && idx === 0) {
                const emptyValue = this._fileFormat === FileType.csv ? `""` : '';
                rowOutputStrings.push(emptyValue);
            }
            // get the output by analyzing if we'll pull the value from the cell or from a formatter
            let itemData = exportWithFormatterWhenDefined(row, col, itemObj, columnDef, this._grid, this._exportOptions);
            // does the user want to sanitize the output data (remove HTML tags)?
            if (columnDef.sanitizeDataExport || this._exportOptions.sanitizeDataExport) {
                itemData = sanitizeHtmlToText(itemData);
            }
            // when CSV we also need to escape double quotes twice, so " becomes ""
            if (this._fileFormat === FileType.csv && itemData) {
                itemData = itemData.toString().replace(/"/gi, `""`);
            }
            // do we have a wrapper to keep as a string? in certain cases like "1E06", we don't want excel to transform it into exponential (1.0E06)
            // to cancel that effect we can had = in front, ex: ="1E06"
            const keepAsStringWrapper = (columnDef && columnDef.exportCsvForceToKeepAsString) ? '=' : '';
            rowOutputStrings.push(keepAsStringWrapper + exportQuoteWrapper + itemData + exportQuoteWrapper);
            idx++;
        }
        return rowOutputStrings.join(this._delimiter);
    }
    /**
     * Get the grouped title(s) and its group title formatter, for example if we grouped by salesRep, the returned result would be:: 'Sales Rep: John Dow (2 items)'
     * @param itemObj
     */
    readGroupedTitleRow(itemObj) {
        let groupName = sanitizeHtmlToText(itemObj.title);
        const exportQuoteWrapper = this._exportQuoteWrapper;
        groupName = addWhiteSpaces(5 * itemObj.level) + groupName;
        if (this._fileFormat === FileType.csv) {
            // when CSV we also need to escape double quotes twice, so " becomes ""
            groupName = groupName.toString().replace(/"/gi, `""`);
        }
        return exportQuoteWrapper + groupName + exportQuoteWrapper;
    }
    /**
     * Get the grouped totals (below the regular rows), these are set by Slick Aggregators.
     * For example if we grouped by "salesRep" and we have a Sum Aggregator on "sales", then the returned output would be:: ["Sum 123$"]
     * @param itemObj
     */
    readGroupedTotalRow(columns, itemObj) {
        const delimiter = this._exportOptions.delimiter;
        const format = this._exportOptions.format;
        const groupingAggregatorRowText = this._exportOptions.groupingAggregatorRowText || '';
        const exportQuoteWrapper = this._exportQuoteWrapper;
        const outputStrings = [`${exportQuoteWrapper}${groupingAggregatorRowText}${exportQuoteWrapper}`];
        columns.forEach((columnDef) => {
            let itemData = '';
            const skippedField = columnDef.excludeFromExport || false;
            // if there's a groupTotalsFormatter, we will re-run it to get the exact same output as what is shown in UI
            if (columnDef.groupTotalsFormatter) {
                itemData = columnDef.groupTotalsFormatter(itemObj, columnDef);
            }
            // does the user want to sanitize the output data (remove HTML tags)?
            if (columnDef.sanitizeDataExport || this._exportOptions.sanitizeDataExport) {
                itemData = sanitizeHtmlToText(itemData);
            }
            if (format === FileType.csv) {
                // when CSV we also need to escape double quotes twice, so a double quote " becomes 2x double quotes ""
                itemData = itemData.toString().replace(/"/gi, `""`);
            }
            // add the column (unless user wants to skip it)
            if ((columnDef.width === undefined || columnDef.width > 0) && !skippedField) {
                outputStrings.push(exportQuoteWrapper + itemData + exportQuoteWrapper);
            }
        });
        return outputStrings.join(delimiter);
    }
};
ExportService = tslib_1.__decorate([
    Injectable(),
    tslib_1.__param(0, Optional()),
    tslib_1.__metadata("design:paramtypes", [TranslateService])
], ExportService);
export { ExportService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwb3J0LnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyLXNsaWNrZ3JpZC8iLCJzb3VyY2VzIjpbImFwcC9tb2R1bGVzL2FuZ3VsYXItc2xpY2tncmlkL3NlcnZpY2VzL2V4cG9ydC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNyRCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN2RCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDbEQsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUUvQixPQUFPLEVBR0wsUUFBUSxHQUlULE1BQU0sbUJBQW1CLENBQUM7QUFDM0IsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzNDLE9BQU8sRUFBRSw4QkFBOEIsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ3BFLE9BQU8sRUFBRSxjQUFjLEVBQUUsZ0JBQWdCLEVBQUUsa0JBQWtCLEVBQUUsU0FBUyxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFNMUcsSUFBYSxhQUFhLEdBQTFCLE1BQWEsYUFBYTtJQWV4QixZQUFnQyxTQUEyQjtRQUEzQixjQUFTLEdBQVQsU0FBUyxDQUFrQjtRQWRuRCxlQUFVLEdBQUcsR0FBRyxDQUFDO1FBQ2pCLGdCQUFXLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQztRQUMzQix3QkFBbUIsR0FBRyxJQUFJLENBQUM7UUFJM0Isd0JBQW1CLEdBQUcsRUFBRSxDQUFDO1FBR3pCLHFCQUFnQixHQUFHLEtBQUssQ0FBQztRQUVqQyw2QkFBd0IsR0FBRyxJQUFJLE9BQU8sRUFBVyxDQUFDO1FBQ2xELDRCQUF1QixHQUFHLElBQUksT0FBTyxFQUFvRixDQUFDO0lBRTNELENBQUM7SUFFaEUsSUFBWSxhQUFhO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLHFCQUFxQixJQUFJLElBQUksQ0FBQztJQUM5RSxDQUFDO0lBRUQsaUVBQWlFO0lBQ2pFLElBQVksWUFBWTtRQUN0QixPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFDOUUsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsSUFBSSxDQUFDLElBQVMsRUFBRSxRQUFhO1FBQzNCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLElBQUksQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDO1FBRTFCLGdHQUFnRztRQUNoRyxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLElBQUksU0FBUyxDQUFDLE9BQU8sQ0FBQztRQUVwRixJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsZUFBZSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUNyRixNQUFNLElBQUksS0FBSyxDQUFDLGdJQUFnSSxDQUFDLENBQUM7U0FDbko7SUFDSCxDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSCxZQUFZLENBQUMsT0FBcUI7UUFDaEMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQ2xDLE1BQU0sSUFBSSxLQUFLLENBQUMsMkpBQTJKLENBQUMsQ0FBQztTQUM5SztRQUVELE9BQU8sSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLEVBQUU7WUFDckMsSUFBSSxDQUFDLHdCQUF3QixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUN6QyxJQUFJLENBQUMsY0FBYyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLEVBQUUsRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsQ0FBQztZQUNuRixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsaUJBQWlCLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxTQUFTLElBQUksRUFBRSxDQUFDO1lBQy9GLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLElBQUksUUFBUSxDQUFDLEdBQUcsQ0FBQztZQUU5RCx3Q0FBd0M7WUFDeEMsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1lBRXhDLDBCQUEwQjtZQUMxQixzSEFBc0g7WUFDdEgsVUFBVSxDQUFDLEdBQUcsRUFBRTtnQkFDZCxJQUFJO29CQUNGLE1BQU0sZUFBZSxHQUFHO3dCQUN0QixRQUFRLEVBQUUsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFO3dCQUMvRCxNQUFNLEVBQUUsSUFBSSxDQUFDLFdBQVc7d0JBQ3hCLGNBQWMsRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsSUFBSTtxQkFDakgsQ0FBQztvQkFFRixvR0FBb0c7b0JBQ3BHLElBQUksQ0FBQyxpQkFBaUIsbUJBQU0sZUFBZSxJQUFFLE9BQU8sRUFBRSxVQUFVLElBQUcsQ0FBQyxDQUFDLHVCQUF1QjtvQkFDNUYsSUFBSSxDQUFDLHVCQUF1QixDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztvQkFDbkQsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUNmO2dCQUFDLE9BQU8sS0FBSyxFQUFFO29CQUNkLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztpQkFDZjtZQUNILENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNSLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsaUJBQWlCLENBQUMsT0FBa0c7UUFDbEgsb0tBQW9LO1FBQ3BLLElBQUksU0FBUyxDQUFDLE9BQU8sS0FBSyw2QkFBNkIsRUFBRTtZQUN2RCxNQUFNLElBQUksS0FBSyxDQUFDLDJHQUEyRyxDQUFDLENBQUM7U0FDOUg7UUFFRCw0QkFBNEI7UUFDNUIsTUFBTSxRQUFRLEdBQUcsQ0FBQyxPQUFPLENBQUMsTUFBTSxLQUFLLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUM7UUFFL0UsK0NBQStDO1FBQy9DLE1BQU0sV0FBVyxHQUFHLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUV0RCxtSEFBbUg7UUFDbkgsaUtBQWlLO1FBQ2pLLHVHQUF1RztRQUN2Ryx1RUFBdUU7UUFDdkUsSUFBSSxVQUErQixDQUFDO1FBQ3BDLElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxRQUFRLENBQUMsR0FBRyxFQUFFO1lBQ25DLFVBQVUsR0FBRyxJQUFJLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7U0FDM0Q7YUFBTTtZQUNMLFVBQVUsR0FBRyxXQUFXLENBQUM7U0FDMUI7UUFFRCx3Q0FBd0M7UUFDeEMsTUFBTSxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxVQUFVLENBQUMsRUFBRTtZQUMxRSxJQUFJLEVBQUUsR0FBRyxRQUFRLGlCQUFpQjtTQUNuQyxDQUFDLENBQUM7UUFFSCx1REFBdUQ7UUFDdkQsSUFBSSxPQUFPLFNBQVMsQ0FBQyxnQkFBZ0IsS0FBSyxVQUFVLEVBQUU7WUFDcEQsU0FBUyxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDcEQ7YUFBTTtZQUNMLDRDQUE0QztZQUM1Qyx3RUFBd0U7WUFDeEUsTUFBTSxJQUFJLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUN6QyxNQUFNLE1BQU0sR0FBRyxHQUFHLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRXpDLElBQUksQ0FBQyxXQUFXLEdBQUcsVUFBVSxDQUFDO1lBQzlCLElBQUksQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDO1lBQ25CLElBQUksQ0FBQyxZQUFZLENBQUMsVUFBVSxFQUFFLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUVoRCx3RUFBd0U7WUFDeEUsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEdBQUcsUUFBUSxDQUFDO1lBRWpDLDBIQUEwSDtZQUMxSCxRQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNoQyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDYixRQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNqQztJQUNILENBQUM7SUFFRCwwQkFBMEI7SUFDMUIsb0JBQW9CO0lBQ3BCLDBCQUEwQjtJQUVsQixhQUFhO1FBQ25CLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFLElBQUksRUFBRSxDQUFDO1FBRTlDLHFJQUFxSTtRQUNySSxJQUFJLG1CQUFtQixHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMseUJBQXlCLENBQUM7UUFDeEUsSUFBSSxDQUFDLG1CQUFtQixJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsZUFBZSxJQUFJLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUU7WUFDdkksbUJBQW1CLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDMUQ7YUFBTSxJQUFJLENBQUMsbUJBQW1CLEVBQUU7WUFDL0IsbUJBQW1CLEdBQUcsSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQztTQUNwRTtRQUVELDZFQUE2RTtRQUM3RSxJQUFJLENBQUMsbUJBQW1CLEdBQUcsQ0FBQyxJQUFJLENBQUMsV0FBVyxLQUFLLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFFMUUsNkRBQTZEO1FBQzdELElBQUksZ0JBQWdCLEdBQUcsRUFBRSxDQUFDO1FBRTFCLG9HQUFvRztRQUNwRywrREFBK0Q7UUFDL0QsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUM5QyxJQUFJLFFBQVEsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQzlELElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7WUFDN0IsZ0JBQWdCLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxLQUFLLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxtQkFBbUIsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsbUJBQW1CLEdBQUcsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1NBQ3JKO2FBQU07WUFDTCxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDO1NBQy9CO1FBRUQseUJBQXlCO1FBQ3pCLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUMzRCxJQUFJLElBQUksQ0FBQyxjQUFjLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQy9GLDREQUE0RDtZQUM1RCxNQUFNLGtCQUFrQixHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUU7Z0JBQzVELE9BQU8sSUFBSSxDQUFDLG1CQUFtQixHQUFHLE1BQU0sQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDO1lBQzVFLENBQUMsQ0FBQyxDQUFDO1lBQ0gsZ0JBQWdCLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1NBQzNGO1FBRUQscUNBQXFDO1FBQ3JDLGdCQUFnQixJQUFJLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUM7UUFFOUUsT0FBTyxnQkFBZ0IsQ0FBQztJQUMxQixDQUFDO0lBRUQ7O09BRUc7SUFDSyxpQkFBaUIsQ0FBQyxPQUFpQixFQUFFLGtCQUEwQjtRQUNyRSxNQUFNLGlCQUFpQixHQUFHLEVBQUUsQ0FBQztRQUM3QixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBRTdDLHlDQUF5QztRQUN6QyxLQUFLLElBQUksU0FBUyxHQUFHLENBQUMsRUFBRSxTQUFTLEdBQUcsU0FBUyxFQUFFLFNBQVMsRUFBRSxFQUFFO1lBQzFELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ2xELElBQUksT0FBTyxJQUFJLElBQUksRUFBRTtnQkFDbkIsNEdBQTRHO2dCQUM1RyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksSUFBSSxFQUFFO29CQUN2Qyw0QkFBNEI7b0JBQzVCLGlCQUFpQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO2lCQUM5RTtxQkFBTSxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsSUFBSSxPQUFPLENBQUMsYUFBYSxLQUFLLFNBQVMsRUFBRTtvQkFDdkUsb0JBQW9CO29CQUNwQixpQkFBaUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7aUJBQzNEO3FCQUFNLElBQUksT0FBTyxDQUFDLGFBQWEsRUFBRTtvQkFDaEMsMEhBQTBIO29CQUMxSCxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO2lCQUNwRTthQUNGO1NBQ0Y7UUFFRCxPQUFPLGlCQUFpQixDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0lBQ3BELENBQUM7SUFFRDs7O09BR0c7SUFDSyxnQkFBZ0IsQ0FBQyxPQUFpQjtRQUN4QyxJQUFJLENBQUMsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxPQUFPLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUMvRCxPQUFPLElBQUksQ0FBQztTQUNiO1FBQ0QsTUFBTSxhQUFhLEdBQUcsRUFBRSxDQUFDO1FBRXpCLG9EQUFvRDtRQUNwRCxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsU0FBUyxFQUFFLEVBQUU7WUFDNUIsSUFBSSxXQUFXLEdBQUcsRUFBRSxDQUFDO1lBQ3JCLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxJQUFJLFNBQVMsQ0FBQyxPQUFPLENBQUMsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLGVBQWUsSUFBSSxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFO2dCQUM3SixXQUFXLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxTQUFTLENBQUMsU0FBUyxJQUFJLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO2FBQ2xGO2lCQUFNO2dCQUNMLFdBQVcsR0FBRyxTQUFTLENBQUMsSUFBSSxJQUFJLFNBQVMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDNUQ7WUFDRCxNQUFNLFlBQVksR0FBRyxTQUFTLENBQUMsaUJBQWlCLElBQUksS0FBSyxDQUFDO1lBRTFELDJHQUEyRztZQUMzRyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssS0FBSyxTQUFTLElBQUksU0FBUyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRTtnQkFDM0UsYUFBYSxDQUFDLElBQUksQ0FBQztvQkFDakIsR0FBRyxFQUFFLFNBQVMsQ0FBQyxLQUFLLElBQUksU0FBUyxDQUFDLEVBQUU7b0JBQ3BDLEtBQUssRUFBRSxXQUFXO2lCQUNuQixDQUFDLENBQUM7YUFDSjtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxhQUFhLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSyxrQkFBa0IsQ0FBQyxPQUFpQixFQUFFLEdBQVcsRUFBRSxPQUFZO1FBQ3JFLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQztRQUNaLE1BQU0sZ0JBQWdCLEdBQUcsRUFBRSxDQUFDO1FBQzVCLE1BQU0sa0JBQWtCLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDO1FBRXBELEtBQUssSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLEdBQUcsR0FBRyxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUU7WUFDdEQsTUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBRS9CLHVCQUF1QjtZQUN2QixJQUFJLFNBQVMsQ0FBQyxpQkFBaUIsRUFBRTtnQkFDL0IsU0FBUzthQUNWO1lBRUQsb0pBQW9KO1lBQ3BKLElBQUksSUFBSSxDQUFDLGdCQUFnQixJQUFJLEdBQUcsS0FBSyxDQUFDLEVBQUU7Z0JBQ3RDLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxXQUFXLEtBQUssUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7Z0JBQ2pFLGdCQUFnQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQzthQUNuQztZQUVELHdGQUF3RjtZQUN4RixJQUFJLFFBQVEsR0FBRyw4QkFBOEIsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7WUFFN0cscUVBQXFFO1lBQ3JFLElBQUksU0FBUyxDQUFDLGtCQUFrQixJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsa0JBQWtCLEVBQUU7Z0JBQzFFLFFBQVEsR0FBRyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUN6QztZQUVELHVFQUF1RTtZQUN2RSxJQUFJLElBQUksQ0FBQyxXQUFXLEtBQUssUUFBUSxDQUFDLEdBQUcsSUFBSSxRQUFRLEVBQUU7Z0JBQ2pELFFBQVEsR0FBRyxRQUFRLENBQUMsUUFBUSxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQzthQUNyRDtZQUVELHdJQUF3STtZQUN4SSwyREFBMkQ7WUFDM0QsTUFBTSxtQkFBbUIsR0FBRyxDQUFDLFNBQVMsSUFBSSxTQUFTLENBQUMsNEJBQTRCLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFFN0YsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLG1CQUFtQixHQUFHLGtCQUFrQixHQUFHLFFBQVEsR0FBRyxrQkFBa0IsQ0FBQyxDQUFDO1lBQ2hHLEdBQUcsRUFBRSxDQUFDO1NBQ1A7UUFFRCxPQUFPLGdCQUFnQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVEOzs7T0FHRztJQUNLLG1CQUFtQixDQUFDLE9BQVk7UUFDdEMsSUFBSSxTQUFTLEdBQUcsa0JBQWtCLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2xELE1BQU0sa0JBQWtCLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDO1FBRXBELFNBQVMsR0FBRyxjQUFjLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxTQUFTLENBQUM7UUFFMUQsSUFBSSxJQUFJLENBQUMsV0FBVyxLQUFLLFFBQVEsQ0FBQyxHQUFHLEVBQUU7WUFDckMsdUVBQXVFO1lBQ3ZFLFNBQVMsR0FBRyxTQUFTLENBQUMsUUFBUSxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztTQUN2RDtRQUNELE9BQU8sa0JBQWtCLEdBQUcsU0FBUyxHQUFHLGtCQUFrQixDQUFDO0lBQzdELENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssbUJBQW1CLENBQUMsT0FBaUIsRUFBRSxPQUFZO1FBQ3pELE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDO1FBQ2hELE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDO1FBQzFDLE1BQU0seUJBQXlCLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyx5QkFBeUIsSUFBSSxFQUFFLENBQUM7UUFDdEYsTUFBTSxrQkFBa0IsR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUM7UUFDcEQsTUFBTSxhQUFhLEdBQUcsQ0FBQyxHQUFHLGtCQUFrQixHQUFHLHlCQUF5QixHQUFHLGtCQUFrQixFQUFFLENBQUMsQ0FBQztRQUVqRyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsU0FBUyxFQUFFLEVBQUU7WUFDNUIsSUFBSSxRQUFRLEdBQUcsRUFBRSxDQUFDO1lBRWxCLE1BQU0sWUFBWSxHQUFHLFNBQVMsQ0FBQyxpQkFBaUIsSUFBSSxLQUFLLENBQUM7WUFFMUQsMkdBQTJHO1lBQzNHLElBQUksU0FBUyxDQUFDLG9CQUFvQixFQUFFO2dCQUNsQyxRQUFRLEdBQUcsU0FBUyxDQUFDLG9CQUFvQixDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQzthQUMvRDtZQUVELHFFQUFxRTtZQUNyRSxJQUFJLFNBQVMsQ0FBQyxrQkFBa0IsSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLGtCQUFrQixFQUFFO2dCQUMxRSxRQUFRLEdBQUcsa0JBQWtCLENBQUMsUUFBUSxDQUFDLENBQUM7YUFDekM7WUFFRCxJQUFJLE1BQU0sS0FBSyxRQUFRLENBQUMsR0FBRyxFQUFFO2dCQUMzQix1R0FBdUc7Z0JBQ3ZHLFFBQVEsR0FBRyxRQUFRLENBQUMsUUFBUSxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQzthQUNyRDtZQUVELGdEQUFnRDtZQUNoRCxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssS0FBSyxTQUFTLElBQUksU0FBUyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRTtnQkFDM0UsYUFBYSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxRQUFRLEdBQUcsa0JBQWtCLENBQUMsQ0FBQzthQUN4RTtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxhQUFhLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3ZDLENBQUM7Q0FDRixDQUFBO0FBcldZLGFBQWE7SUFEekIsVUFBVSxFQUFFO0lBZ0JFLG1CQUFBLFFBQVEsRUFBRSxDQUFBOzZDQUFvQixnQkFBZ0I7R0FmaEQsYUFBYSxDQXFXekI7U0FyV1ksYUFBYSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFRyYW5zbGF0ZVNlcnZpY2UgfSBmcm9tICdAbmd4LXRyYW5zbGF0ZS9jb3JlJztcclxuaW1wb3J0IHsgVGV4dEVuY29kZXIgfSBmcm9tICd0ZXh0LWVuY29kaW5nLXV0Zi04JztcclxuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xyXG5cclxuaW1wb3J0IHtcclxuICBDb2x1bW4sXHJcbiAgRXhwb3J0T3B0aW9uLFxyXG4gIEZpbGVUeXBlLFxyXG4gIEdyaWRPcHRpb24sXHJcbiAgS2V5VGl0bGVQYWlyLFxyXG4gIExvY2FsZSxcclxufSBmcm9tICcuLy4uL21vZGVscy9pbmRleCc7XHJcbmltcG9ydCB7IENvbnN0YW50cyB9IGZyb20gJy4vLi4vY29uc3RhbnRzJztcclxuaW1wb3J0IHsgZXhwb3J0V2l0aEZvcm1hdHRlcldoZW5EZWZpbmVkIH0gZnJvbSAnLi9leHBvcnQtdXRpbGl0aWVzJztcclxuaW1wb3J0IHsgYWRkV2hpdGVTcGFjZXMsIGh0bWxFbnRpdHlEZWNvZGUsIHNhbml0aXplSHRtbFRvVGV4dCwgdGl0bGVDYXNlIH0gZnJvbSAnLi8uLi9zZXJ2aWNlcy91dGlsaXRpZXMnO1xyXG5cclxuLy8gdXNpbmcgZXh0ZXJuYWwgbm9uLXR5cGVkIGpzIGxpYnJhcmllc1xyXG5kZWNsYXJlIGxldCAkOiBhbnk7XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBFeHBvcnRTZXJ2aWNlIHtcclxuICBwcml2YXRlIF9kZWxpbWl0ZXIgPSAnLCc7XHJcbiAgcHJpdmF0ZSBfZmlsZUZvcm1hdCA9IEZpbGVUeXBlLmNzdjtcclxuICBwcml2YXRlIF9saW5lQ2FycmlhZ2VSZXR1cm4gPSAnXFxuJztcclxuICBwcml2YXRlIF9kYXRhVmlldzogYW55O1xyXG4gIHByaXZhdGUgX2dyaWQ6IGFueTtcclxuICBwcml2YXRlIF9sb2NhbGVzOiBMb2NhbGU7XHJcbiAgcHJpdmF0ZSBfZXhwb3J0UXVvdGVXcmFwcGVyID0gJyc7XHJcbiAgcHJpdmF0ZSBfY29sdW1uSGVhZGVyczogS2V5VGl0bGVQYWlyW107XHJcbiAgcHJpdmF0ZSBfZ3JvdXBlZEhlYWRlcnM6IEtleVRpdGxlUGFpcltdO1xyXG4gIHByaXZhdGUgX2hhc0dyb3VwZWRJdGVtcyA9IGZhbHNlO1xyXG4gIHByaXZhdGUgX2V4cG9ydE9wdGlvbnM6IEV4cG9ydE9wdGlvbjtcclxuICBvbkdyaWRCZWZvcmVFeHBvcnRUb0ZpbGUgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xyXG4gIG9uR3JpZEFmdGVyRXhwb3J0VG9GaWxlID0gbmV3IFN1YmplY3Q8eyBjb250ZW50Pzogc3RyaW5nOyBmaWxlbmFtZTogc3RyaW5nOyBmb3JtYXQ6IHN0cmluZzsgdXNlVXRmOFdpdGhCb206IGJvb2xlYW47IH0+KCk7XHJcblxyXG4gIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIHByaXZhdGUgdHJhbnNsYXRlOiBUcmFuc2xhdGVTZXJ2aWNlKSB7IH1cclxuXHJcbiAgcHJpdmF0ZSBnZXQgZGF0YXNldElkTmFtZSgpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLmRhdGFzZXRJZFByb3BlcnR5TmFtZSB8fCAnaWQnO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBmb3IgdGhlIEdyaWQgT3B0aW9ucyBwdWxsZWQgdGhyb3VnaCB0aGUgR3JpZCBPYmplY3QgKi9cclxuICBwcml2YXRlIGdldCBfZ3JpZE9wdGlvbnMoKTogR3JpZE9wdGlvbiB7XHJcbiAgICByZXR1cm4gKHRoaXMuX2dyaWQgJiYgdGhpcy5fZ3JpZC5nZXRPcHRpb25zKSA/IHRoaXMuX2dyaWQuZ2V0T3B0aW9ucygpIDoge307XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbml0aWFsaXplIHRoZSBFeHBvcnQgU2VydmljZVxyXG4gICAqIEBwYXJhbSBncmlkXHJcbiAgICogQHBhcmFtIGdyaWRPcHRpb25zXHJcbiAgICogQHBhcmFtIGRhdGFWaWV3XHJcbiAgICovXHJcbiAgaW5pdChncmlkOiBhbnksIGRhdGFWaWV3OiBhbnkpOiB2b2lkIHtcclxuICAgIHRoaXMuX2dyaWQgPSBncmlkO1xyXG4gICAgdGhpcy5fZGF0YVZpZXcgPSBkYXRhVmlldztcclxuXHJcbiAgICAvLyBnZXQgbG9jYWxlcyBwcm92aWRlZCBieSB1c2VyIGluIGZvclJvb3Qgb3IgZWxzZSB1c2UgZGVmYXVsdCBFbmdsaXNoIGxvY2FsZXMgdmlhIHRoZSBDb25zdGFudHNcclxuICAgIHRoaXMuX2xvY2FsZXMgPSB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5sb2NhbGVzIHx8IENvbnN0YW50cy5sb2NhbGVzO1xyXG5cclxuICAgIGlmICh0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVUcmFuc2xhdGUgJiYgKCF0aGlzLnRyYW5zbGF0ZSB8fCAhdGhpcy50cmFuc2xhdGUuaW5zdGFudCkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbQW5ndWxhci1TbGlja2dyaWRdIHJlcXVpcmVzIFwibmd4LXRyYW5zbGF0ZVwiIHRvIGJlIGluc3RhbGxlZCBhbmQgY29uZmlndXJlZCB3aGVuIHRoZSBncmlkIG9wdGlvbiBcImVuYWJsZVRyYW5zbGF0ZVwiIGlzIGVuYWJsZWQuJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGdW5jdGlvbiB0byBleHBvcnQgdGhlIEdyaWQgcmVzdWx0IHRvIGFuIEV4Y2VsIENTViBmb3JtYXQgdXNpbmcgamF2YXNjcmlwdCBmb3IgaXQgdG8gcHJvZHVjZSB0aGUgQ1NWIGZpbGUuXHJcbiAgICogVGhpcyBpcyBhIFdZU0lXWUcgZXhwb3J0IHRvIGZpbGUgb3V0cHV0IChXaGF0IFlvdSBTZWUgaXMgV2hhdCBZb3UgR2V0KVxyXG4gICAqXHJcbiAgICogTk9URVM6IFRoZSBjb2x1bW4gcG9zaXRpb24gbmVlZHMgdG8gbWF0Y2ggcGVyZmVjdGx5IHRoZSBKU09OIE9iamVjdCBwb3NpdGlvbiBiZWNhdXNlIG9mIHRoZSB3YXkgd2UgYXJlIHB1bGxpbmcgdGhlIGRhdGEsXHJcbiAgICogd2hpY2ggbWVhbnMgdGhhdCBpZiBhbnkgY29sdW1uKHMpIGdvdCBtb3ZlZCBpbiB0aGUgVUksIGl0IGhhcyB0byBiZSByZWZsZWN0ZWQgaW4gdGhlIEpTT04gYXJyYXkgb3V0cHV0IGFzIHdlbGxcclxuICAgKlxyXG4gICAqIEV4YW1wbGU6IGV4cG9ydFRvRmlsZSh7IGZvcm1hdDogRmlsZVR5cGUuY3N2LCBkZWxpbWl0ZXI6IERlbGltaXRlclR5cGUuY29tbWEgfSlcclxuICAgKi9cclxuICBleHBvcnRUb0ZpbGUob3B0aW9uczogRXhwb3J0T3B0aW9uKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICBpZiAoIXRoaXMuX2dyaWQgfHwgIXRoaXMuX2RhdGFWaWV3KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignW0FuZ3VsYXItU2xpY2tncmlkXSBpdCBzZWVtcyB0aGF0IHRoZSBTbGlja0dyaWQgJiBEYXRhVmlldyBvYmplY3RzIGFyZSBub3QgaW5pdGlhbGl6ZWQgZGlkIHlvdSBmb3JnZXQgdG8gZW5hYmxlIHRoZSBncmlkIG9wdGlvbiBmbGFnIFwiZW5hYmxlRXhjZWxFeHBvcnRcIj8nKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICB0aGlzLm9uR3JpZEJlZm9yZUV4cG9ydFRvRmlsZS5uZXh0KHRydWUpO1xyXG4gICAgICB0aGlzLl9leHBvcnRPcHRpb25zID0gJC5leHRlbmQodHJ1ZSwge30sIHRoaXMuX2dyaWRPcHRpb25zLmV4cG9ydE9wdGlvbnMsIG9wdGlvbnMpO1xyXG4gICAgICB0aGlzLl9kZWxpbWl0ZXIgPSB0aGlzLl9leHBvcnRPcHRpb25zLmRlbGltaXRlck92ZXJyaWRlIHx8IHRoaXMuX2V4cG9ydE9wdGlvbnMuZGVsaW1pdGVyIHx8ICcnO1xyXG4gICAgICB0aGlzLl9maWxlRm9ybWF0ID0gdGhpcy5fZXhwb3J0T3B0aW9ucy5mb3JtYXQgfHwgRmlsZVR5cGUuY3N2O1xyXG5cclxuICAgICAgLy8gZ2V0IHRoZSBDU1Ygb3V0cHV0IGZyb20gdGhlIGdyaWQgZGF0YVxyXG4gICAgICBjb25zdCBkYXRhT3V0cHV0ID0gdGhpcy5nZXREYXRhT3V0cHV0KCk7XHJcblxyXG4gICAgICAvLyB0cmlnZ2VyIGEgZG93bmxvYWQgZmlsZVxyXG4gICAgICAvLyB3cmFwIGl0IGludG8gYSBzZXRUaW1lb3V0IHNvIHRoYXQgdGhlIEV2ZW50QWdncmVnYXRvciBoYXMgZW5vdWdoIHRpbWUgdG8gc3RhcnQgYSBwcmUtcHJvY2VzcyBsaWtlIHNob3dpbmcgYSBzcGlubmVyXHJcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBkb3dubG9hZE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGZpbGVuYW1lOiBgJHt0aGlzLl9leHBvcnRPcHRpb25zLmZpbGVuYW1lfS4ke3RoaXMuX2ZpbGVGb3JtYXR9YCxcclxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLl9maWxlRm9ybWF0LFxyXG4gICAgICAgICAgICB1c2VVdGY4V2l0aEJvbTogdGhpcy5fZXhwb3J0T3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgndXNlVXRmOFdpdGhCb20nKSA/IHRoaXMuX2V4cG9ydE9wdGlvbnMudXNlVXRmOFdpdGhCb20gOiB0cnVlXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIC8vIHN0YXJ0IGRvd25sb2FkaW5nIGJ1dCBhZGQgdGhlIGNvbnRlbnQgcHJvcGVydHkgb25seSBvbiB0aGUgc3RhcnQgZG93bmxvYWQgbm90IG9uIHRoZSBldmVudCBpdHNlbGZcclxuICAgICAgICAgIHRoaXMuc3RhcnREb3dubG9hZEZpbGUoeyAuLi5kb3dubG9hZE9wdGlvbnMsIGNvbnRlbnQ6IGRhdGFPdXRwdXQgfSk7IC8vIGFkZCBjb250ZW50IHByb3BlcnR5XHJcbiAgICAgICAgICB0aGlzLm9uR3JpZEFmdGVyRXhwb3J0VG9GaWxlLm5leHQoZG93bmxvYWRPcHRpb25zKTtcclxuICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCAwKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJpZ2dlcnMgZG93bmxvYWQgZmlsZSB3aXRoIGZpbGUgZm9ybWF0LlxyXG4gICAqIElFKDYtMTApIGFyZSBub3Qgc3VwcG9ydGVkXHJcbiAgICogQWxsIG90aGVyIGJyb3dzZXJzIHdpbGwgdXNlIHBsYWluIGphdmFzY3JpcHQgb24gY2xpZW50IHNpZGUgdG8gcHJvZHVjZSBhIGZpbGUgZG93bmxvYWQuXHJcbiAgICogQHBhcmFtIG9wdGlvbnNcclxuICAgKi9cclxuICBzdGFydERvd25sb2FkRmlsZShvcHRpb25zOiB7IGZpbGVuYW1lOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZywgZm9ybWF0OiBGaWxlVHlwZSB8IHN0cmluZywgdXNlVXRmOFdpdGhCb206IGJvb2xlYW4gfSkge1xyXG4gICAgLy8gSUUoNi0xMCkgZG9uJ3Qgc3VwcG9ydCBqYXZhc2NyaXB0IGRvd25sb2FkIGFuZCBvdXIgc2VydmljZSBkb2Vzbid0IHN1cHBvcnQgZWl0aGVyIHNvIHRocm93IGFuIGVycm9yLCB3ZSBoYXZlIHRvIG1ha2UgYSByb3VuZCB0cmlwIHRvIHRoZSBXZWIgU2VydmVyIGZvciBleHBvcnRpbmdcclxuICAgIGlmIChuYXZpZ2F0b3IuYXBwTmFtZSA9PT0gJ01pY3Jvc29mdCBJbnRlcm5ldCBFeHBsb3JlcicpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXIgNiB0byAxMCBkbyBub3Qgc3VwcG9ydCBqYXZhc2NyaXB0IGV4cG9ydCB0byBDU1YuIFBsZWFzZSB1cGdyYWRlIHlvdXIgYnJvd3Nlci4nKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBzZXQgdGhlIGNvcnJlY3QgTUlNRSB0eXBlXHJcbiAgICBjb25zdCBtaW1lVHlwZSA9IChvcHRpb25zLmZvcm1hdCA9PT0gRmlsZVR5cGUuY3N2KSA/ICd0ZXh0L2NzdicgOiAndGV4dC9wbGFpbic7XHJcblxyXG4gICAgLy8gbWFrZSBzdXJlIG5vIGh0bWwgZW50aXRpZXMgZXhpc3QgaW4gdGhlIGRhdGFcclxuICAgIGNvbnN0IGRhdGFDb250ZW50ID0gaHRtbEVudGl0eURlY29kZShvcHRpb25zLmNvbnRlbnQpO1xyXG5cclxuICAgIC8vIGRlYWxpbmcgd2l0aCBFeGNlbCBDU1YgZXhwb3J0IGFuZCBVVEYtOCBpcyBhIGxpdHRsZSB0cmlja3kuLiBXZSB3aWxsIHVzZSBPcHRpb24gIzIgdG8gY292ZXIgb2xkZXIgRXhjZWwgdmVyc2lvbnNcclxuICAgIC8vIE9wdGlvbiAjMTogd2UgbmVlZCB0byBtYWtlIEV4Y2VsIGtub3dpbmcgdGhhdCBpdCdzIGRlYWxpbmcgd2l0aCBhbiBVVEYtOCwgQSBjb3JyZWN0bHkgZm9ybWF0dGVkIFVURjggZmlsZSBjYW4gaGF2ZSBhIEJ5dGUgT3JkZXIgTWFyayBhcyBpdHMgZmlyc3QgdGhyZWUgb2N0ZXRzXHJcbiAgICAvLyByZWZlcmVuY2U6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTU1MDk3L21pY3Jvc29mdC1leGNlbC1tYW5nbGVzLWRpYWNyaXRpY3MtaW4tY3N2LWZpbGVzXHJcbiAgICAvLyBPcHRpb24jMjogdXNlIGEgM3JkIHBhcnR5IGV4dGVuc2lvbiB0byBqYXZhc2NyaXB0IGVuY29kZSBpbnRvIFVURi0xNlxyXG4gICAgbGV0IG91dHB1dERhdGE6IFVpbnQ4QXJyYXkgfCBzdHJpbmc7XHJcbiAgICBpZiAob3B0aW9ucy5mb3JtYXQgPT09IEZpbGVUeXBlLmNzdikge1xyXG4gICAgICBvdXRwdXREYXRhID0gbmV3IFRleHRFbmNvZGVyKCd1dGYtOCcpLmVuY29kZShkYXRhQ29udGVudCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBvdXRwdXREYXRhID0gZGF0YUNvbnRlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY3JlYXRlIGEgQmxvYiBvYmplY3QgZm9yIHRoZSBkb3dubG9hZFxyXG4gICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtvcHRpb25zLnVzZVV0ZjhXaXRoQm9tID8gJ1xcdUZFRkYnIDogJycsIG91dHB1dERhdGFdLCB7XHJcbiAgICAgIHR5cGU6IGAke21pbWVUeXBlfTtjaGFyc2V0PXV0Zi04O2BcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHdoZW4gdXNpbmcgSUUvRWRnZSwgdGhlbiB1c2UgZGlmZmVyZW50IGRvd25sb2FkIGNhbGxcclxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgbmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IoYmxvYiwgb3B0aW9ucy5maWxlbmFtZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyB0aGlzIHRyaWNrIHdpbGwgZ2VuZXJhdGUgYSB0ZW1wIDxhIC8+IHRhZ1xyXG4gICAgICAvLyB0aGUgY29kZSB3aWxsIHRoZW4gdHJpZ2dlciBhIGhpZGRlbiBjbGljayBmb3IgaXQgdG8gc3RhcnQgZG93bmxvYWRpbmdcclxuICAgICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcclxuICAgICAgY29uc3QgY3N2VXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuXHJcbiAgICAgIGxpbmsudGV4dENvbnRlbnQgPSAnZG93bmxvYWQnO1xyXG4gICAgICBsaW5rLmhyZWYgPSBjc3ZVcmw7XHJcbiAgICAgIGxpbmsuc2V0QXR0cmlidXRlKCdkb3dubG9hZCcsIG9wdGlvbnMuZmlsZW5hbWUpO1xyXG5cclxuICAgICAgLy8gc2V0IHRoZSB2aXNpYmlsaXR5IHRvIGhpZGRlbiBzbyB0aGVyZSBpcyBubyBlZmZlY3Qgb24geW91ciB3ZWItbGF5b3V0XHJcbiAgICAgIGxpbmsuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG5cclxuICAgICAgLy8gdGhpcyBwYXJ0IHdpbGwgYXBwZW5kIHRoZSBhbmNob3IgdGFnLCB0cmlnZ2VyIGEgY2xpY2sgKGZvciBkb3dubG9hZCB0byBzdGFydCkgYW5kIGZpbmFsbHkgcmVtb3ZlIHRoZSB0YWcgb25jZSBjb21wbGV0ZWRcclxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaW5rKTtcclxuICAgICAgbGluay5jbGljaygpO1xyXG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGxpbmspO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyBQcml2YXRlIGZ1bmN0aW9uc1xyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIHByaXZhdGUgZ2V0RGF0YU91dHB1dCgpOiBzdHJpbmcge1xyXG4gICAgY29uc3QgY29sdW1ucyA9IHRoaXMuX2dyaWQuZ2V0Q29sdW1ucygpIHx8IFtdO1xyXG5cclxuICAgIC8vIEdyb3VwIEJ5IHRleHQsIGl0IGNvdWxkIGJlIHNldCBpbiB0aGUgZXhwb3J0IG9wdGlvbnMgb3IgZnJvbSB0cmFuc2xhdGlvbiBvciBpZiBub3RoaW5nIGlzIGZvdW5kIHRoZW4gdXNlIHRoZSBFbmdsaXNoIGNvbnN0YW50IHRleHRcclxuICAgIGxldCBncm91cEJ5Q29sdW1uSGVhZGVyID0gdGhpcy5fZXhwb3J0T3B0aW9ucy5ncm91cGluZ0NvbHVtbkhlYWRlclRpdGxlO1xyXG4gICAgaWYgKCFncm91cEJ5Q29sdW1uSGVhZGVyICYmIHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZVRyYW5zbGF0ZSAmJiB0aGlzLnRyYW5zbGF0ZSAmJiB0aGlzLnRyYW5zbGF0ZS5jdXJyZW50TGFuZyAmJiB0aGlzLnRyYW5zbGF0ZS5pbnN0YW50KSB7XHJcbiAgICAgIGdyb3VwQnlDb2x1bW5IZWFkZXIgPSB0aGlzLnRyYW5zbGF0ZS5pbnN0YW50KCdHUk9VUF9CWScpO1xyXG4gICAgfSBlbHNlIGlmICghZ3JvdXBCeUNvbHVtbkhlYWRlcikge1xyXG4gICAgICBncm91cEJ5Q29sdW1uSGVhZGVyID0gdGhpcy5fbG9jYWxlcyAmJiB0aGlzLl9sb2NhbGVzLlRFWFRfR1JPVVBfQlk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYSBDU1YgbmVlZHMgZG91YmxlIHF1b3RlcyB3cmFwcGVyLCB0aGUgb3RoZXIgdHlwZXMgZG8gbm90IG5lZWQgYW55IHdyYXBwZXJcclxuICAgIHRoaXMuX2V4cG9ydFF1b3RlV3JhcHBlciA9ICh0aGlzLl9maWxlRm9ybWF0ID09PSBGaWxlVHlwZS5jc3YpID8gJ1wiJyA6ICcnO1xyXG5cclxuICAgIC8vIGRhdGEgdmFyaWFibGUgd2hpY2ggd2lsbCBob2xkIGFsbCB0aGUgZmllbGRzIGRhdGEgb2YgYSByb3dcclxuICAgIGxldCBvdXRwdXREYXRhU3RyaW5nID0gJyc7XHJcblxyXG4gICAgLy8gZ2V0IGdyb3VwZWQgY29sdW1uIHRpdGxlcyBhbmQgaWYgZm91bmQsIHdlIHdpbGwgYWRkIGEgXCJHcm91cCBieVwiIGNvbHVtbiBhdCB0aGUgZmlyc3QgY29sdW1uIGluZGV4XHJcbiAgICAvLyBpZiBpdCdzIGEgQ1NWIGZvcm1hdCwgd2UnbGwgZXNjYXBlIHRoZSB0ZXh0IGluIGRvdWJsZSBxdW90ZXNcclxuICAgIGNvbnN0IGdyb3VwaW5nID0gdGhpcy5fZGF0YVZpZXcuZ2V0R3JvdXBpbmcoKTtcclxuICAgIGlmIChncm91cGluZyAmJiBBcnJheS5pc0FycmF5KGdyb3VwaW5nKSAmJiBncm91cGluZy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHRoaXMuX2hhc0dyb3VwZWRJdGVtcyA9IHRydWU7XHJcbiAgICAgIG91dHB1dERhdGFTdHJpbmcgKz0gKHRoaXMuX2ZpbGVGb3JtYXQgPT09IEZpbGVUeXBlLmNzdikgPyBgXCIke2dyb3VwQnlDb2x1bW5IZWFkZXJ9XCIke3RoaXMuX2RlbGltaXRlcn1gIDogYCR7Z3JvdXBCeUNvbHVtbkhlYWRlcn0ke3RoaXMuX2RlbGltaXRlcn1gO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5faGFzR3JvdXBlZEl0ZW1zID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZ2V0IGFsbCBjb2x1bW4gaGVhZGVyc1xyXG4gICAgdGhpcy5fY29sdW1uSGVhZGVycyA9IHRoaXMuZ2V0Q29sdW1uSGVhZGVycyhjb2x1bW5zKSB8fCBbXTtcclxuICAgIGlmICh0aGlzLl9jb2x1bW5IZWFkZXJzICYmIEFycmF5LmlzQXJyYXkodGhpcy5fY29sdW1uSGVhZGVycykgJiYgdGhpcy5fY29sdW1uSGVhZGVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIC8vIGFkZCB0aGUgaGVhZGVyIHJvdyArIGFkZCBhIG5ldyBsaW5lIGF0IHRoZSBlbmQgb2YgdGhlIHJvd1xyXG4gICAgICBjb25zdCBvdXRwdXRIZWFkZXJUaXRsZXMgPSB0aGlzLl9jb2x1bW5IZWFkZXJzLm1hcCgoaGVhZGVyKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4cG9ydFF1b3RlV3JhcHBlciArIGhlYWRlci50aXRsZSArIHRoaXMuX2V4cG9ydFF1b3RlV3JhcHBlcjtcclxuICAgICAgfSk7XHJcbiAgICAgIG91dHB1dERhdGFTdHJpbmcgKz0gKG91dHB1dEhlYWRlclRpdGxlcy5qb2luKHRoaXMuX2RlbGltaXRlcikgKyB0aGlzLl9saW5lQ2FycmlhZ2VSZXR1cm4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFBvcHVsYXRlIHRoZSByZXN0IG9mIHRoZSBHcmlkIERhdGFcclxuICAgIG91dHB1dERhdGFTdHJpbmcgKz0gdGhpcy5nZXRBbGxHcmlkUm93RGF0YShjb2x1bW5zLCB0aGlzLl9saW5lQ2FycmlhZ2VSZXR1cm4pO1xyXG5cclxuICAgIHJldHVybiBvdXRwdXREYXRhU3RyaW5nO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGFsbCB0aGUgZ3JpZCByb3cgZGF0YSBhbmQgcmV0dXJuIHRoYXQgYXMgYW4gb3V0cHV0IHN0cmluZ1xyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0QWxsR3JpZFJvd0RhdGEoY29sdW1uczogQ29sdW1uW10sIGxpbmVDYXJyaWFnZVJldHVybjogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IG91dHB1dERhdGFTdHJpbmdzID0gW107XHJcbiAgICBjb25zdCBsaW5lQ291bnQgPSB0aGlzLl9kYXRhVmlldy5nZXRMZW5ndGgoKTtcclxuXHJcbiAgICAvLyBsb29wIHRocm91Z2ggYWxsIHRoZSBncmlkIHJvd3Mgb2YgZGF0YVxyXG4gICAgZm9yIChsZXQgcm93TnVtYmVyID0gMDsgcm93TnVtYmVyIDwgbGluZUNvdW50OyByb3dOdW1iZXIrKykge1xyXG4gICAgICBjb25zdCBpdGVtT2JqID0gdGhpcy5fZGF0YVZpZXcuZ2V0SXRlbShyb3dOdW1iZXIpO1xyXG4gICAgICBpZiAoaXRlbU9iaiAhPSBudWxsKSB7XHJcbiAgICAgICAgLy8gTm9ybWFsIHJvdyAobm90IGdyb3VwZWQgYnkgYW55dGhpbmcpIHdvdWxkIGhhdmUgYW4gSUQgd2hpY2ggd2FzIHByZWRlZmluZWQgaW4gdGhlIEdyaWQgQ29sdW1ucyBkZWZpbml0aW9uXHJcbiAgICAgICAgaWYgKGl0ZW1PYmpbdGhpcy5kYXRhc2V0SWROYW1lXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAvLyBnZXQgcmVndWxhciByb3cgaXRlbSBkYXRhXHJcbiAgICAgICAgICBvdXRwdXREYXRhU3RyaW5ncy5wdXNoKHRoaXMucmVhZFJlZ3VsYXJSb3dEYXRhKGNvbHVtbnMsIHJvd051bWJlciwgaXRlbU9iaikpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5faGFzR3JvdXBlZEl0ZW1zICYmIGl0ZW1PYmouX19ncm91cFRvdGFscyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAvLyBnZXQgdGhlIGdyb3VwIHJvd1xyXG4gICAgICAgICAgb3V0cHV0RGF0YVN0cmluZ3MucHVzaCh0aGlzLnJlYWRHcm91cGVkVGl0bGVSb3coaXRlbU9iaikpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbU9iai5fX2dyb3VwVG90YWxzKSB7XHJcbiAgICAgICAgICAvLyBlbHNlIGlmIHRoZSByb3cgaXMgYSBHcm91cCBCeSBhbmQgd2UgaGF2ZSBhZ3JlZ2dhdG9ycywgdGhlbiBhIHByb3BlcnR5IG9mICdfX2dyb3VwVG90YWxzJyB3b3VsZCBleGlzdCB1bmRlciB0aGF0IG9iamVjdFxyXG4gICAgICAgICAgb3V0cHV0RGF0YVN0cmluZ3MucHVzaCh0aGlzLnJlYWRHcm91cGVkVG90YWxSb3coY29sdW1ucywgaXRlbU9iaikpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRwdXREYXRhU3RyaW5ncy5qb2luKGxpbmVDYXJyaWFnZVJldHVybik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgYWxsIGhlYWRlciB0aXRsZXMgYW5kIHRoZWlyIGtleXMsIHRyYW5zbGF0ZSB0aGUgdGl0bGUgd2hlbiByZXF1aXJlZC5cclxuICAgKiBAcGFyYW0gY29sdW1ucyBvZiB0aGUgZ3JpZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0Q29sdW1uSGVhZGVycyhjb2x1bW5zOiBDb2x1bW5bXSk6IEtleVRpdGxlUGFpcltdIHtcclxuICAgIGlmICghY29sdW1ucyB8fCAhQXJyYXkuaXNBcnJheShjb2x1bW5zKSB8fCBjb2x1bW5zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IGNvbHVtbkhlYWRlcnMgPSBbXTtcclxuXHJcbiAgICAvLyBQb3B1bGF0ZSB0aGUgQ29sdW1uIEhlYWRlciwgcHVsbCB0aGUgbmFtZSBkZWZpbmVkXHJcbiAgICBjb2x1bW5zLmZvckVhY2goKGNvbHVtbkRlZikgPT4ge1xyXG4gICAgICBsZXQgaGVhZGVyVGl0bGUgPSAnJztcclxuICAgICAgaWYgKChjb2x1bW5EZWYuaGVhZGVyS2V5IHx8IGNvbHVtbkRlZi5uYW1lS2V5KSAmJiB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVUcmFuc2xhdGUgJiYgdGhpcy50cmFuc2xhdGUgJiYgdGhpcy50cmFuc2xhdGUuY3VycmVudExhbmcgJiYgdGhpcy50cmFuc2xhdGUuaW5zdGFudCkge1xyXG4gICAgICAgIGhlYWRlclRpdGxlID0gdGhpcy50cmFuc2xhdGUuaW5zdGFudCgoY29sdW1uRGVmLmhlYWRlcktleSB8fCBjb2x1bW5EZWYubmFtZUtleSkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGhlYWRlclRpdGxlID0gY29sdW1uRGVmLm5hbWUgfHwgdGl0bGVDYXNlKGNvbHVtbkRlZi5maWVsZCk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgc2tpcHBlZEZpZWxkID0gY29sdW1uRGVmLmV4Y2x1ZGVGcm9tRXhwb3J0IHx8IGZhbHNlO1xyXG5cclxuICAgICAgLy8gaWYgY29sdW1uIHdpZHRoIGlzIDAsIHRoZW4gd2UgY29uc2lkZXIgdGhhdCBmaWVsZCBhcyBhIGhpZGRlbiBmaWVsZCBhbmQgc2hvdWxkIG5vdCBiZSBwYXJ0IG9mIHRoZSBleHBvcnRcclxuICAgICAgaWYgKChjb2x1bW5EZWYud2lkdGggPT09IHVuZGVmaW5lZCB8fCBjb2x1bW5EZWYud2lkdGggPiAwKSAmJiAhc2tpcHBlZEZpZWxkKSB7XHJcbiAgICAgICAgY29sdW1uSGVhZGVycy5wdXNoKHtcclxuICAgICAgICAgIGtleTogY29sdW1uRGVmLmZpZWxkIHx8IGNvbHVtbkRlZi5pZCxcclxuICAgICAgICAgIHRpdGxlOiBoZWFkZXJUaXRsZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gY29sdW1uSGVhZGVycztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZGF0YSBvZiBhIHJlZ3VsYXIgcm93IChhIHJvdyB3aXRob3V0IGdyb3VwaW5nKVxyXG4gICAqIEBwYXJhbSByb3dcclxuICAgKiBAcGFyYW0gaXRlbU9ialxyXG4gICAqL1xyXG4gIHByaXZhdGUgcmVhZFJlZ3VsYXJSb3dEYXRhKGNvbHVtbnM6IENvbHVtbltdLCByb3c6IG51bWJlciwgaXRlbU9iajogYW55KSB7XHJcbiAgICBsZXQgaWR4ID0gMDtcclxuICAgIGNvbnN0IHJvd091dHB1dFN0cmluZ3MgPSBbXTtcclxuICAgIGNvbnN0IGV4cG9ydFF1b3RlV3JhcHBlciA9IHRoaXMuX2V4cG9ydFF1b3RlV3JhcHBlcjtcclxuXHJcbiAgICBmb3IgKGxldCBjb2wgPSAwLCBsbiA9IGNvbHVtbnMubGVuZ3RoOyBjb2wgPCBsbjsgY29sKyspIHtcclxuICAgICAgY29uc3QgY29sdW1uRGVmID0gY29sdW1uc1tjb2xdO1xyXG5cclxuICAgICAgLy8gc2tpcCBleGNsdWRlZCBjb2x1bW5cclxuICAgICAgaWYgKGNvbHVtbkRlZi5leGNsdWRlRnJvbUV4cG9ydCkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBpZiB3ZSBhcmUgZ3JvdXBpbmcgYW5kIGFyZSBvbiAxc3QgY29sdW1uIGluZGV4LCB3ZSBuZWVkIHRvIHNraXAgdGhpcyBjb2x1bW4gc2luY2UgaXQgd2lsbCBiZSB1c2VkIGxhdGVyIGJ5IHRoZSBncm91cGluZyB0ZXh0OjogR3JvdXAgYnkgW2NvbHVtblhdXHJcbiAgICAgIGlmICh0aGlzLl9oYXNHcm91cGVkSXRlbXMgJiYgaWR4ID09PSAwKSB7XHJcbiAgICAgICAgY29uc3QgZW1wdHlWYWx1ZSA9IHRoaXMuX2ZpbGVGb3JtYXQgPT09IEZpbGVUeXBlLmNzdiA/IGBcIlwiYCA6ICcnO1xyXG4gICAgICAgIHJvd091dHB1dFN0cmluZ3MucHVzaChlbXB0eVZhbHVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZ2V0IHRoZSBvdXRwdXQgYnkgYW5hbHl6aW5nIGlmIHdlJ2xsIHB1bGwgdGhlIHZhbHVlIGZyb20gdGhlIGNlbGwgb3IgZnJvbSBhIGZvcm1hdHRlclxyXG4gICAgICBsZXQgaXRlbURhdGEgPSBleHBvcnRXaXRoRm9ybWF0dGVyV2hlbkRlZmluZWQocm93LCBjb2wsIGl0ZW1PYmosIGNvbHVtbkRlZiwgdGhpcy5fZ3JpZCwgdGhpcy5fZXhwb3J0T3B0aW9ucyk7XHJcblxyXG4gICAgICAvLyBkb2VzIHRoZSB1c2VyIHdhbnQgdG8gc2FuaXRpemUgdGhlIG91dHB1dCBkYXRhIChyZW1vdmUgSFRNTCB0YWdzKT9cclxuICAgICAgaWYgKGNvbHVtbkRlZi5zYW5pdGl6ZURhdGFFeHBvcnQgfHwgdGhpcy5fZXhwb3J0T3B0aW9ucy5zYW5pdGl6ZURhdGFFeHBvcnQpIHtcclxuICAgICAgICBpdGVtRGF0YSA9IHNhbml0aXplSHRtbFRvVGV4dChpdGVtRGF0YSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHdoZW4gQ1NWIHdlIGFsc28gbmVlZCB0byBlc2NhcGUgZG91YmxlIHF1b3RlcyB0d2ljZSwgc28gXCIgYmVjb21lcyBcIlwiXHJcbiAgICAgIGlmICh0aGlzLl9maWxlRm9ybWF0ID09PSBGaWxlVHlwZS5jc3YgJiYgaXRlbURhdGEpIHtcclxuICAgICAgICBpdGVtRGF0YSA9IGl0ZW1EYXRhLnRvU3RyaW5nKCkucmVwbGFjZSgvXCIvZ2ksIGBcIlwiYCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGRvIHdlIGhhdmUgYSB3cmFwcGVyIHRvIGtlZXAgYXMgYSBzdHJpbmc/IGluIGNlcnRhaW4gY2FzZXMgbGlrZSBcIjFFMDZcIiwgd2UgZG9uJ3Qgd2FudCBleGNlbCB0byB0cmFuc2Zvcm0gaXQgaW50byBleHBvbmVudGlhbCAoMS4wRTA2KVxyXG4gICAgICAvLyB0byBjYW5jZWwgdGhhdCBlZmZlY3Qgd2UgY2FuIGhhZCA9IGluIGZyb250LCBleDogPVwiMUUwNlwiXHJcbiAgICAgIGNvbnN0IGtlZXBBc1N0cmluZ1dyYXBwZXIgPSAoY29sdW1uRGVmICYmIGNvbHVtbkRlZi5leHBvcnRDc3ZGb3JjZVRvS2VlcEFzU3RyaW5nKSA/ICc9JyA6ICcnO1xyXG5cclxuICAgICAgcm93T3V0cHV0U3RyaW5ncy5wdXNoKGtlZXBBc1N0cmluZ1dyYXBwZXIgKyBleHBvcnRRdW90ZVdyYXBwZXIgKyBpdGVtRGF0YSArIGV4cG9ydFF1b3RlV3JhcHBlcik7XHJcbiAgICAgIGlkeCsrO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByb3dPdXRwdXRTdHJpbmdzLmpvaW4odGhpcy5fZGVsaW1pdGVyKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZ3JvdXBlZCB0aXRsZShzKSBhbmQgaXRzIGdyb3VwIHRpdGxlIGZvcm1hdHRlciwgZm9yIGV4YW1wbGUgaWYgd2UgZ3JvdXBlZCBieSBzYWxlc1JlcCwgdGhlIHJldHVybmVkIHJlc3VsdCB3b3VsZCBiZTo6ICdTYWxlcyBSZXA6IEpvaG4gRG93ICgyIGl0ZW1zKSdcclxuICAgKiBAcGFyYW0gaXRlbU9ialxyXG4gICAqL1xyXG4gIHByaXZhdGUgcmVhZEdyb3VwZWRUaXRsZVJvdyhpdGVtT2JqOiBhbnkpIHtcclxuICAgIGxldCBncm91cE5hbWUgPSBzYW5pdGl6ZUh0bWxUb1RleHQoaXRlbU9iai50aXRsZSk7XHJcbiAgICBjb25zdCBleHBvcnRRdW90ZVdyYXBwZXIgPSB0aGlzLl9leHBvcnRRdW90ZVdyYXBwZXI7XHJcblxyXG4gICAgZ3JvdXBOYW1lID0gYWRkV2hpdGVTcGFjZXMoNSAqIGl0ZW1PYmoubGV2ZWwpICsgZ3JvdXBOYW1lO1xyXG5cclxuICAgIGlmICh0aGlzLl9maWxlRm9ybWF0ID09PSBGaWxlVHlwZS5jc3YpIHtcclxuICAgICAgLy8gd2hlbiBDU1Ygd2UgYWxzbyBuZWVkIHRvIGVzY2FwZSBkb3VibGUgcXVvdGVzIHR3aWNlLCBzbyBcIiBiZWNvbWVzIFwiXCJcclxuICAgICAgZ3JvdXBOYW1lID0gZ3JvdXBOYW1lLnRvU3RyaW5nKCkucmVwbGFjZSgvXCIvZ2ksIGBcIlwiYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXhwb3J0UXVvdGVXcmFwcGVyICsgZ3JvdXBOYW1lICsgZXhwb3J0UXVvdGVXcmFwcGVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBncm91cGVkIHRvdGFscyAoYmVsb3cgdGhlIHJlZ3VsYXIgcm93cyksIHRoZXNlIGFyZSBzZXQgYnkgU2xpY2sgQWdncmVnYXRvcnMuXHJcbiAgICogRm9yIGV4YW1wbGUgaWYgd2UgZ3JvdXBlZCBieSBcInNhbGVzUmVwXCIgYW5kIHdlIGhhdmUgYSBTdW0gQWdncmVnYXRvciBvbiBcInNhbGVzXCIsIHRoZW4gdGhlIHJldHVybmVkIG91dHB1dCB3b3VsZCBiZTo6IFtcIlN1bSAxMjMkXCJdXHJcbiAgICogQHBhcmFtIGl0ZW1PYmpcclxuICAgKi9cclxuICBwcml2YXRlIHJlYWRHcm91cGVkVG90YWxSb3coY29sdW1uczogQ29sdW1uW10sIGl0ZW1PYmo6IGFueSkge1xyXG4gICAgY29uc3QgZGVsaW1pdGVyID0gdGhpcy5fZXhwb3J0T3B0aW9ucy5kZWxpbWl0ZXI7XHJcbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLl9leHBvcnRPcHRpb25zLmZvcm1hdDtcclxuICAgIGNvbnN0IGdyb3VwaW5nQWdncmVnYXRvclJvd1RleHQgPSB0aGlzLl9leHBvcnRPcHRpb25zLmdyb3VwaW5nQWdncmVnYXRvclJvd1RleHQgfHwgJyc7XHJcbiAgICBjb25zdCBleHBvcnRRdW90ZVdyYXBwZXIgPSB0aGlzLl9leHBvcnRRdW90ZVdyYXBwZXI7XHJcbiAgICBjb25zdCBvdXRwdXRTdHJpbmdzID0gW2Ake2V4cG9ydFF1b3RlV3JhcHBlcn0ke2dyb3VwaW5nQWdncmVnYXRvclJvd1RleHR9JHtleHBvcnRRdW90ZVdyYXBwZXJ9YF07XHJcblxyXG4gICAgY29sdW1ucy5mb3JFYWNoKChjb2x1bW5EZWYpID0+IHtcclxuICAgICAgbGV0IGl0ZW1EYXRhID0gJyc7XHJcblxyXG4gICAgICBjb25zdCBza2lwcGVkRmllbGQgPSBjb2x1bW5EZWYuZXhjbHVkZUZyb21FeHBvcnQgfHwgZmFsc2U7XHJcblxyXG4gICAgICAvLyBpZiB0aGVyZSdzIGEgZ3JvdXBUb3RhbHNGb3JtYXR0ZXIsIHdlIHdpbGwgcmUtcnVuIGl0IHRvIGdldCB0aGUgZXhhY3Qgc2FtZSBvdXRwdXQgYXMgd2hhdCBpcyBzaG93biBpbiBVSVxyXG4gICAgICBpZiAoY29sdW1uRGVmLmdyb3VwVG90YWxzRm9ybWF0dGVyKSB7XHJcbiAgICAgICAgaXRlbURhdGEgPSBjb2x1bW5EZWYuZ3JvdXBUb3RhbHNGb3JtYXR0ZXIoaXRlbU9iaiwgY29sdW1uRGVmKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZG9lcyB0aGUgdXNlciB3YW50IHRvIHNhbml0aXplIHRoZSBvdXRwdXQgZGF0YSAocmVtb3ZlIEhUTUwgdGFncyk/XHJcbiAgICAgIGlmIChjb2x1bW5EZWYuc2FuaXRpemVEYXRhRXhwb3J0IHx8IHRoaXMuX2V4cG9ydE9wdGlvbnMuc2FuaXRpemVEYXRhRXhwb3J0KSB7XHJcbiAgICAgICAgaXRlbURhdGEgPSBzYW5pdGl6ZUh0bWxUb1RleHQoaXRlbURhdGEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoZm9ybWF0ID09PSBGaWxlVHlwZS5jc3YpIHtcclxuICAgICAgICAvLyB3aGVuIENTViB3ZSBhbHNvIG5lZWQgdG8gZXNjYXBlIGRvdWJsZSBxdW90ZXMgdHdpY2UsIHNvIGEgZG91YmxlIHF1b3RlIFwiIGJlY29tZXMgMnggZG91YmxlIHF1b3RlcyBcIlwiXHJcbiAgICAgICAgaXRlbURhdGEgPSBpdGVtRGF0YS50b1N0cmluZygpLnJlcGxhY2UoL1wiL2dpLCBgXCJcImApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBhZGQgdGhlIGNvbHVtbiAodW5sZXNzIHVzZXIgd2FudHMgdG8gc2tpcCBpdClcclxuICAgICAgaWYgKChjb2x1bW5EZWYud2lkdGggPT09IHVuZGVmaW5lZCB8fCBjb2x1bW5EZWYud2lkdGggPiAwKSAmJiAhc2tpcHBlZEZpZWxkKSB7XHJcbiAgICAgICAgb3V0cHV0U3RyaW5ncy5wdXNoKGV4cG9ydFF1b3RlV3JhcHBlciArIGl0ZW1EYXRhICsgZXhwb3J0UXVvdGVXcmFwcGVyKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIG91dHB1dFN0cmluZ3Muam9pbihkZWxpbWl0ZXIpO1xyXG4gIH1cclxufVxyXG4iXX0=