import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { ExtensionService } from './extension.service';
import { FilterService } from './filter.service';
import { GridStateService } from './gridState.service';
import { SortService } from './sort.service';
import { Subject } from 'rxjs';
let highlightTimerEnd;
const GridServiceDeleteOptionDefaults = { triggerEvent: true };
const GridServiceInsertOptionDefaults = { highlightRow: true, position: 'top', resortGrid: false, selectRow: false, triggerEvent: true };
const GridServiceUpdateOptionDefaults = { highlightRow: true, selectRow: false, scrollRowIntoView: false, triggerEvent: true };
let GridService = class GridService {
    constructor(extensionService, filterService, gridStateService, sortService) {
        this.extensionService = extensionService;
        this.filterService = filterService;
        this.gridStateService = gridStateService;
        this.sortService = sortService;
        this.onItemAdded = new Subject();
        this.onItemDeleted = new Subject();
        this.onItemUpdated = new Subject();
        this.onItemUpserted = new Subject();
    }
    /** Getter for the Grid Options pulled through the Grid Object */
    get _gridOptions() {
        return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
    }
    init(grid, dataView) {
        this._grid = grid;
        this._dataView = dataView;
    }
    /** Clear all Filters & Sorts */
    clearAllFiltersAndSorts() {
        // call both clear Filters & Sort but only trigger the last one to avoid sending multiple backend queries
        if (this.sortService && this.sortService.clearSorting) {
            this.sortService.clearSorting(false); // skip event trigger on this one
        }
        if (this.filterService && this.filterService.clearFilters) {
            this.filterService.clearFilters();
        }
    }
    /**
     * From a SlickGrid Event triggered get the Column Definition and Item Data Context
     *
     * For example the SlickGrid onClick will return cell arguments when subscribing to it.
     * From these cellArgs, we want to get the Column Definition and Item Data
     * @param cell event args
     * @return object with columnDef and dataContext
     */
    getColumnFromEventArguments(args) {
        if (!args || !args.grid || !args.grid.getColumns || !args.grid.getDataItem) {
            throw new Error('To get the column definition and data, we need to have these arguments passed as objects (row, cell, grid)');
        }
        return {
            row: args.row,
            cell: args.cell,
            columnDef: args.grid.getColumns()[args.cell],
            dataContext: args.grid.getDataItem(args.row),
            dataView: this._dataView,
            grid: this._grid
        };
    }
    /** Get data item by it's row index number */
    getDataItemByRowNumber(rowNumber) {
        if (!this._grid || typeof this._grid.getDataItem !== 'function') {
            throw new Error(`We could not find SlickGrid Grid object or it's "getDataItem" method`);
        }
        return this._grid.getDataItem(rowNumber);
    }
    /** Chain the item Metadata with our implementation of Metadata at given row index */
    getItemRowMetadataToHighlight(previousItemMetadata) {
        return (rowNumber) => {
            const item = this._dataView.getItem(rowNumber);
            let meta = { cssClasses: '' };
            if (typeof previousItemMetadata === 'function') {
                meta = previousItemMetadata(rowNumber);
            }
            if (!meta) {
                meta = { cssClasses: '' };
            }
            if (item && item._dirty) {
                meta.cssClasses = (meta && meta.cssClasses || '') + ' dirty';
            }
            if (item && item.rowClass && meta) {
                meta.cssClasses += ` ${item.rowClass}`;
                meta.cssClasses += ` row${rowNumber}`;
            }
            return meta;
        };
    }
    /**
     * Highlight then fade a row for x seconds.
     * The implementation follows this SO answer: https://stackoverflow.com/a/19985148/1212166
     * @param rowNumber
     * @param fadeDelay
     */
    highlightRow(rowNumber, fadeDelay = 1500, fadeOutDelay = 300) {
        // create a SelectionModel if there's not one yet
        if (!this._grid.getSelectionModel() && Slick && Slick.RowSelectionModel) {
            const rowSelectionPlugin = new Slick.RowSelectionModel(this._gridOptions.rowSelectionOptions || {});
            this._grid.setSelectionModel(rowSelectionPlugin);
        }
        if (Array.isArray(rowNumber)) {
            rowNumber.forEach(row => this.highlightRowByMetadata(row, fadeDelay, fadeOutDelay));
        }
        else {
            this.highlightRowByMetadata(rowNumber, fadeDelay, fadeOutDelay);
        }
    }
    highlightRowByMetadata(rowNumber, fadeDelay = 1500, fadeOutDelay = 300) {
        this._dataView.getItemMetadata = this.getItemRowMetadataToHighlight(this._dataView.getItemMetadata);
        const item = this._dataView.getItem(rowNumber);
        if (item && item.id) {
            item.rowClass = 'highlight';
            this._dataView.updateItem(item.id, item);
            this.renderGrid();
            // fade out
            clearTimeout(highlightTimerEnd);
            highlightTimerEnd = setTimeout(() => {
                item.rowClass = 'highlight-end';
                this._dataView.updateItem(item.id, item);
                this.renderGrid();
            }, fadeOutDelay);
            // delete the row's CSS highlight classes once the delay is passed
            setTimeout(() => {
                if (item && item.id) {
                    delete item.rowClass;
                    if (this._dataView.getIdxById(item.id) !== undefined) {
                        this._dataView.updateItem(item.id, item);
                        this.renderGrid();
                    }
                }
            }, fadeDelay + fadeOutDelay);
        }
    }
    /** Get the Data Item from a grid row index */
    getDataItemByRowIndex(index) {
        if (!this._grid || typeof this._grid.getDataItem !== 'function') {
            throw new Error('We could not find SlickGrid Grid object and/or "getDataItem" method');
        }
        return this._grid.getDataItem(index);
    }
    /** Get the Data Item from an array of grid row indexes */
    getDataItemByRowIndexes(indexes) {
        if (!this._grid || typeof this._grid.getDataItem !== 'function') {
            throw new Error('We could not find SlickGrid Grid object and/or "getDataItem" method');
        }
        const dataItems = [];
        if (Array.isArray(indexes)) {
            indexes.forEach((idx) => {
                dataItems.push(this._grid.getDataItem(idx));
            });
        }
        return dataItems;
    }
    /** Get the currently selected row indexes */
    getSelectedRows() {
        if (!this._grid || typeof this._grid.getSelectedRows !== 'function') {
            throw new Error('We could not find SlickGrid Grid object and/or "getSelectedRows" method');
        }
        return this._grid.getSelectedRows();
    }
    /** Get the currently selected rows item data */
    getSelectedRowsDataItem() {
        if (!this._grid || typeof this._grid.getSelectedRows !== 'function') {
            throw new Error('We could not find SlickGrid Grid object and/or "getSelectedRows" method');
        }
        const selectedRowIndexes = this._grid.getSelectedRows();
        return this.getDataItemByRowIndexes(selectedRowIndexes);
    }
    /** Select the selected row by a row index */
    setSelectedRow(rowIndex) {
        if (this._grid && this._grid.setSelectedRows) {
            this._grid.setSelectedRows([rowIndex]);
        }
    }
    /** Set selected rows with provided array of row indexes */
    setSelectedRows(rowIndexes) {
        if (this._grid && this._grid.setSelectedRows) {
            this._grid.setSelectedRows(rowIndexes);
        }
    }
    /** Re-Render the Grid */
    renderGrid() {
        if (this._grid && typeof this._grid.invalidate === 'function') {
            this._grid.invalidate();
            this._grid.render();
        }
    }
    /**
     * Reset the grid to it's original state (clear any filters, sorting & pagination if exists) .
     * The column definitions could be passed as argument to reset (this can be used after a Grid State reset)
     * The reset will clear the Filters & Sort, then will reset the Columns to their original state
     */
    resetGrid(columnDefinitions) {
        // reset columns to original states & refresh the grid
        if (this._grid && this._dataView) {
            const originalColumns = this.extensionService.getAllColumns();
            if (Array.isArray(originalColumns) && originalColumns.length > 0) {
                // set the grid columns to it's original column definitions
                this._grid.setColumns(originalColumns);
                if (this._gridOptions && this._gridOptions.enableAutoSizeColumns) {
                    this._grid.autosizeColumns();
                }
                this.gridStateService.resetColumns(columnDefinitions);
            }
        }
        if (this.filterService && this.filterService.clearFilters) {
            this.filterService.clearFilters();
        }
        if (this.sortService && this.sortService.clearSorting) {
            this.sortService.clearSorting();
        }
    }
    /** @deprecated please use "addItem" method instead */
    addItemToDatagrid(item, shouldHighlightRow = true, shouldResortGrid = false, shouldTriggerEvent = true, shouldSelectRow = true) {
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "addItem" method since "addItemToDatagrid" will be deprecated in the future.');
        return this.addItem(item, { highlightRow: shouldHighlightRow, resortGrid: shouldResortGrid, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });
    }
    /** @deprecated please use "addItems" method instead */
    addItemsToDatagrid(items, shouldHighlightRow = true, shouldResortGrid = false, shouldTriggerEvent = true, shouldSelectRow = true) {
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "addItems" method since "addItemsToDatagrid" will be deprecated in the future.');
        return this.addItems(items, { highlightRow: shouldHighlightRow, resortGrid: shouldResortGrid, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });
    }
    /**
     * Add an item (data item) to the datagrid, by default it will highlight (flashing) the inserted row but we can disable it too
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
     * @return rowIndex: typically index 0 when adding to position "top" or a different number when adding to the "bottom"
     */
    addItem(item, options) {
        options = Object.assign({}, GridServiceInsertOptionDefaults, options);
        if (!this._grid || !this._gridOptions || !this._dataView) {
            throw new Error('We could not find SlickGrid Grid, DataView objects');
        }
        if (!item || !item.hasOwnProperty('id')) {
            throw new Error(`Adding an item requires the item to include an "id" property`);
        }
        // insert position top/bottom, defaults to top
        // when position is top we'll call insert at index 0, else call addItem which just push to the DataView array
        if (options && options.position === 'bottom') {
            this._dataView.addItem(item);
        }
        else {
            this._dataView.insertItem(0, item); // insert at index 0
        }
        // row number in the grid, by default it will be on first row (top is the default)
        let rowNumber = 0;
        // do we want the item to be sorted in the grid, when set to False it will insert on first row (defaults to false)
        if (options.resortGrid) {
            this._dataView.reSort();
            // find the row number in the grid and if user wanted to see highlighted row
            // we need to do it here after resort and get each row number because it possibly changes after the sort
            rowNumber = this._dataView.getRowById(item.id);
        }
        else {
            // scroll to row index 0 when inserting on top else scroll to the bottom where it got inserted
            rowNumber = (options && options.position === 'bottom') ? this._dataView.getRowById(item.id) : 0;
            this._grid.scrollRowIntoView(rowNumber);
        }
        // if highlight is enabled, we'll highlight the row we just added
        if (options.highlightRow) {
            this.highlightRow(rowNumber);
        }
        // if row selection (checkbox selector) is enabled, we'll select the row in the grid
        if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
            this.setSelectedRow(rowNumber);
        }
        // do we want to trigger an event after adding the item
        if (options.triggerEvent) {
            this.onItemAdded.next(item);
        }
        return rowNumber;
    }
    /**
     * Add item array (data item) to the datagrid, by default it will highlight (flashing) the inserted row but we can disable it too
     * @param item object arrays, which must contain unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
     */
    addItems(items, options) {
        options = Object.assign({}, GridServiceInsertOptionDefaults, options);
        const rowNumbers = [];
        // loop through all items to add
        if (!Array.isArray(items)) {
            return [this.addItem(items, options)];
        }
        else {
            items.forEach((item) => this.addItem(item, Object.assign({}, options, { highlightRow: false, resortGrid: false, triggerEvent: false, selectRow: false })));
        }
        // do we want the item to be sorted in the grid, when set to False it will insert on first row (defaults to false)
        if (options.resortGrid) {
            this._dataView.reSort();
        }
        // scroll to row index 0 when inserting on top else scroll to the bottom where it got inserted
        (options && options.position === 'bottom') ? this._grid.navigateBottom() : this._grid.navigateTop();
        // get row numbers of all new inserted items
        // we need to do it after resort and get each row number because it possibly changed after the sort
        items.forEach((item) => rowNumbers.push(this._dataView.getRowById(item.id)));
        // if user wanted to see highlighted row
        if (options.highlightRow) {
            this.highlightRow(rowNumbers);
        }
        // select the row in the grid
        if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
            this.setSelectedRows(rowNumbers);
        }
        // do we want to trigger an event after adding the item
        if (options.triggerEvent) {
            this.onItemAdded.next(items);
        }
        return rowNumbers;
    }
    /** @deprecated please use "deleteItem" method instead */
    deleteDataGridItem(item, shouldTriggerEvent = true) {
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "deleteItem" method since "deleteDataGridItem" will be deprecated in the future.');
        this.deleteItem(item, { triggerEvent: shouldTriggerEvent });
    }
    /** @deprecated please use "deleteItems" method instead */
    deleteDataGridItems(items, shouldTriggerEvent = true) {
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "deleteItems" method since "deleteDataGridItems" will be deprecated in the future.');
        this.deleteItems(items, { triggerEvent: shouldTriggerEvent });
    }
    /** @deprecated please use "deleteItemById" method instead */
    deleteDataGridItemById(itemId, shouldTriggerEvent = true) {
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "deleteItemById" method since "deleteDataGridItemById" will be deprecated in the future.');
        this.deleteItemById(itemId, { triggerEvent: shouldTriggerEvent });
    }
    /** @deprecated please use "deleteItemByIds" method instead */
    deleteDataGridItemByIds(itemIds, shouldTriggerEvent = true) {
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "deleteItemByIds" method since "deleteDataGridItemByIds" will be deprecated in the future.');
        this.deleteItemByIds(itemIds, { triggerEvent: shouldTriggerEvent });
    }
    /**
     * Delete an existing item from the datagrid (dataView)
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (triggerEvent)
     * @return item id deleted
     */
    deleteItem(item, options) {
        options = Object.assign({}, GridServiceDeleteOptionDefaults, options);
        if (!item || !item.hasOwnProperty('id')) {
            throw new Error(`Deleting an item requires the item to include an "id" property`);
        }
        return this.deleteItemById(item.id, options);
    }
    /**
     * Delete an array of existing items from the datagrid
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (triggerEvent)
     * @return item id deleted
     */
    deleteItems(items, options) {
        options = Object.assign({}, GridServiceDeleteOptionDefaults, options);
        // when it's not an array, we can call directly the single item delete
        if (!Array.isArray(items)) {
            this.deleteItem(items, options);
            return [items.id];
        }
        const itemIds = [];
        items.forEach((item) => {
            if (item && item.id !== undefined) {
                itemIds.push(item.id);
            }
            this.deleteItem(item, Object.assign({}, options, { triggerEvent: false }));
        });
        // do we want to trigger an event after deleting the item
        if (options.triggerEvent) {
            this.onItemDeleted.next(items);
        }
        return itemIds;
    }
    /**
     * Delete an existing item from the datagrid (dataView) by it's id
     * @param itemId: item unique id
     * @param options: provide the possibility to do certain actions after or during the upsert (triggerEvent)
     * @return item id deleted
     */
    deleteItemById(itemId, options) {
        options = Object.assign({}, GridServiceDeleteOptionDefaults, options);
        if (itemId === null || itemId === undefined) {
            throw new Error(`Cannot delete a row without a valid "id"`);
        }
        // when user has row selection enabled, we should clear any selection to avoid confusion after a delete
        const isSyncGridSelectionEnabled = this.gridStateService && this.gridStateService.needToPreserveRowSelection() || false;
        if (!isSyncGridSelectionEnabled && this._grid && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
            this.setSelectedRows([]);
        }
        // delete the item from the dataView
        this._dataView.deleteItem(itemId);
        // do we want to trigger an event after deleting the item
        if (options.triggerEvent) {
            this.onItemDeleted.next(itemId);
        }
        return itemId;
    }
    /**
     * Delete an array of existing items from the datagrid
     * @param itemIds array of item unique IDs
     * @param options: provide the possibility to do certain actions after or during the upsert (triggerEvent)
     */
    deleteItemByIds(itemIds, options) {
        options = Object.assign({}, GridServiceDeleteOptionDefaults, options);
        // when it's not an array, we can call directly the single item delete
        if (Array.isArray(itemIds)) {
            for (let i = 0; i < itemIds.length; i++) {
                if (itemIds[i] !== null) {
                    this.deleteItemById(itemIds[i], { triggerEvent: false });
                }
            }
            // do we want to trigger an event after deleting the item
            if (options.triggerEvent) {
                this.onItemDeleted.next(itemIds);
            }
            return itemIds;
        }
        return [];
    }
    /** @deprecated please use "updateItem" method instead */
    updateDataGridItem(item, shouldHighlightRow = true, shouldTriggerEvent = true, shouldSelectRow = true) {
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "updateItem" method since "updateDataGridItem" will be deprecated in the future.');
        return this.updateItem(item, { highlightRow: shouldHighlightRow, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });
    }
    /** @deprecated please use "updateItems" method instead */
    updateDataGridItems(items, shouldHighlightRow = true, shouldTriggerEvent = true, shouldSelectRow = true) {
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "updateItems" method since "updateDataGridItems" will be deprecated in the future.');
        return this.updateItems(items, { highlightRow: shouldHighlightRow, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });
    }
    /** @deprecated please use "updateItemById" method instead */
    updateDataGridItemById(itemId, item, shouldHighlightRow = true, shouldTriggerEvent = true, shouldSelectRow = true) {
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "updateItemById" method since "updateDataGridItemById" will be deprecated in the future.');
        return this.updateItemById(itemId, item, { highlightRow: shouldHighlightRow, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });
    }
    /**
     * Update an existing item with new properties inside the datagrid
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, selectRow, triggerEvent)
     * @return grid row index
     */
    updateItem(item, options) {
        options = Object.assign({}, GridServiceUpdateOptionDefaults, options);
        const itemId = (!item || !item.hasOwnProperty('id')) ? undefined : item.id;
        if (itemId === undefined) {
            throw new Error(`Calling Update of an item requires the item to include an "id" property`);
        }
        return this.updateItemById(itemId, item, options);
    }
    /**
     * Update an array of existing items with new properties inside the datagrid
     * @param item object arrays, which must contain unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, selectRow, triggerEvent)
     * @return grid row indexes
     */
    updateItems(items, options) {
        options = Object.assign({}, GridServiceUpdateOptionDefaults, options);
        // when it's not an array, we can call directly the single item update
        if (!Array.isArray(items)) {
            return [this.updateItem(items, options)];
        }
        const gridRowNumbers = [];
        items.forEach((item) => {
            gridRowNumbers.push(this.updateItem(item, Object.assign({}, options, { highlightRow: false, selectRow: false, triggerEvent: false })));
        });
        // only highlight at the end, all at once
        // we have to do this because doing highlight 1 by 1 would only re-select the last highlighted row which is wrong behavior
        if (options.highlightRow) {
            this.highlightRow(gridRowNumbers);
        }
        // select the row in the grid
        if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
            this.setSelectedRows(gridRowNumbers);
        }
        // do we want to trigger an event after updating the item
        if (options.triggerEvent) {
            this.onItemUpdated.next(items);
        }
        return gridRowNumbers;
    }
    /**
     * Update an existing item in the datagrid by it's id and new properties
     * @param itemId: item unique id
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, selectRow, triggerEvent)
     * @return grid row number
     */
    updateItemById(itemId, item, options) {
        options = Object.assign({}, GridServiceUpdateOptionDefaults, options);
        if (itemId === undefined) {
            throw new Error(`Cannot update a row without a valid "id"`);
        }
        const rowNumber = this._dataView.getRowById(itemId);
        if (!item || rowNumber === undefined) {
            throw new Error(`The item to update in the grid was not found with id: ${itemId}`);
        }
        if (this._dataView.getIdxById(itemId) !== undefined) {
            // Update the item itself inside the dataView
            this._dataView.updateItem(itemId, item);
            this._grid.updateRow(rowNumber);
            // do we want to scroll to the row so that it shows in the Viewport (UI)
            if (options.scrollRowIntoView) {
                this._grid.scrollRowIntoView(rowNumber);
            }
            // highlight the row we just updated, if defined
            if (options.highlightRow) {
                this.highlightRow(rowNumber);
            }
            // select the row in the grid
            if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
                this.setSelectedRow(rowNumber);
            }
            // do we want to trigger an event after updating the item
            if (options.triggerEvent) {
                this.onItemUpdated.next(item);
            }
        }
        return rowNumber;
    }
    /**
     * Insert a row into the grid if it doesn't already exist or update if it does.
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
     */
    upsertItem(item, options) {
        options = Object.assign({}, GridServiceInsertOptionDefaults, options);
        const itemId = (!item || !item.hasOwnProperty('id')) ? undefined : item.id;
        if (itemId === undefined) {
            throw new Error(`Calling Upsert of an item requires the item to include an "id" property`);
        }
        return this.upsertItemById(itemId, item, options);
    }
    /**
     * Update an array of existing items with new properties inside the datagrid
     * @param item object arrays, which must contain unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
     * @return row numbers in the grid
     */
    upsertItems(items, options) {
        options = Object.assign({}, GridServiceInsertOptionDefaults, options);
        // when it's not an array, we can call directly the single item update
        if (!Array.isArray(items)) {
            return [this.upsertItem(items, options)];
        }
        const upsertedRows = [];
        items.forEach((item) => {
            upsertedRows.push(this.upsertItem(item, Object.assign({}, options, { highlightRow: false, resortGrid: false, selectRow: false, triggerEvent: false })));
        });
        const rowNumbers = upsertedRows.map((upsertRow) => upsertRow.added !== undefined ? upsertRow.added : upsertRow.updated);
        // only highlight at the end, all at once
        // we have to do this because doing highlight 1 by 1 would only re-select the last highlighted row which is wrong behavior
        if (options.highlightRow) {
            this.highlightRow(rowNumbers);
        }
        // select the row in the grid
        if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
            this.setSelectedRows(rowNumbers);
        }
        // do we want to trigger an event after updating the item
        if (options.triggerEvent) {
            this.onItemUpserted.next(items);
            const addedItems = upsertedRows.filter((upsertRow) => upsertRow.added !== undefined);
            if (Array.isArray(addedItems) && addedItems.length > 0) {
                this.onItemAdded.next(addedItems);
            }
            const updatedItems = upsertedRows.filter((upsertRow) => upsertRow.updated !== undefined);
            if (Array.isArray(updatedItems) && updatedItems.length > 0) {
                this.onItemUpdated.next(updatedItems);
            }
        }
        return upsertedRows;
    }
    /**
     * Update an existing item in the datagrid by it's id and new properties
     * @param itemId: item unique id
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
     * @return grid row number in the grid
     */
    upsertItemById(itemId, item, options) {
        let isItemAdded = false;
        options = Object.assign({}, GridServiceInsertOptionDefaults, options);
        if (itemId === undefined) {
            throw new Error(`Calling Upsert of an item requires the item to include a valid and unique "id" property`);
        }
        let rowNumberAdded;
        let rowNumberUpdated;
        if (this._dataView.getRowById(itemId) === undefined) {
            rowNumberAdded = this.addItem(item, options);
            isItemAdded = true;
        }
        else {
            rowNumberUpdated = this.updateItem(item, { highlightRow: options.highlightRow, selectRow: options.selectRow, triggerEvent: options.triggerEvent });
            isItemAdded = false;
        }
        // do we want to trigger an event after updating the item
        if (options.triggerEvent) {
            this.onItemUpserted.next(item);
            isItemAdded ? this.onItemAdded.next(item) : this.onItemUpdated.next(item);
        }
        return { added: rowNumberAdded, updated: rowNumberUpdated };
    }
};
GridService = tslib_1.__decorate([
    Injectable(),
    tslib_1.__metadata("design:paramtypes", [ExtensionService,
        FilterService,
        GridStateService,
        SortService])
], GridService);
export { GridService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1zbGlja2dyaWQvIiwic291cmNlcyI6WyJhcHAvbW9kdWxlcy9hbmd1bGFyLXNsaWNrZ3JpZC9zZXJ2aWNlcy9ncmlkLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFVM0MsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDdkQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ2pELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM3QyxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBSS9CLElBQUksaUJBQXNCLENBQUM7QUFDM0IsTUFBTSwrQkFBK0IsR0FBNEIsRUFBRSxZQUFZLEVBQUUsSUFBSSxFQUFFLENBQUM7QUFDeEYsTUFBTSwrQkFBK0IsR0FBNEIsRUFBRSxZQUFZLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUNsSyxNQUFNLCtCQUErQixHQUE0QixFQUFFLFlBQVksRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxpQkFBaUIsRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRSxDQUFDO0FBR3hKLElBQWEsV0FBVyxHQUF4QixNQUFhLFdBQVc7SUFRdEIsWUFDVSxnQkFBa0MsRUFDbEMsYUFBNEIsRUFDNUIsZ0JBQWtDLEVBQ2xDLFdBQXdCO1FBSHhCLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBa0I7UUFDbEMsa0JBQWEsR0FBYixhQUFhLENBQWU7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QUFDLENBQUM7WUFDbkosV0FBVyxHQUFHLEtBQUssQ0FBQztTQUNyQjtRQUVELHlEQUF5RDtRQUN6RCxJQUFJLE9BQU8sQ0FBQyxZQUFZLEVBQUU7WUFDeEIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDL0IsV0FBVyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDM0U7UUFDRCxPQUFPLEVBQUUsS0FBSyxFQUFFLGNBQWMsRUFBRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsQ0FBQztJQUM5RCxDQUFDO0NBQ0YsQ0FBQTtBQTVxQlksV0FBVztJQUR2QixVQUFVLEVBQUU7NkNBVWlCLGdCQUFnQjtRQUNuQixhQUFhO1FBQ1YsZ0JBQWdCO1FBQ3JCLFdBQVc7R0FadkIsV0FBVyxDQTRxQnZCO1NBNXFCWSxXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge1xyXG4gIENlbGxBcmdzLFxyXG4gIENvbHVtbixcclxuICBHcmlkT3B0aW9uLFxyXG4gIEdyaWRTZXJ2aWNlRGVsZXRlT3B0aW9uLFxyXG4gIEdyaWRTZXJ2aWNlSW5zZXJ0T3B0aW9uLFxyXG4gIEdyaWRTZXJ2aWNlVXBkYXRlT3B0aW9uLFxyXG4gIE9uRXZlbnRBcmdzXHJcbn0gZnJvbSAnLi8uLi9tb2RlbHMvaW5kZXgnO1xyXG5pbXBvcnQgeyBFeHRlbnNpb25TZXJ2aWNlIH0gZnJvbSAnLi9leHRlbnNpb24uc2VydmljZSc7XHJcbmltcG9ydCB7IEZpbHRlclNlcnZpY2UgfSBmcm9tICcuL2ZpbHRlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgR3JpZFN0YXRlU2VydmljZSB9IGZyb20gJy4vZ3JpZFN0YXRlLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBTb3J0U2VydmljZSB9IGZyb20gJy4vc29ydC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xyXG5cclxuLy8gdXNpbmcgZXh0ZXJuYWwgbm9uLXR5cGVkIGpzIGxpYnJhcmllc1xyXG5kZWNsYXJlIHZhciBTbGljazogYW55O1xyXG5sZXQgaGlnaGxpZ2h0VGltZXJFbmQ6IGFueTtcclxuY29uc3QgR3JpZFNlcnZpY2VEZWxldGVPcHRpb25EZWZhdWx0czogR3JpZFNlcnZpY2VEZWxldGVPcHRpb24gPSB7IHRyaWdnZXJFdmVudDogdHJ1ZSB9O1xyXG5jb25zdCBHcmlkU2VydmljZUluc2VydE9wdGlvbkRlZmF1bHRzOiBHcmlkU2VydmljZUluc2VydE9wdGlvbiA9IHsgaGlnaGxpZ2h0Um93OiB0cnVlLCBwb3NpdGlvbjogJ3RvcCcsIHJlc29ydEdyaWQ6IGZhbHNlLCBzZWxlY3RSb3c6IGZhbHNlLCB0cmlnZ2VyRXZlbnQ6IHRydWUgfTtcclxuY29uc3QgR3JpZFNlcnZpY2VVcGRhdGVPcHRpb25EZWZhdWx0czogR3JpZFNlcnZpY2VVcGRhdGVPcHRpb24gPSB7IGhpZ2hsaWdodFJvdzogdHJ1ZSwgc2VsZWN0Um93OiBmYWxzZSwgc2Nyb2xsUm93SW50b1ZpZXc6IGZhbHNlLCB0cmlnZ2VyRXZlbnQ6IHRydWUgfTtcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEdyaWRTZXJ2aWNlIHtcclxuICBwcml2YXRlIF9ncmlkOiBhbnk7XHJcbiAgcHJpdmF0ZSBfZGF0YVZpZXc6IGFueTtcclxuICBvbkl0ZW1BZGRlZCA9IG5ldyBTdWJqZWN0PGFueSB8IGFueVtdPigpO1xyXG4gIG9uSXRlbURlbGV0ZWQgPSBuZXcgU3ViamVjdDxhbnkgfCBhbnlbXT4oKTtcclxuICBvbkl0ZW1VcGRhdGVkID0gbmV3IFN1YmplY3Q8YW55IHwgYW55W10+KCk7XHJcbiAgb25JdGVtVXBzZXJ0ZWQgPSBuZXcgU3ViamVjdDxhbnkgfCBhbnlbXT4oKTtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIGV4dGVuc2lvblNlcnZpY2U6IEV4dGVuc2lvblNlcnZpY2UsXHJcbiAgICBwcml2YXRlIGZpbHRlclNlcnZpY2U6IEZpbHRlclNlcnZpY2UsXHJcbiAgICBwcml2YXRlIGdyaWRTdGF0ZVNlcnZpY2U6IEdyaWRTdGF0ZVNlcnZpY2UsXHJcbiAgICBwcml2YXRlIHNvcnRTZXJ2aWNlOiBTb3J0U2VydmljZVxyXG4gICkgeyB9XHJcblxyXG4gIC8qKiBHZXR0ZXIgZm9yIHRoZSBHcmlkIE9wdGlvbnMgcHVsbGVkIHRocm91Z2ggdGhlIEdyaWQgT2JqZWN0ICovXHJcbiAgcHJpdmF0ZSBnZXQgX2dyaWRPcHRpb25zKCk6IEdyaWRPcHRpb24ge1xyXG4gICAgcmV0dXJuICh0aGlzLl9ncmlkICYmIHRoaXMuX2dyaWQuZ2V0T3B0aW9ucykgPyB0aGlzLl9ncmlkLmdldE9wdGlvbnMoKSA6IHt9O1xyXG4gIH1cclxuXHJcbiAgaW5pdChncmlkOiBhbnksIGRhdGFWaWV3OiBhbnkpOiB2b2lkIHtcclxuICAgIHRoaXMuX2dyaWQgPSBncmlkO1xyXG4gICAgdGhpcy5fZGF0YVZpZXcgPSBkYXRhVmlldztcclxuICB9XHJcblxyXG4gIC8qKiBDbGVhciBhbGwgRmlsdGVycyAmIFNvcnRzICovXHJcbiAgY2xlYXJBbGxGaWx0ZXJzQW5kU29ydHMoKSB7XHJcbiAgICAvLyBjYWxsIGJvdGggY2xlYXIgRmlsdGVycyAmIFNvcnQgYnV0IG9ubHkgdHJpZ2dlciB0aGUgbGFzdCBvbmUgdG8gYXZvaWQgc2VuZGluZyBtdWx0aXBsZSBiYWNrZW5kIHF1ZXJpZXNcclxuICAgIGlmICh0aGlzLnNvcnRTZXJ2aWNlICYmIHRoaXMuc29ydFNlcnZpY2UuY2xlYXJTb3J0aW5nKSB7XHJcbiAgICAgIHRoaXMuc29ydFNlcnZpY2UuY2xlYXJTb3J0aW5nKGZhbHNlKTsgLy8gc2tpcCBldmVudCB0cmlnZ2VyIG9uIHRoaXMgb25lXHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5maWx0ZXJTZXJ2aWNlICYmIHRoaXMuZmlsdGVyU2VydmljZS5jbGVhckZpbHRlcnMpIHtcclxuICAgICAgdGhpcy5maWx0ZXJTZXJ2aWNlLmNsZWFyRmlsdGVycygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRnJvbSBhIFNsaWNrR3JpZCBFdmVudCB0cmlnZ2VyZWQgZ2V0IHRoZSBDb2x1bW4gRGVmaW5pdGlvbiBhbmQgSXRlbSBEYXRhIENvbnRleHRcclxuICAgKlxyXG4gICAqIEZvciBleGFtcGxlIHRoZSBTbGlja0dyaWQgb25DbGljayB3aWxsIHJldHVybiBjZWxsIGFyZ3VtZW50cyB3aGVuIHN1YnNjcmliaW5nIHRvIGl0LlxyXG4gICAqIEZyb20gdGhlc2UgY2VsbEFyZ3MsIHdlIHdhbnQgdG8gZ2V0IHRoZSBDb2x1bW4gRGVmaW5pdGlvbiBhbmQgSXRlbSBEYXRhXHJcbiAgICogQHBhcmFtIGNlbGwgZXZlbnQgYXJnc1xyXG4gICAqIEByZXR1cm4gb2JqZWN0IHdpdGggY29sdW1uRGVmIGFuZCBkYXRhQ29udGV4dFxyXG4gICAqL1xyXG4gIGdldENvbHVtbkZyb21FdmVudEFyZ3VtZW50cyhhcmdzOiBDZWxsQXJncyk6IE9uRXZlbnRBcmdzIHtcclxuICAgIGlmICghYXJncyB8fCAhYXJncy5ncmlkIHx8ICFhcmdzLmdyaWQuZ2V0Q29sdW1ucyB8fCAhYXJncy5ncmlkLmdldERhdGFJdGVtKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignVG8gZ2V0IHRoZSBjb2x1bW4gZGVmaW5pdGlvbiBhbmQgZGF0YSwgd2UgbmVlZCB0byBoYXZlIHRoZXNlIGFyZ3VtZW50cyBwYXNzZWQgYXMgb2JqZWN0cyAocm93LCBjZWxsLCBncmlkKScpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHJvdzogYXJncy5yb3csXHJcbiAgICAgIGNlbGw6IGFyZ3MuY2VsbCxcclxuICAgICAgY29sdW1uRGVmOiBhcmdzLmdyaWQuZ2V0Q29sdW1ucygpW2FyZ3MuY2VsbF0sXHJcbiAgICAgIGRhdGFDb250ZXh0OiBhcmdzLmdyaWQuZ2V0RGF0YUl0ZW0oYXJncy5yb3cpLFxyXG4gICAgICBkYXRhVmlldzogdGhpcy5fZGF0YVZpZXcsXHJcbiAgICAgIGdyaWQ6IHRoaXMuX2dyaWRcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKiogR2V0IGRhdGEgaXRlbSBieSBpdCdzIHJvdyBpbmRleCBudW1iZXIgKi9cclxuICBnZXREYXRhSXRlbUJ5Um93TnVtYmVyKHJvd051bWJlcjogbnVtYmVyKSB7XHJcbiAgICBpZiAoIXRoaXMuX2dyaWQgfHwgdHlwZW9mIHRoaXMuX2dyaWQuZ2V0RGF0YUl0ZW0gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBXZSBjb3VsZCBub3QgZmluZCBTbGlja0dyaWQgR3JpZCBvYmplY3Qgb3IgaXQncyBcImdldERhdGFJdGVtXCIgbWV0aG9kYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5fZ3JpZC5nZXREYXRhSXRlbShyb3dOdW1iZXIpO1xyXG4gIH1cclxuXHJcbiAgLyoqIENoYWluIHRoZSBpdGVtIE1ldGFkYXRhIHdpdGggb3VyIGltcGxlbWVudGF0aW9uIG9mIE1ldGFkYXRhIGF0IGdpdmVuIHJvdyBpbmRleCAqL1xyXG4gIGdldEl0ZW1Sb3dNZXRhZGF0YVRvSGlnaGxpZ2h0KHByZXZpb3VzSXRlbU1ldGFkYXRhOiBhbnkpIHtcclxuICAgIHJldHVybiAocm93TnVtYmVyOiBudW1iZXIpID0+IHtcclxuICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX2RhdGFWaWV3LmdldEl0ZW0ocm93TnVtYmVyKTtcclxuICAgICAgbGV0IG1ldGEgPSB7IGNzc0NsYXNzZXM6ICcnIH07XHJcbiAgICAgIGlmICh0eXBlb2YgcHJldmlvdXNJdGVtTWV0YWRhdGEgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBtZXRhID0gcHJldmlvdXNJdGVtTWV0YWRhdGEocm93TnVtYmVyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFtZXRhKSB7XHJcbiAgICAgICAgbWV0YSA9IHsgY3NzQ2xhc3NlczogJycgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5fZGlydHkpIHtcclxuICAgICAgICBtZXRhLmNzc0NsYXNzZXMgPSAobWV0YSAmJiBtZXRhLmNzc0NsYXNzZXMgfHwgJycpICsgJyBkaXJ0eSc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpdGVtICYmIGl0ZW0ucm93Q2xhc3MgJiYgbWV0YSkge1xyXG4gICAgICAgIG1ldGEuY3NzQ2xhc3NlcyArPSBgICR7aXRlbS5yb3dDbGFzc31gO1xyXG4gICAgICAgIG1ldGEuY3NzQ2xhc3NlcyArPSBgIHJvdyR7cm93TnVtYmVyfWA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtZXRhO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhpZ2hsaWdodCB0aGVuIGZhZGUgYSByb3cgZm9yIHggc2Vjb25kcy5cclxuICAgKiBUaGUgaW1wbGVtZW50YXRpb24gZm9sbG93cyB0aGlzIFNPIGFuc3dlcjogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE5OTg1MTQ4LzEyMTIxNjZcclxuICAgKiBAcGFyYW0gcm93TnVtYmVyXHJcbiAgICogQHBhcmFtIGZhZGVEZWxheVxyXG4gICAqL1xyXG4gIGhpZ2hsaWdodFJvdyhyb3dOdW1iZXI6IG51bWJlciB8IG51bWJlcltdLCBmYWRlRGVsYXkgPSAxNTAwLCBmYWRlT3V0RGVsYXkgPSAzMDApIHtcclxuICAgIC8vIGNyZWF0ZSBhIFNlbGVjdGlvbk1vZGVsIGlmIHRoZXJlJ3Mgbm90IG9uZSB5ZXRcclxuICAgIGlmICghdGhpcy5fZ3JpZC5nZXRTZWxlY3Rpb25Nb2RlbCgpICYmIFNsaWNrICYmIFNsaWNrLlJvd1NlbGVjdGlvbk1vZGVsKSB7XHJcbiAgICAgIGNvbnN0IHJvd1NlbGVjdGlvblBsdWdpbiA9IG5ldyBTbGljay5Sb3dTZWxlY3Rpb25Nb2RlbCh0aGlzLl9ncmlkT3B0aW9ucy5yb3dTZWxlY3Rpb25PcHRpb25zIHx8IHt9KTtcclxuICAgICAgdGhpcy5fZ3JpZC5zZXRTZWxlY3Rpb25Nb2RlbChyb3dTZWxlY3Rpb25QbHVnaW4pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHJvd051bWJlcikpIHtcclxuICAgICAgcm93TnVtYmVyLmZvckVhY2gocm93ID0+IHRoaXMuaGlnaGxpZ2h0Um93QnlNZXRhZGF0YShyb3csIGZhZGVEZWxheSwgZmFkZU91dERlbGF5KSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmhpZ2hsaWdodFJvd0J5TWV0YWRhdGEocm93TnVtYmVyLCBmYWRlRGVsYXksIGZhZGVPdXREZWxheSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBoaWdobGlnaHRSb3dCeU1ldGFkYXRhKHJvd051bWJlcjogbnVtYmVyLCBmYWRlRGVsYXkgPSAxNTAwLCBmYWRlT3V0RGVsYXkgPSAzMDApIHtcclxuICAgIHRoaXMuX2RhdGFWaWV3LmdldEl0ZW1NZXRhZGF0YSA9IHRoaXMuZ2V0SXRlbVJvd01ldGFkYXRhVG9IaWdobGlnaHQodGhpcy5fZGF0YVZpZXcuZ2V0SXRlbU1ldGFkYXRhKTtcclxuXHJcbiAgICBjb25zdCBpdGVtID0gdGhpcy5fZGF0YVZpZXcuZ2V0SXRlbShyb3dOdW1iZXIpO1xyXG4gICAgaWYgKGl0ZW0gJiYgaXRlbS5pZCkge1xyXG4gICAgICBpdGVtLnJvd0NsYXNzID0gJ2hpZ2hsaWdodCc7XHJcbiAgICAgIHRoaXMuX2RhdGFWaWV3LnVwZGF0ZUl0ZW0oaXRlbS5pZCwgaXRlbSk7XHJcbiAgICAgIHRoaXMucmVuZGVyR3JpZCgpO1xyXG5cclxuICAgICAgLy8gZmFkZSBvdXRcclxuICAgICAgY2xlYXJUaW1lb3V0KGhpZ2hsaWdodFRpbWVyRW5kKTtcclxuICAgICAgaGlnaGxpZ2h0VGltZXJFbmQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBpdGVtLnJvd0NsYXNzID0gJ2hpZ2hsaWdodC1lbmQnO1xyXG4gICAgICAgIHRoaXMuX2RhdGFWaWV3LnVwZGF0ZUl0ZW0oaXRlbS5pZCwgaXRlbSk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJHcmlkKCk7XHJcbiAgICAgIH0sIGZhZGVPdXREZWxheSk7XHJcblxyXG4gICAgICAvLyBkZWxldGUgdGhlIHJvdydzIENTUyBoaWdobGlnaHQgY2xhc3NlcyBvbmNlIHRoZSBkZWxheSBpcyBwYXNzZWRcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5pZCkge1xyXG4gICAgICAgICAgZGVsZXRlIGl0ZW0ucm93Q2xhc3M7XHJcbiAgICAgICAgICBpZiAodGhpcy5fZGF0YVZpZXcuZ2V0SWR4QnlJZChpdGVtLmlkKSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGFWaWV3LnVwZGF0ZUl0ZW0oaXRlbS5pZCwgaXRlbSk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyR3JpZCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSwgZmFkZURlbGF5ICsgZmFkZU91dERlbGF5KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBHZXQgdGhlIERhdGEgSXRlbSBmcm9tIGEgZ3JpZCByb3cgaW5kZXggKi9cclxuICBnZXREYXRhSXRlbUJ5Um93SW5kZXgoaW5kZXg6IG51bWJlcik6IGFueSB7XHJcbiAgICBpZiAoIXRoaXMuX2dyaWQgfHwgdHlwZW9mIHRoaXMuX2dyaWQuZ2V0RGF0YUl0ZW0gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZSBjb3VsZCBub3QgZmluZCBTbGlja0dyaWQgR3JpZCBvYmplY3QgYW5kL29yIFwiZ2V0RGF0YUl0ZW1cIiBtZXRob2QnKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5fZ3JpZC5nZXREYXRhSXRlbShpbmRleCk7XHJcbiAgfVxyXG5cclxuICAvKiogR2V0IHRoZSBEYXRhIEl0ZW0gZnJvbSBhbiBhcnJheSBvZiBncmlkIHJvdyBpbmRleGVzICovXHJcbiAgZ2V0RGF0YUl0ZW1CeVJvd0luZGV4ZXMoaW5kZXhlczogbnVtYmVyW10pOiBhbnlbXSB7XHJcbiAgICBpZiAoIXRoaXMuX2dyaWQgfHwgdHlwZW9mIHRoaXMuX2dyaWQuZ2V0RGF0YUl0ZW0gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZSBjb3VsZCBub3QgZmluZCBTbGlja0dyaWQgR3JpZCBvYmplY3QgYW5kL29yIFwiZ2V0RGF0YUl0ZW1cIiBtZXRob2QnKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkYXRhSXRlbXMgPSBbXTtcclxuXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbmRleGVzKSkge1xyXG4gICAgICBpbmRleGVzLmZvckVhY2goKGlkeCkgPT4ge1xyXG4gICAgICAgIGRhdGFJdGVtcy5wdXNoKHRoaXMuX2dyaWQuZ2V0RGF0YUl0ZW0oaWR4KSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkYXRhSXRlbXM7XHJcbiAgfVxyXG5cclxuICAvKiogR2V0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgcm93IGluZGV4ZXMgKi9cclxuICBnZXRTZWxlY3RlZFJvd3MoKTogbnVtYmVyW10ge1xyXG4gICAgaWYgKCF0aGlzLl9ncmlkIHx8IHR5cGVvZiB0aGlzLl9ncmlkLmdldFNlbGVjdGVkUm93cyAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlIGNvdWxkIG5vdCBmaW5kIFNsaWNrR3JpZCBHcmlkIG9iamVjdCBhbmQvb3IgXCJnZXRTZWxlY3RlZFJvd3NcIiBtZXRob2QnKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl9ncmlkLmdldFNlbGVjdGVkUm93cygpO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHJvd3MgaXRlbSBkYXRhICovXHJcbiAgZ2V0U2VsZWN0ZWRSb3dzRGF0YUl0ZW0oKTogYW55W10ge1xyXG4gICAgaWYgKCF0aGlzLl9ncmlkIHx8IHR5cGVvZiB0aGlzLl9ncmlkLmdldFNlbGVjdGVkUm93cyAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlIGNvdWxkIG5vdCBmaW5kIFNsaWNrR3JpZCBHcmlkIG9iamVjdCBhbmQvb3IgXCJnZXRTZWxlY3RlZFJvd3NcIiBtZXRob2QnKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzZWxlY3RlZFJvd0luZGV4ZXMgPSB0aGlzLl9ncmlkLmdldFNlbGVjdGVkUm93cygpO1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0RGF0YUl0ZW1CeVJvd0luZGV4ZXMoc2VsZWN0ZWRSb3dJbmRleGVzKTtcclxuICB9XHJcblxyXG4gIC8qKiBTZWxlY3QgdGhlIHNlbGVjdGVkIHJvdyBieSBhIHJvdyBpbmRleCAqL1xyXG4gIHNldFNlbGVjdGVkUm93KHJvd0luZGV4OiBudW1iZXIpIHtcclxuICAgIGlmICh0aGlzLl9ncmlkICYmIHRoaXMuX2dyaWQuc2V0U2VsZWN0ZWRSb3dzKSB7XHJcbiAgICAgIHRoaXMuX2dyaWQuc2V0U2VsZWN0ZWRSb3dzKFtyb3dJbmRleF0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIFNldCBzZWxlY3RlZCByb3dzIHdpdGggcHJvdmlkZWQgYXJyYXkgb2Ygcm93IGluZGV4ZXMgKi9cclxuICBzZXRTZWxlY3RlZFJvd3Mocm93SW5kZXhlczogbnVtYmVyW10pIHtcclxuICAgIGlmICh0aGlzLl9ncmlkICYmIHRoaXMuX2dyaWQuc2V0U2VsZWN0ZWRSb3dzKSB7XHJcbiAgICAgIHRoaXMuX2dyaWQuc2V0U2VsZWN0ZWRSb3dzKHJvd0luZGV4ZXMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIFJlLVJlbmRlciB0aGUgR3JpZCAqL1xyXG4gIHJlbmRlckdyaWQoKSB7XHJcbiAgICBpZiAodGhpcy5fZ3JpZCAmJiB0eXBlb2YgdGhpcy5fZ3JpZC5pbnZhbGlkYXRlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRoaXMuX2dyaWQuaW52YWxpZGF0ZSgpO1xyXG4gICAgICB0aGlzLl9ncmlkLnJlbmRlcigpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgdGhlIGdyaWQgdG8gaXQncyBvcmlnaW5hbCBzdGF0ZSAoY2xlYXIgYW55IGZpbHRlcnMsIHNvcnRpbmcgJiBwYWdpbmF0aW9uIGlmIGV4aXN0cykgLlxyXG4gICAqIFRoZSBjb2x1bW4gZGVmaW5pdGlvbnMgY291bGQgYmUgcGFzc2VkIGFzIGFyZ3VtZW50IHRvIHJlc2V0ICh0aGlzIGNhbiBiZSB1c2VkIGFmdGVyIGEgR3JpZCBTdGF0ZSByZXNldClcclxuICAgKiBUaGUgcmVzZXQgd2lsbCBjbGVhciB0aGUgRmlsdGVycyAmIFNvcnQsIHRoZW4gd2lsbCByZXNldCB0aGUgQ29sdW1ucyB0byB0aGVpciBvcmlnaW5hbCBzdGF0ZVxyXG4gICAqL1xyXG4gIHJlc2V0R3JpZChjb2x1bW5EZWZpbml0aW9ucz86IENvbHVtbltdKSB7XHJcbiAgICAvLyByZXNldCBjb2x1bW5zIHRvIG9yaWdpbmFsIHN0YXRlcyAmIHJlZnJlc2ggdGhlIGdyaWRcclxuICAgIGlmICh0aGlzLl9ncmlkICYmIHRoaXMuX2RhdGFWaWV3KSB7XHJcbiAgICAgIGNvbnN0IG9yaWdpbmFsQ29sdW1ucyA9IHRoaXMuZXh0ZW5zaW9uU2VydmljZS5nZXRBbGxDb2x1bW5zKCk7XHJcblxyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvcmlnaW5hbENvbHVtbnMpICYmIG9yaWdpbmFsQ29sdW1ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgLy8gc2V0IHRoZSBncmlkIGNvbHVtbnMgdG8gaXQncyBvcmlnaW5hbCBjb2x1bW4gZGVmaW5pdGlvbnNcclxuICAgICAgICB0aGlzLl9ncmlkLnNldENvbHVtbnMob3JpZ2luYWxDb2x1bW5zKTtcclxuICAgICAgICBpZiAodGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlQXV0b1NpemVDb2x1bW5zKSB7XHJcbiAgICAgICAgICB0aGlzLl9ncmlkLmF1dG9zaXplQ29sdW1ucygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmdyaWRTdGF0ZVNlcnZpY2UucmVzZXRDb2x1bW5zKGNvbHVtbkRlZmluaXRpb25zKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmZpbHRlclNlcnZpY2UgJiYgdGhpcy5maWx0ZXJTZXJ2aWNlLmNsZWFyRmlsdGVycykge1xyXG4gICAgICB0aGlzLmZpbHRlclNlcnZpY2UuY2xlYXJGaWx0ZXJzKCk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5zb3J0U2VydmljZSAmJiB0aGlzLnNvcnRTZXJ2aWNlLmNsZWFyU29ydGluZykge1xyXG4gICAgICB0aGlzLnNvcnRTZXJ2aWNlLmNsZWFyU29ydGluZygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIEBkZXByZWNhdGVkIHBsZWFzZSB1c2UgXCJhZGRJdGVtXCIgbWV0aG9kIGluc3RlYWQgKi9cclxuICBhZGRJdGVtVG9EYXRhZ3JpZChpdGVtOiBhbnksIHNob3VsZEhpZ2hsaWdodFJvdyA9IHRydWUsIHNob3VsZFJlc29ydEdyaWQgPSBmYWxzZSwgc2hvdWxkVHJpZ2dlckV2ZW50ID0gdHJ1ZSwgc2hvdWxkU2VsZWN0Um93ID0gdHJ1ZSk6IG51bWJlciB7XHJcbiAgICBjb25zb2xlLndhcm4oJ1tBbmd1bGFyLVNsaWNrZ3JpZCAtIEdyaWRTZXJ2aWNlXSBwbGVhc2UgY29uc2lkZXIgdXNpbmcgdGhlIG5ldyBcImFkZEl0ZW1cIiBtZXRob2Qgc2luY2UgXCJhZGRJdGVtVG9EYXRhZ3JpZFwiIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB0aGUgZnV0dXJlLicpO1xyXG4gICAgcmV0dXJuIHRoaXMuYWRkSXRlbShpdGVtLCB7IGhpZ2hsaWdodFJvdzogc2hvdWxkSGlnaGxpZ2h0Um93LCByZXNvcnRHcmlkOiBzaG91bGRSZXNvcnRHcmlkLCB0cmlnZ2VyRXZlbnQ6IHNob3VsZFRyaWdnZXJFdmVudCwgc2VsZWN0Um93OiBzaG91bGRTZWxlY3RSb3cgfSk7XHJcbiAgfVxyXG5cclxuICAvKiogQGRlcHJlY2F0ZWQgcGxlYXNlIHVzZSBcImFkZEl0ZW1zXCIgbWV0aG9kIGluc3RlYWQgKi9cclxuICBhZGRJdGVtc1RvRGF0YWdyaWQoaXRlbXM6IGFueVtdLCBzaG91bGRIaWdobGlnaHRSb3cgPSB0cnVlLCBzaG91bGRSZXNvcnRHcmlkID0gZmFsc2UsIHNob3VsZFRyaWdnZXJFdmVudCA9IHRydWUsIHNob3VsZFNlbGVjdFJvdyA9IHRydWUpOiBudW1iZXJbXSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ1tBbmd1bGFyLVNsaWNrZ3JpZCAtIEdyaWRTZXJ2aWNlXSBwbGVhc2UgY29uc2lkZXIgdXNpbmcgdGhlIG5ldyBcImFkZEl0ZW1zXCIgbWV0aG9kIHNpbmNlIFwiYWRkSXRlbXNUb0RhdGFncmlkXCIgd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUuJyk7XHJcbiAgICByZXR1cm4gdGhpcy5hZGRJdGVtcyhpdGVtcywgeyBoaWdobGlnaHRSb3c6IHNob3VsZEhpZ2hsaWdodFJvdywgcmVzb3J0R3JpZDogc2hvdWxkUmVzb3J0R3JpZCwgdHJpZ2dlckV2ZW50OiBzaG91bGRUcmlnZ2VyRXZlbnQsIHNlbGVjdFJvdzogc2hvdWxkU2VsZWN0Um93IH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGFuIGl0ZW0gKGRhdGEgaXRlbSkgdG8gdGhlIGRhdGFncmlkLCBieSBkZWZhdWx0IGl0IHdpbGwgaGlnaGxpZ2h0IChmbGFzaGluZykgdGhlIGluc2VydGVkIHJvdyBidXQgd2UgY2FuIGRpc2FibGUgaXQgdG9vXHJcbiAgICogQHBhcmFtIGl0ZW0gb2JqZWN0IHdoaWNoIG11c3QgY29udGFpbiBhIHVuaXF1ZSBcImlkXCIgcHJvcGVydHkgYW5kIGFueSBvdGhlciBzdWl0YWJsZSBwcm9wZXJ0aWVzXHJcbiAgICogQHBhcmFtIG9wdGlvbnM6IHByb3ZpZGUgdGhlIHBvc3NpYmlsaXR5IHRvIGRvIGNlcnRhaW4gYWN0aW9ucyBhZnRlciBvciBkdXJpbmcgdGhlIHVwc2VydCAoaGlnaGxpZ2h0Um93LCByZXNvcnRHcmlkLCBzZWxlY3RSb3csIHRyaWdnZXJFdmVudClcclxuICAgKiBAcmV0dXJuIHJvd0luZGV4OiB0eXBpY2FsbHkgaW5kZXggMCB3aGVuIGFkZGluZyB0byBwb3NpdGlvbiBcInRvcFwiIG9yIGEgZGlmZmVyZW50IG51bWJlciB3aGVuIGFkZGluZyB0byB0aGUgXCJib3R0b21cIlxyXG4gICAqL1xyXG4gIGFkZEl0ZW0oaXRlbTogYW55LCBvcHRpb25zPzogR3JpZFNlcnZpY2VJbnNlcnRPcHRpb24pOiBudW1iZXIge1xyXG4gICAgb3B0aW9ucyA9IHsgLi4uR3JpZFNlcnZpY2VJbnNlcnRPcHRpb25EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xyXG5cclxuICAgIGlmICghdGhpcy5fZ3JpZCB8fCAhdGhpcy5fZ3JpZE9wdGlvbnMgfHwgIXRoaXMuX2RhdGFWaWV3KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2UgY291bGQgbm90IGZpbmQgU2xpY2tHcmlkIEdyaWQsIERhdGFWaWV3IG9iamVjdHMnKTtcclxuICAgIH1cclxuICAgIGlmICghaXRlbSB8fCAhaXRlbS5oYXNPd25Qcm9wZXJ0eSgnaWQnKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFkZGluZyBhbiBpdGVtIHJlcXVpcmVzIHRoZSBpdGVtIHRvIGluY2x1ZGUgYW4gXCJpZFwiIHByb3BlcnR5YCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaW5zZXJ0IHBvc2l0aW9uIHRvcC9ib3R0b20sIGRlZmF1bHRzIHRvIHRvcFxyXG4gICAgLy8gd2hlbiBwb3NpdGlvbiBpcyB0b3Agd2UnbGwgY2FsbCBpbnNlcnQgYXQgaW5kZXggMCwgZWxzZSBjYWxsIGFkZEl0ZW0gd2hpY2gganVzdCBwdXNoIHRvIHRoZSBEYXRhVmlldyBhcnJheVxyXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcclxuICAgICAgdGhpcy5fZGF0YVZpZXcuYWRkSXRlbShpdGVtKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX2RhdGFWaWV3Lmluc2VydEl0ZW0oMCwgaXRlbSk7IC8vIGluc2VydCBhdCBpbmRleCAwXHJcbiAgICB9XHJcblxyXG4gICAgLy8gcm93IG51bWJlciBpbiB0aGUgZ3JpZCwgYnkgZGVmYXVsdCBpdCB3aWxsIGJlIG9uIGZpcnN0IHJvdyAodG9wIGlzIHRoZSBkZWZhdWx0KVxyXG4gICAgbGV0IHJvd051bWJlciA9IDA7XHJcblxyXG4gICAgLy8gZG8gd2Ugd2FudCB0aGUgaXRlbSB0byBiZSBzb3J0ZWQgaW4gdGhlIGdyaWQsIHdoZW4gc2V0IHRvIEZhbHNlIGl0IHdpbGwgaW5zZXJ0IG9uIGZpcnN0IHJvdyAoZGVmYXVsdHMgdG8gZmFsc2UpXHJcbiAgICBpZiAob3B0aW9ucy5yZXNvcnRHcmlkKSB7XHJcbiAgICAgIHRoaXMuX2RhdGFWaWV3LnJlU29ydCgpO1xyXG5cclxuICAgICAgLy8gZmluZCB0aGUgcm93IG51bWJlciBpbiB0aGUgZ3JpZCBhbmQgaWYgdXNlciB3YW50ZWQgdG8gc2VlIGhpZ2hsaWdodGVkIHJvd1xyXG4gICAgICAvLyB3ZSBuZWVkIHRvIGRvIGl0IGhlcmUgYWZ0ZXIgcmVzb3J0IGFuZCBnZXQgZWFjaCByb3cgbnVtYmVyIGJlY2F1c2UgaXQgcG9zc2libHkgY2hhbmdlcyBhZnRlciB0aGUgc29ydFxyXG4gICAgICByb3dOdW1iZXIgPSB0aGlzLl9kYXRhVmlldy5nZXRSb3dCeUlkKGl0ZW0uaWQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gc2Nyb2xsIHRvIHJvdyBpbmRleCAwIHdoZW4gaW5zZXJ0aW5nIG9uIHRvcCBlbHNlIHNjcm9sbCB0byB0aGUgYm90dG9tIHdoZXJlIGl0IGdvdCBpbnNlcnRlZFxyXG4gICAgICByb3dOdW1iZXIgPSAob3B0aW9ucyAmJiBvcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJykgPyB0aGlzLl9kYXRhVmlldy5nZXRSb3dCeUlkKGl0ZW0uaWQpIDogMDtcclxuICAgICAgdGhpcy5fZ3JpZC5zY3JvbGxSb3dJbnRvVmlldyhyb3dOdW1iZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIGhpZ2hsaWdodCBpcyBlbmFibGVkLCB3ZSdsbCBoaWdobGlnaHQgdGhlIHJvdyB3ZSBqdXN0IGFkZGVkXHJcbiAgICBpZiAob3B0aW9ucy5oaWdobGlnaHRSb3cpIHtcclxuICAgICAgdGhpcy5oaWdobGlnaHRSb3cocm93TnVtYmVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpZiByb3cgc2VsZWN0aW9uIChjaGVja2JveCBzZWxlY3RvcikgaXMgZW5hYmxlZCwgd2UnbGwgc2VsZWN0IHRoZSByb3cgaW4gdGhlIGdyaWRcclxuICAgIGlmIChvcHRpb25zLnNlbGVjdFJvdyAmJiB0aGlzLl9ncmlkT3B0aW9ucyAmJiAodGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlQ2hlY2tib3hTZWxlY3RvciB8fCB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVSb3dTZWxlY3Rpb24pKSB7XHJcbiAgICAgIHRoaXMuc2V0U2VsZWN0ZWRSb3cocm93TnVtYmVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBkbyB3ZSB3YW50IHRvIHRyaWdnZXIgYW4gZXZlbnQgYWZ0ZXIgYWRkaW5nIHRoZSBpdGVtXHJcbiAgICBpZiAob3B0aW9ucy50cmlnZ2VyRXZlbnQpIHtcclxuICAgICAgdGhpcy5vbkl0ZW1BZGRlZC5uZXh0KGl0ZW0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByb3dOdW1iZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGQgaXRlbSBhcnJheSAoZGF0YSBpdGVtKSB0byB0aGUgZGF0YWdyaWQsIGJ5IGRlZmF1bHQgaXQgd2lsbCBoaWdobGlnaHQgKGZsYXNoaW5nKSB0aGUgaW5zZXJ0ZWQgcm93IGJ1dCB3ZSBjYW4gZGlzYWJsZSBpdCB0b29cclxuICAgKiBAcGFyYW0gaXRlbSBvYmplY3QgYXJyYXlzLCB3aGljaCBtdXN0IGNvbnRhaW4gdW5pcXVlIFwiaWRcIiBwcm9wZXJ0eSBhbmQgYW55IG90aGVyIHN1aXRhYmxlIHByb3BlcnRpZXNcclxuICAgKiBAcGFyYW0gb3B0aW9uczogcHJvdmlkZSB0aGUgcG9zc2liaWxpdHkgdG8gZG8gY2VydGFpbiBhY3Rpb25zIGFmdGVyIG9yIGR1cmluZyB0aGUgdXBzZXJ0IChoaWdobGlnaHRSb3csIHJlc29ydEdyaWQsIHNlbGVjdFJvdywgdHJpZ2dlckV2ZW50KVxyXG4gICAqL1xyXG4gIGFkZEl0ZW1zKGl0ZW1zOiBhbnkgfCBhbnlbXSwgb3B0aW9ucz86IEdyaWRTZXJ2aWNlSW5zZXJ0T3B0aW9uKTogbnVtYmVyW10ge1xyXG4gICAgb3B0aW9ucyA9IHsgLi4uR3JpZFNlcnZpY2VJbnNlcnRPcHRpb25EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xyXG4gICAgY29uc3Qgcm93TnVtYmVyczogbnVtYmVyW10gPSBbXTtcclxuXHJcbiAgICAvLyBsb29wIHRocm91Z2ggYWxsIGl0ZW1zIHRvIGFkZFxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xyXG4gICAgICByZXR1cm4gW3RoaXMuYWRkSXRlbShpdGVtcywgb3B0aW9ucyldO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbTogYW55KSA9PiB0aGlzLmFkZEl0ZW0oaXRlbSwgeyAuLi5vcHRpb25zLCBoaWdobGlnaHRSb3c6IGZhbHNlLCByZXNvcnRHcmlkOiBmYWxzZSwgdHJpZ2dlckV2ZW50OiBmYWxzZSwgc2VsZWN0Um93OiBmYWxzZSB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZG8gd2Ugd2FudCB0aGUgaXRlbSB0byBiZSBzb3J0ZWQgaW4gdGhlIGdyaWQsIHdoZW4gc2V0IHRvIEZhbHNlIGl0IHdpbGwgaW5zZXJ0IG9uIGZpcnN0IHJvdyAoZGVmYXVsdHMgdG8gZmFsc2UpXHJcbiAgICBpZiAob3B0aW9ucy5yZXNvcnRHcmlkKSB7XHJcbiAgICAgIHRoaXMuX2RhdGFWaWV3LnJlU29ydCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNjcm9sbCB0byByb3cgaW5kZXggMCB3aGVuIGluc2VydGluZyBvbiB0b3AgZWxzZSBzY3JvbGwgdG8gdGhlIGJvdHRvbSB3aGVyZSBpdCBnb3QgaW5zZXJ0ZWRcclxuICAgIChvcHRpb25zICYmIG9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nKSA/IHRoaXMuX2dyaWQubmF2aWdhdGVCb3R0b20oKSA6IHRoaXMuX2dyaWQubmF2aWdhdGVUb3AoKTtcclxuXHJcbiAgICAvLyBnZXQgcm93IG51bWJlcnMgb2YgYWxsIG5ldyBpbnNlcnRlZCBpdGVtc1xyXG4gICAgLy8gd2UgbmVlZCB0byBkbyBpdCBhZnRlciByZXNvcnQgYW5kIGdldCBlYWNoIHJvdyBudW1iZXIgYmVjYXVzZSBpdCBwb3NzaWJseSBjaGFuZ2VkIGFmdGVyIHRoZSBzb3J0XHJcbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtOiBhbnkpID0+IHJvd051bWJlcnMucHVzaCh0aGlzLl9kYXRhVmlldy5nZXRSb3dCeUlkKGl0ZW0uaWQpKSk7XHJcblxyXG4gICAgLy8gaWYgdXNlciB3YW50ZWQgdG8gc2VlIGhpZ2hsaWdodGVkIHJvd1xyXG4gICAgaWYgKG9wdGlvbnMuaGlnaGxpZ2h0Um93KSB7XHJcbiAgICAgIHRoaXMuaGlnaGxpZ2h0Um93KHJvd051bWJlcnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNlbGVjdCB0aGUgcm93IGluIHRoZSBncmlkXHJcbiAgICBpZiAob3B0aW9ucy5zZWxlY3RSb3cgJiYgdGhpcy5fZ3JpZE9wdGlvbnMgJiYgKHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZUNoZWNrYm94U2VsZWN0b3IgfHwgdGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlUm93U2VsZWN0aW9uKSkge1xyXG4gICAgICB0aGlzLnNldFNlbGVjdGVkUm93cyhyb3dOdW1iZXJzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBkbyB3ZSB3YW50IHRvIHRyaWdnZXIgYW4gZXZlbnQgYWZ0ZXIgYWRkaW5nIHRoZSBpdGVtXHJcbiAgICBpZiAob3B0aW9ucy50cmlnZ2VyRXZlbnQpIHtcclxuICAgICAgdGhpcy5vbkl0ZW1BZGRlZC5uZXh0KGl0ZW1zKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcm93TnVtYmVycztcclxuICB9XHJcblxyXG4gIC8qKiBAZGVwcmVjYXRlZCBwbGVhc2UgdXNlIFwiZGVsZXRlSXRlbVwiIG1ldGhvZCBpbnN0ZWFkICovXHJcbiAgZGVsZXRlRGF0YUdyaWRJdGVtKGl0ZW06IGFueSwgc2hvdWxkVHJpZ2dlckV2ZW50ID0gdHJ1ZSkge1xyXG4gICAgY29uc29sZS53YXJuKCdbQW5ndWxhci1TbGlja2dyaWQgLSBHcmlkU2VydmljZV0gcGxlYXNlIGNvbnNpZGVyIHVzaW5nIHRoZSBuZXcgXCJkZWxldGVJdGVtXCIgbWV0aG9kIHNpbmNlIFwiZGVsZXRlRGF0YUdyaWRJdGVtXCIgd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUuJyk7XHJcbiAgICB0aGlzLmRlbGV0ZUl0ZW0oaXRlbSwgeyB0cmlnZ2VyRXZlbnQ6IHNob3VsZFRyaWdnZXJFdmVudCB9KTtcclxuICB9XHJcblxyXG4gIC8qKiBAZGVwcmVjYXRlZCBwbGVhc2UgdXNlIFwiZGVsZXRlSXRlbXNcIiBtZXRob2QgaW5zdGVhZCAqL1xyXG4gIGRlbGV0ZURhdGFHcmlkSXRlbXMoaXRlbXM6IGFueVtdLCBzaG91bGRUcmlnZ2VyRXZlbnQgPSB0cnVlKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ1tBbmd1bGFyLVNsaWNrZ3JpZCAtIEdyaWRTZXJ2aWNlXSBwbGVhc2UgY29uc2lkZXIgdXNpbmcgdGhlIG5ldyBcImRlbGV0ZUl0ZW1zXCIgbWV0aG9kIHNpbmNlIFwiZGVsZXRlRGF0YUdyaWRJdGVtc1wiIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB0aGUgZnV0dXJlLicpO1xyXG4gICAgdGhpcy5kZWxldGVJdGVtcyhpdGVtcywgeyB0cmlnZ2VyRXZlbnQ6IHNob3VsZFRyaWdnZXJFdmVudCB9KTtcclxuICB9XHJcblxyXG4gIC8qKiBAZGVwcmVjYXRlZCBwbGVhc2UgdXNlIFwiZGVsZXRlSXRlbUJ5SWRcIiBtZXRob2QgaW5zdGVhZCAqL1xyXG4gIGRlbGV0ZURhdGFHcmlkSXRlbUJ5SWQoaXRlbUlkOiBzdHJpbmcgfCBudW1iZXIsIHNob3VsZFRyaWdnZXJFdmVudCA9IHRydWUpIHtcclxuICAgIGNvbnNvbGUud2FybignW0FuZ3VsYXItU2xpY2tncmlkIC0gR3JpZFNlcnZpY2VdIHBsZWFzZSBjb25zaWRlciB1c2luZyB0aGUgbmV3IFwiZGVsZXRlSXRlbUJ5SWRcIiBtZXRob2Qgc2luY2UgXCJkZWxldGVEYXRhR3JpZEl0ZW1CeUlkXCIgd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUuJyk7XHJcbiAgICB0aGlzLmRlbGV0ZUl0ZW1CeUlkKGl0ZW1JZCwgeyB0cmlnZ2VyRXZlbnQ6IHNob3VsZFRyaWdnZXJFdmVudCB9KTtcclxuICB9XHJcblxyXG4gIC8qKiBAZGVwcmVjYXRlZCBwbGVhc2UgdXNlIFwiZGVsZXRlSXRlbUJ5SWRzXCIgbWV0aG9kIGluc3RlYWQgKi9cclxuICBkZWxldGVEYXRhR3JpZEl0ZW1CeUlkcyhpdGVtSWRzOiBudW1iZXJbXSB8IHN0cmluZ1tdLCBzaG91bGRUcmlnZ2VyRXZlbnQgPSB0cnVlKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ1tBbmd1bGFyLVNsaWNrZ3JpZCAtIEdyaWRTZXJ2aWNlXSBwbGVhc2UgY29uc2lkZXIgdXNpbmcgdGhlIG5ldyBcImRlbGV0ZUl0ZW1CeUlkc1wiIG1ldGhvZCBzaW5jZSBcImRlbGV0ZURhdGFHcmlkSXRlbUJ5SWRzXCIgd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUuJyk7XHJcbiAgICB0aGlzLmRlbGV0ZUl0ZW1CeUlkcyhpdGVtSWRzLCB7IHRyaWdnZXJFdmVudDogc2hvdWxkVHJpZ2dlckV2ZW50IH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVsZXRlIGFuIGV4aXN0aW5nIGl0ZW0gZnJvbSB0aGUgZGF0YWdyaWQgKGRhdGFWaWV3KVxyXG4gICAqIEBwYXJhbSBpdGVtIG9iamVjdCB3aGljaCBtdXN0IGNvbnRhaW4gYSB1bmlxdWUgXCJpZFwiIHByb3BlcnR5IGFuZCBhbnkgb3RoZXIgc3VpdGFibGUgcHJvcGVydGllc1xyXG4gICAqIEBwYXJhbSBvcHRpb25zOiBwcm92aWRlIHRoZSBwb3NzaWJpbGl0eSB0byBkbyBjZXJ0YWluIGFjdGlvbnMgYWZ0ZXIgb3IgZHVyaW5nIHRoZSB1cHNlcnQgKHRyaWdnZXJFdmVudClcclxuICAgKiBAcmV0dXJuIGl0ZW0gaWQgZGVsZXRlZFxyXG4gICAqL1xyXG4gIGRlbGV0ZUl0ZW0oaXRlbTogYW55LCBvcHRpb25zPzogR3JpZFNlcnZpY2VEZWxldGVPcHRpb24pOiBudW1iZXIgfCBzdHJpbmcge1xyXG4gICAgb3B0aW9ucyA9IHsgLi4uR3JpZFNlcnZpY2VEZWxldGVPcHRpb25EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xyXG5cclxuICAgIGlmICghaXRlbSB8fCAhaXRlbS5oYXNPd25Qcm9wZXJ0eSgnaWQnKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYERlbGV0aW5nIGFuIGl0ZW0gcmVxdWlyZXMgdGhlIGl0ZW0gdG8gaW5jbHVkZSBhbiBcImlkXCIgcHJvcGVydHlgKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmRlbGV0ZUl0ZW1CeUlkKGl0ZW0uaWQsIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVsZXRlIGFuIGFycmF5IG9mIGV4aXN0aW5nIGl0ZW1zIGZyb20gdGhlIGRhdGFncmlkXHJcbiAgICogQHBhcmFtIGl0ZW0gb2JqZWN0IHdoaWNoIG11c3QgY29udGFpbiBhIHVuaXF1ZSBcImlkXCIgcHJvcGVydHkgYW5kIGFueSBvdGhlciBzdWl0YWJsZSBwcm9wZXJ0aWVzXHJcbiAgICogQHBhcmFtIG9wdGlvbnM6IHByb3ZpZGUgdGhlIHBvc3NpYmlsaXR5IHRvIGRvIGNlcnRhaW4gYWN0aW9ucyBhZnRlciBvciBkdXJpbmcgdGhlIHVwc2VydCAodHJpZ2dlckV2ZW50KVxyXG4gICAqIEByZXR1cm4gaXRlbSBpZCBkZWxldGVkXHJcbiAgICovXHJcbiAgZGVsZXRlSXRlbXMoaXRlbXM6IGFueSB8IGFueVtdLCBvcHRpb25zPzogR3JpZFNlcnZpY2VEZWxldGVPcHRpb24pOiBudW1iZXJbXSB8IHN0cmluZ1tdIHtcclxuICAgIG9wdGlvbnMgPSB7IC4uLkdyaWRTZXJ2aWNlRGVsZXRlT3B0aW9uRGVmYXVsdHMsIC4uLm9wdGlvbnMgfTtcclxuXHJcbiAgICAvLyB3aGVuIGl0J3Mgbm90IGFuIGFycmF5LCB3ZSBjYW4gY2FsbCBkaXJlY3RseSB0aGUgc2luZ2xlIGl0ZW0gZGVsZXRlXHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XHJcbiAgICAgIHRoaXMuZGVsZXRlSXRlbShpdGVtcywgb3B0aW9ucyk7XHJcbiAgICAgIHJldHVybiBbaXRlbXMuaWRdO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaXRlbUlkcyA9IFtdO1xyXG4gICAgaXRlbXMuZm9yRWFjaCgoaXRlbTogYW55KSA9PiB7XHJcbiAgICAgIGlmIChpdGVtICYmIGl0ZW0uaWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGl0ZW1JZHMucHVzaChpdGVtLmlkKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmRlbGV0ZUl0ZW0oaXRlbSwgeyAuLi5vcHRpb25zLCB0cmlnZ2VyRXZlbnQ6IGZhbHNlIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gZG8gd2Ugd2FudCB0byB0cmlnZ2VyIGFuIGV2ZW50IGFmdGVyIGRlbGV0aW5nIHRoZSBpdGVtXHJcbiAgICBpZiAob3B0aW9ucy50cmlnZ2VyRXZlbnQpIHtcclxuICAgICAgdGhpcy5vbkl0ZW1EZWxldGVkLm5leHQoaXRlbXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGl0ZW1JZHM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZWxldGUgYW4gZXhpc3RpbmcgaXRlbSBmcm9tIHRoZSBkYXRhZ3JpZCAoZGF0YVZpZXcpIGJ5IGl0J3MgaWRcclxuICAgKiBAcGFyYW0gaXRlbUlkOiBpdGVtIHVuaXF1ZSBpZFxyXG4gICAqIEBwYXJhbSBvcHRpb25zOiBwcm92aWRlIHRoZSBwb3NzaWJpbGl0eSB0byBkbyBjZXJ0YWluIGFjdGlvbnMgYWZ0ZXIgb3IgZHVyaW5nIHRoZSB1cHNlcnQgKHRyaWdnZXJFdmVudClcclxuICAgKiBAcmV0dXJuIGl0ZW0gaWQgZGVsZXRlZFxyXG4gICAqL1xyXG4gIGRlbGV0ZUl0ZW1CeUlkKGl0ZW1JZDogc3RyaW5nIHwgbnVtYmVyLCBvcHRpb25zPzogR3JpZFNlcnZpY2VEZWxldGVPcHRpb24pOiBudW1iZXIgfCBzdHJpbmcge1xyXG4gICAgb3B0aW9ucyA9IHsgLi4uR3JpZFNlcnZpY2VEZWxldGVPcHRpb25EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xyXG5cclxuICAgIGlmIChpdGVtSWQgPT09IG51bGwgfHwgaXRlbUlkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZGVsZXRlIGEgcm93IHdpdGhvdXQgYSB2YWxpZCBcImlkXCJgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB3aGVuIHVzZXIgaGFzIHJvdyBzZWxlY3Rpb24gZW5hYmxlZCwgd2Ugc2hvdWxkIGNsZWFyIGFueSBzZWxlY3Rpb24gdG8gYXZvaWQgY29uZnVzaW9uIGFmdGVyIGEgZGVsZXRlXHJcbiAgICBjb25zdCBpc1N5bmNHcmlkU2VsZWN0aW9uRW5hYmxlZCA9IHRoaXMuZ3JpZFN0YXRlU2VydmljZSAmJiB0aGlzLmdyaWRTdGF0ZVNlcnZpY2UubmVlZFRvUHJlc2VydmVSb3dTZWxlY3Rpb24oKSB8fCBmYWxzZTtcclxuICAgIGlmICghaXNTeW5jR3JpZFNlbGVjdGlvbkVuYWJsZWQgJiYgdGhpcy5fZ3JpZCAmJiB0aGlzLl9ncmlkT3B0aW9ucyAmJiAodGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlQ2hlY2tib3hTZWxlY3RvciB8fCB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVSb3dTZWxlY3Rpb24pKSB7XHJcbiAgICAgIHRoaXMuc2V0U2VsZWN0ZWRSb3dzKFtdKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBkZWxldGUgdGhlIGl0ZW0gZnJvbSB0aGUgZGF0YVZpZXdcclxuICAgIHRoaXMuX2RhdGFWaWV3LmRlbGV0ZUl0ZW0oaXRlbUlkKTtcclxuXHJcbiAgICAvLyBkbyB3ZSB3YW50IHRvIHRyaWdnZXIgYW4gZXZlbnQgYWZ0ZXIgZGVsZXRpbmcgdGhlIGl0ZW1cclxuICAgIGlmIChvcHRpb25zLnRyaWdnZXJFdmVudCkge1xyXG4gICAgICB0aGlzLm9uSXRlbURlbGV0ZWQubmV4dChpdGVtSWQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGl0ZW1JZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlbGV0ZSBhbiBhcnJheSBvZiBleGlzdGluZyBpdGVtcyBmcm9tIHRoZSBkYXRhZ3JpZFxyXG4gICAqIEBwYXJhbSBpdGVtSWRzIGFycmF5IG9mIGl0ZW0gdW5pcXVlIElEc1xyXG4gICAqIEBwYXJhbSBvcHRpb25zOiBwcm92aWRlIHRoZSBwb3NzaWJpbGl0eSB0byBkbyBjZXJ0YWluIGFjdGlvbnMgYWZ0ZXIgb3IgZHVyaW5nIHRoZSB1cHNlcnQgKHRyaWdnZXJFdmVudClcclxuICAgKi9cclxuICBkZWxldGVJdGVtQnlJZHMoaXRlbUlkczogbnVtYmVyW10gfCBzdHJpbmdbXSwgb3B0aW9ucz86IEdyaWRTZXJ2aWNlRGVsZXRlT3B0aW9uKTogbnVtYmVyW10gfCBzdHJpbmdbXSB7XHJcbiAgICBvcHRpb25zID0geyAuLi5HcmlkU2VydmljZURlbGV0ZU9wdGlvbkRlZmF1bHRzLCAuLi5vcHRpb25zIH07XHJcblxyXG4gICAgLy8gd2hlbiBpdCdzIG5vdCBhbiBhcnJheSwgd2UgY2FuIGNhbGwgZGlyZWN0bHkgdGhlIHNpbmdsZSBpdGVtIGRlbGV0ZVxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbUlkcykpIHtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtSWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGl0ZW1JZHNbaV0gIT09IG51bGwpIHtcclxuICAgICAgICAgIHRoaXMuZGVsZXRlSXRlbUJ5SWQoaXRlbUlkc1tpXSwgeyB0cmlnZ2VyRXZlbnQ6IGZhbHNlIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZG8gd2Ugd2FudCB0byB0cmlnZ2VyIGFuIGV2ZW50IGFmdGVyIGRlbGV0aW5nIHRoZSBpdGVtXHJcbiAgICAgIGlmIChvcHRpb25zLnRyaWdnZXJFdmVudCkge1xyXG4gICAgICAgIHRoaXMub25JdGVtRGVsZXRlZC5uZXh0KGl0ZW1JZHMpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBpdGVtSWRzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBkZXByZWNhdGVkIHBsZWFzZSB1c2UgXCJ1cGRhdGVJdGVtXCIgbWV0aG9kIGluc3RlYWQgKi9cclxuICB1cGRhdGVEYXRhR3JpZEl0ZW0oaXRlbTogYW55LCBzaG91bGRIaWdobGlnaHRSb3cgPSB0cnVlLCBzaG91bGRUcmlnZ2VyRXZlbnQgPSB0cnVlLCBzaG91bGRTZWxlY3RSb3cgPSB0cnVlKTogbnVtYmVyIHtcclxuICAgIGNvbnNvbGUud2FybignW0FuZ3VsYXItU2xpY2tncmlkIC0gR3JpZFNlcnZpY2VdIHBsZWFzZSBjb25zaWRlciB1c2luZyB0aGUgbmV3IFwidXBkYXRlSXRlbVwiIG1ldGhvZCBzaW5jZSBcInVwZGF0ZURhdGFHcmlkSXRlbVwiIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB0aGUgZnV0dXJlLicpO1xyXG4gICAgcmV0dXJuIHRoaXMudXBkYXRlSXRlbShpdGVtLCB7IGhpZ2hsaWdodFJvdzogc2hvdWxkSGlnaGxpZ2h0Um93LCB0cmlnZ2VyRXZlbnQ6IHNob3VsZFRyaWdnZXJFdmVudCwgc2VsZWN0Um93OiBzaG91bGRTZWxlY3RSb3cgfSk7XHJcbiAgfVxyXG5cclxuICAvKiogQGRlcHJlY2F0ZWQgcGxlYXNlIHVzZSBcInVwZGF0ZUl0ZW1zXCIgbWV0aG9kIGluc3RlYWQgKi9cclxuICB1cGRhdGVEYXRhR3JpZEl0ZW1zKGl0ZW1zOiBhbnkgfCBhbnlbXSwgc2hvdWxkSGlnaGxpZ2h0Um93ID0gdHJ1ZSwgc2hvdWxkVHJpZ2dlckV2ZW50ID0gdHJ1ZSwgc2hvdWxkU2VsZWN0Um93ID0gdHJ1ZSk6IG51bWJlcltdIHtcclxuICAgIGNvbnNvbGUud2FybignW0FuZ3VsYXItU2xpY2tncmlkIC0gR3JpZFNlcnZpY2VdIHBsZWFzZSBjb25zaWRlciB1c2luZyB0aGUgbmV3IFwidXBkYXRlSXRlbXNcIiBtZXRob2Qgc2luY2UgXCJ1cGRhdGVEYXRhR3JpZEl0ZW1zXCIgd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUuJyk7XHJcbiAgICByZXR1cm4gdGhpcy51cGRhdGVJdGVtcyhpdGVtcywgeyBoaWdobGlnaHRSb3c6IHNob3VsZEhpZ2hsaWdodFJvdywgdHJpZ2dlckV2ZW50OiBzaG91bGRUcmlnZ2VyRXZlbnQsIHNlbGVjdFJvdzogc2hvdWxkU2VsZWN0Um93IH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBkZXByZWNhdGVkIHBsZWFzZSB1c2UgXCJ1cGRhdGVJdGVtQnlJZFwiIG1ldGhvZCBpbnN0ZWFkICovXHJcbiAgdXBkYXRlRGF0YUdyaWRJdGVtQnlJZChpdGVtSWQ6IG51bWJlciB8IHN0cmluZywgaXRlbTogYW55LCBzaG91bGRIaWdobGlnaHRSb3cgPSB0cnVlLCBzaG91bGRUcmlnZ2VyRXZlbnQgPSB0cnVlLCBzaG91bGRTZWxlY3RSb3cgPSB0cnVlKTogbnVtYmVyIHtcclxuICAgIGNvbnNvbGUud2FybignW0FuZ3VsYXItU2xpY2tncmlkIC0gR3JpZFNlcnZpY2VdIHBsZWFzZSBjb25zaWRlciB1c2luZyB0aGUgbmV3IFwidXBkYXRlSXRlbUJ5SWRcIiBtZXRob2Qgc2luY2UgXCJ1cGRhdGVEYXRhR3JpZEl0ZW1CeUlkXCIgd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUuJyk7XHJcbiAgICByZXR1cm4gdGhpcy51cGRhdGVJdGVtQnlJZChpdGVtSWQsIGl0ZW0sIHsgaGlnaGxpZ2h0Um93OiBzaG91bGRIaWdobGlnaHRSb3csIHRyaWdnZXJFdmVudDogc2hvdWxkVHJpZ2dlckV2ZW50LCBzZWxlY3RSb3c6IHNob3VsZFNlbGVjdFJvdyB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBhbiBleGlzdGluZyBpdGVtIHdpdGggbmV3IHByb3BlcnRpZXMgaW5zaWRlIHRoZSBkYXRhZ3JpZFxyXG4gICAqIEBwYXJhbSBpdGVtIG9iamVjdCB3aGljaCBtdXN0IGNvbnRhaW4gYSB1bmlxdWUgXCJpZFwiIHByb3BlcnR5IGFuZCBhbnkgb3RoZXIgc3VpdGFibGUgcHJvcGVydGllc1xyXG4gICAqIEBwYXJhbSBvcHRpb25zOiBwcm92aWRlIHRoZSBwb3NzaWJpbGl0eSB0byBkbyBjZXJ0YWluIGFjdGlvbnMgYWZ0ZXIgb3IgZHVyaW5nIHRoZSB1cHNlcnQgKGhpZ2hsaWdodFJvdywgc2VsZWN0Um93LCB0cmlnZ2VyRXZlbnQpXHJcbiAgICogQHJldHVybiBncmlkIHJvdyBpbmRleFxyXG4gICAqL1xyXG4gIHVwZGF0ZUl0ZW0oaXRlbTogYW55LCBvcHRpb25zPzogR3JpZFNlcnZpY2VVcGRhdGVPcHRpb24pOiBudW1iZXIge1xyXG4gICAgb3B0aW9ucyA9IHsgLi4uR3JpZFNlcnZpY2VVcGRhdGVPcHRpb25EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xyXG4gICAgY29uc3QgaXRlbUlkID0gKCFpdGVtIHx8ICFpdGVtLmhhc093blByb3BlcnR5KCdpZCcpKSA/IHVuZGVmaW5lZCA6IGl0ZW0uaWQ7XHJcblxyXG4gICAgaWYgKGl0ZW1JZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FsbGluZyBVcGRhdGUgb2YgYW4gaXRlbSByZXF1aXJlcyB0aGUgaXRlbSB0byBpbmNsdWRlIGFuIFwiaWRcIiBwcm9wZXJ0eWApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLnVwZGF0ZUl0ZW1CeUlkKGl0ZW1JZCwgaXRlbSwgb3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgYW4gYXJyYXkgb2YgZXhpc3RpbmcgaXRlbXMgd2l0aCBuZXcgcHJvcGVydGllcyBpbnNpZGUgdGhlIGRhdGFncmlkXHJcbiAgICogQHBhcmFtIGl0ZW0gb2JqZWN0IGFycmF5cywgd2hpY2ggbXVzdCBjb250YWluIHVuaXF1ZSBcImlkXCIgcHJvcGVydHkgYW5kIGFueSBvdGhlciBzdWl0YWJsZSBwcm9wZXJ0aWVzXHJcbiAgICogQHBhcmFtIG9wdGlvbnM6IHByb3ZpZGUgdGhlIHBvc3NpYmlsaXR5IHRvIGRvIGNlcnRhaW4gYWN0aW9ucyBhZnRlciBvciBkdXJpbmcgdGhlIHVwc2VydCAoaGlnaGxpZ2h0Um93LCBzZWxlY3RSb3csIHRyaWdnZXJFdmVudClcclxuICAgKiBAcmV0dXJuIGdyaWQgcm93IGluZGV4ZXNcclxuICAgKi9cclxuICB1cGRhdGVJdGVtcyhpdGVtczogYW55IHwgYW55W10sIG9wdGlvbnM/OiBHcmlkU2VydmljZVVwZGF0ZU9wdGlvbik6IG51bWJlcltdIHtcclxuICAgIG9wdGlvbnMgPSB7IC4uLkdyaWRTZXJ2aWNlVXBkYXRlT3B0aW9uRGVmYXVsdHMsIC4uLm9wdGlvbnMgfTtcclxuXHJcbiAgICAvLyB3aGVuIGl0J3Mgbm90IGFuIGFycmF5LCB3ZSBjYW4gY2FsbCBkaXJlY3RseSB0aGUgc2luZ2xlIGl0ZW0gdXBkYXRlXHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XHJcbiAgICAgIHJldHVybiBbdGhpcy51cGRhdGVJdGVtKGl0ZW1zLCBvcHRpb25zKV07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZ3JpZFJvd051bWJlcnM6IG51bWJlcltdID0gW107XHJcbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtOiBhbnkpID0+IHtcclxuICAgICAgZ3JpZFJvd051bWJlcnMucHVzaCh0aGlzLnVwZGF0ZUl0ZW0oaXRlbSwgeyAuLi5vcHRpb25zLCBoaWdobGlnaHRSb3c6IGZhbHNlLCBzZWxlY3RSb3c6IGZhbHNlLCB0cmlnZ2VyRXZlbnQ6IGZhbHNlIH0pKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIG9ubHkgaGlnaGxpZ2h0IGF0IHRoZSBlbmQsIGFsbCBhdCBvbmNlXHJcbiAgICAvLyB3ZSBoYXZlIHRvIGRvIHRoaXMgYmVjYXVzZSBkb2luZyBoaWdobGlnaHQgMSBieSAxIHdvdWxkIG9ubHkgcmUtc2VsZWN0IHRoZSBsYXN0IGhpZ2hsaWdodGVkIHJvdyB3aGljaCBpcyB3cm9uZyBiZWhhdmlvclxyXG4gICAgaWYgKG9wdGlvbnMuaGlnaGxpZ2h0Um93KSB7XHJcbiAgICAgIHRoaXMuaGlnaGxpZ2h0Um93KGdyaWRSb3dOdW1iZXJzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBzZWxlY3QgdGhlIHJvdyBpbiB0aGUgZ3JpZFxyXG4gICAgaWYgKG9wdGlvbnMuc2VsZWN0Um93ICYmIHRoaXMuX2dyaWRPcHRpb25zICYmICh0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVDaGVja2JveFNlbGVjdG9yIHx8IHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZVJvd1NlbGVjdGlvbikpIHtcclxuICAgICAgdGhpcy5zZXRTZWxlY3RlZFJvd3MoZ3JpZFJvd051bWJlcnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGRvIHdlIHdhbnQgdG8gdHJpZ2dlciBhbiBldmVudCBhZnRlciB1cGRhdGluZyB0aGUgaXRlbVxyXG4gICAgaWYgKG9wdGlvbnMudHJpZ2dlckV2ZW50KSB7XHJcbiAgICAgIHRoaXMub25JdGVtVXBkYXRlZC5uZXh0KGl0ZW1zKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZ3JpZFJvd051bWJlcnM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgYW4gZXhpc3RpbmcgaXRlbSBpbiB0aGUgZGF0YWdyaWQgYnkgaXQncyBpZCBhbmQgbmV3IHByb3BlcnRpZXNcclxuICAgKiBAcGFyYW0gaXRlbUlkOiBpdGVtIHVuaXF1ZSBpZFxyXG4gICAqIEBwYXJhbSBpdGVtIG9iamVjdCB3aGljaCBtdXN0IGNvbnRhaW4gYSB1bmlxdWUgXCJpZFwiIHByb3BlcnR5IGFuZCBhbnkgb3RoZXIgc3VpdGFibGUgcHJvcGVydGllc1xyXG4gICAqIEBwYXJhbSBvcHRpb25zOiBwcm92aWRlIHRoZSBwb3NzaWJpbGl0eSB0byBkbyBjZXJ0YWluIGFjdGlvbnMgYWZ0ZXIgb3IgZHVyaW5nIHRoZSB1cHNlcnQgKGhpZ2hsaWdodFJvdywgc2VsZWN0Um93LCB0cmlnZ2VyRXZlbnQpXHJcbiAgICogQHJldHVybiBncmlkIHJvdyBudW1iZXJcclxuICAgKi9cclxuICB1cGRhdGVJdGVtQnlJZChpdGVtSWQ6IG51bWJlciB8IHN0cmluZywgaXRlbTogYW55LCBvcHRpb25zPzogR3JpZFNlcnZpY2VVcGRhdGVPcHRpb24pOiBudW1iZXIge1xyXG4gICAgb3B0aW9ucyA9IHsgLi4uR3JpZFNlcnZpY2VVcGRhdGVPcHRpb25EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xyXG4gICAgaWYgKGl0ZW1JZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHVwZGF0ZSBhIHJvdyB3aXRob3V0IGEgdmFsaWQgXCJpZFwiYCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCByb3dOdW1iZXIgPSB0aGlzLl9kYXRhVmlldy5nZXRSb3dCeUlkKGl0ZW1JZCk7XHJcblxyXG4gICAgaWYgKCFpdGVtIHx8IHJvd051bWJlciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGl0ZW0gdG8gdXBkYXRlIGluIHRoZSBncmlkIHdhcyBub3QgZm91bmQgd2l0aCBpZDogJHtpdGVtSWR9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX2RhdGFWaWV3LmdldElkeEJ5SWQoaXRlbUlkKSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIC8vIFVwZGF0ZSB0aGUgaXRlbSBpdHNlbGYgaW5zaWRlIHRoZSBkYXRhVmlld1xyXG4gICAgICB0aGlzLl9kYXRhVmlldy51cGRhdGVJdGVtKGl0ZW1JZCwgaXRlbSk7XHJcbiAgICAgIHRoaXMuX2dyaWQudXBkYXRlUm93KHJvd051bWJlcik7XHJcblxyXG4gICAgICAvLyBkbyB3ZSB3YW50IHRvIHNjcm9sbCB0byB0aGUgcm93IHNvIHRoYXQgaXQgc2hvd3MgaW4gdGhlIFZpZXdwb3J0IChVSSlcclxuICAgICAgaWYgKG9wdGlvbnMuc2Nyb2xsUm93SW50b1ZpZXcpIHtcclxuICAgICAgICB0aGlzLl9ncmlkLnNjcm9sbFJvd0ludG9WaWV3KHJvd051bWJlcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGhpZ2hsaWdodCB0aGUgcm93IHdlIGp1c3QgdXBkYXRlZCwgaWYgZGVmaW5lZFxyXG4gICAgICBpZiAob3B0aW9ucy5oaWdobGlnaHRSb3cpIHtcclxuICAgICAgICB0aGlzLmhpZ2hsaWdodFJvdyhyb3dOdW1iZXIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBzZWxlY3QgdGhlIHJvdyBpbiB0aGUgZ3JpZFxyXG4gICAgICBpZiAob3B0aW9ucy5zZWxlY3RSb3cgJiYgdGhpcy5fZ3JpZE9wdGlvbnMgJiYgKHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZUNoZWNrYm94U2VsZWN0b3IgfHwgdGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlUm93U2VsZWN0aW9uKSkge1xyXG4gICAgICAgIHRoaXMuc2V0U2VsZWN0ZWRSb3cocm93TnVtYmVyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZG8gd2Ugd2FudCB0byB0cmlnZ2VyIGFuIGV2ZW50IGFmdGVyIHVwZGF0aW5nIHRoZSBpdGVtXHJcbiAgICAgIGlmIChvcHRpb25zLnRyaWdnZXJFdmVudCkge1xyXG4gICAgICAgIHRoaXMub25JdGVtVXBkYXRlZC5uZXh0KGl0ZW0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcm93TnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5zZXJ0IGEgcm93IGludG8gdGhlIGdyaWQgaWYgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0IG9yIHVwZGF0ZSBpZiBpdCBkb2VzLlxyXG4gICAqIEBwYXJhbSBpdGVtIG9iamVjdCB3aGljaCBtdXN0IGNvbnRhaW4gYSB1bmlxdWUgXCJpZFwiIHByb3BlcnR5IGFuZCBhbnkgb3RoZXIgc3VpdGFibGUgcHJvcGVydGllc1xyXG4gICAqIEBwYXJhbSBvcHRpb25zOiBwcm92aWRlIHRoZSBwb3NzaWJpbGl0eSB0byBkbyBjZXJ0YWluIGFjdGlvbnMgYWZ0ZXIgb3IgZHVyaW5nIHRoZSB1cHNlcnQgKGhpZ2hsaWdodFJvdywgcmVzb3J0R3JpZCwgc2VsZWN0Um93LCB0cmlnZ2VyRXZlbnQpXHJcbiAgICovXHJcbiAgdXBzZXJ0SXRlbShpdGVtOiBhbnksIG9wdGlvbnM/OiBHcmlkU2VydmljZUluc2VydE9wdGlvbik6IHsgYWRkZWQ6IG51bWJlciwgdXBkYXRlZDogbnVtYmVyIH0ge1xyXG4gICAgb3B0aW9ucyA9IHsgLi4uR3JpZFNlcnZpY2VJbnNlcnRPcHRpb25EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xyXG4gICAgY29uc3QgaXRlbUlkID0gKCFpdGVtIHx8ICFpdGVtLmhhc093blByb3BlcnR5KCdpZCcpKSA/IHVuZGVmaW5lZCA6IGl0ZW0uaWQ7XHJcblxyXG4gICAgaWYgKGl0ZW1JZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FsbGluZyBVcHNlcnQgb2YgYW4gaXRlbSByZXF1aXJlcyB0aGUgaXRlbSB0byBpbmNsdWRlIGFuIFwiaWRcIiBwcm9wZXJ0eWApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLnVwc2VydEl0ZW1CeUlkKGl0ZW1JZCwgaXRlbSwgb3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgYW4gYXJyYXkgb2YgZXhpc3RpbmcgaXRlbXMgd2l0aCBuZXcgcHJvcGVydGllcyBpbnNpZGUgdGhlIGRhdGFncmlkXHJcbiAgICogQHBhcmFtIGl0ZW0gb2JqZWN0IGFycmF5cywgd2hpY2ggbXVzdCBjb250YWluIHVuaXF1ZSBcImlkXCIgcHJvcGVydHkgYW5kIGFueSBvdGhlciBzdWl0YWJsZSBwcm9wZXJ0aWVzXHJcbiAgICogQHBhcmFtIG9wdGlvbnM6IHByb3ZpZGUgdGhlIHBvc3NpYmlsaXR5IHRvIGRvIGNlcnRhaW4gYWN0aW9ucyBhZnRlciBvciBkdXJpbmcgdGhlIHVwc2VydCAoaGlnaGxpZ2h0Um93LCByZXNvcnRHcmlkLCBzZWxlY3RSb3csIHRyaWdnZXJFdmVudClcclxuICAgKiBAcmV0dXJuIHJvdyBudW1iZXJzIGluIHRoZSBncmlkXHJcbiAgICovXHJcbiAgdXBzZXJ0SXRlbXMoaXRlbXM6IGFueSB8IGFueVtdLCBvcHRpb25zPzogR3JpZFNlcnZpY2VJbnNlcnRPcHRpb24pOiB7IGFkZGVkOiBudW1iZXIsIHVwZGF0ZWQ6IG51bWJlciB9W10ge1xyXG4gICAgb3B0aW9ucyA9IHsgLi4uR3JpZFNlcnZpY2VJbnNlcnRPcHRpb25EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xyXG4gICAgLy8gd2hlbiBpdCdzIG5vdCBhbiBhcnJheSwgd2UgY2FuIGNhbGwgZGlyZWN0bHkgdGhlIHNpbmdsZSBpdGVtIHVwZGF0ZVxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xyXG4gICAgICByZXR1cm4gW3RoaXMudXBzZXJ0SXRlbShpdGVtcywgb3B0aW9ucyldO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdXBzZXJ0ZWRSb3dzOiB7IGFkZGVkOiBudW1iZXIsIHVwZGF0ZWQ6IG51bWJlciB9W10gPSBbXTtcclxuICAgIGl0ZW1zLmZvckVhY2goKGl0ZW06IGFueSkgPT4ge1xyXG4gICAgICB1cHNlcnRlZFJvd3MucHVzaCh0aGlzLnVwc2VydEl0ZW0oaXRlbSwgeyAuLi5vcHRpb25zLCBoaWdobGlnaHRSb3c6IGZhbHNlLCByZXNvcnRHcmlkOiBmYWxzZSwgc2VsZWN0Um93OiBmYWxzZSwgdHJpZ2dlckV2ZW50OiBmYWxzZSB9KSk7XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHJvd051bWJlcnMgPSB1cHNlcnRlZFJvd3MubWFwKCh1cHNlcnRSb3cpID0+IHVwc2VydFJvdy5hZGRlZCAhPT0gdW5kZWZpbmVkID8gdXBzZXJ0Um93LmFkZGVkIDogdXBzZXJ0Um93LnVwZGF0ZWQpO1xyXG4gICAgLy8gb25seSBoaWdobGlnaHQgYXQgdGhlIGVuZCwgYWxsIGF0IG9uY2VcclxuICAgIC8vIHdlIGhhdmUgdG8gZG8gdGhpcyBiZWNhdXNlIGRvaW5nIGhpZ2hsaWdodCAxIGJ5IDEgd291bGQgb25seSByZS1zZWxlY3QgdGhlIGxhc3QgaGlnaGxpZ2h0ZWQgcm93IHdoaWNoIGlzIHdyb25nIGJlaGF2aW9yXHJcbiAgICBpZiAob3B0aW9ucy5oaWdobGlnaHRSb3cpIHtcclxuICAgICAgdGhpcy5oaWdobGlnaHRSb3cocm93TnVtYmVycyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2VsZWN0IHRoZSByb3cgaW4gdGhlIGdyaWRcclxuICAgIGlmIChvcHRpb25zLnNlbGVjdFJvdyAmJiB0aGlzLl9ncmlkT3B0aW9ucyAmJiAodGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlQ2hlY2tib3hTZWxlY3RvciB8fCB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVSb3dTZWxlY3Rpb24pKSB7XHJcbiAgICAgIHRoaXMuc2V0U2VsZWN0ZWRSb3dzKHJvd051bWJlcnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGRvIHdlIHdhbnQgdG8gdHJpZ2dlciBhbiBldmVudCBhZnRlciB1cGRhdGluZyB0aGUgaXRlbVxyXG4gICAgaWYgKG9wdGlvbnMudHJpZ2dlckV2ZW50KSB7XHJcbiAgICAgIHRoaXMub25JdGVtVXBzZXJ0ZWQubmV4dChpdGVtcyk7XHJcbiAgICAgIGNvbnN0IGFkZGVkSXRlbXMgPSB1cHNlcnRlZFJvd3MuZmlsdGVyKCh1cHNlcnRSb3cpID0+IHVwc2VydFJvdy5hZGRlZCAhPT0gdW5kZWZpbmVkKTtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYWRkZWRJdGVtcykgJiYgYWRkZWRJdGVtcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdGhpcy5vbkl0ZW1BZGRlZC5uZXh0KGFkZGVkSXRlbXMpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHVwZGF0ZWRJdGVtcyA9IHVwc2VydGVkUm93cy5maWx0ZXIoKHVwc2VydFJvdykgPT4gdXBzZXJ0Um93LnVwZGF0ZWQgIT09IHVuZGVmaW5lZCk7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHVwZGF0ZWRJdGVtcykgJiYgdXBkYXRlZEl0ZW1zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB0aGlzLm9uSXRlbVVwZGF0ZWQubmV4dCh1cGRhdGVkSXRlbXMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdXBzZXJ0ZWRSb3dzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIGFuIGV4aXN0aW5nIGl0ZW0gaW4gdGhlIGRhdGFncmlkIGJ5IGl0J3MgaWQgYW5kIG5ldyBwcm9wZXJ0aWVzXHJcbiAgICogQHBhcmFtIGl0ZW1JZDogaXRlbSB1bmlxdWUgaWRcclxuICAgKiBAcGFyYW0gaXRlbSBvYmplY3Qgd2hpY2ggbXVzdCBjb250YWluIGEgdW5pcXVlIFwiaWRcIiBwcm9wZXJ0eSBhbmQgYW55IG90aGVyIHN1aXRhYmxlIHByb3BlcnRpZXNcclxuICAgKiBAcGFyYW0gb3B0aW9uczogcHJvdmlkZSB0aGUgcG9zc2liaWxpdHkgdG8gZG8gY2VydGFpbiBhY3Rpb25zIGFmdGVyIG9yIGR1cmluZyB0aGUgdXBzZXJ0IChoaWdobGlnaHRSb3csIHJlc29ydEdyaWQsIHNlbGVjdFJvdywgdHJpZ2dlckV2ZW50KVxyXG4gICAqIEByZXR1cm4gZ3JpZCByb3cgbnVtYmVyIGluIHRoZSBncmlkXHJcbiAgICovXHJcbiAgdXBzZXJ0SXRlbUJ5SWQoaXRlbUlkOiBudW1iZXIgfCBzdHJpbmcsIGl0ZW06IGFueSwgb3B0aW9ucz86IEdyaWRTZXJ2aWNlSW5zZXJ0T3B0aW9uKTogeyBhZGRlZDogbnVtYmVyLCB1cGRhdGVkOiBudW1iZXIgfSB7XHJcbiAgICBsZXQgaXNJdGVtQWRkZWQgPSBmYWxzZTtcclxuICAgIG9wdGlvbnMgPSB7IC4uLkdyaWRTZXJ2aWNlSW5zZXJ0T3B0aW9uRGVmYXVsdHMsIC4uLm9wdGlvbnMgfTtcclxuICAgIGlmIChpdGVtSWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbGxpbmcgVXBzZXJ0IG9mIGFuIGl0ZW0gcmVxdWlyZXMgdGhlIGl0ZW0gdG8gaW5jbHVkZSBhIHZhbGlkIGFuZCB1bmlxdWUgXCJpZFwiIHByb3BlcnR5YCk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHJvd051bWJlckFkZGVkOiBudW1iZXI7XHJcbiAgICBsZXQgcm93TnVtYmVyVXBkYXRlZDogbnVtYmVyO1xyXG4gICAgaWYgKHRoaXMuX2RhdGFWaWV3LmdldFJvd0J5SWQoaXRlbUlkKSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJvd051bWJlckFkZGVkID0gdGhpcy5hZGRJdGVtKGl0ZW0sIG9wdGlvbnMpO1xyXG4gICAgICBpc0l0ZW1BZGRlZCA9IHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByb3dOdW1iZXJVcGRhdGVkID0gdGhpcy51cGRhdGVJdGVtKGl0ZW0sIHsgaGlnaGxpZ2h0Um93OiBvcHRpb25zLmhpZ2hsaWdodFJvdywgc2VsZWN0Um93OiBvcHRpb25zLnNlbGVjdFJvdywgdHJpZ2dlckV2ZW50OiBvcHRpb25zLnRyaWdnZXJFdmVudCB9KTtcclxuICAgICAgaXNJdGVtQWRkZWQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBkbyB3ZSB3YW50IHRvIHRyaWdnZXIgYW4gZXZlbnQgYWZ0ZXIgdXBkYXRpbmcgdGhlIGl0ZW1cclxuICAgIGlmIChvcHRpb25zLnRyaWdnZXJFdmVudCkge1xyXG4gICAgICB0aGlzLm9uSXRlbVVwc2VydGVkLm5leHQoaXRlbSk7XHJcbiAgICAgIGlzSXRlbUFkZGVkID8gdGhpcy5vbkl0ZW1BZGRlZC5uZXh0KGl0ZW0pIDogdGhpcy5vbkl0ZW1VcGRhdGVkLm5leHQoaXRlbSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBhZGRlZDogcm93TnVtYmVyQWRkZWQsIHVwZGF0ZWQ6IHJvd051bWJlclVwZGF0ZWQgfTtcclxuICB9XHJcbn1cclxuIl19