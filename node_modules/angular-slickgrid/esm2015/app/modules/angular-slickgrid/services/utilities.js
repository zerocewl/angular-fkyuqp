import { Observable } from 'rxjs';
import { first } from 'rxjs/operators';
import * as moment_ from 'moment-mini';
const moment = moment_; // patch to fix rollup "moment has no default export" issue, document here https://github.com/rollup/rollup/issues/670
import { FieldType, OperatorType } from '../models/index';
/**
 * Add an item to an array only when the item does not exists, when the item is an object we will be using their "id" to compare
 * @param inputArray
 * @param inputItem
 */
export function addToArrayWhenNotExists(inputArray, inputItem) {
    let arrayRowIndex = -1;
    if (typeof inputItem === 'object' && inputItem.hasOwnProperty('id')) {
        arrayRowIndex = inputArray.findIndex((item) => item.id === inputItem.id);
    }
    else {
        arrayRowIndex = inputArray.findIndex((item) => item === inputItem);
    }
    if (arrayRowIndex < 0) {
        inputArray.push(inputItem);
    }
}
/**
 * Simple function to which will loop and create as demanded the number of white spaces,
 * this is used in the CSV export
 * @param int nbSpaces: number of white spaces to create
 */
export function addWhiteSpaces(nbSpaces) {
    let result = '';
    for (let i = 0; i < nbSpaces; i++) {
        result += ' ';
    }
    return result;
}
/**
 * HTML decode using jQuery with a <div>
 * Create a in-memory div, set it's inner text(which jQuery automatically encodes)
 * then grab the encoded contents back out.  The div never exists on the page.
*/
export function htmlDecode(encodedStr) {
    const parser = DOMParser && new DOMParser;
    if (parser && parser.parseFromString) {
        const dom = parser.parseFromString('<!doctype html><body>' + encodedStr, 'text/html');
        return dom && dom.body && dom.body.textContent;
    }
    else {
        // for some browsers that might not support DOMParser, use jQuery instead
        return $('<div/>').html(encodedStr).text();
    }
}
/**
 * HTML encode using jQuery with a <div>
 * Create a in-memory div, set it's inner text(which jQuery automatically encodes)
 * then grab the encoded contents back out.  The div never exists on the page.
*/
export function htmlEncode(inputValue) {
    const entityMap = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        '\'': '&#39;'
    };
    // all symbols::  /[&<>"'`=\/]/g
    return (inputValue || '').toString().replace(/[&<>"']/g, (s) => entityMap[s]);
}
/**
 * Decode text into html entity
 * @param string text: input text
 * @param string text: output text
 */
export function htmlEntityDecode(input) {
    return input.replace(/&#(\d+);/g, function (match, dec) {
        return String.fromCharCode(dec);
    });
}
/**
 * Decode text into html entity
 * @param string text: input text
 * @param string text: output text
 */
export function htmlEntityEncode(input) {
    const buf = [];
    for (let i = input.length - 1; i >= 0; i--) {
        buf.unshift(['&#', input[i].charCodeAt(), ';'].join(''));
    }
    return buf.join('');
}
/**
 * Compares two arrays of characters to determine if all the items are equal
 * @param a first array
 * @param b second array to compare with a
 * @param [orderMatters=false] flag if the order matters, if not arrays will be sorted before comparison
 * @return boolean true if equal, else false
 */
export function charArraysEqual(a, b, orderMatters = false) {
    if (!a || !b || !Array.isArray(a) || !Array.isArray(a)) {
        return false;
    }
    if (a.length !== b.length) {
        return false;
    }
    if (!orderMatters) {
        a.sort();
        b.sort();
    }
    for (let i = 0; i < a.length; ++i) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
/**
 * Try casting an input of type Promise | Observable into a Promise type.
 * @param object which could be of type Promise or Observable
 * @param fromServiceName string representing the caller service name and will be used if we throw a casting problem error
 */
export function castToPromise(input, fromServiceName = '') {
    let promise = input;
    if (input instanceof Promise) {
        // if it's already a Promise then return it
        return input;
    }
    else if (input instanceof Observable) {
        promise = input.pipe(first()).toPromise();
    }
    if (!(promise instanceof Promise)) {
        throw new Error(`Something went wrong, Angular-Slickgrid ${fromServiceName} is not able to convert the Observable into a Promise.
      If you are using Angular HttpClient, you could try converting your http call to a Promise with ".toPromise()"
      for example::  this.http.post('graphql', { query: graphqlQuery }).toPromise()
      `);
    }
    return promise;
}
/**
 * Uses the logic function to find an item in an array or returns the default
 * value provided (empty object by default)
 * @param any[] array the array to filter
 * @param function logic the logic to find the item
 * @param any [defaultVal={}] the default value to return
 * @return object the found object or default value
 */
export function findOrDefault(array, logic, defaultVal = {}) {
    return array.find(logic) || defaultVal;
}
/**
  * Take a number (or a string) and display it as a formatted decimal string with defined minimum and maximum decimals
  * @param input
  * @param minDecimal
  * @param maxDecimal
  */
export function decimalFormatted(input, minDecimal, maxDecimal, decimalSeparator = '.', thousandSeparator = '') {
    if (isNaN(+input)) {
        return input;
    }
    const minDec = (minDecimal === undefined) ? 2 : minDecimal;
    const maxDec = (maxDecimal === undefined) ? 2 : maxDecimal;
    let amount = String(Math.round(+input * Math.pow(10, maxDec)) / Math.pow(10, maxDec));
    if ((amount.indexOf('.') < 0) && (minDec > 0)) {
        amount += '.';
    }
    while ((amount.length - amount.indexOf('.')) <= minDec) {
        amount += '0';
    }
    // do we want to display our number with a custom separator in each thousand position
    if (thousandSeparator) {
        amount = thousandSeparatorFormatted(amount, thousandSeparator);
    }
    // when using a separator that is not a dot, replace it with the new separator
    if (decimalSeparator !== '.') {
        amount = amount.replace('.', decimalSeparator);
    }
    return amount;
}
/**
 * Format a number following options passed as arguments (decimals, separator, ...)
 * @param input
 * @param minDecimal
 * @param maxDecimal
 * @param displayNegativeNumberWithParentheses
 * @param symbolPrefix
 * @param symbolSuffix
 * @param decimalSeparator
 * @param thousandSeparator
 */
export function formatNumber(input, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, symbolPrefix = '', symbolSuffix = '', decimalSeparator = '.', thousandSeparator = '') {
    if (isNaN(+input)) {
        return input;
    }
    const calculatedValue = ((Math.round(parseFloat(input) * 1000000) / 1000000));
    if (calculatedValue < 0) {
        const absValue = Math.abs(calculatedValue);
        if (displayNegativeNumberWithParentheses) {
            if (!isNaN(minDecimal) || !isNaN(maxDecimal)) {
                return `(${symbolPrefix}${decimalFormatted(absValue, minDecimal, maxDecimal, decimalSeparator, thousandSeparator)}${symbolSuffix})`;
            }
            const formattedValue = thousandSeparatorFormatted(`${absValue}`, thousandSeparator);
            return `(${symbolPrefix}${formattedValue}${symbolSuffix})`;
        }
        else {
            if (!isNaN(minDecimal) || !isNaN(maxDecimal)) {
                return `-${symbolPrefix}${decimalFormatted(absValue, minDecimal, maxDecimal, decimalSeparator, thousandSeparator)}${symbolSuffix}`;
            }
            const formattedValue = thousandSeparatorFormatted(`${absValue}`, thousandSeparator);
            return `-${symbolPrefix}${formattedValue}${symbolSuffix}`;
        }
    }
    else {
        if (!isNaN(minDecimal) || !isNaN(maxDecimal)) {
            return `${symbolPrefix}${decimalFormatted(input, minDecimal, maxDecimal, decimalSeparator, thousandSeparator)}${symbolSuffix}`;
        }
        const formattedValue = thousandSeparatorFormatted(`${input}`, thousandSeparator);
        return `${symbolPrefix}${formattedValue}${symbolSuffix}`;
    }
}
/** From a dot (.) notation path, find and return a property within an object given a path */
export function getDescendantProperty(obj, path) {
    return path.split('.').reduce((acc, part) => acc && acc[part], obj);
}
/** Get the browser's scrollbar width, this is different to each browser */
export function getScrollBarWidth() {
    const $outer = $('<div>').css({ visibility: 'hidden', width: 100, overflow: 'scroll' }).appendTo('body');
    const widthWithScroll = $('<div>').css({ width: '100%' }).appendTo($outer).outerWidth();
    $outer.remove();
    return Math.ceil(100 - widthWithScroll);
}
/**
 * From a Date FieldType, return it's equivalent moment.js format
 * refer to moment.js for the format standard used: https://momentjs.com/docs/#/parsing/string-format/
 * @param fieldType
 */
export function mapMomentDateFormatWithFieldType(fieldType) {
    let map;
    switch (fieldType) {
        case FieldType.dateTime:
        case FieldType.dateTimeIso:
            map = 'YYYY-MM-DD HH:mm:ss';
            break;
        case FieldType.dateTimeShortIso:
            map = 'YYYY-MM-DD HH:mm';
            break;
        case FieldType.dateTimeIsoAmPm:
            map = 'YYYY-MM-DD hh:mm:ss a';
            break;
        case FieldType.dateTimeIsoAM_PM:
            map = 'YYYY-MM-DD hh:mm:ss A';
            break;
        // all Euro Formats (date/month/year)
        case FieldType.dateEuro:
            map = 'DD/MM/YYYY';
            break;
        case FieldType.dateEuroShort:
            map = 'D/M/YY';
            break;
        case FieldType.dateTimeEuro:
            map = 'DD/MM/YYYY HH:mm:ss';
            break;
        case FieldType.dateTimeShortEuro:
            map = 'DD/MM/YYYY HH:mm';
            break;
        case FieldType.dateTimeEuroAmPm:
            map = 'DD/MM/YYYY hh:mm:ss a';
            break;
        case FieldType.dateTimeEuroAM_PM:
            map = 'DD/MM/YYYY hh:mm:ss A';
            break;
        case FieldType.dateTimeEuroShort:
            map = 'D/M/YY H:m:s';
            break;
        case FieldType.dateTimeEuroShortAmPm:
            map = 'D/M/YY h:m:s a';
            break;
        // all US Formats (month/date/year)
        case FieldType.dateUs:
            map = 'MM/DD/YYYY';
            break;
        case FieldType.dateUsShort:
            map = 'M/D/YY';
            break;
        case FieldType.dateTimeUs:
            map = 'MM/DD/YYYY HH:mm:ss';
            break;
        case FieldType.dateTimeShortUs:
            map = 'MM/DD/YYYY HH:mm';
            break;
        case FieldType.dateTimeUsAmPm:
            map = 'MM/DD/YYYY hh:mm:ss a';
            break;
        case FieldType.dateTimeUsAM_PM:
            map = 'MM/DD/YYYY hh:mm:ss A';
            break;
        case FieldType.dateTimeUsShort:
            map = 'M/D/YY H:m:s';
            break;
        case FieldType.dateTimeUsShortAmPm:
            map = 'M/D/YY h:m:s a';
            break;
        case FieldType.dateUtc:
            map = 'YYYY-MM-DDTHH:mm:ss.SSSZ';
            break;
        case FieldType.date:
        case FieldType.dateIso:
        default:
            map = 'YYYY-MM-DD';
            break;
    }
    return map;
}
/**
 * From a Date FieldType, return it's equivalent Flatpickr format
 * refer to Flatpickr for the format standard used: https://chmln.github.io/flatpickr/formatting/#date-formatting-tokens
 * also note that they seem very similar to PHP format (except for am/pm): http://php.net/manual/en/function.date.php
 * @param fieldType
 */
export function mapFlatpickrDateFormatWithFieldType(fieldType) {
    /*
      d: Day of the month, 2 digits with leading zeros	01 to 31
      D: A textual representation of a day	Mon through Sun
      l: (lowercase 'L')	A full textual representation of the day of the week	Sunday through Saturday
      j: Day of the month without leading zeros	1 to 31
      J: Day of the month without leading zeros and ordinal suffix	1st, 2nd, to 31st
      w: Numeric representation of the day of the week	0 (for Sunday) through 6 (for Saturday)
      F: A full textual representation of a month	January through December
      m: Numeric representation of a month, with leading zero	01 through 12
      n: Numeric representation of a month, without leading zeros	1 through 12
      M: A short textual representation of a month	Jan through Dec
      U: The number of seconds since the Unix Epoch	1413704993
      y: A two digit representation of a year	99 or 03
      Y: A full numeric representation of a year, 4 digits	1999 or 2003
      H: Hours (24 hours)	00 to 23
      h: Hours	1 to 12
      i: Minutes	00 to 59
      S: Seconds, 2 digits	00 to 59
      s: Seconds	0, 1 to 59
      K: AM/PM	AM or PM
    */
    let map;
    switch (fieldType) {
        case FieldType.dateTime:
        case FieldType.dateTimeIso:
            map = 'Y-m-d H:i:S';
            break;
        case FieldType.dateTimeShortIso:
            map = 'Y-m-d H:i';
            break;
        case FieldType.dateTimeIsoAmPm:
        case FieldType.dateTimeIsoAM_PM:
            map = 'Y-m-d h:i:S K'; // there is no lowercase in Flatpickr :(
            break;
        // all Euro Formats (date/month/year)
        case FieldType.dateEuro:
            map = 'd/m/Y';
            break;
        case FieldType.dateEuroShort:
            map = 'd/m/y';
            break;
        case FieldType.dateTimeEuro:
            map = 'd/m/Y H:i:S';
            break;
        case FieldType.dateTimeShortEuro:
            map = 'd/m/y H:i';
            break;
        case FieldType.dateTimeEuroAmPm:
            map = 'd/m/Y h:i:S K'; // there is no lowercase in Flatpickr :(
            break;
        case FieldType.dateTimeEuroAM_PM:
            map = 'd/m/Y h:i:s K';
            break;
        case FieldType.dateTimeEuroShort:
            map = 'd/m/y H:i:s';
            break;
        case FieldType.dateTimeEuroShortAmPm:
            map = 'd/m/y h:i:s K'; // there is no lowercase in Flatpickr :(
            break;
        // all US Formats (month/date/year)
        case FieldType.dateUs:
            map = 'm/d/Y';
            break;
        case FieldType.dateUsShort:
            map = 'm/d/y';
            break;
        case FieldType.dateTimeUs:
            map = 'm/d/Y H:i:S';
            break;
        case FieldType.dateTimeShortUs:
            map = 'm/d/y H:i';
            break;
        case FieldType.dateTimeUsAmPm:
            map = 'm/d/Y h:i:S K'; // there is no lowercase in Flatpickr :(
            break;
        case FieldType.dateTimeUsAM_PM:
            map = 'm/d/Y h:i:s K';
            break;
        case FieldType.dateTimeUsShort:
            map = 'm/d/y H:i:s';
            break;
        case FieldType.dateTimeUsShortAmPm:
            map = 'm/d/y h:i:s K'; // there is no lowercase in Flatpickr :(
            break;
        case FieldType.dateUtc:
            map = 'Z';
            break;
        case FieldType.date:
        case FieldType.dateIso:
        default:
            map = 'Y-m-d';
            break;
    }
    return map;
}
/**
 * Mapper for query operators (ex.: <= is "le", > is "gt")
 * @param string operator
 * @returns string map
 */
export function mapOperatorType(operator) {
    let map;
    switch (operator) {
        case '<':
        case 'LT':
            map = OperatorType.lessThan;
            break;
        case '<=':
        case 'LE':
            map = OperatorType.lessThanOrEqual;
            break;
        case '>':
        case 'GT':
            map = OperatorType.greaterThan;
            break;
        case '>=':
        case 'GE':
            map = OperatorType.greaterThanOrEqual;
            break;
        case '<>':
        case '!=':
        case 'NE':
            map = OperatorType.notEqual;
            break;
        case '*':
        case 'a*':
        case 'StartsWith':
            map = OperatorType.startsWith;
            break;
        case '*z':
        case 'EndsWith':
            map = OperatorType.endsWith;
            break;
        case '=':
        case '==':
        case 'EQ':
            map = OperatorType.equal;
            break;
        case 'IN':
            map = OperatorType.in;
            break;
        case 'NIN':
        case 'NOT_IN':
            map = OperatorType.notIn;
            break;
        case 'Not_Contains':
        case 'NOT_CONTAINS':
            map = OperatorType.notContains;
            break;
        case 'Contains':
        case 'CONTAINS':
        default:
            map = OperatorType.contains;
            break;
    }
    return map;
}
/**
 * Find equivalent short designation of an Operator Type or Operator String.
 * When using a Compound Filter, we use the short designation and so we need the mapped value.
 * For example OperatorType.startsWith short designation is "a*", while OperatorType.greaterThanOrEqual is ">="
 */
export function mapOperatorToShorthandDesignation(operator) {
    let shortOperator = '';
    switch (operator) {
        case OperatorType.greaterThan:
        case '>':
            shortOperator = '>';
            break;
        case OperatorType.greaterThanOrEqual:
        case '>=':
            shortOperator = '>=';
            break;
        case OperatorType.lessThan:
        case '<':
            shortOperator = '<';
            break;
        case OperatorType.lessThanOrEqual:
        case '<=':
            shortOperator = '<=';
            break;
        case OperatorType.notEqual:
        case '<>':
            shortOperator = '<>';
            break;
        case OperatorType.equal:
        case '=':
        case '==':
        case 'EQ':
            shortOperator = '=';
            break;
        case OperatorType.startsWith:
        case 'a*':
        case '*':
            shortOperator = 'a*';
            break;
        case OperatorType.endsWith:
        case '*z':
            shortOperator = '*z';
            break;
        default:
            // any other operator will be considered as already a short expression, so we can return same input operator
            shortOperator = operator;
            break;
    }
    return shortOperator;
}
/**
 * Mapper for query operator by a Filter Type
 * For example a multiple-select typically uses 'IN' operator
 * @param operator
 * @returns string map
 */
export function mapOperatorByFieldType(fieldType) {
    let map;
    switch (fieldType) {
        case FieldType.string:
        case FieldType.unknown:
            map = OperatorType.contains;
            break;
        case FieldType.float:
        case FieldType.number:
        case FieldType.date:
        case FieldType.dateIso:
        case FieldType.dateUtc:
        case FieldType.dateTime:
        case FieldType.dateTimeIso:
        case FieldType.dateTimeIsoAmPm:
        case FieldType.dateTimeIsoAM_PM:
        case FieldType.dateEuro:
        case FieldType.dateEuroShort:
        case FieldType.dateTimeEuro:
        case FieldType.dateTimeEuroAmPm:
        case FieldType.dateTimeEuroAM_PM:
        case FieldType.dateTimeEuroShort:
        case FieldType.dateTimeEuroShortAmPm:
        case FieldType.dateTimeEuroShortAM_PM:
        case FieldType.dateUs:
        case FieldType.dateUsShort:
        case FieldType.dateTimeUs:
        case FieldType.dateTimeUsAmPm:
        case FieldType.dateTimeUsAM_PM:
        case FieldType.dateTimeUsShort:
        case FieldType.dateTimeUsShortAmPm:
        case FieldType.dateTimeUsShortAM_PM:
        default:
            map = OperatorType.equal;
            break;
    }
    return map;
}
/** Parse any input (bool, number, string) and return a boolean or False when not possible */
export function parseBoolean(input) {
    return /(true|1)/i.test(input + '');
}
/**
 * Parse a date passed as a string (Date only, without time) and return a Date object (if valid)
 * @param inputDateString
 * @returns string date formatted
 */
export function parseUtcDate(inputDateString, useUtc) {
    let date = null;
    if (/^[0-9\-\/]*$/.test(inputDateString)) {
        // get the UTC datetime with moment.js but we need to decode the value so that it's valid text
        const dateString = decodeURIComponent(inputDateString);
        const dateMoment = moment(new Date(dateString));
        if (dateMoment.isValid() && dateMoment.year().toString().length === 4) {
            date = (useUtc) ? dateMoment.utc().format() : dateMoment.format();
        }
    }
    return date;
}
/**
 * Sanitize, return only the text without HTML tags
 * @input htmlString
 * @return text
 */
export function sanitizeHtmlToText(htmlString) {
    const temp = document.createElement('div');
    temp.innerHTML = htmlString;
    return temp.textContent || temp.innerText || '';
}
/** Set the object value of deeper node from a given dot (.) notation path (e.g.: "user.firstName") */
export function setDeepValue(obj, path, value) {
    if (typeof path === 'string') {
        path = path.split('.');
    }
    if (path.length > 1) {
        const e = path.shift();
        setDeepValue(obj[e] = Object.prototype.toString.call(obj[e]) === '[object Object]' ? obj[e] : {}, path, value);
    }
    else {
        obj[path[0]] = value;
    }
}
/**
 * Format a number or a string into a string that is separated every thousand,
 * the default separator is a comma but user can optionally pass a different one
 * @param inputValue
 * @param separator default to comma ","
 * @returns string
 */
export function thousandSeparatorFormatted(inputValue, separator = ',') {
    if (inputValue !== null && inputValue !== undefined) {
        const stringValue = `${inputValue}`;
        const decimalSplit = stringValue.split('.');
        if (decimalSplit.length === 2) {
            return `${decimalSplit[0].replace(/\B(?=(\d{3})+(?!\d))/g, separator)}.${decimalSplit[1]}`;
        }
        return stringValue.replace(/\B(?=(\d{3})+(?!\d))/g, separator);
    }
    return inputValue;
}
/**
 * Title case (or capitalize) first char of a string
 * Optionall title case the complete sentence (upper case first char of each word while changing everything else to lower case)
 * @param inputStr
 * @returns string
 */
export function titleCase(inputStr, caseEveryWords = false) {
    if (typeof inputStr === 'string') {
        if (caseEveryWords) {
            return inputStr.replace(/\w\S*/g, (outputStr) => {
                return outputStr.charAt(0).toUpperCase() + outputStr.substr(1).toLowerCase();
            });
        }
        return inputStr.charAt(0).toUpperCase() + inputStr.slice(1);
    }
    return inputStr;
}
/**
 * Converts a string to camel case (camelCase)
 * @param inputStr the string to convert
 * @return the string in camel case
 */
export function toCamelCase(inputStr) {
    if (typeof inputStr === 'string') {
        return inputStr.replace(/(?:^\w|[A-Z]|\b\w|[\s+\-_\/])/g, (match, offset) => {
            // remove white space or hypens or underscores
            if (/[\s+\-_\/]/.test(match)) {
                return '';
            }
            return offset === 0 ? match.toLowerCase() : match.toUpperCase();
        });
    }
    return inputStr;
}
/**
 * Converts a string to kebab (hypen) case
 * @param str the string to convert
 * @return the string in kebab case
 */
export function toKebabCase(inputStr) {
    if (typeof inputStr === 'string') {
        return toCamelCase(inputStr).replace(/([A-Z])/g, '-$1').toLowerCase();
    }
    return inputStr;
}
/**
 * Converts a string from camelCase to snake_case (underscore) case
 * @param str the string to convert
 * @return the string in kebab case
 */
export function toSnakeCase(inputStr) {
    if (typeof inputStr === 'string') {
        return toCamelCase(inputStr).replace(/([A-Z])/g, '_$1').toLowerCase();
    }
    return inputStr;
}
/**
 * Takes an input array and makes sure the array has unique values by removing duplicates
 * @param array input with possible duplicates
 * @param objectProperty optionally provide an object property to compare (example: 'id')
 * @return array output without duplicates
 */
export function uniqueArray(arr) {
    if (Array.isArray(arr) && arr.length > 0) {
        return arr.filter((item, index) => {
            return arr.indexOf(item) >= index;
        });
    }
    return arr;
}
/**
 * Takes an input array of objects and makes sure the array has unique object values by removing duplicates
 * it will loop through the array using a property name (or "id" when is not provided) to compare uniqueness
 * @param array input with possible duplicates
 * @param propertyName defaults to "id"
 * @return array output without duplicates
 */
export function uniqueObjectArray(arr, propertyName = 'id') {
    if (Array.isArray(arr) && arr.length > 0) {
        const result = [];
        const map = new Map();
        for (const item of arr) {
            if (!map.has(item[propertyName])) {
                map.set(item[propertyName], true); // set any value to Map
                result.push({
                    id: item[propertyName],
                    name: item.name
                });
            }
        }
        return result;
    }
    return arr;
}
/**
 * Unsubscribe all Observables Subscriptions
 * It will return an empty array if it all went well
 * @param subscriptions
 */
export function unsubscribeAllObservables(subscriptions) {
    if (Array.isArray(subscriptions)) {
        subscriptions.forEach((subscription) => {
            if (subscription && subscription.unsubscribe) {
                subscription.unsubscribe();
            }
        });
        subscriptions = [];
    }
    return subscriptions;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbGl0aWVzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1zbGlja2dyaWQvIiwic291cmNlcyI6WyJhcHAvbW9kdWxlcy9hbmd1bGFyLXNsaWNrZ3JpZC9zZXJ2aWNlcy91dGlsaXRpZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBZ0IsTUFBTSxNQUFNLENBQUM7QUFDaEQsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3ZDLE9BQU8sS0FBSyxPQUFPLE1BQU0sYUFBYSxDQUFDO0FBQ3ZDLE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxDQUFDLHNIQUFzSDtBQUU5SSxPQUFPLEVBQUUsU0FBUyxFQUFrQixZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUsxRTs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLHVCQUF1QixDQUFDLFVBQWlCLEVBQUUsU0FBYztJQUN2RSxJQUFJLGFBQWEsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUN2QixJQUFJLE9BQU8sU0FBUyxLQUFLLFFBQVEsSUFBSSxTQUFTLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQ25FLGFBQWEsR0FBRyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxLQUFLLFNBQVMsQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUMxRTtTQUFNO1FBQ0wsYUFBYSxHQUFHLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksS0FBSyxTQUFTLENBQUMsQ0FBQztLQUNwRTtJQUVELElBQUksYUFBYSxHQUFHLENBQUMsRUFBRTtRQUNyQixVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0tBQzVCO0FBQ0gsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsY0FBYyxDQUFDLFFBQWdCO0lBQzdDLElBQUksTUFBTSxH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QUFhLEdBQUcsRUFBRSxDQUFDO0tBQ3BCO0lBRUQsT0FBTyxhQUFhLENBQUM7QUFDdkIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9ic2VydmFibGUsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlyc3QgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgKiBhcyBtb21lbnRfIGZyb20gJ21vbWVudC1taW5pJztcbmNvbnN0IG1vbWVudCA9IG1vbWVudF87IC8vIHBhdGNoIHRvIGZpeCByb2xsdXAgXCJtb21lbnQgaGFzIG5vIGRlZmF1bHQgZXhwb3J0XCIgaXNzdWUsIGRvY3VtZW50IGhlcmUgaHR0cHM6Ly9naXRodWIuY29tL3JvbGx1cC9yb2xsdXAvaXNzdWVzLzY3MFxuXG5pbXBvcnQgeyBGaWVsZFR5cGUsIE9wZXJhdG9yU3RyaW5nLCBPcGVyYXRvclR5cGUgfSBmcm9tICcuLi9tb2RlbHMvaW5kZXgnO1xuXG4vLyB1c2luZyBleHRlcm5hbCBub24tdHlwZWQganMgbGlicmFyaWVzXG5kZWNsYXJlIHZhciAkOiBhbnk7XG5cbi8qKlxuICogQWRkIGFuIGl0ZW0gdG8gYW4gYXJyYXkgb25seSB3aGVuIHRoZSBpdGVtIGRvZXMgbm90IGV4aXN0cywgd2hlbiB0aGUgaXRlbSBpcyBhbiBvYmplY3Qgd2Ugd2lsbCBiZSB1c2luZyB0aGVpciBcImlkXCIgdG8gY29tcGFyZVxuICogQHBhcmFtIGlucHV0QXJyYXlcbiAqIEBwYXJhbSBpbnB1dEl0ZW1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFRvQXJyYXlXaGVuTm90RXhpc3RzKGlucHV0QXJyYXk6IGFueVtdLCBpbnB1dEl0ZW06IGFueSkge1xuICBsZXQgYXJyYXlSb3dJbmRleCA9IC0xO1xuICBpZiAodHlwZW9mIGlucHV0SXRlbSA9PT0gJ29iamVjdCcgJiYgaW5wdXRJdGVtLmhhc093blByb3BlcnR5KCdpZCcpKSB7XG4gICAgYXJyYXlSb3dJbmRleCA9IGlucHV0QXJyYXkuZmluZEluZGV4KChpdGVtKSA9PiBpdGVtLmlkID09PSBpbnB1dEl0ZW0uaWQpO1xuICB9IGVsc2Uge1xuICAgIGFycmF5Um93SW5kZXggPSBpbnB1dEFycmF5LmZpbmRJbmRleCgoaXRlbSkgPT4gaXRlbSA9PT0gaW5wdXRJdGVtKTtcbiAgfVxuXG4gIGlmIChhcnJheVJvd0luZGV4IDwgMCkge1xuICAgIGlucHV0QXJyYXkucHVzaChpbnB1dEl0ZW0pO1xuICB9XG59XG5cbi8qKlxuICogU2ltcGxlIGZ1bmN0aW9uIHRvIHdoaWNoIHdpbGwgbG9vcCBhbmQgY3JlYXRlIGFzIGRlbWFuZGVkIHRoZSBudW1iZXIgb2Ygd2hpdGUgc3BhY2VzLFxuICogdGhpcyBpcyB1c2VkIGluIHRoZSBDU1YgZXhwb3J0XG4gKiBAcGFyYW0gaW50IG5iU3BhY2VzOiBudW1iZXIgb2Ygd2hpdGUgc3BhY2VzIHRvIGNyZWF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkV2hpdGVTcGFjZXMobmJTcGFjZXM6IG51bWJlcik6IHN0cmluZyB7XG4gIGxldCByZXN1bHQgPSAnJztcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5iU3BhY2VzOyBpKyspIHtcbiAgICByZXN1bHQgKz0gJyAnO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogSFRNTCBkZWNvZGUgdXNpbmcgalF1ZXJ5IHdpdGggYSA8ZGl2PlxuICogQ3JlYXRlIGEgaW4tbWVtb3J5IGRpdiwgc2V0IGl0J3MgaW5uZXIgdGV4dCh3aGljaCBqUXVlcnkgYXV0b21hdGljYWxseSBlbmNvZGVzKVxuICogdGhlbiBncmFiIHRoZSBlbmNvZGVkIGNvbnRlbnRzIGJhY2sgb3V0LiAgVGhlIGRpdiBuZXZlciBleGlzdHMgb24gdGhlIHBhZ2UuXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGh0bWxEZWNvZGUoZW5jb2RlZFN0cjogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgcGFyc2VyID0gRE9NUGFyc2VyICYmIG5ldyBET01QYXJzZXI7XG4gIGlmIChwYXJzZXIgJiYgcGFyc2VyLnBhcnNlRnJvbVN0cmluZykge1xuICAgIGNvbnN0IGRvbSA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoXG4gICAgICAnPCFkb2N0eXBlIGh0bWw+PGJvZHk+JyArIGVuY29kZWRTdHIsXG4gICAgICAndGV4dC9odG1sJyk7XG4gICAgcmV0dXJuIGRvbSAmJiBkb20uYm9keSAmJiBkb20uYm9keS50ZXh0Q29udGVudDtcbiAgfSBlbHNlIHtcbiAgICAvLyBmb3Igc29tZSBicm93c2VycyB0aGF0IG1pZ2h0IG5vdCBzdXBwb3J0IERPTVBhcnNlciwgdXNlIGpRdWVyeSBpbnN0ZWFkXG4gICAgcmV0dXJuICQoJzxkaXYvPicpLmh0bWwoZW5jb2RlZFN0cikudGV4dCgpO1xuICB9XG59XG5cbi8qKlxuICogSFRNTCBlbmNvZGUgdXNpbmcgalF1ZXJ5IHdpdGggYSA8ZGl2PlxuICogQ3JlYXRlIGEgaW4tbWVtb3J5IGRpdiwgc2V0IGl0J3MgaW5uZXIgdGV4dCh3aGljaCBqUXVlcnkgYXV0b21hdGljYWxseSBlbmNvZGVzKVxuICogdGhlbiBncmFiIHRoZSBlbmNvZGVkIGNvbnRlbnRzIGJhY2sgb3V0LiAgVGhlIGRpdiBuZXZlciBleGlzdHMgb24gdGhlIHBhZ2UuXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGh0bWxFbmNvZGUoaW5wdXRWYWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgZW50aXR5TWFwID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICAnXFwnJzogJyYjMzk7J1xuICB9O1xuICAvLyBhbGwgc3ltYm9sczo6ICAvWyY8PlwiJ2A9XFwvXS9nXG4gIHJldHVybiAoaW5wdXRWYWx1ZSB8fCAnJykudG9TdHJpbmcoKS5yZXBsYWNlKC9bJjw+XCInXS9nLCAocykgPT4gZW50aXR5TWFwW3NdKTtcbn1cblxuLyoqXG4gKiBEZWNvZGUgdGV4dCBpbnRvIGh0bWwgZW50aXR5XG4gKiBAcGFyYW0gc3RyaW5nIHRleHQ6IGlucHV0IHRleHRcbiAqIEBwYXJhbSBzdHJpbmcgdGV4dDogb3V0cHV0IHRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh0bWxFbnRpdHlEZWNvZGUoaW5wdXQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBpbnB1dC5yZXBsYWNlKC8mIyhcXGQrKTsvZywgZnVuY3Rpb24gKG1hdGNoLCBkZWMpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShkZWMpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBEZWNvZGUgdGV4dCBpbnRvIGh0bWwgZW50aXR5XG4gKiBAcGFyYW0gc3RyaW5nIHRleHQ6IGlucHV0IHRleHRcbiAqIEBwYXJhbSBzdHJpbmcgdGV4dDogb3V0cHV0IHRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh0bWxFbnRpdHlFbmNvZGUoaW5wdXQ6IGFueSk6IHN0cmluZyB7XG4gIGNvbnN0IGJ1ZiA9IFtdO1xuICBmb3IgKGxldCBpID0gaW5wdXQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBidWYudW5zaGlmdChbJyYjJywgaW5wdXRbaV0uY2hhckNvZGVBdCgpLCAnOyddLmpvaW4oJycpKTtcbiAgfVxuICByZXR1cm4gYnVmLmpvaW4oJycpO1xufVxuXG4vKipcbiAqIENvbXBhcmVzIHR3byBhcnJheXMgb2YgY2hhcmFjdGVycyB0byBkZXRlcm1pbmUgaWYgYWxsIHRoZSBpdGVtcyBhcmUgZXF1YWxcbiAqIEBwYXJhbSBhIGZpcnN0IGFycmF5XG4gKiBAcGFyYW0gYiBzZWNvbmQgYXJyYXkgdG8gY29tcGFyZSB3aXRoIGFcbiAqIEBwYXJhbSBbb3JkZXJNYXR0ZXJzPWZhbHNlXSBmbGFnIGlmIHRoZSBvcmRlciBtYXR0ZXJzLCBpZiBub3QgYXJyYXlzIHdpbGwgYmUgc29ydGVkIGJlZm9yZSBjb21wYXJpc29uXG4gKiBAcmV0dXJuIGJvb2xlYW4gdHJ1ZSBpZiBlcXVhbCwgZWxzZSBmYWxzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hhckFycmF5c0VxdWFsKGE6IGFueVtdLCBiOiBhbnlbXSwgb3JkZXJNYXR0ZXJzOiBib29sZWFuID0gZmFsc2UpOiBib29sZWFuIHtcbiAgaWYgKCFhIHx8ICFiIHx8ICFBcnJheS5pc0FycmF5KGEpIHx8ICFBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghb3JkZXJNYXR0ZXJzKSB7XG4gICAgYS5zb3J0KCk7XG4gICAgYi5zb3J0KCk7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFRyeSBjYXN0aW5nIGFuIGlucHV0IG9mIHR5cGUgUHJvbWlzZSB8IE9ic2VydmFibGUgaW50byBhIFByb21pc2UgdHlwZS5cbiAqIEBwYXJhbSBvYmplY3Qgd2hpY2ggY291bGQgYmUgb2YgdHlwZSBQcm9taXNlIG9yIE9ic2VydmFibGVcbiAqIEBwYXJhbSBmcm9tU2VydmljZU5hbWUgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY2FsbGVyIHNlcnZpY2UgbmFtZSBhbmQgd2lsbCBiZSB1c2VkIGlmIHdlIHRocm93IGEgY2FzdGluZyBwcm9ibGVtIGVycm9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYXN0VG9Qcm9taXNlPFQ+KGlucHV0OiBQcm9taXNlPFQ+IHwgT2JzZXJ2YWJsZTxUPiwgZnJvbVNlcnZpY2VOYW1lOiBzdHJpbmcgPSAnJyk6IFByb21pc2U8VD4ge1xuICBsZXQgcHJvbWlzZTogYW55ID0gaW5wdXQ7XG5cbiAgaWYgKGlucHV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgIC8vIGlmIGl0J3MgYWxyZWFkeSBhIFByb21pc2UgdGhlbiByZXR1cm4gaXRcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH0gZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBPYnNlcnZhYmxlKSB7XG4gICAgcHJvbWlzZSA9IGlucHV0LnBpcGUoZmlyc3QoKSkudG9Qcm9taXNlKCk7XG4gIH1cblxuICBpZiAoIShwcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgU29tZXRoaW5nIHdlbnQgd3JvbmcsIEFuZ3VsYXItU2xpY2tncmlkICR7ZnJvbVNlcnZpY2VOYW1lfSBpcyBub3QgYWJsZSB0byBjb252ZXJ0IHRoZSBPYnNlcnZhYmxlIGludG8gYSBQcm9taXNlLlxuICAgICAgSWYgeW91IGFyZSB1c2luZyBBbmd1bGFyIEh0dHBDbGllbnQsIHlvdSBjb3VsZCB0cnkgY29udmVydGluZyB5b3VyIGh0dHAgY2FsbCB0byBhIFByb21pc2Ugd2l0aCBcIi50b1Byb21pc2UoKVwiXG4gICAgICBmb3IgZXhhbXBsZTo6ICB0aGlzLmh0dHAucG9zdCgnZ3JhcGhxbCcsIHsgcXVlcnk6IGdyYXBocWxRdWVyeSB9KS50b1Byb21pc2UoKVxuICAgICAgYCk7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLyoqXG4gKiBVc2VzIHRoZSBsb2dpYyBmdW5jdGlvbiB0byBmaW5kIGFuIGl0ZW0gaW4gYW4gYXJyYXkgb3IgcmV0dXJucyB0aGUgZGVmYXVsdFxuICogdmFsdWUgcHJvdmlkZWQgKGVtcHR5IG9iamVjdCBieSBkZWZhdWx0KVxuICogQHBhcmFtIGFueVtdIGFycmF5IHRoZSBhcnJheSB0byBmaWx0ZXJcbiAqIEBwYXJhbSBmdW5jdGlvbiBsb2dpYyB0aGUgbG9naWMgdG8gZmluZCB0aGUgaXRlbVxuICogQHBhcmFtIGFueSBbZGVmYXVsdFZhbD17fV0gdGhlIGRlZmF1bHQgdmFsdWUgdG8gcmV0dXJuXG4gKiBAcmV0dXJuIG9iamVjdCB0aGUgZm91bmQgb2JqZWN0IG9yIGRlZmF1bHQgdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRPckRlZmF1bHQoYXJyYXk6IGFueVtdLCBsb2dpYzogKGl0ZW06IGFueSkgPT4gYm9vbGVhbiwgZGVmYXVsdFZhbCA9IHt9KTogYW55IHtcbiAgcmV0dXJuIGFycmF5LmZpbmQobG9naWMpIHx8IGRlZmF1bHRWYWw7XG59XG5cbi8qKlxuICAqIFRha2UgYSBudW1iZXIgKG9yIGEgc3RyaW5nKSBhbmQgZGlzcGxheSBpdCBhcyBhIGZvcm1hdHRlZCBkZWNpbWFsIHN0cmluZyB3aXRoIGRlZmluZWQgbWluaW11bSBhbmQgbWF4aW11bSBkZWNpbWFsc1xuICAqIEBwYXJhbSBpbnB1dFxuICAqIEBwYXJhbSBtaW5EZWNpbWFsXG4gICogQHBhcmFtIG1heERlY2ltYWxcbiAgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNpbWFsRm9ybWF0dGVkKGlucHV0OiBudW1iZXIgfCBzdHJpbmcsIG1pbkRlY2ltYWw/OiBudW1iZXIsIG1heERlY2ltYWw/OiBudW1iZXIsIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyB8ICcsJyA9ICcuJywgdGhvdXNhbmRTZXBhcmF0b3I6ICcsJyB8ICdfJyB8ICcuJyB8ICcgJyB8ICcnID0gJycpOiBzdHJpbmcge1xuICBpZiAoaXNOYU4oK2lucHV0KSkge1xuICAgIHJldHVybiBpbnB1dCBhcyBzdHJpbmc7XG4gIH1cblxuICBjb25zdCBtaW5EZWMgPSAobWluRGVjaW1hbCA9PT0gdW5kZWZpbmVkKSA/IDIgOiBtaW5EZWNpbWFsO1xuICBjb25zdCBtYXhEZWMgPSAobWF4RGVjaW1hbCA9PT0gdW5kZWZpbmVkKSA/IDIgOiBtYXhEZWNpbWFsO1xuICBsZXQgYW1vdW50ID0gU3RyaW5nKE1hdGgucm91bmQoK2lucHV0ICogTWF0aC5wb3coMTAsIG1heERlYykpIC8gTWF0aC5wb3coMTAsIG1heERlYykpO1xuXG4gIGlmICgoYW1vdW50LmluZGV4T2YoJy4nKSA8IDApICYmIChtaW5EZWMgPiAwKSkge1xuICAgIGFtb3VudCArPSAnLic7XG4gIH1cbiAgd2hpbGUgKChhbW91bnQubGVuZ3RoIC0gYW1vdW50LmluZGV4T2YoJy4nKSkgPD0gbWluRGVjKSB7XG4gICAgYW1vdW50ICs9ICcwJztcbiAgfVxuXG4gIC8vIGRvIHdlIHdhbnQgdG8gZGlzcGxheSBvdXIgbnVtYmVyIHdpdGggYSBjdXN0b20gc2VwYXJhdG9yIGluIGVhY2ggdGhvdXNhbmQgcG9zaXRpb25cbiAgaWYgKHRob3VzYW5kU2VwYXJhdG9yKSB7XG4gICAgYW1vdW50ID0gdGhvdXNhbmRTZXBhcmF0b3JGb3JtYXR0ZWQoYW1vdW50LCB0aG91c2FuZFNlcGFyYXRvcik7XG4gIH1cblxuICAvLyB3aGVuIHVzaW5nIGEgc2VwYXJhdG9yIHRoYXQgaXMgbm90IGEgZG90LCByZXBsYWNlIGl0IHdpdGggdGhlIG5ldyBzZXBhcmF0b3JcbiAgaWYgKGRlY2ltYWxTZXBhcmF0b3IgIT09ICcuJykge1xuICAgIGFtb3VudCA9IGFtb3VudC5yZXBsYWNlKCcuJywgZGVjaW1hbFNlcGFyYXRvcik7XG4gIH1cbiAgcmV0dXJuIGFtb3VudDtcbn1cblxuLyoqXG4gKiBGb3JtYXQgYSBudW1iZXIgZm9sbG93aW5nIG9wdGlvbnMgcGFzc2VkIGFzIGFyZ3VtZW50cyAoZGVjaW1hbHMsIHNlcGFyYXRvciwgLi4uKVxuICogQHBhcmFtIGlucHV0XG4gKiBAcGFyYW0gbWluRGVjaW1hbFxuICogQHBhcmFtIG1heERlY2ltYWxcbiAqIEBwYXJhbSBkaXNwbGF5TmVnYXRpdmVOdW1iZXJXaXRoUGFyZW50aGVzZXNcbiAqIEBwYXJhbSBzeW1ib2xQcmVmaXhcbiAqIEBwYXJhbSBzeW1ib2xTdWZmaXhcbiAqIEBwYXJhbSBkZWNpbWFsU2VwYXJhdG9yXG4gKiBAcGFyYW0gdGhvdXNhbmRTZXBhcmF0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdE51bWJlcihpbnB1dDogbnVtYmVyIHwgc3RyaW5nLCBtaW5EZWNpbWFsPzogbnVtYmVyLCBtYXhEZWNpbWFsPzogbnVtYmVyLCBkaXNwbGF5TmVnYXRpdmVOdW1iZXJXaXRoUGFyZW50aGVzZXM/OiBib29sZWFuLCBzeW1ib2xQcmVmaXggPSAnJywgc3ltYm9sU3VmZml4ID0gJycsIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyB8ICcsJyA9ICcuJywgdGhvdXNhbmRTZXBhcmF0b3I6ICcsJyB8ICdfJyB8ICcuJyB8ICcgJyB8ICcnID0gJycpOiBzdHJpbmcge1xuICBpZiAoaXNOYU4oK2lucHV0KSkge1xuICAgIHJldHVybiBpbnB1dCBhcyBzdHJpbmc7XG4gIH1cblxuICBjb25zdCBjYWxjdWxhdGVkVmFsdWUgPSAoKE1hdGgucm91bmQocGFyc2VGbG9hdChpbnB1dCBhcyBzdHJpbmcpICogMTAwMDAwMCkgLyAxMDAwMDAwKSk7XG5cbiAgaWYgKGNhbGN1bGF0ZWRWYWx1ZSA8IDApIHtcbiAgICBjb25zdCBhYnNWYWx1ZSA9IE1hdGguYWJzKGNhbGN1bGF0ZWRWYWx1ZSk7XG4gICAgaWYgKGRpc3BsYXlOZWdhdGl2ZU51bWJlcldpdGhQYXJlbnRoZXNlcykge1xuICAgICAgaWYgKCFpc05hTihtaW5EZWNpbWFsKSB8fCAhaXNOYU4obWF4RGVjaW1hbCkpIHtcbiAgICAgICAgcmV0dXJuIGAoJHtzeW1ib2xQcmVmaXh9JHtkZWNpbWFsRm9ybWF0dGVkKGFic1ZhbHVlLCBtaW5EZWNpbWFsLCBtYXhEZWNpbWFsLCBkZWNpbWFsU2VwYXJhdG9yLCB0aG91c2FuZFNlcGFyYXRvcil9JHtzeW1ib2xTdWZmaXh9KWA7XG4gICAgICB9XG4gICAgICBjb25zdCBmb3JtYXR0ZWRWYWx1ZSA9IHRob3VzYW5kU2VwYXJhdG9yRm9ybWF0dGVkKGAke2Fic1ZhbHVlfWAsIHRob3VzYW5kU2VwYXJhdG9yKTtcbiAgICAgIHJldHVybiBgKCR7c3ltYm9sUHJlZml4fSR7Zm9ybWF0dGVkVmFsdWV9JHtzeW1ib2xTdWZmaXh9KWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghaXNOYU4obWluRGVjaW1hbCkgfHwgIWlzTmFOKG1heERlY2ltYWwpKSB7XG4gICAgICAgIHJldHVybiBgLSR7c3ltYm9sUHJlZml4fSR7ZGVjaW1hbEZvcm1hdHRlZChhYnNWYWx1ZSwgbWluRGVjaW1hbCwgbWF4RGVjaW1hbCwgZGVjaW1hbFNlcGFyYXRvciwgdGhvdXNhbmRTZXBhcmF0b3IpfSR7c3ltYm9sU3VmZml4fWA7XG4gICAgICB9XG4gICAgICBjb25zdCBmb3JtYXR0ZWRWYWx1ZSA9IHRob3VzYW5kU2VwYXJhdG9yRm9ybWF0dGVkKGAke2Fic1ZhbHVlfWAsIHRob3VzYW5kU2VwYXJhdG9yKTtcbiAgICAgIHJldHVybiBgLSR7c3ltYm9sUHJlZml4fSR7Zm9ybWF0dGVkVmFsdWV9JHtzeW1ib2xTdWZmaXh9YDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFpc05hTihtaW5EZWNpbWFsKSB8fCAhaXNOYU4obWF4RGVjaW1hbCkpIHtcbiAgICAgIHJldHVybiBgJHtzeW1ib2xQcmVmaXh9JHtkZWNpbWFsRm9ybWF0dGVkKGlucHV0LCBtaW5EZWNpbWFsLCBtYXhEZWNpbWFsLCBkZWNpbWFsU2VwYXJhdG9yLCB0aG91c2FuZFNlcGFyYXRvcil9JHtzeW1ib2xTdWZmaXh9YDtcbiAgICB9XG4gICAgY29uc3QgZm9ybWF0dGVkVmFsdWUgPSB0aG91c2FuZFNlcGFyYXRvckZvcm1hdHRlZChgJHtpbnB1dH1gLCB0aG91c2FuZFNlcGFyYXRvcik7XG4gICAgcmV0dXJuIGAke3N5bWJvbFByZWZpeH0ke2Zvcm1hdHRlZFZhbHVlfSR7c3ltYm9sU3VmZml4fWA7XG4gIH1cbn1cblxuLyoqIEZyb20gYSBkb3QgKC4pIG5vdGF0aW9uIHBhdGgsIGZpbmQgYW5kIHJldHVybiBhIHByb3BlcnR5IHdpdGhpbiBhbiBvYmplY3QgZ2l2ZW4gYSBwYXRoICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVzY2VuZGFudFByb3BlcnR5KG9iajogYW55LCBwYXRoOiBzdHJpbmcpOiBhbnkge1xuICByZXR1cm4gcGF0aC5zcGxpdCgnLicpLnJlZHVjZSgoYWNjLCBwYXJ0KSA9PiBhY2MgJiYgYWNjW3BhcnRdLCBvYmopO1xufVxuXG4vKiogR2V0IHRoZSBicm93c2VyJ3Mgc2Nyb2xsYmFyIHdpZHRoLCB0aGlzIGlzIGRpZmZlcmVudCB0byBlYWNoIGJyb3dzZXIgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY3JvbGxCYXJXaWR0aCgpOiBudW1iZXIge1xuICBjb25zdCAkb3V0ZXIgPSAkKCc8ZGl2PicpLmNzcyh7IHZpc2liaWxpdHk6ICdoaWRkZW4nLCB3aWR0aDogMTAwLCBvdmVyZmxvdzogJ3Njcm9sbCcgfSkuYXBwZW5kVG8oJ2JvZHknKTtcbiAgY29uc3Qgd2lkdGhXaXRoU2Nyb2xsID0gJCgnPGRpdj4nKS5jc3MoeyB3aWR0aDogJzEwMCUnIH0pLmFwcGVuZFRvKCRvdXRlcikub3V0ZXJXaWR0aCgpO1xuICAkb3V0ZXIucmVtb3ZlKCk7XG4gIHJldHVybiBNYXRoLmNlaWwoMTAwIC0gd2lkdGhXaXRoU2Nyb2xsKTtcbn1cblxuLyoqXG4gKiBGcm9tIGEgRGF0ZSBGaWVsZFR5cGUsIHJldHVybiBpdCdzIGVxdWl2YWxlbnQgbW9tZW50LmpzIGZvcm1hdFxuICogcmVmZXIgdG8gbW9tZW50LmpzIGZvciB0aGUgZm9ybWF0IHN0YW5kYXJkIHVzZWQ6IGh0dHBzOi8vbW9tZW50anMuY29tL2RvY3MvIy9wYXJzaW5nL3N0cmluZy1mb3JtYXQvXG4gKiBAcGFyYW0gZmllbGRUeXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBNb21lbnREYXRlRm9ybWF0V2l0aEZpZWxkVHlwZShmaWVsZFR5cGU6IEZpZWxkVHlwZSk6IHN0cmluZyB7XG4gIGxldCBtYXA6IHN0cmluZztcbiAgc3dpdGNoIChmaWVsZFR5cGUpIHtcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZTpcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUlzbzpcbiAgICAgIG1hcCA9ICdZWVlZLU1NLUREIEhIOm1tOnNzJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lU2hvcnRJc286XG4gICAgICBtYXAgPSAnWVlZWS1NTS1ERCBISDptbSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUlzb0FtUG06XG4gICAgICBtYXAgPSAnWVlZWS1NTS1ERCBoaDptbTpzcyBhJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lSXNvQU1fUE06XG4gICAgICBtYXAgPSAnWVlZWS1NTS1ERCBoaDptbTpzcyBBJztcbiAgICAgIGJyZWFrO1xuICAgIC8vIGFsbCBFdXJvIEZvcm1hdHMgKGRhdGUvbW9udGgveWVhcilcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlRXVybzpcbiAgICAgIG1hcCA9ICdERC9NTS9ZWVlZJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVFdXJvU2hvcnQ6XG4gICAgICBtYXAgPSAnRC9NL1lZJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lRXVybzpcbiAgICAgIG1hcCA9ICdERC9NTS9ZWVlZIEhIOm1tOnNzJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lU2hvcnRFdXJvOlxuICAgICAgbWFwID0gJ0REL01NL1lZWVkgSEg6bW0nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVFdXJvQW1QbTpcbiAgICAgIG1hcCA9ICdERC9NTS9ZWVlZIGhoOm1tOnNzIGEnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVFdXJvQU1fUE06XG4gICAgICBtYXAgPSAnREQvTU0vWVlZWSBoaDptbTpzcyBBJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lRXVyb1Nob3J0OlxuICAgICAgbWFwID0gJ0QvTS9ZWSBIOm06cyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUV1cm9TaG9ydEFtUG06XG4gICAgICBtYXAgPSAnRC9NL1lZIGg6bTpzIGEnO1xuICAgICAgYnJlYWs7XG4gICAgLy8gYWxsIFVTIEZvcm1hdHMgKG1vbnRoL2RhdGUveWVhcilcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVXM6XG4gICAgICBtYXAgPSAnTU0vREQvWVlZWSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVXNTaG9ydDpcbiAgICAgIG1hcCA9ICdNL0QvWVknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVVczpcbiAgICAgIG1hcCA9ICdNTS9ERC9ZWVlZIEhIOm1tOnNzJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lU2hvcnRVczpcbiAgICAgIG1hcCA9ICdNTS9ERC9ZWVlZIEhIOm1tJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lVXNBbVBtOlxuICAgICAgbWFwID0gJ01NL0REL1lZWVkgaGg6bW06c3MgYSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVVzQU1fUE06XG4gICAgICBtYXAgPSAnTU0vREQvWVlZWSBoaDptbTpzcyBBJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lVXNTaG9ydDpcbiAgICAgIG1hcCA9ICdNL0QvWVkgSDptOnMnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVVc1Nob3J0QW1QbTpcbiAgICAgIG1hcCA9ICdNL0QvWVkgaDptOnMgYSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVXRjOlxuICAgICAgbWFwID0gJ1lZWVktTU0tRERUSEg6bW06c3MuU1NTWic7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlOlxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVJc286XG4gICAgZGVmYXVsdDpcbiAgICAgIG1hcCA9ICdZWVlZLU1NLUREJztcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBtYXA7XG59XG5cbi8qKlxuICogRnJvbSBhIERhdGUgRmllbGRUeXBlLCByZXR1cm4gaXQncyBlcXVpdmFsZW50IEZsYXRwaWNrciBmb3JtYXRcbiAqIHJlZmVyIHRvIEZsYXRwaWNrciBmb3IgdGhlIGZvcm1hdCBzdGFuZGFyZCB1c2VkOiBodHRwczovL2NobWxuLmdpdGh1Yi5pby9mbGF0cGlja3IvZm9ybWF0dGluZy8jZGF0ZS1mb3JtYXR0aW5nLXRva2Vuc1xuICogYWxzbyBub3RlIHRoYXQgdGhleSBzZWVtIHZlcnkgc2ltaWxhciB0byBQSFAgZm9ybWF0IChleGNlcHQgZm9yIGFtL3BtKTogaHR0cDovL3BocC5uZXQvbWFudWFsL2VuL2Z1bmN0aW9uLmRhdGUucGhwXG4gKiBAcGFyYW0gZmllbGRUeXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBGbGF0cGlja3JEYXRlRm9ybWF0V2l0aEZpZWxkVHlwZShmaWVsZFR5cGU6IEZpZWxkVHlwZSk6IHN0cmluZyB7XG4gIC8qXG4gICAgZDogRGF5IG9mIHRoZSBtb250aCwgMiBkaWdpdHMgd2l0aCBsZWFkaW5nIHplcm9zXHQwMSB0byAzMVxuICAgIEQ6IEEgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiBhIGRheVx0TW9uIHRocm91Z2ggU3VuXG4gICAgbDogKGxvd2VyY2FzZSAnTCcpXHRBIGZ1bGwgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGF5IG9mIHRoZSB3ZWVrXHRTdW5kYXkgdGhyb3VnaCBTYXR1cmRheVxuICAgIGo6IERheSBvZiB0aGUgbW9udGggd2l0aG91dCBsZWFkaW5nIHplcm9zXHQxIHRvIDMxXG4gICAgSjogRGF5IG9mIHRoZSBtb250aCB3aXRob3V0IGxlYWRpbmcgemVyb3MgYW5kIG9yZGluYWwgc3VmZml4XHQxc3QsIDJuZCwgdG8gMzFzdFxuICAgIHc6IE51bWVyaWMgcmVwcmVzZW50YXRpb24gb2YgdGhlIGRheSBvZiB0aGUgd2Vla1x0MCAoZm9yIFN1bmRheSkgdGhyb3VnaCA2IChmb3IgU2F0dXJkYXkpXG4gICAgRjogQSBmdWxsIHRleHR1YWwgcmVwcmVzZW50YXRpb24gb2YgYSBtb250aFx0SmFudWFyeSB0aHJvdWdoIERlY2VtYmVyXG4gICAgbTogTnVtZXJpYyByZXByZXNlbnRhdGlvbiBvZiBhIG1vbnRoLCB3aXRoIGxlYWRpbmcgemVyb1x0MDEgdGhyb3VnaCAxMlxuICAgIG46IE51bWVyaWMgcmVwcmVzZW50YXRpb24gb2YgYSBtb250aCwgd2l0aG91dCBsZWFkaW5nIHplcm9zXHQxIHRocm91Z2ggMTJcbiAgICBNOiBBIHNob3J0IHRleHR1YWwgcmVwcmVzZW50YXRpb24gb2YgYSBtb250aFx0SmFuIHRocm91Z2ggRGVjXG4gICAgVTogVGhlIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIHRoZSBVbml4IEVwb2NoXHQxNDEzNzA0OTkzXG4gICAgeTogQSB0d28gZGlnaXQgcmVwcmVzZW50YXRpb24gb2YgYSB5ZWFyXHQ5OSBvciAwM1xuICAgIFk6IEEgZnVsbCBudW1lcmljIHJlcHJlc2VudGF0aW9uIG9mIGEgeWVhciwgNCBkaWdpdHNcdDE5OTkgb3IgMjAwM1xuICAgIEg6IEhvdXJzICgyNCBob3VycylcdDAwIHRvIDIzXG4gICAgaDogSG91cnNcdDEgdG8gMTJcbiAgICBpOiBNaW51dGVzXHQwMCB0byA1OVxuICAgIFM6IFNlY29uZHMsIDIgZGlnaXRzXHQwMCB0byA1OVxuICAgIHM6IFNlY29uZHNcdDAsIDEgdG8gNTlcbiAgICBLOiBBTS9QTVx0QU0gb3IgUE1cbiAgKi9cbiAgbGV0IG1hcDogc3RyaW5nO1xuICBzd2l0Y2ggKGZpZWxkVHlwZSkge1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lOlxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lSXNvOlxuICAgICAgbWFwID0gJ1ktbS1kIEg6aTpTJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lU2hvcnRJc286XG4gICAgICBtYXAgPSAnWS1tLWQgSDppJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lSXNvQW1QbTpcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUlzb0FNX1BNOlxuICAgICAgbWFwID0gJ1ktbS1kIGg6aTpTIEsnOyAvLyB0aGVyZSBpcyBubyBsb3dlcmNhc2UgaW4gRmxhdHBpY2tyIDooXG4gICAgICBicmVhaztcbiAgICAvLyBhbGwgRXVybyBGb3JtYXRzIChkYXRlL21vbnRoL3llYXIpXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZUV1cm86XG4gICAgICBtYXAgPSAnZC9tL1knO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZUV1cm9TaG9ydDpcbiAgICAgIG1hcCA9ICdkL20veSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUV1cm86XG4gICAgICBtYXAgPSAnZC9tL1kgSDppOlMnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVTaG9ydEV1cm86XG4gICAgICBtYXAgPSAnZC9tL3kgSDppJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lRXVyb0FtUG06XG4gICAgICBtYXAgPSAnZC9tL1kgaDppOlMgSyc7IC8vIHRoZXJlIGlzIG5vIGxvd2VyY2FzZSBpbiBGbGF0cGlja3IgOihcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lRXVyb0FNX1BNOlxuICAgICAgbWFwID0gJ2QvbS9ZIGg6aTpzIEsnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVFdXJvU2hvcnQ6XG4gICAgICBtYXAgPSAnZC9tL3kgSDppOnMnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVFdXJvU2hvcnRBbVBtOlxuICAgICAgbWFwID0gJ2QvbS95IGg6aTpzIEsnOyAvLyB0aGVyZSBpcyBubyBsb3dlcmNhc2UgaW4gRmxhdHBpY2tyIDooXG4gICAgICBicmVhaztcbiAgICAvLyBhbGwgVVMgRm9ybWF0cyAobW9udGgvZGF0ZS95ZWFyKVxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVVczpcbiAgICAgIG1hcCA9ICdtL2QvWSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVXNTaG9ydDpcbiAgICAgIG1hcCA9ICdtL2QveSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVVzOlxuICAgICAgbWFwID0gJ20vZC9ZIEg6aTpTJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lU2hvcnRVczpcbiAgICAgIG1hcCA9ICdtL2QveSBIOmknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVVc0FtUG06XG4gICAgICBtYXAgPSAnbS9kL1kgaDppOlMgSyc7IC8vIHRoZXJlIGlzIG5vIGxvd2VyY2FzZSBpbiBGbGF0cGlja3IgOihcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lVXNBTV9QTTpcbiAgICAgIG1hcCA9ICdtL2QvWSBoOmk6cyBLJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lVXNTaG9ydDpcbiAgICAgIG1hcCA9ICdtL2QveSBIOmk6cyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVVzU2hvcnRBbVBtOlxuICAgICAgbWFwID0gJ20vZC95IGg6aTpzIEsnOyAvLyB0aGVyZSBpcyBubyBsb3dlcmNhc2UgaW4gRmxhdHBpY2tyIDooXG4gICAgICBicmVhaztcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVXRjOlxuICAgICAgbWFwID0gJ1onO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZTpcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlSXNvOlxuICAgIGRlZmF1bHQ6XG4gICAgICBtYXAgPSAnWS1tLWQnO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIG1hcDtcbn1cblxuLyoqXG4gKiBNYXBwZXIgZm9yIHF1ZXJ5IG9wZXJhdG9ycyAoZXguOiA8PSBpcyBcImxlXCIsID4gaXMgXCJndFwiKVxuICogQHBhcmFtIHN0cmluZyBvcGVyYXRvclxuICogQHJldHVybnMgc3RyaW5nIG1hcFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwT3BlcmF0b3JUeXBlKG9wZXJhdG9yOiBPcGVyYXRvclR5cGUgfCBPcGVyYXRvclN0cmluZyk6IE9wZXJhdG9yVHlwZSB7XG4gIGxldCBtYXA6IE9wZXJhdG9yVHlwZTtcblxuICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgY2FzZSAnPCc6XG4gICAgY2FzZSAnTFQnOlxuICAgICAgbWFwID0gT3BlcmF0b3JUeXBlLmxlc3NUaGFuO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnPD0nOlxuICAgIGNhc2UgJ0xFJzpcbiAgICAgIG1hcCA9IE9wZXJhdG9yVHlwZS5sZXNzVGhhbk9yRXF1YWw7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc+JzpcbiAgICBjYXNlICdHVCc6XG4gICAgICBtYXAgPSBPcGVyYXRvclR5cGUuZ3JlYXRlclRoYW47XG4gICAgICBicmVhaztcbiAgICBjYXNlICc+PSc6XG4gICAgY2FzZSAnR0UnOlxuICAgICAgbWFwID0gT3BlcmF0b3JUeXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzw+JzpcbiAgICBjYXNlICchPSc6XG4gICAgY2FzZSAnTkUnOlxuICAgICAgbWFwID0gT3BlcmF0b3JUeXBlLm5vdEVxdWFsO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnKic6XG4gICAgY2FzZSAnYSonOlxuICAgIGNhc2UgJ1N0YXJ0c1dpdGgnOlxuICAgICAgbWFwID0gT3BlcmF0b3JUeXBlLnN0YXJ0c1dpdGg7XG4gICAgICBicmVhaztcbiAgICBjYXNlICcqeic6XG4gICAgY2FzZSAnRW5kc1dpdGgnOlxuICAgICAgbWFwID0gT3BlcmF0b3JUeXBlLmVuZHNXaXRoO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnPSc6XG4gICAgY2FzZSAnPT0nOlxuICAgIGNhc2UgJ0VRJzpcbiAgICAgIG1hcCA9IE9wZXJhdG9yVHlwZS5lcXVhbDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0lOJzpcbiAgICAgIG1hcCA9IE9wZXJhdG9yVHlwZS5pbjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ05JTic6XG4gICAgY2FzZSAnTk9UX0lOJzpcbiAgICAgIG1hcCA9IE9wZXJhdG9yVHlwZS5ub3RJbjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ05vdF9Db250YWlucyc6XG4gICAgY2FzZSAnTk9UX0NPTlRBSU5TJzpcbiAgICAgIG1hcCA9IE9wZXJhdG9yVHlwZS5ub3RDb250YWlucztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0NvbnRhaW5zJzpcbiAgICBjYXNlICdDT05UQUlOUyc6XG4gICAgZGVmYXVsdDpcbiAgICAgIG1hcCA9IE9wZXJhdG9yVHlwZS5jb250YWlucztcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIG1hcDtcbn1cblxuLyoqXG4gKiBGaW5kIGVxdWl2YWxlbnQgc2hvcnQgZGVzaWduYXRpb24gb2YgYW4gT3BlcmF0b3IgVHlwZSBvciBPcGVyYXRvciBTdHJpbmcuXG4gKiBXaGVuIHVzaW5nIGEgQ29tcG91bmQgRmlsdGVyLCB3ZSB1c2UgdGhlIHNob3J0IGRlc2lnbmF0aW9uIGFuZCBzbyB3ZSBuZWVkIHRoZSBtYXBwZWQgdmFsdWUuXG4gKiBGb3IgZXhhbXBsZSBPcGVyYXRvclR5cGUuc3RhcnRzV2l0aCBzaG9ydCBkZXNpZ25hdGlvbiBpcyBcImEqXCIsIHdoaWxlIE9wZXJhdG9yVHlwZS5ncmVhdGVyVGhhbk9yRXF1YWwgaXMgXCI+PVwiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBPcGVyYXRvclRvU2hvcnRoYW5kRGVzaWduYXRpb24ob3BlcmF0b3I6IE9wZXJhdG9yVHlwZSB8IE9wZXJhdG9yU3RyaW5nKTogT3BlcmF0b3JTdHJpbmcge1xuICBsZXQgc2hvcnRPcGVyYXRvcjogT3BlcmF0b3JTdHJpbmcgPSAnJztcblxuICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgY2FzZSBPcGVyYXRvclR5cGUuZ3JlYXRlclRoYW46XG4gICAgY2FzZSAnPic6XG4gICAgICBzaG9ydE9wZXJhdG9yID0gJz4nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBPcGVyYXRvclR5cGUuZ3JlYXRlclRoYW5PckVxdWFsOlxuICAgIGNhc2UgJz49JzpcbiAgICAgIHNob3J0T3BlcmF0b3IgPSAnPj0nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBPcGVyYXRvclR5cGUubGVzc1RoYW46XG4gICAgY2FzZSAnPCc6XG4gICAgICBzaG9ydE9wZXJhdG9yID0gJzwnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBPcGVyYXRvclR5cGUubGVzc1RoYW5PckVxdWFsOlxuICAgIGNhc2UgJzw9JzpcbiAgICAgIHNob3J0T3BlcmF0b3IgPSAnPD0nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBPcGVyYXRvclR5cGUubm90RXF1YWw6XG4gICAgY2FzZSAnPD4nOlxuICAgICAgc2hvcnRPcGVyYXRvciA9ICc8Pic7XG4gICAgICBicmVhaztcbiAgICBjYXNlIE9wZXJhdG9yVHlwZS5lcXVhbDpcbiAgICBjYXNlICc9JzpcbiAgICBjYXNlICc9PSc6XG4gICAgY2FzZSAnRVEnOlxuICAgICAgc2hvcnRPcGVyYXRvciA9ICc9JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgT3BlcmF0b3JUeXBlLnN0YXJ0c1dpdGg6XG4gICAgY2FzZSAnYSonOlxuICAgIGNhc2UgJyonOlxuICAgICAgc2hvcnRPcGVyYXRvciA9ICdhKic7XG4gICAgICBicmVhaztcbiAgICBjYXNlIE9wZXJhdG9yVHlwZS5lbmRzV2l0aDpcbiAgICBjYXNlICcqeic6XG4gICAgICBzaG9ydE9wZXJhdG9yID0gJyp6JztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBhbnkgb3RoZXIgb3BlcmF0b3Igd2lsbCBiZSBjb25zaWRlcmVkIGFzIGFscmVhZHkgYSBzaG9ydCBleHByZXNzaW9uLCBzbyB3ZSBjYW4gcmV0dXJuIHNhbWUgaW5wdXQgb3BlcmF0b3JcbiAgICAgIHNob3J0T3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHNob3J0T3BlcmF0b3I7XG59XG5cbi8qKlxuICogTWFwcGVyIGZvciBxdWVyeSBvcGVyYXRvciBieSBhIEZpbHRlciBUeXBlXG4gKiBGb3IgZXhhbXBsZSBhIG11bHRpcGxlLXNlbGVjdCB0eXBpY2FsbHkgdXNlcyAnSU4nIG9wZXJhdG9yXG4gKiBAcGFyYW0gb3BlcmF0b3JcbiAqIEByZXR1cm5zIHN0cmluZyBtYXBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcE9wZXJhdG9yQnlGaWVsZFR5cGUoZmllbGRUeXBlOiBGaWVsZFR5cGUgfCBzdHJpbmcpOiBPcGVyYXRvclR5cGUge1xuICBsZXQgbWFwOiBPcGVyYXRvclR5cGU7XG5cbiAgc3dpdGNoIChmaWVsZFR5cGUpIHtcbiAgICBjYXNlIEZpZWxkVHlwZS5zdHJpbmc6XG4gICAgY2FzZSBGaWVsZFR5cGUudW5rbm93bjpcbiAgICAgIG1hcCA9IE9wZXJhdG9yVHlwZS5jb250YWlucztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmllbGRUeXBlLmZsb2F0OlxuICAgIGNhc2UgRmllbGRUeXBlLm51bWJlcjpcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlOlxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVJc286XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVV0YzpcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZTpcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUlzbzpcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUlzb0FtUG06XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVJc29BTV9QTTpcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlRXVybzpcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlRXVyb1Nob3J0OlxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lRXVybzpcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUV1cm9BbVBtOlxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lRXVyb0FNX1BNOlxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lRXVyb1Nob3J0OlxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lRXVyb1Nob3J0QW1QbTpcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUV1cm9TaG9ydEFNX1BNOlxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVVczpcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVXNTaG9ydDpcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVVzOlxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lVXNBbVBtOlxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lVXNBTV9QTTpcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVVzU2hvcnQ6XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVVc1Nob3J0QW1QbTpcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVVzU2hvcnRBTV9QTTpcbiAgICBkZWZhdWx0OlxuICAgICAgbWFwID0gT3BlcmF0b3JUeXBlLmVxdWFsO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gbWFwO1xufVxuXG4vKiogUGFyc2UgYW55IGlucHV0IChib29sLCBudW1iZXIsIHN0cmluZykgYW5kIHJldHVybiBhIGJvb2xlYW4gb3IgRmFsc2Ugd2hlbiBub3QgcG9zc2libGUgKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUJvb2xlYW4oaW5wdXQ6IGFueSk6IGJvb2xlYW4ge1xuICByZXR1cm4gLyh0cnVlfDEpL2kudGVzdChpbnB1dCArICcnKTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhIGRhdGUgcGFzc2VkIGFzIGEgc3RyaW5nIChEYXRlIG9ubHksIHdpdGhvdXQgdGltZSkgYW5kIHJldHVybiBhIERhdGUgb2JqZWN0IChpZiB2YWxpZClcbiAqIEBwYXJhbSBpbnB1dERhdGVTdHJpbmdcbiAqIEByZXR1cm5zIHN0cmluZyBkYXRlIGZvcm1hdHRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VVdGNEYXRlKGlucHV0RGF0ZVN0cmluZzogc3RyaW5nLCB1c2VVdGM/OiBib29sZWFuKTogc3RyaW5nIHwgbnVsbCB7XG4gIGxldCBkYXRlID0gbnVsbDtcblxuICBpZiAoL15bMC05XFwtXFwvXSokLy50ZXN0KGlucHV0RGF0ZVN0cmluZykpIHtcbiAgICAvLyBnZXQgdGhlIFVUQyBkYXRldGltZSB3aXRoIG1vbWVudC5qcyBidXQgd2UgbmVlZCB0byBkZWNvZGUgdGhlIHZhbHVlIHNvIHRoYXQgaXQncyB2YWxpZCB0ZXh0XG4gICAgY29uc3QgZGF0ZVN0cmluZyA9IGRlY29kZVVSSUNvbXBvbmVudChpbnB1dERhdGVTdHJpbmcpO1xuICAgIGNvbnN0IGRhdGVNb21lbnQgPSBtb21lbnQobmV3IERhdGUoZGF0ZVN0cmluZykpO1xuICAgIGlmIChkYXRlTW9tZW50LmlzVmFsaWQoKSAmJiBkYXRlTW9tZW50LnllYXIoKS50b1N0cmluZygpLmxlbmd0aCA9PT0gNCkge1xuICAgICAgZGF0ZSA9ICh1c2VVdGMpID8gZGF0ZU1vbWVudC51dGMoKS5mb3JtYXQoKSA6IGRhdGVNb21lbnQuZm9ybWF0KCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGU7XG59XG5cbi8qKlxuICogU2FuaXRpemUsIHJldHVybiBvbmx5IHRoZSB0ZXh0IHdpdGhvdXQgSFRNTCB0YWdzXG4gKiBAaW5wdXQgaHRtbFN0cmluZ1xuICogQHJldHVybiB0ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYW5pdGl6ZUh0bWxUb1RleHQoaHRtbFN0cmluZzogc3RyaW5nKSB7XG4gIGNvbnN0IHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGVtcC5pbm5lckhUTUwgPSBodG1sU3RyaW5nO1xuICByZXR1cm4gdGVtcC50ZXh0Q29udGVudCB8fCB0ZW1wLmlubmVyVGV4dCB8fCAnJztcbn1cblxuLyoqIFNldCB0aGUgb2JqZWN0IHZhbHVlIG9mIGRlZXBlciBub2RlIGZyb20gYSBnaXZlbiBkb3QgKC4pIG5vdGF0aW9uIHBhdGggKGUuZy46IFwidXNlci5maXJzdE5hbWVcIikgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXREZWVwVmFsdWUob2JqOiBhbnksIHBhdGg6IHN0cmluZyB8IHN0cmluZ1tdLCB2YWx1ZTogYW55KSB7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICBwYXRoID0gcGF0aC5zcGxpdCgnLicpO1xuICB9XG5cbiAgaWYgKHBhdGgubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IGUgPSBwYXRoLnNoaWZ0KCk7XG4gICAgc2V0RGVlcFZhbHVlKFxuICAgICAgb2JqW2VdID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9ialtlXSkgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gb2JqW2VdIDoge30sXG4gICAgICBwYXRoLFxuICAgICAgdmFsdWVcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIG9ialtwYXRoWzBdXSA9IHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogRm9ybWF0IGEgbnVtYmVyIG9yIGEgc3RyaW5nIGludG8gYSBzdHJpbmcgdGhhdCBpcyBzZXBhcmF0ZWQgZXZlcnkgdGhvdXNhbmQsXG4gKiB0aGUgZGVmYXVsdCBzZXBhcmF0b3IgaXMgYSBjb21tYSBidXQgdXNlciBjYW4gb3B0aW9uYWxseSBwYXNzIGEgZGlmZmVyZW50IG9uZVxuICogQHBhcmFtIGlucHV0VmFsdWVcbiAqIEBwYXJhbSBzZXBhcmF0b3IgZGVmYXVsdCB0byBjb21tYSBcIixcIlxuICogQHJldHVybnMgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aG91c2FuZFNlcGFyYXRvckZvcm1hdHRlZChpbnB1dFZhbHVlOiBzdHJpbmcgfCBudW1iZXIgfCBudWxsLCBzZXBhcmF0b3I6ICcsJyB8ICdfJyB8ICcuJyB8ICcgJyB8ICcnID0gJywnKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmIChpbnB1dFZhbHVlICE9PSBudWxsICYmIGlucHV0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHN0cmluZ1ZhbHVlID0gYCR7aW5wdXRWYWx1ZX1gO1xuICAgIGNvbnN0IGRlY2ltYWxTcGxpdCA9IHN0cmluZ1ZhbHVlLnNwbGl0KCcuJyk7XG4gICAgaWYgKGRlY2ltYWxTcGxpdC5sZW5ndGggPT09IDIpIHtcbiAgICAgIHJldHVybiBgJHtkZWNpbWFsU3BsaXRbMF0ucmVwbGFjZSgvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgc2VwYXJhdG9yKX0uJHtkZWNpbWFsU3BsaXRbMV19YDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ1ZhbHVlLnJlcGxhY2UoL1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csIHNlcGFyYXRvcik7XG4gIH1cbiAgcmV0dXJuIGlucHV0VmFsdWUgYXMgbnVsbDtcbn1cblxuLyoqXG4gKiBUaXRsZSBjYXNlIChvciBjYXBpdGFsaXplKSBmaXJzdCBjaGFyIG9mIGEgc3RyaW5nXG4gKiBPcHRpb25hbGwgdGl0bGUgY2FzZSB0aGUgY29tcGxldGUgc2VudGVuY2UgKHVwcGVyIGNhc2UgZmlyc3QgY2hhciBvZiBlYWNoIHdvcmQgd2hpbGUgY2hhbmdpbmcgZXZlcnl0aGluZyBlbHNlIHRvIGxvd2VyIGNhc2UpXG4gKiBAcGFyYW0gaW5wdXRTdHJcbiAqIEByZXR1cm5zIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gdGl0bGVDYXNlKGlucHV0U3RyOiBzdHJpbmcsIGNhc2VFdmVyeVdvcmRzID0gZmFsc2UpOiBzdHJpbmcge1xuICBpZiAodHlwZW9mIGlucHV0U3RyID09PSAnc3RyaW5nJykge1xuICAgIGlmIChjYXNlRXZlcnlXb3Jkcykge1xuICAgICAgcmV0dXJuIGlucHV0U3RyLnJlcGxhY2UoL1xcd1xcUyovZywgKG91dHB1dFN0cikgPT4ge1xuICAgICAgICByZXR1cm4gb3V0cHV0U3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgb3V0cHV0U3RyLnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dFN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGlucHV0U3RyLnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBpbnB1dFN0cjtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyB0byBjYW1lbCBjYXNlIChjYW1lbENhc2UpXG4gKiBAcGFyYW0gaW5wdXRTdHIgdGhlIHN0cmluZyB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIHRoZSBzdHJpbmcgaW4gY2FtZWwgY2FzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9DYW1lbENhc2UoaW5wdXRTdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmICh0eXBlb2YgaW5wdXRTdHIgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGlucHV0U3RyLnJlcGxhY2UoLyg/Ol5cXHd8W0EtWl18XFxiXFx3fFtcXHMrXFwtX1xcL10pL2csIChtYXRjaDogc3RyaW5nLCBvZmZzZXQ6IG51bWJlcikgPT4ge1xuICAgICAgLy8gcmVtb3ZlIHdoaXRlIHNwYWNlIG9yIGh5cGVucyBvciB1bmRlcnNjb3Jlc1xuICAgICAgaWYgKC9bXFxzK1xcLV9cXC9dLy50ZXN0KG1hdGNoKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvZmZzZXQgPT09IDAgPyBtYXRjaC50b0xvd2VyQ2FzZSgpIDogbWF0Y2gudG9VcHBlckNhc2UoKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaW5wdXRTdHI7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgdG8ga2ViYWIgKGh5cGVuKSBjYXNlXG4gKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgdG8gY29udmVydFxuICogQHJldHVybiB0aGUgc3RyaW5nIGluIGtlYmFiIGNhc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvS2ViYWJDYXNlKGlucHV0U3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAodHlwZW9mIGlucHV0U3RyID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0b0NhbWVsQ2FzZShpbnB1dFN0cikucmVwbGFjZSgvKFtBLVpdKS9nLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbiAgfVxuICByZXR1cm4gaW5wdXRTdHI7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgZnJvbSBjYW1lbENhc2UgdG8gc25ha2VfY2FzZSAodW5kZXJzY29yZSkgY2FzZVxuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4gdGhlIHN0cmluZyBpbiBrZWJhYiBjYXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1NuYWtlQ2FzZShpbnB1dFN0cjogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKHR5cGVvZiBpbnB1dFN0ciA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdG9DYW1lbENhc2UoaW5wdXRTdHIpLnJlcGxhY2UoLyhbQS1aXSkvZywgJ18kMScpLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgcmV0dXJuIGlucHV0U3RyO1xufVxuXG4vKipcbiAqIFRha2VzIGFuIGlucHV0IGFycmF5IGFuZCBtYWtlcyBzdXJlIHRoZSBhcnJheSBoYXMgdW5pcXVlIHZhbHVlcyBieSByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0gYXJyYXkgaW5wdXQgd2l0aCBwb3NzaWJsZSBkdXBsaWNhdGVzXG4gKiBAcGFyYW0gb2JqZWN0UHJvcGVydHkgb3B0aW9uYWxseSBwcm92aWRlIGFuIG9iamVjdCBwcm9wZXJ0eSB0byBjb21wYXJlIChleGFtcGxlOiAnaWQnKVxuICogQHJldHVybiBhcnJheSBvdXRwdXQgd2l0aG91dCBkdXBsaWNhdGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmlxdWVBcnJheShhcnI6IGFueVtdKTogYW55W10ge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpICYmIGFyci5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGFyci5maWx0ZXIoKGl0ZW06IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgcmV0dXJuIGFyci5pbmRleE9mKGl0ZW0pID49IGluZGV4O1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbi8qKlxuICogVGFrZXMgYW4gaW5wdXQgYXJyYXkgb2Ygb2JqZWN0cyBhbmQgbWFrZXMgc3VyZSB0aGUgYXJyYXkgaGFzIHVuaXF1ZSBvYmplY3QgdmFsdWVzIGJ5IHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIGl0IHdpbGwgbG9vcCB0aHJvdWdoIHRoZSBhcnJheSB1c2luZyBhIHByb3BlcnR5IG5hbWUgKG9yIFwiaWRcIiB3aGVuIGlzIG5vdCBwcm92aWRlZCkgdG8gY29tcGFyZSB1bmlxdWVuZXNzXG4gKiBAcGFyYW0gYXJyYXkgaW5wdXQgd2l0aCBwb3NzaWJsZSBkdXBsaWNhdGVzXG4gKiBAcGFyYW0gcHJvcGVydHlOYW1lIGRlZmF1bHRzIHRvIFwiaWRcIlxuICogQHJldHVybiBhcnJheSBvdXRwdXQgd2l0aG91dCBkdXBsaWNhdGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmlxdWVPYmplY3RBcnJheShhcnI6IGFueVtdLCBwcm9wZXJ0eU5hbWUgPSAnaWQnKTogYW55W10ge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpICYmIGFyci5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGFycikge1xuICAgICAgaWYgKCFtYXAuaGFzKGl0ZW1bcHJvcGVydHlOYW1lXSkpIHtcbiAgICAgICAgbWFwLnNldChpdGVtW3Byb3BlcnR5TmFtZV0sIHRydWUpOyAgICAvLyBzZXQgYW55IHZhbHVlIHRvIE1hcFxuICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgaWQ6IGl0ZW1bcHJvcGVydHlOYW1lXSxcbiAgICAgICAgICBuYW1lOiBpdGVtLm5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuLyoqXG4gKiBVbnN1YnNjcmliZSBhbGwgT2JzZXJ2YWJsZXMgU3Vic2NyaXB0aW9uc1xuICogSXQgd2lsbCByZXR1cm4gYW4gZW1wdHkgYXJyYXkgaWYgaXQgYWxsIHdlbnQgd2VsbFxuICogQHBhcmFtIHN1YnNjcmlwdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuc3Vic2NyaWJlQWxsT2JzZXJ2YWJsZXMoc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10pOiBTdWJzY3JpcHRpb25bXSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHN1YnNjcmlwdGlvbnMpKSB7XG4gICAgc3Vic2NyaXB0aW9ucy5mb3JFYWNoKChzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbikgPT4ge1xuICAgICAgaWYgKHN1YnNjcmlwdGlvbiAmJiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUpIHtcbiAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc3Vic2NyaXB0aW9ucyA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIHN1YnNjcmlwdGlvbnM7XG59XG4iXX0=