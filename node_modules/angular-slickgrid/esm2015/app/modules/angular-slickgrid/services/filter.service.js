import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { isObservable, Subject } from 'rxjs';
import * as isequal_ from 'lodash.isequal';
const isequal = isequal_; // patch to fix rollup to work
import { EmitterType, FieldType, KeyCode, OperatorType, } from './../models/index';
import { executeBackendCallback, refreshBackendDataset } from './backend-utilities';
import { getDescendantProperty } from './utilities';
import { FilterConditions } from './../filter-conditions';
import { FilterFactory } from '../filters/filterFactory';
import { SharedService } from './shared.service';
// timer for keeping track of user typing waits
let timer;
const DEFAULT_FILTER_TYPING_DEBOUNCE = 500;
let FilterService = class FilterService {
    constructor(filterFactory, sharedService) {
        this.filterFactory = filterFactory;
        this.sharedService = sharedService;
        this._isFilterFirstRender = true;
        this._firstColumnIdRendered = '';
        this._filtersMetadata = [];
        this._columnFilters = {};
        this.httpCancelRequests$ = new Subject(); // this will be used to cancel any pending http request
        this.onFilterChanged = new Subject();
        this.onFilterCleared = new Subject();
        this._eventHandler = new Slick.EventHandler();
        this._onSearchChange = new Slick.Event();
    }
    /** Getter of the SlickGrid Event Handler */
    get eventHandler() {
        return this._eventHandler;
    }
    /** Getter to know if the filter was already rendered or if it was its first time render */
    get isFilterFirstRender() {
        return this._isFilterFirstRender;
    }
    /** Getter of the SlickGrid Event Handler */
    get onSearchChange() {
        return this._onSearchChange;
    }
    /** Getter for the Grid Options pulled through the Grid Object */
    get _gridOptions() {
        return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
    }
    /** Getter for the Column Definitions pulled through the Grid Object */
    get _columnDefinitions() {
        return (this._grid && this._grid.getColumns) ? this._grid.getColumns() : [];
    }
    init(grid) {
        this._grid = grid;
    }
    dispose() {
        this.disposeColumnFilters();
        // unsubscribe all SlickGrid events
        if (this._eventHandler && this._eventHandler.unsubscribeAll) {
            this._eventHandler.unsubscribeAll();
        }
        if (isObservable(this.httpCancelRequests$)) {
            this.httpCancelRequests$.next(); // this cancels any pending http requests
        }
    }
    /**
     * Dispose of the filters, since it's a singleton, we don't want to affect other grids with same columns
     */
    disposeColumnFilters() {
        // we need to loop through all columnFilters and delete them 1 by 1
        // only trying to make columnFilter an empty (without looping) would not trigger a dataset change
        if (typeof this._columnFilters === 'object') {
            for (const columnId in this._columnFilters) {
                if (columnId && this._columnFilters[columnId]) {
                    delete this._columnFilters[columnId];
                }
            }
        }
        // also destroy each Filter instances
        if (Array.isArray(this._filtersMetadata)) {
            this._filtersMetadata.forEach((filter) => {
                if (filter && filter.destroy) {
                    filter.destroy(true);
                }
            });
        }
    }
    /**
     * Bind a backend filter hook to the grid
     * @param grid SlickGrid Grid object
     */
    bindBackendOnFilter(grid, dataView) {
        this._dataView = dataView;
        this._filtersMetadata = [];
        // subscribe to SlickGrid onHeaderRowCellRendered event to create filter template
        this._eventHandler.subscribe(grid.onHeaderRowCellRendered, (e, args) => {
            // firstColumnIdRendered is null at first, so if it changes to being filled and equal, then we would know that it was already rendered
            // this is to avoid rendering the filter twice (only the Select Filter for now), rendering it again also clears the filter which has unwanted side effect
            if (args.column.id === this._firstColumnIdRendered) {
                this._isFilterFirstRender = false;
            }
            this.addFilterTemplateToHeaderRow(args, this._isFilterFirstRender);
            if (this._firstColumnIdRendered === '') {
                this._firstColumnIdRendered = args.column.id;
            }
        });
        // subscribe to the SlickGrid event and call the backend execution
        this._eventHandler.subscribe(this._onSearchChange, this.onBackendFilterChange.bind(this));
    }
    /**
     * Bind a local filter hook to the grid
     * @param grid SlickGrid Grid object
     * @param dataView
     */
    bindLocalOnFilter(grid, dataView) {
        this._filtersMetadata = [];
        this._dataView = dataView;
        dataView.setFilterArgs({ columnFilters: this._columnFilters, grid: this._grid, dataView });
        dataView.setFilter(this.customLocalFilter.bind(this));
        this._eventHandler.subscribe(this._onSearchChange, (e, args) => {
            const columnId = args.columnId;
            if (columnId != null) {
                dataView.refresh();
            }
            // emit an onFilterChanged event when it's not called by a clear filter
            if (args && !args.clearFilterTriggered) {
                this.emitFilterChanged(EmitterType.local);
            }
        });
        // subscribe to SlickGrid onHeaderRowCellRendered event to create filter template
        this._eventHandler.subscribe(grid.onHeaderRowCellRendered, (e, args) => {
            this.addFilterTemplateToHeaderRow(args);
        });
    }
    clearFilterByColumnId(event, columnId) {
        // get current column filter before clearing, this allow us to know if the filter was empty prior to calling the clear filter
        const currentColumnFilters = Object.keys(this._columnFilters);
        let currentColFilter;
        if (Array.isArray(currentColumnFilters)) {
            currentColFilter = currentColumnFilters.find((name) => name === columnId);
        }
        // find the filter object and call its clear method with true (the argument tells the method it was called by a clear filter)
        const colFilter = this._filtersMetadata.find((filter) => filter.columnDef.id === columnId);
        if (colFilter && colFilter.clear) {
            colFilter.clear(true);
        }
        let emitter = EmitterType.local;
        const isBackendApi = this._gridOptions && this._gridOptions.backendServiceApi || false;
        // when using a backend service, we need to manually trigger a filter change but only if the filter was previously filled
        if (isBackendApi) {
            emitter = EmitterType.remote;
            if (currentColFilter) {
                this.onBackendFilterChange(event, { grid: this._grid, columnFilters: this._columnFilters });
            }
        }
        // emit an event when filter is cleared
        this.emitFilterChanged(emitter);
    }
    /** Clear the search filters (below the column titles) */
    clearFilters(triggerChange = true) {
        this._filtersMetadata.forEach((filter) => {
            if (filter && filter.clear) {
                // clear element but don't trigger individual clear change,
                // we'll do 1 trigger for all filters at once afterward
                filter.clear(false);
            }
        });
        // we also need to refresh the dataView and optionally the grid (it's optional since we use DataView)
        if (this._dataView && this._grid) {
            this._dataView.refresh();
            this._grid.invalidate();
        }
        // when using backend service, we need to query only once so it's better to do it here
        const backendApi = this._gridOptions && this._gridOptions.backendServiceApi;
        if (backendApi && triggerChange) {
            const callbackArgs = { clearFilterTriggered: true, shouldTriggerQuery: triggerChange, grid: this._grid, columnFilters: this._columnFilters };
            const queryResponse = backendApi.service.processOnFilterChanged(undefined, callbackArgs);
            if (queryResponse instanceof Promise && queryResponse.then) {
                // @deprecated, processOnFilterChanged in the future should be returned as a query string NOT as a Promise
                console.warn(`[Angular-Slickgrid] please note that the "processOnFilterChanged" from your Backend Service, should now return a string instead of a Promise.
          Returning a Promise will be deprecated in the future.`);
                queryResponse.then((query) => {
                    const totalItems = this._gridOptions && this._gridOptions.pagination && this._gridOptions.pagination.totalItems;
                    executeBackendCallback(backendApi, query, callbackArgs, new Date(), totalItems, this.emitFilterChanged.bind(this));
                });
            }
            else {
                const query = queryResponse;
                const totalItems = this._gridOptions && this._gridOptions.pagination && this._gridOptions.pagination.totalItems;
                executeBackendCallback(backendApi, query, callbackArgs, new Date(), totalItems, this.emitFilterChanged.bind(this));
            }
        }
        // emit an event when filters are all cleared
        if (triggerChange) {
            this.onFilterCleared.next(true);
        }
    }
    customLocalFilter(item, args) {
        const dataView = args && args.dataView;
        for (const columnId of Object.keys(args.columnFilters)) {
            const columnFilter = args.columnFilters[columnId];
            let columnIndex = args.grid.getColumnIndex(columnId);
            let columnDef = args.grid.getColumns()[columnIndex];
            // it might be a hidden column, if so it won't be part of the getColumns (because it we hide a column via setColumns)
            // when that happens we can try to get the column definition from all defined columns
            if (!columnDef && this.sharedService && Array.isArray(this.sharedService.allColumns)) {
                columnIndex = this.sharedService.allColumns.findIndex((col) => col.field === columnId);
                columnDef = this.sharedService.allColumns[columnIndex];
            }
            // if we still don't have a column definition then we should return then row anyway (true)
            if (!columnDef) {
                return true;
            }
            // Row Detail View plugin, if the row is padding we just get the value we're filtering on from it's parent
            if (this._gridOptions.enableRowDetailView) {
                const metadataPrefix = this._gridOptions.rowDetailView && this._gridOptions.rowDetailView.keyPrefix || '__';
                if (item[`${metadataPrefix}isPadding`] && item[`${metadataPrefix}parent`]) {
                    item = item[`${metadataPrefix}parent`];
                }
            }
            const dataKey = columnDef.dataKey;
            const fieldName = columnDef.queryFieldFilter || columnDef.queryField || columnDef.field;
            const fieldType = columnDef.type || FieldType.string;
            const filterSearchType = (columnDef.filterSearchType) ? columnDef.filterSearchType : null;
            let cellValue = item[fieldName];
            // when item is a complex object (dot "." notation), we need to filter the value contained in the object tree
            if (fieldName.indexOf('.') >= 0) {
                cellValue = getDescendantProperty(item, fieldName);
            }
            // if we find searchTerms use them but make a deep copy so that we don't affect original array
            // we might have to overwrite the value(s) locally that are returned
            // e.g: we don't want to operator within the search value, since it will fail filter condition check trigger afterward
            const searchValues = (columnFilter && columnFilter.searchTerms) ? $.extend(true, [], columnFilter.searchTerms) : null;
            let fieldSearchValue = (Array.isArray(searchValues) && searchValues.length === 1) ? searchValues[0] : '';
            let matches = null;
            if (fieldType !== FieldType.object) {
                fieldSearchValue = '' + fieldSearchValue; // make sure it's a string
                matches = fieldSearchValue.match(/^([<>!=\*]{0,2})(.*[^<>!=\*])([\*]?)$/); // group 1: Operator, 2: searchValue, 3: last char is '*' (meaning starts with, ex.: abc*)
            }
            let operator = columnFilter.operator || ((matches) ? matches[1] : '');
            const searchTerm = (!!matches) ? matches[2] : '';
            const lastValueChar = (!!matches) ? matches[3] : (operator === '*z' ? '*' : '');
            if (searchValues && searchValues.length > 1) {
                fieldSearchValue = searchValues.join(',');
            }
            else if (typeof fieldSearchValue === 'string') {
                // escaping the search value
                fieldSearchValue = fieldSearchValue.replace(`'`, `''`); // escape single quotes by doubling them
                if (operator === '*' || operator === 'a*' || operator === '*z' || lastValueChar === '*') {
                    operator = (operator === '*' || operator === '*z') ? OperatorType.endsWith : OperatorType.startsWith;
                }
            }
            // no need to query if search value is empty
            if (searchTerm === '' && (!searchValues || (Array.isArray(searchValues) && searchValues.length === 0))) {
                return true;
            }
            // if search value has a regex match we will only keep the value without the operator
            // in this case we need to overwrite the returned search values to truncate operator from the string search
            if (Array.isArray(matches) && matches.length >= 1 && (Array.isArray(searchValues) && searchValues.length === 1)) {
                searchValues[0] = searchTerm;
            }
            // filter search terms should always be string type (even though we permit the end user to input numbers)
            // so make sure each term are strings, if user has some default search terms, we will cast them to string
            if (searchValues && Array.isArray(searchValues) && fieldType !== FieldType.object) {
                for (let k = 0, ln = searchValues.length; k < ln; k++) {
                    // make sure all search terms are strings
                    searchValues[k] = ((searchValues[k] === undefined || searchValues[k] === null) ? '' : searchValues[k]) + '';
                }
            }
            // when using localization (i18n), we should use the formatter output to search as the new cell value
            if (columnDef && columnDef.params && columnDef.params.useFormatterOuputToFilter) {
                const rowIndex = (dataView && typeof dataView.getIdxById === 'function') ? dataView.getIdxById(item.id) : 0;
                cellValue = columnDef.formatter(rowIndex, columnIndex, cellValue, columnDef, item, this._grid);
            }
            // make sure cell value is always a string
            if (typeof cellValue === 'number') {
                cellValue = cellValue.toString();
            }
            const conditionOptions = {
                dataKey,
                fieldType,
                searchTerms: searchValues,
                cellValue,
                operator: operator,
                cellValueLastChar: lastValueChar,
                filterSearchType
            };
            if (!FilterConditions.executeMappedCondition(conditionOptions)) {
                return false;
            }
        }
        return true;
    }
    getColumnFilters() {
        return this._columnFilters;
    }
    getFiltersMetadata() {
        return this._filtersMetadata;
    }
    getCurrentLocalFilters() {
        const currentFilters = [];
        if (this._columnFilters) {
            for (const colId of Object.keys(this._columnFilters)) {
                const columnFilter = this._columnFilters[colId];
                const filter = { columnId: colId || '' };
                if (columnFilter && columnFilter.searchTerms) {
                    filter.searchTerms = columnFilter.searchTerms;
                }
                if (columnFilter.operator) {
                    filter.operator = columnFilter.operator;
                }
                if (Array.isArray(filter.searchTerms) && filter.searchTerms.length > 0 && filter.searchTerms[0] !== '') {
                    currentFilters.push(filter);
                }
            }
        }
        return currentFilters;
    }
    /**
     * A simple function that is binded to the subscriber and emit a change when the filter is called.
     * Other services, like Pagination, can then subscribe to it.
     * @param caller
     */
    emitFilterChanged(caller) {
        if (caller === EmitterType.remote && this._gridOptions && this._gridOptions.backendServiceApi) {
            let currentFilters = [];
            const backendService = this._gridOptions.backendServiceApi.service;
            if (backendService && backendService.getCurrentFilters) {
                currentFilters = backendService.getCurrentFilters();
            }
            this.onFilterChanged.next(currentFilters);
        }
        else if (caller === EmitterType.local) {
            this.onFilterChanged.next(this.getCurrentLocalFilters());
        }
    }
    onBackendFilterChange(event, args) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!args || !args.grid) {
                throw new Error('Something went wrong when trying to bind the "onBackendFilterChange(event, args)" function, it seems that "args" is not populated correctly');
            }
            // const gridOptions: GridOption = (args.grid && args.grid.getOptions) ? args.grid.getOptions() : {};
            const backendApi = this._gridOptions.backendServiceApi;
            if (!backendApi || !backendApi.process || !backendApi.service) {
                throw new Error(`BackendServiceApi requires at least a "process" function and a "service" defined`);
            }
            // keep start time & end timestamps & return it after process execution
            const startTime = new Date();
            // run a preProcess callback if defined
            if (backendApi.preProcess) {
                backendApi.preProcess();
            }
            // only add a delay when user is typing, on select dropdown filter (or "Clear Filter") it will execute right away
            let debounceTypingDelay = 0;
            const isTriggeredByClearFilter = args && args.clearFilterTriggered; // was it trigger by a "Clear Filter" command?
            const eventType = event && event.type;
            const eventKeyCode = event && event.keyCode;
            if (!isTriggeredByClearFilter && eventKeyCode !== KeyCode.ENTER && (eventType === 'input' || eventType === 'keyup' || eventType === 'keydown')) {
                debounceTypingDelay = backendApi.hasOwnProperty('filterTypingDebounce') ? backendApi.filterTypingDebounce : DEFAULT_FILTER_TYPING_DEBOUNCE;
            }
            // query backend, except when it's called by a ClearFilters then we won't
            if (args && args.shouldTriggerQuery) {
                // call the service to get a query back
                // @deprecated TODO: remove async/await on next major change, refer to processOnFilterChanged in BackendService interface (with @deprecated)
                clearTimeout(timer);
                if (debounceTypingDelay > 0) {
                    timer = setTimeout(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        const query = yield backendApi.service.processOnFilterChanged(event, args);
                        const totalItems = this._gridOptions && this._gridOptions.pagination && this._gridOptions.pagination.totalItems;
                        executeBackendCallback(backendApi, query, args, startTime, totalItems, this.emitFilterChanged.bind(this), this.httpCancelRequests$);
                    }), debounceTypingDelay);
                }
                else {
                    const query = yield backendApi.service.processOnFilterChanged(event, args);
                    const totalItems = this._gridOptions && this._gridOptions.pagination && this._gridOptions.pagination.totalItems;
                    executeBackendCallback(backendApi, query, args, startTime, totalItems, this.emitFilterChanged.bind(this), this.httpCancelRequests$);
                }
            }
        });
    }
    /**
     * When user passes an array of preset filters, we need to pre-populate each column filter searchTerm(s)
     * The process is to loop through the preset filters array, find the associated column from columnDefinitions and fill in the filter object searchTerm(s)
     * This is basically the same as if we would manually add searchTerm(s) to a column filter object in the column definition, but we do it programmatically.
     * At the end of the day, when creating the Filter (DOM Element), it will use these searchTerm(s) so we can take advantage of that without recoding each Filter type (DOM element)
     */
    populateColumnFilterSearchTermPresets(filters) {
        if (Array.isArray(filters) && filters.length > 0) {
            this._columnDefinitions.forEach((columnDef) => {
                // clear any columnDef searchTerms before applying Presets
                if (columnDef.filter && columnDef.filter.searchTerms) {
                    delete columnDef.filter.searchTerms;
                }
                // from each presets, we will find the associated columnDef and apply the preset searchTerms & operator if there is
                const columnPreset = filters.find((presetFilter) => {
                    return presetFilter.columnId === columnDef.id;
                });
                if (columnPreset && columnPreset.searchTerms && Array.isArray(columnPreset.searchTerms)) {
                    columnDef.filter = columnDef.filter || {};
                    columnDef.filter.operator = columnPreset.operator || columnDef.filter.operator || '';
                    columnDef.filter.searchTerms = columnPreset.searchTerms;
                }
            });
        }
        return this._columnDefinitions;
    }
    /**
     * Set the sort icons in the UI (ONLY the icons, it does not do any sorting)
     * The column sort icons are not necessarily inter-connected to the sorting functionality itself,
     * you can change the sorting icons separately by passing an array of columnId/sortAsc and that will change ONLY the icons
     * @param sortColumns
     */
    setSortColumnIcons(sortColumns) {
        if (this._grid && Array.isArray(sortColumns)) {
            this._grid.setSortColumns(sortColumns);
        }
    }
    /**
     * Update Filters dynamically just by providing an array of filter(s).
     * You can also choose emit (default) a Filter Changed event that will be picked by the Grid State Service.
     *
     * Also for backend service only, you can choose to trigger a backend query (default) or not if you wish to do it later,
     * this could be useful when using updateFilters & updateSorting and you wish to only send the backend query once.
     * @param filters array
     * @param triggerEvent defaults to True, do we want to emit a filter changed event?
     * @param triggerBackendQuery defaults to True, which will query the backend.
     */
    updateFilters(filters, emitChangedEvent = true, triggerBackendQuery = true) {
        if (!this._filtersMetadata || this._filtersMetadata.length === 0 || !this._gridOptions || !this._gridOptions.enableFiltering) {
            throw new Error('[Angular-Slickgrid] in order to use "updateFilters" method, you need to have Filterable Columns defined in your grid and "enableFiltering" set in your Grid Options');
        }
        if (Array.isArray(filters)) {
            // start by clearing all filters (without triggering an event) before applying any new filters
            this.clearFilters(false);
            // pre-fill (value + operator) and render all filters in the DOM
            // loop through each Filters provided (which has a columnId property)
            // then find their associated Filter instances that were originally created in the grid
            filters.forEach((newFilter) => {
                const uiFilter = this._filtersMetadata.find((filter) => newFilter.columnId === filter.columnDef.id);
                if (newFilter && uiFilter) {
                    const newOperator = newFilter.operator || uiFilter.defaultOperator;
                    this.updateColumnFilters(newFilter.searchTerms, uiFilter.columnDef, newOperator);
                    uiFilter.setValues(newFilter.searchTerms, newOperator);
                }
            });
            const backendApi = this._gridOptions && this._gridOptions.backendServiceApi;
            // refresh the DataView and trigger an event after all filters were updated and rendered
            this._dataView.refresh();
            if (backendApi) {
                const backendApiService = backendApi && backendApi.service;
                if (backendApiService) {
                    backendApiService.updateFilters(filters, true);
                    if (triggerBackendQuery) {
                        refreshBackendDataset(this._gridOptions);
                    }
                }
            }
            if (emitChangedEvent) {
                const emitterType = backendApi ? EmitterType.remote : EmitterType.local;
                this.emitFilterChanged(emitterType);
            }
        }
    }
    // --
    // private functions
    // -------------------
    /** Add all created filters (from their template) to the header row section area */
    addFilterTemplateToHeaderRow(args, isFilterFirstRender = true) {
        const columnDef = args.column;
        const columnId = columnDef && columnDef.id || '';
        if (columnDef && columnId !== 'selector' && columnDef.filterable) {
            let searchTerms;
            let operator;
            const newFilter = this.filterFactory.createFilter(args.column.filter);
            operator = (columnDef && columnDef.filter && columnDef.filter.operator) || (newFilter && newFilter.operator) || undefined;
            if (this._columnFilters[columnDef.id]) {
                searchTerms = this._columnFilters[columnDef.id].searchTerms || undefined;
                operator = this._columnFilters[columnDef.id].operator || undefined;
            }
            else if (columnDef.filter) {
                // when hiding/showing (with Column Picker or Grid Menu), it will try to re-create yet again the filters (since SlickGrid does a re-render)
                // because of that we need to first get searchTerm(s) from the columnFilters (that is what the user last typed in a filter search input)
                searchTerms = columnDef.filter.searchTerms || undefined;
                this.updateColumnFilters(searchTerms, columnDef, operator);
            }
            const filterArguments = {
                grid: this._grid,
                operator,
                searchTerms,
                columnDef,
                callback: this.callbackSearchEvent.bind(this)
            };
            if (newFilter) {
                newFilter.init(filterArguments, isFilterFirstRender);
                const filterExistIndex = this._filtersMetadata.findIndex((filter) => newFilter.columnDef.id === filter.columnDef.id);
                // add to the filters arrays or replace it when found
                if (filterExistIndex === -1) {
                    this._filtersMetadata.push(newFilter);
                }
                else {
                    this._filtersMetadata[filterExistIndex] = newFilter;
                }
                // when hiding/showing (with Column Picker or Grid Menu), it will try to re-create yet again the filters (since SlickGrid does a re-render)
                // we need to also set again the values in the DOM elements if the values were set by a searchTerm(s)
                if (searchTerms && newFilter.setValues) {
                    newFilter.setValues(searchTerms);
                }
            }
        }
    }
    /**
     * Callback method that is called and executed by the individual Filter (DOM element),
     * for example when user type in a word to search (which uses InputFilter), this Filter will execute the callback from a keyup event.
     */
    callbackSearchEvent(event, args) {
        if (args) {
            const searchTerm = ((event && event.target) ? event.target.value : undefined);
            const searchTerms = (args.searchTerms && Array.isArray(args.searchTerms)) ? args.searchTerms : (searchTerm ? [searchTerm] : undefined);
            const columnDef = args.columnDef || null;
            const columnId = columnDef && columnDef.id || '';
            const operator = args.operator || undefined;
            const hasSearchTerms = searchTerms && Array.isArray(searchTerms);
            const termsCount = hasSearchTerms && searchTerms && searchTerms.length;
            const oldColumnFilters = Object.assign({}, this._columnFilters);
            if (columnDef && columnId) {
                if (!hasSearchTerms || termsCount === 0 || (termsCount === 1 && Array.isArray(searchTerms) && searchTerms[0] === '')) {
                    // delete the property from the columnFilters when it becomes empty
                    // without doing this, it would leave an incorrect state of the previous column filters when filtering on another column
                    delete this._columnFilters[columnId];
                }
                else {
                    const colId = '' + columnId;
                    const colFilter = {
                        columnId: colId,
                        columnDef,
                        searchTerms,
                    };
                    if (operator) {
                        colFilter.operator = operator;
                    }
                    this._columnFilters[colId] = colFilter;
                }
            }
            // event might have been created as a CustomEvent (e.g. CompoundDateFilter), without being a valid Slick.EventData,
            // if so we will create a new Slick.EventData and merge it with that CustomEvent to avoid having SlickGrid errors
            const eventData = (event && typeof event.isPropagationStopped !== 'function') ? $.extend({}, new Slick.EventData(), event) : event;
            // trigger an event only if Filters changed or if ENTER key was pressed
            const eventKeyCode = event && event.keyCode;
            if (eventKeyCode === KeyCode.ENTER || !isequal(oldColumnFilters, this._columnFilters)) {
                this._onSearchChange.notify({
                    clearFilterTriggered: args.clearFilterTriggered,
                    shouldTriggerQuery: args.shouldTriggerQuery,
                    columnId,
                    columnDef,
                    columnFilters: this._columnFilters,
                    operator,
                    searchTerms,
                    grid: this._grid
                }, eventData);
            }
        }
    }
    updateColumnFilters(searchTerms, columnDef, operator) {
        if (searchTerms && columnDef) {
            this._columnFilters[columnDef.id] = {
                columnId: columnDef.id,
                columnDef,
                searchTerms,
                operator
            };
        }
    }
};
FilterService = tslib_1.__decorate([
    Injectable(),
    tslib_1.__metadata("design:paramtypes", [FilterFactory, SharedService])
], FilterService);
export { FilterService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsdGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyLXNsaWNrZ3JpZC8iLCJzb3VyY2VzIjpbImFwcC9tb2R1bGVzL2FuZ3VsYXItc2xpY2tncmlkL3NlcnZpY2VzL2ZpbHRlci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxZQUFZLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBRTdDLE9BQU8sS0FBSyxRQUFRLE1BQU0sZ0JBQWdCLENBQUM7QUFDM0MsTUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLENBQUMsOEJBQThCO0FBRXhELE9BQU8sRUFLTCxXQUFXLEVBQ1gsU0FBUyxFQU1ULE9BQU8sRUFFUCxZQUFZLEdBSWIsTUFBTSxtQkFBbUIsQ0FBQztBQUMzQixPQUFPLEVBQUUsc0JBQXNCLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUNwRixPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDcEQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDMUQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ3pELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQU1qRCwrQ0FBK0M7QUFDL0MsSUFBSSxLQUFVLENBQUM7QUFDZixNQUFNLDhCQUE4QixHQUFHLEdBQUcsQ0FBQztBQUczQyxJQUFhLGFBQWEsR0FBMUIsTUFBYSxhQUFhO0lBYXhCLFlBQW9CLGFBQTRCLEVBQVUsYUFBNEI7UUFBbEUsa0JBQWEsR0FBYixhQUFhLENBQWU7UUFBVSxrQkFBYSxHQUFiLGFBQWEsQ0FBZTtRQVg5RSx5QkFBb0IsR0FBRyxJQUFJLENBQUM7UUFDNUIsMkJBQXNCLEdBQUcsRUFBRSxDQUFDO1FBQzVCLHFCQUFnQixH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QUNyRixJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQztvQkFDMUIsb0JBQW9CLEVBQUUsSUFBSSxDQUFDLG9CQUFvQjtvQkFDL0Msa0JBQWtCLEVBQUUsSUFBSSxDQUFDLGtCQUFrQjtvQkFDM0MsUUFBUTtvQkFDUixTQUFTO29CQUNULGFBQWEsRUFBRSxJQUFJLENBQUMsY0FBYztvQkFDbEMsUUFBUTtvQkFDUixXQUFXO29CQUNYLElBQUksRUFBRSxJQUFJLENBQUMsS0FBSztpQkFDakIsRUFBRSxTQUFTLENBQUMsQ0FBQzthQUNmO1NBQ0Y7SUFDSCxDQUFDO0lBRU8sbUJBQW1CLENBQUMsV0FBcUMsRUFBRSxTQUFjLEVBQUUsUUFBd0M7UUFDekgsSUFBSSxXQUFXLElBQUksU0FBUyxFQUFFO1lBQzVCLElBQUksQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxHQUFHO2dCQUNsQyxRQUFRLEVBQUUsU0FBUyxDQUFDLEVBQUU7Z0JBQ3RCLFNBQVM7Z0JBQ1QsV0FBVztnQkFDWCxRQUFRO2FBQ1QsQ0FBQztTQUNIO0lBQ0gsQ0FBQztDQUNGLENBQUE7QUFybkJZLGFBQWE7SUFEekIsVUFBVSxFQUFFOzZDQWN3QixhQUFhLEVBQXlCLGFBQWE7R0FiM0UsYUFBYSxDQXFuQnpCO1NBcm5CWSxhQUFhIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBpc09ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcclxuXHJcbmltcG9ydCAqIGFzIGlzZXF1YWxfIGZyb20gJ2xvZGFzaC5pc2VxdWFsJztcclxuY29uc3QgaXNlcXVhbCA9IGlzZXF1YWxfOyAvLyBwYXRjaCB0byBmaXggcm9sbHVwIHRvIHdvcmtcclxuXHJcbmltcG9ydCB7XHJcbiAgQ29sdW1uLFxyXG4gIENvbHVtbkZpbHRlcixcclxuICBDb2x1bW5GaWx0ZXJzLFxyXG4gIEN1cnJlbnRGaWx0ZXIsXHJcbiAgRW1pdHRlclR5cGUsXHJcbiAgRmllbGRUeXBlLFxyXG4gIEZpbHRlcixcclxuICBGaWx0ZXJBcmd1bWVudHMsXHJcbiAgRmlsdGVyQ2FsbGJhY2tBcmcsXHJcbiAgRmlsdGVyQ2hhbmdlZEFyZ3MsXHJcbiAgR3JpZE9wdGlvbixcclxuICBLZXlDb2RlLFxyXG4gIE9wZXJhdG9yU3RyaW5nLFxyXG4gIE9wZXJhdG9yVHlwZSxcclxuICBTZWFyY2hUZXJtLFxyXG4gIFNsaWNrRXZlbnQsXHJcbiAgU2xpY2tFdmVudEhhbmRsZXIsXHJcbn0gZnJvbSAnLi8uLi9tb2RlbHMvaW5kZXgnO1xyXG5pbXBvcnQgeyBleGVjdXRlQmFja2VuZENhbGxiYWNrLCByZWZyZXNoQmFja2VuZERhdGFzZXQgfSBmcm9tICcuL2JhY2tlbmQtdXRpbGl0aWVzJztcclxuaW1wb3J0IHsgZ2V0RGVzY2VuZGFudFByb3BlcnR5IH0gZnJvbSAnLi91dGlsaXRpZXMnO1xyXG5pbXBvcnQgeyBGaWx0ZXJDb25kaXRpb25zIH0gZnJvbSAnLi8uLi9maWx0ZXItY29uZGl0aW9ucyc7XHJcbmltcG9ydCB7IEZpbHRlckZhY3RvcnkgfSBmcm9tICcuLi9maWx0ZXJzL2ZpbHRlckZhY3RvcnknO1xyXG5pbXBvcnQgeyBTaGFyZWRTZXJ2aWNlIH0gZnJvbSAnLi9zaGFyZWQuc2VydmljZSc7XHJcblxyXG4vLyB1c2luZyBleHRlcm5hbCBub24tdHlwZWQganMgbGlicmFyaWVzXHJcbmRlY2xhcmUgdmFyIFNsaWNrOiBhbnk7XHJcbmRlY2xhcmUgdmFyICQ6IGFueTtcclxuXHJcbi8vIHRpbWVyIGZvciBrZWVwaW5nIHRyYWNrIG9mIHVzZXIgdHlwaW5nIHdhaXRzXHJcbmxldCB0aW1lcjogYW55O1xyXG5jb25zdCBERUZBVUxUX0ZJTFRFUl9UWVBJTkdfREVCT1VOQ0UgPSA1MDA7XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBGaWx0ZXJTZXJ2aWNlIHtcclxuICBwcml2YXRlIF9ldmVudEhhbmRsZXI6IFNsaWNrRXZlbnRIYW5kbGVyO1xyXG4gIHByaXZhdGUgX2lzRmlsdGVyRmlyc3RSZW5kZXIgPSB0cnVlO1xyXG4gIHByaXZhdGUgX2ZpcnN0Q29sdW1uSWRSZW5kZXJlZCA9ICcnO1xyXG4gIHByaXZhdGUgX2ZpbHRlcnNNZXRhZGF0YTogYW55W10gPSBbXTtcclxuICBwcml2YXRlIF9jb2x1bW5GaWx0ZXJzOiBDb2x1bW5GaWx0ZXJzID0ge307XHJcbiAgcHJpdmF0ZSBfZGF0YVZpZXc6IGFueTtcclxuICBwcml2YXRlIF9ncmlkOiBhbnk7XHJcbiAgcHJpdmF0ZSBfb25TZWFyY2hDaGFuZ2U6IFNsaWNrRXZlbnQ7XHJcbiAgcHJpdmF0ZSBodHRwQ2FuY2VsUmVxdWVzdHMkOiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTsgLy8gdGhpcyB3aWxsIGJlIHVzZWQgdG8gY2FuY2VsIGFueSBwZW5kaW5nIGh0dHAgcmVxdWVzdFxyXG4gIG9uRmlsdGVyQ2hhbmdlZCA9IG5ldyBTdWJqZWN0PEN1cnJlbnRGaWx0ZXJbXT4oKTtcclxuICBvbkZpbHRlckNsZWFyZWQgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGZpbHRlckZhY3Rvcnk6IEZpbHRlckZhY3RvcnksIHByaXZhdGUgc2hhcmVkU2VydmljZTogU2hhcmVkU2VydmljZSkge1xyXG4gICAgdGhpcy5fZXZlbnRIYW5kbGVyID0gbmV3IFNsaWNrLkV2ZW50SGFuZGxlcigpO1xyXG4gICAgdGhpcy5fb25TZWFyY2hDaGFuZ2UgPSBuZXcgU2xpY2suRXZlbnQoKTtcclxuICB9XHJcblxyXG4gIC8qKiBHZXR0ZXIgb2YgdGhlIFNsaWNrR3JpZCBFdmVudCBIYW5kbGVyICovXHJcbiAgZ2V0IGV2ZW50SGFuZGxlcigpOiBTbGlja0V2ZW50SGFuZGxlciB7XHJcbiAgICByZXR1cm4gdGhpcy5fZXZlbnRIYW5kbGVyO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciB0byBrbm93IGlmIHRoZSBmaWx0ZXIgd2FzIGFscmVhZHkgcmVuZGVyZWQgb3IgaWYgaXQgd2FzIGl0cyBmaXJzdCB0aW1lIHJlbmRlciAqL1xyXG4gIGdldCBpc0ZpbHRlckZpcnN0UmVuZGVyKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX2lzRmlsdGVyRmlyc3RSZW5kZXI7XHJcbiAgfVxyXG5cclxuICAvKiogR2V0dGVyIG9mIHRoZSBTbGlja0dyaWQgRXZlbnQgSGFuZGxlciAqL1xyXG4gIGdldCBvblNlYXJjaENoYW5nZSgpOiBTbGlja0V2ZW50IHtcclxuICAgIHJldHVybiB0aGlzLl9vblNlYXJjaENoYW5nZTtcclxuICB9XHJcblxyXG4gIC8qKiBHZXR0ZXIgZm9yIHRoZSBHcmlkIE9wdGlvbnMgcHVsbGVkIHRocm91Z2ggdGhlIEdyaWQgT2JqZWN0ICovXHJcbiAgcHJpdmF0ZSBnZXQgX2dyaWRPcHRpb25zKCk6IEdyaWRPcHRpb24ge1xyXG4gICAgcmV0dXJuICh0aGlzLl9ncmlkICYmIHRoaXMuX2dyaWQuZ2V0T3B0aW9ucykgPyB0aGlzLl9ncmlkLmdldE9wdGlvbnMoKSA6IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBmb3IgdGhlIENvbHVtbiBEZWZpbml0aW9ucyBwdWxsZWQgdGhyb3VnaCB0aGUgR3JpZCBPYmplY3QgKi9cclxuICBwcml2YXRlIGdldCBfY29sdW1uRGVmaW5pdGlvbnMoKTogQ29sdW1uW10ge1xyXG4gICAgcmV0dXJuICh0aGlzLl9ncmlkICYmIHRoaXMuX2dyaWQuZ2V0Q29sdW1ucykgPyB0aGlzLl9ncmlkLmdldENvbHVtbnMoKSA6IFtdO1xyXG4gIH1cclxuXHJcbiAgaW5pdChncmlkOiBhbnkpOiB2b2lkIHtcclxuICAgIHRoaXMuX2dyaWQgPSBncmlkO1xyXG4gIH1cclxuXHJcbiAgZGlzcG9zZSgpIHtcclxuICAgIHRoaXMuZGlzcG9zZUNvbHVtbkZpbHRlcnMoKTtcclxuXHJcbiAgICAvLyB1bnN1YnNjcmliZSBhbGwgU2xpY2tHcmlkIGV2ZW50c1xyXG4gICAgaWYgKHRoaXMuX2V2ZW50SGFuZGxlciAmJiB0aGlzLl9ldmVudEhhbmRsZXIudW5zdWJzY3JpYmVBbGwpIHtcclxuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyLnVuc3Vic2NyaWJlQWxsKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNPYnNlcnZhYmxlKHRoaXMuaHR0cENhbmNlbFJlcXVlc3RzJCkpIHtcclxuICAgICAgdGhpcy5odHRwQ2FuY2VsUmVxdWVzdHMkLm5leHQoKTsgLy8gdGhpcyBjYW5jZWxzIGFueSBwZW5kaW5nIGh0dHAgcmVxdWVzdHNcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3Bvc2Ugb2YgdGhlIGZpbHRlcnMsIHNpbmNlIGl0J3MgYSBzaW5nbGV0b24sIHdlIGRvbid0IHdhbnQgdG8gYWZmZWN0IG90aGVyIGdyaWRzIHdpdGggc2FtZSBjb2x1bW5zXHJcbiAgICovXHJcbiAgZGlzcG9zZUNvbHVtbkZpbHRlcnMoKSB7XHJcbiAgICAvLyB3ZSBuZWVkIHRvIGxvb3AgdGhyb3VnaCBhbGwgY29sdW1uRmlsdGVycyBhbmQgZGVsZXRlIHRoZW0gMSBieSAxXHJcbiAgICAvLyBvbmx5IHRyeWluZyB0byBtYWtlIGNvbHVtbkZpbHRlciBhbiBlbXB0eSAod2l0aG91dCBsb29waW5nKSB3b3VsZCBub3QgdHJpZ2dlciBhIGRhdGFzZXQgY2hhbmdlXHJcbiAgICBpZiAodHlwZW9mIHRoaXMuX2NvbHVtbkZpbHRlcnMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIGZvciAoY29uc3QgY29sdW1uSWQgaW4gdGhpcy5fY29sdW1uRmlsdGVycykge1xyXG4gICAgICAgIGlmIChjb2x1bW5JZCAmJiB0aGlzLl9jb2x1bW5GaWx0ZXJzW2NvbHVtbklkXSkge1xyXG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2NvbHVtbkZpbHRlcnNbY29sdW1uSWRdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGFsc28gZGVzdHJveSBlYWNoIEZpbHRlciBpbnN0YW5jZXNcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuX2ZpbHRlcnNNZXRhZGF0YSkpIHtcclxuICAgICAgdGhpcy5fZmlsdGVyc01ldGFkYXRhLmZvckVhY2goKGZpbHRlcikgPT4ge1xyXG4gICAgICAgIGlmIChmaWx0ZXIgJiYgZmlsdGVyLmRlc3Ryb3kpIHtcclxuICAgICAgICAgIGZpbHRlci5kZXN0cm95KHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCaW5kIGEgYmFja2VuZCBmaWx0ZXIgaG9vayB0byB0aGUgZ3JpZFxyXG4gICAqIEBwYXJhbSBncmlkIFNsaWNrR3JpZCBHcmlkIG9iamVjdFxyXG4gICAqL1xyXG4gIGJpbmRCYWNrZW5kT25GaWx0ZXIoZ3JpZDogYW55LCBkYXRhVmlldzogYW55KSB7XHJcbiAgICB0aGlzLl9kYXRhVmlldyA9IGRhdGFWaWV3O1xyXG4gICAgdGhpcy5fZmlsdGVyc01ldGFkYXRhID0gW107XHJcblxyXG4gICAgLy8gc3Vic2NyaWJlIHRvIFNsaWNrR3JpZCBvbkhlYWRlclJvd0NlbGxSZW5kZXJlZCBldmVudCB0byBjcmVhdGUgZmlsdGVyIHRlbXBsYXRlXHJcbiAgICB0aGlzLl9ldmVudEhhbmRsZXIuc3Vic2NyaWJlKGdyaWQub25IZWFkZXJSb3dDZWxsUmVuZGVyZWQsIChlOiBLZXlib2FyZEV2ZW50LCBhcmdzOiBhbnkpID0+IHtcclxuICAgICAgLy8gZmlyc3RDb2x1bW5JZFJlbmRlcmVkIGlzIG51bGwgYXQgZmlyc3QsIHNvIGlmIGl0IGNoYW5nZXMgdG8gYmVpbmcgZmlsbGVkIGFuZCBlcXVhbCwgdGhlbiB3ZSB3b3VsZCBrbm93IHRoYXQgaXQgd2FzIGFscmVhZHkgcmVuZGVyZWRcclxuICAgICAgLy8gdGhpcyBpcyB0byBhdm9pZCByZW5kZXJpbmcgdGhlIGZpbHRlciB0d2ljZSAob25seSB0aGUgU2VsZWN0IEZpbHRlciBmb3Igbm93KSwgcmVuZGVyaW5nIGl0IGFnYWluIGFsc28gY2xlYXJzIHRoZSBmaWx0ZXIgd2hpY2ggaGFzIHVud2FudGVkIHNpZGUgZWZmZWN0XHJcbiAgICAgIGlmIChhcmdzLmNvbHVtbi5pZCA9PT0gdGhpcy5fZmlyc3RDb2x1bW5JZFJlbmRlcmVkKSB7XHJcbiAgICAgICAgdGhpcy5faXNGaWx0ZXJGaXJzdFJlbmRlciA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuYWRkRmlsdGVyVGVtcGxhdGVUb0hlYWRlclJvdyhhcmdzLCB0aGlzLl9pc0ZpbHRlckZpcnN0UmVuZGVyKTtcclxuICAgICAgaWYgKHRoaXMuX2ZpcnN0Q29sdW1uSWRSZW5kZXJlZCA9PT0gJycpIHtcclxuICAgICAgICB0aGlzLl9maXJzdENvbHVtbklkUmVuZGVyZWQgPSBhcmdzLmNvbHVtbi5pZDtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gc3Vic2NyaWJlIHRvIHRoZSBTbGlja0dyaWQgZXZlbnQgYW5kIGNhbGwgdGhlIGJhY2tlbmQgZXhlY3V0aW9uXHJcbiAgICB0aGlzLl9ldmVudEhhbmRsZXIuc3Vic2NyaWJlKHRoaXMuX29uU2VhcmNoQ2hhbmdlLCB0aGlzLm9uQmFja2VuZEZpbHRlckNoYW5nZS5iaW5kKHRoaXMpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJpbmQgYSBsb2NhbCBmaWx0ZXIgaG9vayB0byB0aGUgZ3JpZFxyXG4gICAqIEBwYXJhbSBncmlkIFNsaWNrR3JpZCBHcmlkIG9iamVjdFxyXG4gICAqIEBwYXJhbSBkYXRhVmlld1xyXG4gICAqL1xyXG4gIGJpbmRMb2NhbE9uRmlsdGVyKGdyaWQ6IGFueSwgZGF0YVZpZXc6IGFueSkge1xyXG4gICAgdGhpcy5fZmlsdGVyc01ldGFkYXRhID0gW107XHJcbiAgICB0aGlzLl9kYXRhVmlldyA9IGRhdGFWaWV3O1xyXG5cclxuICAgIGRhdGFWaWV3LnNldEZpbHRlckFyZ3MoeyBjb2x1bW5GaWx0ZXJzOiB0aGlzLl9jb2x1bW5GaWx0ZXJzLCBncmlkOiB0aGlzLl9ncmlkLCBkYXRhVmlldyB9KTtcclxuICAgIGRhdGFWaWV3LnNldEZpbHRlcih0aGlzLmN1c3RvbUxvY2FsRmlsdGVyLmJpbmQodGhpcykpO1xyXG5cclxuICAgIHRoaXMuX2V2ZW50SGFuZGxlci5zdWJzY3JpYmUodGhpcy5fb25TZWFyY2hDaGFuZ2UsIChlOiBLZXlib2FyZEV2ZW50LCBhcmdzOiBhbnkpID0+IHtcclxuICAgICAgY29uc3QgY29sdW1uSWQgPSBhcmdzLmNvbHVtbklkO1xyXG4gICAgICBpZiAoY29sdW1uSWQgIT0gbnVsbCkge1xyXG4gICAgICAgIGRhdGFWaWV3LnJlZnJlc2goKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBlbWl0IGFuIG9uRmlsdGVyQ2hhbmdlZCBldmVudCB3aGVuIGl0J3Mgbm90IGNhbGxlZCBieSBhIGNsZWFyIGZpbHRlclxyXG4gICAgICBpZiAoYXJncyAmJiAhYXJncy5jbGVhckZpbHRlclRyaWdnZXJlZCkge1xyXG4gICAgICAgIHRoaXMuZW1pdEZpbHRlckNoYW5nZWQoRW1pdHRlclR5cGUubG9jYWwpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBzdWJzY3JpYmUgdG8gU2xpY2tHcmlkIG9uSGVhZGVyUm93Q2VsbFJlbmRlcmVkIGV2ZW50IHRvIGNyZWF0ZSBmaWx0ZXIgdGVtcGxhdGVcclxuICAgIHRoaXMuX2V2ZW50SGFuZGxlci5zdWJzY3JpYmUoZ3JpZC5vbkhlYWRlclJvd0NlbGxSZW5kZXJlZCwgKGU6IEtleWJvYXJkRXZlbnQsIGFyZ3M6IGFueSkgPT4ge1xyXG4gICAgICB0aGlzLmFkZEZpbHRlclRlbXBsYXRlVG9IZWFkZXJSb3coYXJncyk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGNsZWFyRmlsdGVyQnlDb2x1bW5JZChldmVudDogRXZlbnQsIGNvbHVtbklkOiBudW1iZXIgfCBzdHJpbmcpIHtcclxuICAgIC8vIGdldCBjdXJyZW50IGNvbHVtbiBmaWx0ZXIgYmVmb3JlIGNsZWFyaW5nLCB0aGlzIGFsbG93IHVzIHRvIGtub3cgaWYgdGhlIGZpbHRlciB3YXMgZW1wdHkgcHJpb3IgdG8gY2FsbGluZyB0aGUgY2xlYXIgZmlsdGVyXHJcbiAgICBjb25zdCBjdXJyZW50Q29sdW1uRmlsdGVycyA9IE9iamVjdC5rZXlzKHRoaXMuX2NvbHVtbkZpbHRlcnMpIGFzIENvbHVtbkZpbHRlcltdO1xyXG4gICAgbGV0IGN1cnJlbnRDb2xGaWx0ZXI6IENvbHVtbkZpbHRlcjtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRDb2x1bW5GaWx0ZXJzKSkge1xyXG4gICAgICBjdXJyZW50Q29sRmlsdGVyID0gY3VycmVudENvbHVtbkZpbHRlcnMuZmluZCgobmFtZSkgPT4gbmFtZSA9PT0gY29sdW1uSWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGZpbmQgdGhlIGZpbHRlciBvYmplY3QgYW5kIGNhbGwgaXRzIGNsZWFyIG1ldGhvZCB3aXRoIHRydWUgKHRoZSBhcmd1bWVudCB0ZWxscyB0aGUgbWV0aG9kIGl0IHdhcyBjYWxsZWQgYnkgYSBjbGVhciBmaWx0ZXIpXHJcbiAgICBjb25zdCBjb2xGaWx0ZXI6IEZpbHRlciA9IHRoaXMuX2ZpbHRlcnNNZXRhZGF0YS5maW5kKChmaWx0ZXI6IEZpbHRlcikgPT4gZmlsdGVyLmNvbHVtbkRlZi5pZCA9PT0gY29sdW1uSWQpO1xyXG4gICAgaWYgKGNvbEZpbHRlciAmJiBjb2xGaWx0ZXIuY2xlYXIpIHtcclxuICAgICAgY29sRmlsdGVyLmNsZWFyKHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBlbWl0dGVyOiBFbWl0dGVyVHlwZSA9IEVtaXR0ZXJUeXBlLmxvY2FsO1xyXG4gICAgY29uc3QgaXNCYWNrZW5kQXBpID0gdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuYmFja2VuZFNlcnZpY2VBcGkgfHwgZmFsc2U7XHJcblxyXG4gICAgLy8gd2hlbiB1c2luZyBhIGJhY2tlbmQgc2VydmljZSwgd2UgbmVlZCB0byBtYW51YWxseSB0cmlnZ2VyIGEgZmlsdGVyIGNoYW5nZSBidXQgb25seSBpZiB0aGUgZmlsdGVyIHdhcyBwcmV2aW91c2x5IGZpbGxlZFxyXG4gICAgaWYgKGlzQmFja2VuZEFwaSkge1xyXG4gICAgICBlbWl0dGVyID0gRW1pdHRlclR5cGUucmVtb3RlO1xyXG4gICAgICBpZiAoY3VycmVudENvbEZpbHRlcikge1xyXG4gICAgICAgIHRoaXMub25CYWNrZW5kRmlsdGVyQ2hhbmdlKGV2ZW50IGFzIEtleWJvYXJkRXZlbnQsIHsgZ3JpZDogdGhpcy5fZ3JpZCwgY29sdW1uRmlsdGVyczogdGhpcy5fY29sdW1uRmlsdGVycyB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGVtaXQgYW4gZXZlbnQgd2hlbiBmaWx0ZXIgaXMgY2xlYXJlZFxyXG4gICAgdGhpcy5lbWl0RmlsdGVyQ2hhbmdlZChlbWl0dGVyKTtcclxuICB9XHJcblxyXG4gIC8qKiBDbGVhciB0aGUgc2VhcmNoIGZpbHRlcnMgKGJlbG93IHRoZSBjb2x1bW4gdGl0bGVzKSAqL1xyXG4gIGNsZWFyRmlsdGVycyh0cmlnZ2VyQ2hhbmdlID0gdHJ1ZSkge1xyXG4gICAgdGhpcy5fZmlsdGVyc01ldGFkYXRhLmZvckVhY2goKGZpbHRlcjogRmlsdGVyKSA9PiB7XHJcbiAgICAgIGlmIChmaWx0ZXIgJiYgZmlsdGVyLmNsZWFyKSB7XHJcbiAgICAgICAgLy8gY2xlYXIgZWxlbWVudCBidXQgZG9uJ3QgdHJpZ2dlciBpbmRpdmlkdWFsIGNsZWFyIGNoYW5nZSxcclxuICAgICAgICAvLyB3ZSdsbCBkbyAxIHRyaWdnZXIgZm9yIGFsbCBmaWx0ZXJzIGF0IG9uY2UgYWZ0ZXJ3YXJkXHJcbiAgICAgICAgZmlsdGVyLmNsZWFyKGZhbHNlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gd2UgYWxzbyBuZWVkIHRvIHJlZnJlc2ggdGhlIGRhdGFWaWV3IGFuZCBvcHRpb25hbGx5IHRoZSBncmlkIChpdCdzIG9wdGlvbmFsIHNpbmNlIHdlIHVzZSBEYXRhVmlldylcclxuICAgIGlmICh0aGlzLl9kYXRhVmlldyAmJiB0aGlzLl9ncmlkKSB7XHJcbiAgICAgIHRoaXMuX2RhdGFWaWV3LnJlZnJlc2goKTtcclxuICAgICAgdGhpcy5fZ3JpZC5pbnZhbGlkYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2hlbiB1c2luZyBiYWNrZW5kIHNlcnZpY2UsIHdlIG5lZWQgdG8gcXVlcnkgb25seSBvbmNlIHNvIGl0J3MgYmV0dGVyIHRvIGRvIGl0IGhlcmVcclxuICAgIGNvbnN0IGJhY2tlbmRBcGkgPSB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5iYWNrZW5kU2VydmljZUFwaTtcclxuICAgIGlmIChiYWNrZW5kQXBpICYmIHRyaWdnZXJDaGFuZ2UpIHtcclxuICAgICAgY29uc3QgY2FsbGJhY2tBcmdzID0geyBjbGVhckZpbHRlclRyaWdnZXJlZDogdHJ1ZSwgc2hvdWxkVHJpZ2dlclF1ZXJ5OiB0cmlnZ2VyQ2hhbmdlLCBncmlkOiB0aGlzLl9ncmlkLCBjb2x1bW5GaWx0ZXJzOiB0aGlzLl9jb2x1bW5GaWx0ZXJzIH07XHJcbiAgICAgIGNvbnN0IHF1ZXJ5UmVzcG9uc2UgPSBiYWNrZW5kQXBpLnNlcnZpY2UucHJvY2Vzc09uRmlsdGVyQ2hhbmdlZCh1bmRlZmluZWQsIGNhbGxiYWNrQXJncyBhcyBGaWx0ZXJDaGFuZ2VkQXJncyk7XHJcbiAgICAgIGlmIChxdWVyeVJlc3BvbnNlIGluc3RhbmNlb2YgUHJvbWlzZSAmJiBxdWVyeVJlc3BvbnNlLnRoZW4pIHtcclxuICAgICAgICAvLyBAZGVwcmVjYXRlZCwgcHJvY2Vzc09uRmlsdGVyQ2hhbmdlZCBpbiB0aGUgZnV0dXJlIHNob3VsZCBiZSByZXR1cm5lZCBhcyBhIHF1ZXJ5IHN0cmluZyBOT1QgYXMgYSBQcm9taXNlXHJcbiAgICAgICAgY29uc29sZS53YXJuKGBbQW5ndWxhci1TbGlja2dyaWRdIHBsZWFzZSBub3RlIHRoYXQgdGhlIFwicHJvY2Vzc09uRmlsdGVyQ2hhbmdlZFwiIGZyb20geW91ciBCYWNrZW5kIFNlcnZpY2UsIHNob3VsZCBub3cgcmV0dXJuIGEgc3RyaW5nIGluc3RlYWQgb2YgYSBQcm9taXNlLlxyXG4gICAgICAgICAgUmV0dXJuaW5nIGEgUHJvbWlzZSB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gdGhlIGZ1dHVyZS5gKTtcclxuICAgICAgICBxdWVyeVJlc3BvbnNlLnRoZW4oKHF1ZXJ5OiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgIGNvbnN0IHRvdGFsSXRlbXMgPSB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5wYWdpbmF0aW9uICYmIHRoaXMuX2dyaWRPcHRpb25zLnBhZ2luYXRpb24udG90YWxJdGVtcztcclxuICAgICAgICAgIGV4ZWN1dGVCYWNrZW5kQ2FsbGJhY2soYmFja2VuZEFwaSwgcXVlcnksIGNhbGxiYWNrQXJncywgbmV3IERhdGUoKSwgdG90YWxJdGVtcywgdGhpcy5lbWl0RmlsdGVyQ2hhbmdlZC5iaW5kKHRoaXMpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBxdWVyeSA9IHF1ZXJ5UmVzcG9uc2UgYXMgc3RyaW5nO1xyXG4gICAgICAgIGNvbnN0IHRvdGFsSXRlbXMgPSB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5wYWdpbmF0aW9uICYmIHRoaXMuX2dyaWRPcHRpb25zLnBhZ2luYXRpb24udG90YWxJdGVtcztcclxuICAgICAgICBleGVjdXRlQmFja2VuZENhbGxiYWNrKGJhY2tlbmRBcGksIHF1ZXJ5LCBjYWxsYmFja0FyZ3MsIG5ldyBEYXRlKCksIHRvdGFsSXRlbXMsIHRoaXMuZW1pdEZpbHRlckNoYW5nZWQuYmluZCh0aGlzKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBlbWl0IGFuIGV2ZW50IHdoZW4gZmlsdGVycyBhcmUgYWxsIGNsZWFyZWRcclxuICAgIGlmICh0cmlnZ2VyQ2hhbmdlKSB7XHJcbiAgICAgIHRoaXMub25GaWx0ZXJDbGVhcmVkLm5leHQodHJ1ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjdXN0b21Mb2NhbEZpbHRlcihpdGVtOiBhbnksIGFyZ3M6IGFueSkge1xyXG4gICAgY29uc3QgZGF0YVZpZXcgPSBhcmdzICYmIGFyZ3MuZGF0YVZpZXc7XHJcbiAgICBmb3IgKGNvbnN0IGNvbHVtbklkIG9mIE9iamVjdC5rZXlzKGFyZ3MuY29sdW1uRmlsdGVycykpIHtcclxuICAgICAgY29uc3QgY29sdW1uRmlsdGVyID0gYXJncy5jb2x1bW5GaWx0ZXJzW2NvbHVtbklkXTtcclxuICAgICAgbGV0IGNvbHVtbkluZGV4ID0gYXJncy5ncmlkLmdldENvbHVtbkluZGV4KGNvbHVtbklkKTtcclxuICAgICAgbGV0IGNvbHVtbkRlZiA9IGFyZ3MuZ3JpZC5nZXRDb2x1bW5zKClbY29sdW1uSW5kZXhdO1xyXG5cclxuICAgICAgLy8gaXQgbWlnaHQgYmUgYSBoaWRkZW4gY29sdW1uLCBpZiBzbyBpdCB3b24ndCBiZSBwYXJ0IG9mIHRoZSBnZXRDb2x1bW5zIChiZWNhdXNlIGl0IHdlIGhpZGUgYSBjb2x1bW4gdmlhIHNldENvbHVtbnMpXHJcbiAgICAgIC8vIHdoZW4gdGhhdCBoYXBwZW5zIHdlIGNhbiB0cnkgdG8gZ2V0IHRoZSBjb2x1bW4gZGVmaW5pdGlvbiBmcm9tIGFsbCBkZWZpbmVkIGNvbHVtbnNcclxuICAgICAgaWYgKCFjb2x1bW5EZWYgJiYgdGhpcy5zaGFyZWRTZXJ2aWNlICYmIEFycmF5LmlzQXJyYXkodGhpcy5zaGFyZWRTZXJ2aWNlLmFsbENvbHVtbnMpKSB7XHJcbiAgICAgICAgY29sdW1uSW5kZXggPSB0aGlzLnNoYXJlZFNlcnZpY2UuYWxsQ29sdW1ucy5maW5kSW5kZXgoKGNvbCkgPT4gY29sLmZpZWxkID09PSBjb2x1bW5JZCk7XHJcbiAgICAgICAgY29sdW1uRGVmID0gdGhpcy5zaGFyZWRTZXJ2aWNlLmFsbENvbHVtbnNbY29sdW1uSW5kZXhdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBpZiB3ZSBzdGlsbCBkb24ndCBoYXZlIGEgY29sdW1uIGRlZmluaXRpb24gdGhlbiB3ZSBzaG91bGQgcmV0dXJuIHRoZW4gcm93IGFueXdheSAodHJ1ZSlcclxuICAgICAgaWYgKCFjb2x1bW5EZWYpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUm93IERldGFpbCBWaWV3IHBsdWdpbiwgaWYgdGhlIHJvdyBpcyBwYWRkaW5nIHdlIGp1c3QgZ2V0IHRoZSB2YWx1ZSB3ZSdyZSBmaWx0ZXJpbmcgb24gZnJvbSBpdCdzIHBhcmVudFxyXG4gICAgICBpZiAodGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlUm93RGV0YWlsVmlldykge1xyXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhUHJlZml4ID0gdGhpcy5fZ3JpZE9wdGlvbnMucm93RGV0YWlsVmlldyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5yb3dEZXRhaWxWaWV3LmtleVByZWZpeCB8fCAnX18nO1xyXG4gICAgICAgIGlmIChpdGVtW2Ake21ldGFkYXRhUHJlZml4fWlzUGFkZGluZ2BdICYmIGl0ZW1bYCR7bWV0YWRhdGFQcmVmaXh9cGFyZW50YF0pIHtcclxuICAgICAgICAgIGl0ZW0gPSBpdGVtW2Ake21ldGFkYXRhUHJlZml4fXBhcmVudGBdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZGF0YUtleSA9IGNvbHVtbkRlZi5kYXRhS2V5O1xyXG4gICAgICBjb25zdCBmaWVsZE5hbWUgPSBjb2x1bW5EZWYucXVlcnlGaWVsZEZpbHRlciB8fCBjb2x1bW5EZWYucXVlcnlGaWVsZCB8fCBjb2x1bW5EZWYuZmllbGQ7XHJcbiAgICAgIGNvbnN0IGZpZWxkVHlwZSA9IGNvbHVtbkRlZi50eXBlIHx8IEZpZWxkVHlwZS5zdHJpbmc7XHJcbiAgICAgIGNvbnN0IGZpbHRlclNlYXJjaFR5cGUgPSAoY29sdW1uRGVmLmZpbHRlclNlYXJjaFR5cGUpID8gY29sdW1uRGVmLmZpbHRlclNlYXJjaFR5cGUgOiBudWxsO1xyXG4gICAgICBsZXQgY2VsbFZhbHVlID0gaXRlbVtmaWVsZE5hbWVdO1xyXG5cclxuICAgICAgLy8gd2hlbiBpdGVtIGlzIGEgY29tcGxleCBvYmplY3QgKGRvdCBcIi5cIiBub3RhdGlvbiksIHdlIG5lZWQgdG8gZmlsdGVyIHRoZSB2YWx1ZSBjb250YWluZWQgaW4gdGhlIG9iamVjdCB0cmVlXHJcbiAgICAgIGlmIChmaWVsZE5hbWUuaW5kZXhPZignLicpID49IDApIHtcclxuICAgICAgICBjZWxsVmFsdWUgPSBnZXREZXNjZW5kYW50UHJvcGVydHkoaXRlbSwgZmllbGROYW1lKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gaWYgd2UgZmluZCBzZWFyY2hUZXJtcyB1c2UgdGhlbSBidXQgbWFrZSBhIGRlZXAgY29weSBzbyB0aGF0IHdlIGRvbid0IGFmZmVjdCBvcmlnaW5hbCBhcnJheVxyXG4gICAgICAvLyB3ZSBtaWdodCBoYXZlIHRvIG92ZXJ3cml0ZSB0aGUgdmFsdWUocykgbG9jYWxseSB0aGF0IGFyZSByZXR1cm5lZFxyXG4gICAgICAvLyBlLmc6IHdlIGRvbid0IHdhbnQgdG8gb3BlcmF0b3Igd2l0aGluIHRoZSBzZWFyY2ggdmFsdWUsIHNpbmNlIGl0IHdpbGwgZmFpbCBmaWx0ZXIgY29uZGl0aW9uIGNoZWNrIHRyaWdnZXIgYWZ0ZXJ3YXJkXHJcbiAgICAgIGNvbnN0IHNlYXJjaFZhbHVlcyA9IChjb2x1bW5GaWx0ZXIgJiYgY29sdW1uRmlsdGVyLnNlYXJjaFRlcm1zKSA/ICQuZXh0ZW5kKHRydWUsIFtdLCBjb2x1bW5GaWx0ZXIuc2VhcmNoVGVybXMpIDogbnVsbDtcclxuXHJcbiAgICAgIGxldCBmaWVsZFNlYXJjaFZhbHVlID0gKEFycmF5LmlzQXJyYXkoc2VhcmNoVmFsdWVzKSAmJiBzZWFyY2hWYWx1ZXMubGVuZ3RoID09PSAxKSA/IHNlYXJjaFZhbHVlc1swXSA6ICcnO1xyXG5cclxuICAgICAgbGV0IG1hdGNoZXMgPSBudWxsO1xyXG4gICAgICBpZiAoZmllbGRUeXBlICE9PSBGaWVsZFR5cGUub2JqZWN0KSB7XHJcbiAgICAgICAgZmllbGRTZWFyY2hWYWx1ZSA9ICcnICsgZmllbGRTZWFyY2hWYWx1ZTsgLy8gbWFrZSBzdXJlIGl0J3MgYSBzdHJpbmdcclxuICAgICAgICBtYXRjaGVzID0gZmllbGRTZWFyY2hWYWx1ZS5tYXRjaCgvXihbPD4hPVxcKl17MCwyfSkoLipbXjw+IT1cXCpdKShbXFwqXT8pJC8pOyAvLyBncm91cCAxOiBPcGVyYXRvciwgMjogc2VhcmNoVmFsdWUsIDM6IGxhc3QgY2hhciBpcyAnKicgKG1lYW5pbmcgc3RhcnRzIHdpdGgsIGV4LjogYWJjKilcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IG9wZXJhdG9yID0gY29sdW1uRmlsdGVyLm9wZXJhdG9yIHx8ICgobWF0Y2hlcykgPyBtYXRjaGVzWzFdIDogJycpO1xyXG4gICAgICBjb25zdCBzZWFyY2hUZXJtID0gKCEhbWF0Y2hlcykgPyBtYXRjaGVzWzJdIDogJyc7XHJcbiAgICAgIGNvbnN0IGxhc3RWYWx1ZUNoYXIgPSAoISFtYXRjaGVzKSA/IG1hdGNoZXNbM10gOiAob3BlcmF0b3IgPT09ICcqeicgPyAnKicgOiAnJyk7XHJcblxyXG4gICAgICBpZiAoc2VhcmNoVmFsdWVzICYmIHNlYXJjaFZhbHVlcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgZmllbGRTZWFyY2hWYWx1ZSA9IHNlYXJjaFZhbHVlcy5qb2luKCcsJyk7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZpZWxkU2VhcmNoVmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgLy8gZXNjYXBpbmcgdGhlIHNlYXJjaCB2YWx1ZVxyXG4gICAgICAgIGZpZWxkU2VhcmNoVmFsdWUgPSBmaWVsZFNlYXJjaFZhbHVlLnJlcGxhY2UoYCdgLCBgJydgKTsgLy8gZXNjYXBlIHNpbmdsZSBxdW90ZXMgYnkgZG91YmxpbmcgdGhlbVxyXG4gICAgICAgIGlmIChvcGVyYXRvciA9PT0gJyonIHx8IG9wZXJhdG9yID09PSAnYSonIHx8IG9wZXJhdG9yID09PSAnKnonIHx8IGxhc3RWYWx1ZUNoYXIgPT09ICcqJykge1xyXG4gICAgICAgICAgb3BlcmF0b3IgPSAob3BlcmF0b3IgPT09ICcqJyB8fCBvcGVyYXRvciA9PT0gJyp6JykgPyBPcGVyYXRvclR5cGUuZW5kc1dpdGggOiBPcGVyYXRvclR5cGUuc3RhcnRzV2l0aDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIG5vIG5lZWQgdG8gcXVlcnkgaWYgc2VhcmNoIHZhbHVlIGlzIGVtcHR5XHJcbiAgICAgIGlmIChzZWFyY2hUZXJtID09PSAnJyAmJiAoIXNlYXJjaFZhbHVlcyB8fCAoQXJyYXkuaXNBcnJheShzZWFyY2hWYWx1ZXMpICYmIHNlYXJjaFZhbHVlcy5sZW5ndGggPT09IDApKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBpZiBzZWFyY2ggdmFsdWUgaGFzIGEgcmVnZXggbWF0Y2ggd2Ugd2lsbCBvbmx5IGtlZXAgdGhlIHZhbHVlIHdpdGhvdXQgdGhlIG9wZXJhdG9yXHJcbiAgICAgIC8vIGluIHRoaXMgY2FzZSB3ZSBuZWVkIHRvIG92ZXJ3cml0ZSB0aGUgcmV0dXJuZWQgc2VhcmNoIHZhbHVlcyB0byB0cnVuY2F0ZSBvcGVyYXRvciBmcm9tIHRoZSBzdHJpbmcgc2VhcmNoXHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG1hdGNoZXMpICYmIG1hdGNoZXMubGVuZ3RoID49IDEgJiYgKEFycmF5LmlzQXJyYXkoc2VhcmNoVmFsdWVzKSAmJiBzZWFyY2hWYWx1ZXMubGVuZ3RoID09PSAxKSkge1xyXG4gICAgICAgIHNlYXJjaFZhbHVlc1swXSA9IHNlYXJjaFRlcm07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGZpbHRlciBzZWFyY2ggdGVybXMgc2hvdWxkIGFsd2F5cyBiZSBzdHJpbmcgdHlwZSAoZXZlbiB0aG91Z2ggd2UgcGVybWl0IHRoZSBlbmQgdXNlciB0byBpbnB1dCBudW1iZXJzKVxyXG4gICAgICAvLyBzbyBtYWtlIHN1cmUgZWFjaCB0ZXJtIGFyZSBzdHJpbmdzLCBpZiB1c2VyIGhhcyBzb21lIGRlZmF1bHQgc2VhcmNoIHRlcm1zLCB3ZSB3aWxsIGNhc3QgdGhlbSB0byBzdHJpbmdcclxuICAgICAgaWYgKHNlYXJjaFZhbHVlcyAmJiBBcnJheS5pc0FycmF5KHNlYXJjaFZhbHVlcykgJiYgZmllbGRUeXBlICE9PSBGaWVsZFR5cGUub2JqZWN0KSB7XHJcbiAgICAgICAgZm9yIChsZXQgayA9IDAsIGxuID0gc2VhcmNoVmFsdWVzLmxlbmd0aDsgayA8IGxuOyBrKyspIHtcclxuICAgICAgICAgIC8vIG1ha2Ugc3VyZSBhbGwgc2VhcmNoIHRlcm1zIGFyZSBzdHJpbmdzXHJcbiAgICAgICAgICBzZWFyY2hWYWx1ZXNba10gPSAoKHNlYXJjaFZhbHVlc1trXSA9PT0gdW5kZWZpbmVkIHx8IHNlYXJjaFZhbHVlc1trXSA9PT0gbnVsbCkgPyAnJyA6IHNlYXJjaFZhbHVlc1trXSkgKyAnJztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHdoZW4gdXNpbmcgbG9jYWxpemF0aW9uIChpMThuKSwgd2Ugc2hvdWxkIHVzZSB0aGUgZm9ybWF0dGVyIG91dHB1dCB0byBzZWFyY2ggYXMgdGhlIG5ldyBjZWxsIHZhbHVlXHJcbiAgICAgIGlmIChjb2x1bW5EZWYgJiYgY29sdW1uRGVmLnBhcmFtcyAmJiBjb2x1bW5EZWYucGFyYW1zLnVzZUZvcm1hdHRlck91cHV0VG9GaWx0ZXIpIHtcclxuICAgICAgICBjb25zdCByb3dJbmRleCA9IChkYXRhVmlldyAmJiB0eXBlb2YgZGF0YVZpZXcuZ2V0SWR4QnlJZCA9PT0gJ2Z1bmN0aW9uJykgPyBkYXRhVmlldy5nZXRJZHhCeUlkKGl0ZW0uaWQpIDogMDtcclxuICAgICAgICBjZWxsVmFsdWUgPSBjb2x1bW5EZWYuZm9ybWF0dGVyKHJvd0luZGV4LCBjb2x1bW5JbmRleCwgY2VsbFZhbHVlLCBjb2x1bW5EZWYsIGl0ZW0sIHRoaXMuX2dyaWQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBtYWtlIHN1cmUgY2VsbCB2YWx1ZSBpcyBhbHdheXMgYSBzdHJpbmdcclxuICAgICAgaWYgKHR5cGVvZiBjZWxsVmFsdWUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgY2VsbFZhbHVlID0gY2VsbFZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGNvbmRpdGlvbk9wdGlvbnMgPSB7XHJcbiAgICAgICAgZGF0YUtleSxcclxuICAgICAgICBmaWVsZFR5cGUsXHJcbiAgICAgICAgc2VhcmNoVGVybXM6IHNlYXJjaFZhbHVlcyxcclxuICAgICAgICBjZWxsVmFsdWUsXHJcbiAgICAgICAgb3BlcmF0b3I6IG9wZXJhdG9yIGFzIE9wZXJhdG9yU3RyaW5nLFxyXG4gICAgICAgIGNlbGxWYWx1ZUxhc3RDaGFyOiBsYXN0VmFsdWVDaGFyLFxyXG4gICAgICAgIGZpbHRlclNlYXJjaFR5cGVcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGlmICghRmlsdGVyQ29uZGl0aW9ucy5leGVjdXRlTWFwcGVkQ29uZGl0aW9uKGNvbmRpdGlvbk9wdGlvbnMpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBnZXRDb2x1bW5GaWx0ZXJzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2NvbHVtbkZpbHRlcnM7XHJcbiAgfVxyXG5cclxuICBnZXRGaWx0ZXJzTWV0YWRhdGEoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZmlsdGVyc01ldGFkYXRhO1xyXG4gIH1cclxuXHJcbiAgZ2V0Q3VycmVudExvY2FsRmlsdGVycygpOiBDdXJyZW50RmlsdGVyW10ge1xyXG4gICAgY29uc3QgY3VycmVudEZpbHRlcnM6IEN1cnJlbnRGaWx0ZXJbXSA9IFtdO1xyXG4gICAgaWYgKHRoaXMuX2NvbHVtbkZpbHRlcnMpIHtcclxuICAgICAgZm9yIChjb25zdCBjb2xJZCBvZiBPYmplY3Qua2V5cyh0aGlzLl9jb2x1bW5GaWx0ZXJzKSkge1xyXG4gICAgICAgIGNvbnN0IGNvbHVtbkZpbHRlciA9IHRoaXMuX2NvbHVtbkZpbHRlcnNbY29sSWRdO1xyXG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHsgY29sdW1uSWQ6IGNvbElkIHx8ICcnIH0gYXMgQ3VycmVudEZpbHRlcjtcclxuXHJcbiAgICAgICAgaWYgKGNvbHVtbkZpbHRlciAmJiBjb2x1bW5GaWx0ZXIuc2VhcmNoVGVybXMpIHtcclxuICAgICAgICAgIGZpbHRlci5zZWFyY2hUZXJtcyA9IGNvbHVtbkZpbHRlci5zZWFyY2hUZXJtcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbHVtbkZpbHRlci5vcGVyYXRvcikge1xyXG4gICAgICAgICAgZmlsdGVyLm9wZXJhdG9yID0gY29sdW1uRmlsdGVyLm9wZXJhdG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXIuc2VhcmNoVGVybXMpICYmIGZpbHRlci5zZWFyY2hUZXJtcy5sZW5ndGggPiAwICYmIGZpbHRlci5zZWFyY2hUZXJtc1swXSAhPT0gJycpIHtcclxuICAgICAgICAgIGN1cnJlbnRGaWx0ZXJzLnB1c2goZmlsdGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjdXJyZW50RmlsdGVycztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgc2ltcGxlIGZ1bmN0aW9uIHRoYXQgaXMgYmluZGVkIHRvIHRoZSBzdWJzY3JpYmVyIGFuZCBlbWl0IGEgY2hhbmdlIHdoZW4gdGhlIGZpbHRlciBpcyBjYWxsZWQuXHJcbiAgICogT3RoZXIgc2VydmljZXMsIGxpa2UgUGFnaW5hdGlvbiwgY2FuIHRoZW4gc3Vic2NyaWJlIHRvIGl0LlxyXG4gICAqIEBwYXJhbSBjYWxsZXJcclxuICAgKi9cclxuICBlbWl0RmlsdGVyQ2hhbmdlZChjYWxsZXI6IEVtaXR0ZXJUeXBlKSB7XHJcbiAgICBpZiAoY2FsbGVyID09PSBFbWl0dGVyVHlwZS5yZW1vdGUgJiYgdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuYmFja2VuZFNlcnZpY2VBcGkpIHtcclxuICAgICAgbGV0IGN1cnJlbnRGaWx0ZXJzOiBDdXJyZW50RmlsdGVyW10gPSBbXTtcclxuICAgICAgY29uc3QgYmFja2VuZFNlcnZpY2UgPSB0aGlzLl9ncmlkT3B0aW9ucy5iYWNrZW5kU2VydmljZUFwaS5zZXJ2aWNlO1xyXG4gICAgICBpZiAoYmFja2VuZFNlcnZpY2UgJiYgYmFja2VuZFNlcnZpY2UuZ2V0Q3VycmVudEZpbHRlcnMpIHtcclxuICAgICAgICBjdXJyZW50RmlsdGVycyA9IGJhY2tlbmRTZXJ2aWNlLmdldEN1cnJlbnRGaWx0ZXJzKCkgYXMgQ3VycmVudEZpbHRlcltdO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMub25GaWx0ZXJDaGFuZ2VkLm5leHQoY3VycmVudEZpbHRlcnMpO1xyXG4gICAgfSBlbHNlIGlmIChjYWxsZXIgPT09IEVtaXR0ZXJUeXBlLmxvY2FsKSB7XHJcbiAgICAgIHRoaXMub25GaWx0ZXJDaGFuZ2VkLm5leHQodGhpcy5nZXRDdXJyZW50TG9jYWxGaWx0ZXJzKCkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgb25CYWNrZW5kRmlsdGVyQ2hhbmdlKGV2ZW50OiBLZXlib2FyZEV2ZW50LCBhcmdzOiBhbnkpIHtcclxuICAgIGlmICghYXJncyB8fCAhYXJncy5ncmlkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignU29tZXRoaW5nIHdlbnQgd3Jvbmcgd2hlbiB0cnlpbmcgdG8gYmluZCB0aGUgXCJvbkJhY2tlbmRGaWx0ZXJDaGFuZ2UoZXZlbnQsIGFyZ3MpXCIgZnVuY3Rpb24sIGl0IHNlZW1zIHRoYXQgXCJhcmdzXCIgaXMgbm90IHBvcHVsYXRlZCBjb3JyZWN0bHknKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjb25zdCBncmlkT3B0aW9uczogR3JpZE9wdGlvbiA9IChhcmdzLmdyaWQgJiYgYXJncy5ncmlkLmdldE9wdGlvbnMpID8gYXJncy5ncmlkLmdldE9wdGlvbnMoKSA6IHt9O1xyXG4gICAgY29uc3QgYmFja2VuZEFwaSA9IHRoaXMuX2dyaWRPcHRpb25zLmJhY2tlbmRTZXJ2aWNlQXBpO1xyXG5cclxuICAgIGlmICghYmFja2VuZEFwaSB8fCAhYmFja2VuZEFwaS5wcm9jZXNzIHx8ICFiYWNrZW5kQXBpLnNlcnZpY2UpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCYWNrZW5kU2VydmljZUFwaSByZXF1aXJlcyBhdCBsZWFzdCBhIFwicHJvY2Vzc1wiIGZ1bmN0aW9uIGFuZCBhIFwic2VydmljZVwiIGRlZmluZWRgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBrZWVwIHN0YXJ0IHRpbWUgJiBlbmQgdGltZXN0YW1wcyAmIHJldHVybiBpdCBhZnRlciBwcm9jZXNzIGV4ZWN1dGlvblxyXG4gICAgY29uc3Qgc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcclxuXHJcbiAgICAvLyBydW4gYSBwcmVQcm9jZXNzIGNhbGxiYWNrIGlmIGRlZmluZWRcclxuICAgIGlmIChiYWNrZW5kQXBpLnByZVByb2Nlc3MpIHtcclxuICAgICAgYmFja2VuZEFwaS5wcmVQcm9jZXNzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gb25seSBhZGQgYSBkZWxheSB3aGVuIHVzZXIgaXMgdHlwaW5nLCBvbiBzZWxlY3QgZHJvcGRvd24gZmlsdGVyIChvciBcIkNsZWFyIEZpbHRlclwiKSBpdCB3aWxsIGV4ZWN1dGUgcmlnaHQgYXdheVxyXG4gICAgbGV0IGRlYm91bmNlVHlwaW5nRGVsYXkgPSAwO1xyXG4gICAgY29uc3QgaXNUcmlnZ2VyZWRCeUNsZWFyRmlsdGVyID0gYXJncyAmJiBhcmdzLmNsZWFyRmlsdGVyVHJpZ2dlcmVkOyAvLyB3YXMgaXQgdHJpZ2dlciBieSBhIFwiQ2xlYXIgRmlsdGVyXCIgY29tbWFuZD9cclxuXHJcbiAgICBjb25zdCBldmVudFR5cGUgPSBldmVudCAmJiBldmVudC50eXBlO1xyXG4gICAgY29uc3QgZXZlbnRLZXlDb2RlID0gZXZlbnQgJiYgZXZlbnQua2V5Q29kZTtcclxuICAgIGlmICghaXNUcmlnZ2VyZWRCeUNsZWFyRmlsdGVyICYmIGV2ZW50S2V5Q29kZSAhPT0gS2V5Q29kZS5FTlRFUiAmJiAoZXZlbnRUeXBlID09PSAnaW5wdXQnIHx8IGV2ZW50VHlwZSA9PT0gJ2tleXVwJyB8fCBldmVudFR5cGUgPT09ICdrZXlkb3duJykpIHtcclxuICAgICAgZGVib3VuY2VUeXBpbmdEZWxheSA9IGJhY2tlbmRBcGkuaGFzT3duUHJvcGVydHkoJ2ZpbHRlclR5cGluZ0RlYm91bmNlJykgPyBiYWNrZW5kQXBpLmZpbHRlclR5cGluZ0RlYm91bmNlIGFzIG51bWJlciA6IERFRkFVTFRfRklMVEVSX1RZUElOR19ERUJPVU5DRTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBxdWVyeSBiYWNrZW5kLCBleGNlcHQgd2hlbiBpdCdzIGNhbGxlZCBieSBhIENsZWFyRmlsdGVycyB0aGVuIHdlIHdvbid0XHJcbiAgICBpZiAoYXJncyAmJiBhcmdzLnNob3VsZFRyaWdnZXJRdWVyeSkge1xyXG4gICAgICAvLyBjYWxsIHRoZSBzZXJ2aWNlIHRvIGdldCBhIHF1ZXJ5IGJhY2tcclxuICAgICAgLy8gQGRlcHJlY2F0ZWQgVE9ETzogcmVtb3ZlIGFzeW5jL2F3YWl0IG9uIG5leHQgbWFqb3IgY2hhbmdlLCByZWZlciB0byBwcm9jZXNzT25GaWx0ZXJDaGFuZ2VkIGluIEJhY2tlbmRTZXJ2aWNlIGludGVyZmFjZSAod2l0aCBAZGVwcmVjYXRlZClcclxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuICAgICAgaWYgKGRlYm91bmNlVHlwaW5nRGVsYXkgPiAwKSB7XHJcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcclxuICAgICAgICAgIGNvbnN0IHF1ZXJ5ID0gYXdhaXQgYmFja2VuZEFwaS5zZXJ2aWNlLnByb2Nlc3NPbkZpbHRlckNoYW5nZWQoZXZlbnQsIGFyZ3MpO1xyXG4gICAgICAgICAgY29uc3QgdG90YWxJdGVtcyA9IHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLnBhZ2luYXRpb24gJiYgdGhpcy5fZ3JpZE9wdGlvbnMucGFnaW5hdGlvbi50b3RhbEl0ZW1zO1xyXG4gICAgICAgICAgZXhlY3V0ZUJhY2tlbmRDYWxsYmFjayhiYWNrZW5kQXBpLCBxdWVyeSwgYXJncywgc3RhcnRUaW1lLCB0b3RhbEl0ZW1zLCB0aGlzLmVtaXRGaWx0ZXJDaGFuZ2VkLmJpbmQodGhpcyksIHRoaXMuaHR0cENhbmNlbFJlcXVlc3RzJCk7XHJcbiAgICAgICAgfSwgZGVib3VuY2VUeXBpbmdEZWxheSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgcXVlcnkgPSBhd2FpdCBiYWNrZW5kQXBpLnNlcnZpY2UucHJvY2Vzc09uRmlsdGVyQ2hhbmdlZChldmVudCwgYXJncyk7XHJcbiAgICAgICAgY29uc3QgdG90YWxJdGVtcyA9IHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLnBhZ2luYXRpb24gJiYgdGhpcy5fZ3JpZE9wdGlvbnMucGFnaW5hdGlvbi50b3RhbEl0ZW1zO1xyXG4gICAgICAgIGV4ZWN1dGVCYWNrZW5kQ2FsbGJhY2soYmFja2VuZEFwaSwgcXVlcnksIGFyZ3MsIHN0YXJ0VGltZSwgdG90YWxJdGVtcywgdGhpcy5lbWl0RmlsdGVyQ2hhbmdlZC5iaW5kKHRoaXMpLCB0aGlzLmh0dHBDYW5jZWxSZXF1ZXN0cyQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBXaGVuIHVzZXIgcGFzc2VzIGFuIGFycmF5IG9mIHByZXNldCBmaWx0ZXJzLCB3ZSBuZWVkIHRvIHByZS1wb3B1bGF0ZSBlYWNoIGNvbHVtbiBmaWx0ZXIgc2VhcmNoVGVybShzKVxyXG4gICAqIFRoZSBwcm9jZXNzIGlzIHRvIGxvb3AgdGhyb3VnaCB0aGUgcHJlc2V0IGZpbHRlcnMgYXJyYXksIGZpbmQgdGhlIGFzc29jaWF0ZWQgY29sdW1uIGZyb20gY29sdW1uRGVmaW5pdGlvbnMgYW5kIGZpbGwgaW4gdGhlIGZpbHRlciBvYmplY3Qgc2VhcmNoVGVybShzKVxyXG4gICAqIFRoaXMgaXMgYmFzaWNhbGx5IHRoZSBzYW1lIGFzIGlmIHdlIHdvdWxkIG1hbnVhbGx5IGFkZCBzZWFyY2hUZXJtKHMpIHRvIGEgY29sdW1uIGZpbHRlciBvYmplY3QgaW4gdGhlIGNvbHVtbiBkZWZpbml0aW9uLCBidXQgd2UgZG8gaXQgcHJvZ3JhbW1hdGljYWxseS5cclxuICAgKiBBdCB0aGUgZW5kIG9mIHRoZSBkYXksIHdoZW4gY3JlYXRpbmcgdGhlIEZpbHRlciAoRE9NIEVsZW1lbnQpLCBpdCB3aWxsIHVzZSB0aGVzZSBzZWFyY2hUZXJtKHMpIHNvIHdlIGNhbiB0YWtlIGFkdmFudGFnZSBvZiB0aGF0IHdpdGhvdXQgcmVjb2RpbmcgZWFjaCBGaWx0ZXIgdHlwZSAoRE9NIGVsZW1lbnQpXHJcbiAgICovXHJcbiAgcG9wdWxhdGVDb2x1bW5GaWx0ZXJTZWFyY2hUZXJtUHJlc2V0cyhmaWx0ZXJzOiBDdXJyZW50RmlsdGVyW10pIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGZpbHRlcnMpICYmIGZpbHRlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICB0aGlzLl9jb2x1bW5EZWZpbml0aW9ucy5mb3JFYWNoKChjb2x1bW5EZWY6IENvbHVtbikgPT4ge1xyXG4gICAgICAgIC8vIGNsZWFyIGFueSBjb2x1bW5EZWYgc2VhcmNoVGVybXMgYmVmb3JlIGFwcGx5aW5nIFByZXNldHNcclxuICAgICAgICBpZiAoY29sdW1uRGVmLmZpbHRlciAmJiBjb2x1bW5EZWYuZmlsdGVyLnNlYXJjaFRlcm1zKSB7XHJcbiAgICAgICAgICBkZWxldGUgY29sdW1uRGVmLmZpbHRlci5zZWFyY2hUZXJtcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGZyb20gZWFjaCBwcmVzZXRzLCB3ZSB3aWxsIGZpbmQgdGhlIGFzc29jaWF0ZWQgY29sdW1uRGVmIGFuZCBhcHBseSB0aGUgcHJlc2V0IHNlYXJjaFRlcm1zICYgb3BlcmF0b3IgaWYgdGhlcmUgaXNcclxuICAgICAgICBjb25zdCBjb2x1bW5QcmVzZXQgPSBmaWx0ZXJzLmZpbmQoKHByZXNldEZpbHRlcjogQ3VycmVudEZpbHRlcikgPT4ge1xyXG4gICAgICAgICAgcmV0dXJuIHByZXNldEZpbHRlci5jb2x1bW5JZCA9PT0gY29sdW1uRGVmLmlkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChjb2x1bW5QcmVzZXQgJiYgY29sdW1uUHJlc2V0LnNlYXJjaFRlcm1zICYmIEFycmF5LmlzQXJyYXkoY29sdW1uUHJlc2V0LnNlYXJjaFRlcm1zKSkge1xyXG4gICAgICAgICAgY29sdW1uRGVmLmZpbHRlciA9IGNvbHVtbkRlZi5maWx0ZXIgfHwge307XHJcbiAgICAgICAgICBjb2x1bW5EZWYuZmlsdGVyLm9wZXJhdG9yID0gY29sdW1uUHJlc2V0Lm9wZXJhdG9yIHx8IGNvbHVtbkRlZi5maWx0ZXIub3BlcmF0b3IgfHwgJyc7XHJcbiAgICAgICAgICBjb2x1bW5EZWYuZmlsdGVyLnNlYXJjaFRlcm1zID0gY29sdW1uUHJlc2V0LnNlYXJjaFRlcm1zO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5fY29sdW1uRGVmaW5pdGlvbnM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhlIHNvcnQgaWNvbnMgaW4gdGhlIFVJIChPTkxZIHRoZSBpY29ucywgaXQgZG9lcyBub3QgZG8gYW55IHNvcnRpbmcpXHJcbiAgICogVGhlIGNvbHVtbiBzb3J0IGljb25zIGFyZSBub3QgbmVjZXNzYXJpbHkgaW50ZXItY29ubmVjdGVkIHRvIHRoZSBzb3J0aW5nIGZ1bmN0aW9uYWxpdHkgaXRzZWxmLFxyXG4gICAqIHlvdSBjYW4gY2hhbmdlIHRoZSBzb3J0aW5nIGljb25zIHNlcGFyYXRlbHkgYnkgcGFzc2luZyBhbiBhcnJheSBvZiBjb2x1bW5JZC9zb3J0QXNjIGFuZCB0aGF0IHdpbGwgY2hhbmdlIE9OTFkgdGhlIGljb25zXHJcbiAgICogQHBhcmFtIHNvcnRDb2x1bW5zXHJcbiAgICovXHJcbiAgc2V0U29ydENvbHVtbkljb25zKHNvcnRDb2x1bW5zOiB7IGNvbHVtbklkOiBzdHJpbmcsIHNvcnRBc2M6IGJvb2xlYW4gfVtdKSB7XHJcbiAgICBpZiAodGhpcy5fZ3JpZCAmJiBBcnJheS5pc0FycmF5KHNvcnRDb2x1bW5zKSkge1xyXG4gICAgICB0aGlzLl9ncmlkLnNldFNvcnRDb2x1bW5zKHNvcnRDb2x1bW5zKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBGaWx0ZXJzIGR5bmFtaWNhbGx5IGp1c3QgYnkgcHJvdmlkaW5nIGFuIGFycmF5IG9mIGZpbHRlcihzKS5cclxuICAgKiBZb3UgY2FuIGFsc28gY2hvb3NlIGVtaXQgKGRlZmF1bHQpIGEgRmlsdGVyIENoYW5nZWQgZXZlbnQgdGhhdCB3aWxsIGJlIHBpY2tlZCBieSB0aGUgR3JpZCBTdGF0ZSBTZXJ2aWNlLlxyXG4gICAqXHJcbiAgICogQWxzbyBmb3IgYmFja2VuZCBzZXJ2aWNlIG9ubHksIHlvdSBjYW4gY2hvb3NlIHRvIHRyaWdnZXIgYSBiYWNrZW5kIHF1ZXJ5IChkZWZhdWx0KSBvciBub3QgaWYgeW91IHdpc2ggdG8gZG8gaXQgbGF0ZXIsXHJcbiAgICogdGhpcyBjb3VsZCBiZSB1c2VmdWwgd2hlbiB1c2luZyB1cGRhdGVGaWx0ZXJzICYgdXBkYXRlU29ydGluZyBhbmQgeW91IHdpc2ggdG8gb25seSBzZW5kIHRoZSBiYWNrZW5kIHF1ZXJ5IG9uY2UuXHJcbiAgICogQHBhcmFtIGZpbHRlcnMgYXJyYXlcclxuICAgKiBAcGFyYW0gdHJpZ2dlckV2ZW50IGRlZmF1bHRzIHRvIFRydWUsIGRvIHdlIHdhbnQgdG8gZW1pdCBhIGZpbHRlciBjaGFuZ2VkIGV2ZW50P1xyXG4gICAqIEBwYXJhbSB0cmlnZ2VyQmFja2VuZFF1ZXJ5IGRlZmF1bHRzIHRvIFRydWUsIHdoaWNoIHdpbGwgcXVlcnkgdGhlIGJhY2tlbmQuXHJcbiAgICovXHJcbiAgdXBkYXRlRmlsdGVycyhmaWx0ZXJzOiBDdXJyZW50RmlsdGVyW10sIGVtaXRDaGFuZ2VkRXZlbnQgPSB0cnVlLCB0cmlnZ2VyQmFja2VuZFF1ZXJ5ID0gdHJ1ZSkge1xyXG4gICAgaWYgKCF0aGlzLl9maWx0ZXJzTWV0YWRhdGEgfHwgdGhpcy5fZmlsdGVyc01ldGFkYXRhLmxlbmd0aCA9PT0gMCB8fCAhdGhpcy5fZ3JpZE9wdGlvbnMgfHwgIXRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZUZpbHRlcmluZykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tBbmd1bGFyLVNsaWNrZ3JpZF0gaW4gb3JkZXIgdG8gdXNlIFwidXBkYXRlRmlsdGVyc1wiIG1ldGhvZCwgeW91IG5lZWQgdG8gaGF2ZSBGaWx0ZXJhYmxlIENvbHVtbnMgZGVmaW5lZCBpbiB5b3VyIGdyaWQgYW5kIFwiZW5hYmxlRmlsdGVyaW5nXCIgc2V0IGluIHlvdXIgR3JpZCBPcHRpb25zJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVycykpIHtcclxuICAgICAgLy8gc3RhcnQgYnkgY2xlYXJpbmcgYWxsIGZpbHRlcnMgKHdpdGhvdXQgdHJpZ2dlcmluZyBhbiBldmVudCkgYmVmb3JlIGFwcGx5aW5nIGFueSBuZXcgZmlsdGVyc1xyXG4gICAgICB0aGlzLmNsZWFyRmlsdGVycyhmYWxzZSk7XHJcblxyXG4gICAgICAvLyBwcmUtZmlsbCAodmFsdWUgKyBvcGVyYXRvcikgYW5kIHJlbmRlciBhbGwgZmlsdGVycyBpbiB0aGUgRE9NXHJcbiAgICAgIC8vIGxvb3AgdGhyb3VnaCBlYWNoIEZpbHRlcnMgcHJvdmlkZWQgKHdoaWNoIGhhcyBhIGNvbHVtbklkIHByb3BlcnR5KVxyXG4gICAgICAvLyB0aGVuIGZpbmQgdGhlaXIgYXNzb2NpYXRlZCBGaWx0ZXIgaW5zdGFuY2VzIHRoYXQgd2VyZSBvcmlnaW5hbGx5IGNyZWF0ZWQgaW4gdGhlIGdyaWRcclxuICAgICAgZmlsdGVycy5mb3JFYWNoKChuZXdGaWx0ZXIpID0+IHtcclxuICAgICAgICBjb25zdCB1aUZpbHRlciA9IHRoaXMuX2ZpbHRlcnNNZXRhZGF0YS5maW5kKChmaWx0ZXIpID0+IG5ld0ZpbHRlci5jb2x1bW5JZCA9PT0gZmlsdGVyLmNvbHVtbkRlZi5pZCk7XHJcbiAgICAgICAgaWYgKG5ld0ZpbHRlciAmJiB1aUZpbHRlcikge1xyXG4gICAgICAgICAgY29uc3QgbmV3T3BlcmF0b3IgPSBuZXdGaWx0ZXIub3BlcmF0b3IgfHwgdWlGaWx0ZXIuZGVmYXVsdE9wZXJhdG9yO1xyXG4gICAgICAgICAgdGhpcy51cGRhdGVDb2x1bW5GaWx0ZXJzKG5ld0ZpbHRlci5zZWFyY2hUZXJtcywgdWlGaWx0ZXIuY29sdW1uRGVmLCBuZXdPcGVyYXRvcik7XHJcbiAgICAgICAgICB1aUZpbHRlci5zZXRWYWx1ZXMobmV3RmlsdGVyLnNlYXJjaFRlcm1zLCBuZXdPcGVyYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnN0IGJhY2tlbmRBcGkgPSB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5iYWNrZW5kU2VydmljZUFwaTtcclxuXHJcbiAgICAgIC8vIHJlZnJlc2ggdGhlIERhdGFWaWV3IGFuZCB0cmlnZ2VyIGFuIGV2ZW50IGFmdGVyIGFsbCBmaWx0ZXJzIHdlcmUgdXBkYXRlZCBhbmQgcmVuZGVyZWRcclxuICAgICAgdGhpcy5fZGF0YVZpZXcucmVmcmVzaCgpO1xyXG5cclxuICAgICAgaWYgKGJhY2tlbmRBcGkpIHtcclxuICAgICAgICBjb25zdCBiYWNrZW5kQXBpU2VydmljZSA9IGJhY2tlbmRBcGkgJiYgYmFja2VuZEFwaS5zZXJ2aWNlO1xyXG4gICAgICAgIGlmIChiYWNrZW5kQXBpU2VydmljZSkge1xyXG4gICAgICAgICAgYmFja2VuZEFwaVNlcnZpY2UudXBkYXRlRmlsdGVycyhmaWx0ZXJzLCB0cnVlKTtcclxuICAgICAgICAgIGlmICh0cmlnZ2VyQmFja2VuZFF1ZXJ5KSB7XHJcbiAgICAgICAgICAgIHJlZnJlc2hCYWNrZW5kRGF0YXNldCh0aGlzLl9ncmlkT3B0aW9ucyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoZW1pdENoYW5nZWRFdmVudCkge1xyXG4gICAgICAgIGNvbnN0IGVtaXR0ZXJUeXBlID0gYmFja2VuZEFwaSA/IEVtaXR0ZXJUeXBlLnJlbW90ZSA6IEVtaXR0ZXJUeXBlLmxvY2FsO1xyXG4gICAgICAgIHRoaXMuZW1pdEZpbHRlckNoYW5nZWQoZW1pdHRlclR5cGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyAtLVxyXG4gIC8vIHByaXZhdGUgZnVuY3Rpb25zXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvKiogQWRkIGFsbCBjcmVhdGVkIGZpbHRlcnMgKGZyb20gdGhlaXIgdGVtcGxhdGUpIHRvIHRoZSBoZWFkZXIgcm93IHNlY3Rpb24gYXJlYSAqL1xyXG4gIHByaXZhdGUgYWRkRmlsdGVyVGVtcGxhdGVUb0hlYWRlclJvdyhhcmdzOiB7IGNvbHVtbjogQ29sdW1uOyBncmlkOiBhbnk7IG5vZGU6IEhUTUxFbGVtZW50IH0sIGlzRmlsdGVyRmlyc3RSZW5kZXIgPSB0cnVlKSB7XHJcbiAgICBjb25zdCBjb2x1bW5EZWYgPSBhcmdzLmNvbHVtbjtcclxuICAgIGNvbnN0IGNvbHVtbklkID0gY29sdW1uRGVmICYmIGNvbHVtbkRlZi5pZCB8fCAnJztcclxuXHJcbiAgICBpZiAoY29sdW1uRGVmICYmIGNvbHVtbklkICE9PSAnc2VsZWN0b3InICYmIGNvbHVtbkRlZi5maWx0ZXJhYmxlKSB7XHJcbiAgICAgIGxldCBzZWFyY2hUZXJtczogU2VhcmNoVGVybVtdIHwgdW5kZWZpbmVkO1xyXG4gICAgICBsZXQgb3BlcmF0b3I6IE9wZXJhdG9yVHlwZSB8IE9wZXJhdG9yU3RyaW5nO1xyXG4gICAgICBjb25zdCBuZXdGaWx0ZXI6IEZpbHRlciB8IHVuZGVmaW5lZCA9IHRoaXMuZmlsdGVyRmFjdG9yeS5jcmVhdGVGaWx0ZXIoYXJncy5jb2x1bW4uZmlsdGVyKTtcclxuICAgICAgb3BlcmF0b3IgPSAoY29sdW1uRGVmICYmIGNvbHVtbkRlZi5maWx0ZXIgJiYgY29sdW1uRGVmLmZpbHRlci5vcGVyYXRvcikgfHwgKG5ld0ZpbHRlciAmJiBuZXdGaWx0ZXIub3BlcmF0b3IpIHx8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgIGlmICh0aGlzLl9jb2x1bW5GaWx0ZXJzW2NvbHVtbkRlZi5pZF0pIHtcclxuICAgICAgICBzZWFyY2hUZXJtcyA9IHRoaXMuX2NvbHVtbkZpbHRlcnNbY29sdW1uRGVmLmlkXS5zZWFyY2hUZXJtcyB8fCB1bmRlZmluZWQ7XHJcbiAgICAgICAgb3BlcmF0b3IgPSB0aGlzLl9jb2x1bW5GaWx0ZXJzW2NvbHVtbkRlZi5pZF0ub3BlcmF0b3IgfHwgdW5kZWZpbmVkO1xyXG4gICAgICB9IGVsc2UgaWYgKGNvbHVtbkRlZi5maWx0ZXIpIHtcclxuICAgICAgICAvLyB3aGVuIGhpZGluZy9zaG93aW5nICh3aXRoIENvbHVtbiBQaWNrZXIgb3IgR3JpZCBNZW51KSwgaXQgd2lsbCB0cnkgdG8gcmUtY3JlYXRlIHlldCBhZ2FpbiB0aGUgZmlsdGVycyAoc2luY2UgU2xpY2tHcmlkIGRvZXMgYSByZS1yZW5kZXIpXHJcbiAgICAgICAgLy8gYmVjYXVzZSBvZiB0aGF0IHdlIG5lZWQgdG8gZmlyc3QgZ2V0IHNlYXJjaFRlcm0ocykgZnJvbSB0aGUgY29sdW1uRmlsdGVycyAodGhhdCBpcyB3aGF0IHRoZSB1c2VyIGxhc3QgdHlwZWQgaW4gYSBmaWx0ZXIgc2VhcmNoIGlucHV0KVxyXG4gICAgICAgIHNlYXJjaFRlcm1zID0gY29sdW1uRGVmLmZpbHRlci5zZWFyY2hUZXJtcyB8fCB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGVDb2x1bW5GaWx0ZXJzKHNlYXJjaFRlcm1zLCBjb2x1bW5EZWYsIG9wZXJhdG9yKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZmlsdGVyQXJndW1lbnRzOiBGaWx0ZXJBcmd1bWVudHMgPSB7XHJcbiAgICAgICAgZ3JpZDogdGhpcy5fZ3JpZCxcclxuICAgICAgICBvcGVyYXRvcixcclxuICAgICAgICBzZWFyY2hUZXJtcyxcclxuICAgICAgICBjb2x1bW5EZWYsXHJcbiAgICAgICAgY2FsbGJhY2s6IHRoaXMuY2FsbGJhY2tTZWFyY2hFdmVudC5iaW5kKHRoaXMpXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBpZiAobmV3RmlsdGVyKSB7XHJcbiAgICAgICAgbmV3RmlsdGVyLmluaXQoZmlsdGVyQXJndW1lbnRzLCBpc0ZpbHRlckZpcnN0UmVuZGVyKTtcclxuICAgICAgICBjb25zdCBmaWx0ZXJFeGlzdEluZGV4ID0gdGhpcy5fZmlsdGVyc01ldGFkYXRhLmZpbmRJbmRleCgoZmlsdGVyKSA9PiBuZXdGaWx0ZXIuY29sdW1uRGVmLmlkID09PSBmaWx0ZXIuY29sdW1uRGVmLmlkKTtcclxuXHJcbiAgICAgICAgLy8gYWRkIHRvIHRoZSBmaWx0ZXJzIGFycmF5cyBvciByZXBsYWNlIGl0IHdoZW4gZm91bmRcclxuICAgICAgICBpZiAoZmlsdGVyRXhpc3RJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgIHRoaXMuX2ZpbHRlcnNNZXRhZGF0YS5wdXNoKG5ld0ZpbHRlcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuX2ZpbHRlcnNNZXRhZGF0YVtmaWx0ZXJFeGlzdEluZGV4XSA9IG5ld0ZpbHRlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHdoZW4gaGlkaW5nL3Nob3dpbmcgKHdpdGggQ29sdW1uIFBpY2tlciBvciBHcmlkIE1lbnUpLCBpdCB3aWxsIHRyeSB0byByZS1jcmVhdGUgeWV0IGFnYWluIHRoZSBmaWx0ZXJzIChzaW5jZSBTbGlja0dyaWQgZG9lcyBhIHJlLXJlbmRlcilcclxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGFsc28gc2V0IGFnYWluIHRoZSB2YWx1ZXMgaW4gdGhlIERPTSBlbGVtZW50cyBpZiB0aGUgdmFsdWVzIHdlcmUgc2V0IGJ5IGEgc2VhcmNoVGVybShzKVxyXG4gICAgICAgIGlmIChzZWFyY2hUZXJtcyAmJiBuZXdGaWx0ZXIuc2V0VmFsdWVzKSB7XHJcbiAgICAgICAgICBuZXdGaWx0ZXIuc2V0VmFsdWVzKHNlYXJjaFRlcm1zKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGxiYWNrIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCBhbmQgZXhlY3V0ZWQgYnkgdGhlIGluZGl2aWR1YWwgRmlsdGVyIChET00gZWxlbWVudCksXHJcbiAgICogZm9yIGV4YW1wbGUgd2hlbiB1c2VyIHR5cGUgaW4gYSB3b3JkIHRvIHNlYXJjaCAod2hpY2ggdXNlcyBJbnB1dEZpbHRlciksIHRoaXMgRmlsdGVyIHdpbGwgZXhlY3V0ZSB0aGUgY2FsbGJhY2sgZnJvbSBhIGtleXVwIGV2ZW50LlxyXG4gICAqL1xyXG4gIHByaXZhdGUgY2FsbGJhY2tTZWFyY2hFdmVudChldmVudDogYW55LCBhcmdzOiBGaWx0ZXJDYWxsYmFja0FyZykge1xyXG4gICAgaWYgKGFyZ3MpIHtcclxuICAgICAgY29uc3Qgc2VhcmNoVGVybSA9ICgoZXZlbnQgJiYgZXZlbnQudGFyZ2V0KSA/IChldmVudC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWUgOiB1bmRlZmluZWQpO1xyXG4gICAgICBjb25zdCBzZWFyY2hUZXJtcyA9IChhcmdzLnNlYXJjaFRlcm1zICYmIEFycmF5LmlzQXJyYXkoYXJncy5zZWFyY2hUZXJtcykpID8gYXJncy5zZWFyY2hUZXJtcyA6IChzZWFyY2hUZXJtID8gW3NlYXJjaFRlcm1dIDogdW5kZWZpbmVkKTtcclxuICAgICAgY29uc3QgY29sdW1uRGVmID0gYXJncy5jb2x1bW5EZWYgfHwgbnVsbDtcclxuICAgICAgY29uc3QgY29sdW1uSWQgPSBjb2x1bW5EZWYgJiYgY29sdW1uRGVmLmlkIHx8ICcnO1xyXG4gICAgICBjb25zdCBvcGVyYXRvciA9IGFyZ3Mub3BlcmF0b3IgfHwgdW5kZWZpbmVkO1xyXG4gICAgICBjb25zdCBoYXNTZWFyY2hUZXJtcyA9IHNlYXJjaFRlcm1zICYmIEFycmF5LmlzQXJyYXkoc2VhcmNoVGVybXMpO1xyXG4gICAgICBjb25zdCB0ZXJtc0NvdW50ID0gaGFzU2VhcmNoVGVybXMgJiYgc2VhcmNoVGVybXMgJiYgc2VhcmNoVGVybXMubGVuZ3RoO1xyXG4gICAgICBjb25zdCBvbGRDb2x1bW5GaWx0ZXJzID0geyAuLi50aGlzLl9jb2x1bW5GaWx0ZXJzIH07XHJcblxyXG4gICAgICBpZiAoY29sdW1uRGVmICYmIGNvbHVtbklkKSB7XHJcbiAgICAgICAgaWYgKCFoYXNTZWFyY2hUZXJtcyB8fCB0ZXJtc0NvdW50ID09PSAwIHx8ICh0ZXJtc0NvdW50ID09PSAxICYmIEFycmF5LmlzQXJyYXkoc2VhcmNoVGVybXMpICYmIHNlYXJjaFRlcm1zWzBdID09PSAnJykpIHtcclxuICAgICAgICAgIC8vIGRlbGV0ZSB0aGUgcHJvcGVydHkgZnJvbSB0aGUgY29sdW1uRmlsdGVycyB3aGVuIGl0IGJlY29tZXMgZW1wdHlcclxuICAgICAgICAgIC8vIHdpdGhvdXQgZG9pbmcgdGhpcywgaXQgd291bGQgbGVhdmUgYW4gaW5jb3JyZWN0IHN0YXRlIG9mIHRoZSBwcmV2aW91cyBjb2x1bW4gZmlsdGVycyB3aGVuIGZpbHRlcmluZyBvbiBhbm90aGVyIGNvbHVtblxyXG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2NvbHVtbkZpbHRlcnNbY29sdW1uSWRdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zdCBjb2xJZCA9ICcnICsgY29sdW1uSWQgYXMgc3RyaW5nO1xyXG4gICAgICAgICAgY29uc3QgY29sRmlsdGVyOiBDb2x1bW5GaWx0ZXIgPSB7XHJcbiAgICAgICAgICAgIGNvbHVtbklkOiBjb2xJZCxcclxuICAgICAgICAgICAgY29sdW1uRGVmLFxyXG4gICAgICAgICAgICBzZWFyY2hUZXJtcyxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICBpZiAob3BlcmF0b3IpIHtcclxuICAgICAgICAgICAgY29sRmlsdGVyLm9wZXJhdG9yID0gb3BlcmF0b3I7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLl9jb2x1bW5GaWx0ZXJzW2NvbElkXSA9IGNvbEZpbHRlcjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGV2ZW50IG1pZ2h0IGhhdmUgYmVlbiBjcmVhdGVkIGFzIGEgQ3VzdG9tRXZlbnQgKGUuZy4gQ29tcG91bmREYXRlRmlsdGVyKSwgd2l0aG91dCBiZWluZyBhIHZhbGlkIFNsaWNrLkV2ZW50RGF0YSxcclxuICAgICAgLy8gaWYgc28gd2Ugd2lsbCBjcmVhdGUgYSBuZXcgU2xpY2suRXZlbnREYXRhIGFuZCBtZXJnZSBpdCB3aXRoIHRoYXQgQ3VzdG9tRXZlbnQgdG8gYXZvaWQgaGF2aW5nIFNsaWNrR3JpZCBlcnJvcnNcclxuICAgICAgY29uc3QgZXZlbnREYXRhID0gKGV2ZW50ICYmIHR5cGVvZiBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCAhPT0gJ2Z1bmN0aW9uJykgPyAkLmV4dGVuZCh7fSwgbmV3IFNsaWNrLkV2ZW50RGF0YSgpLCBldmVudCkgOiBldmVudDtcclxuXHJcbiAgICAgIC8vIHRyaWdnZXIgYW4gZXZlbnQgb25seSBpZiBGaWx0ZXJzIGNoYW5nZWQgb3IgaWYgRU5URVIga2V5IHdhcyBwcmVzc2VkXHJcbiAgICAgIGNvbnN0IGV2ZW50S2V5Q29kZSA9IGV2ZW50ICYmIGV2ZW50LmtleUNvZGU7XHJcbiAgICAgIGlmIChldmVudEtleUNvZGUgPT09IEtleUNvZGUuRU5URVIgfHwgIWlzZXF1YWwob2xkQ29sdW1uRmlsdGVycywgdGhpcy5fY29sdW1uRmlsdGVycykpIHtcclxuICAgICAgICB0aGlzLl9vblNlYXJjaENoYW5nZS5ub3RpZnkoe1xyXG4gICAgICAgICAgY2xlYXJGaWx0ZXJUcmlnZ2VyZWQ6IGFyZ3MuY2xlYXJGaWx0ZXJUcmlnZ2VyZWQsXHJcbiAgICAgICAgICBzaG91bGRUcmlnZ2VyUXVlcnk6IGFyZ3Muc2hvdWxkVHJpZ2dlclF1ZXJ5LFxyXG4gICAgICAgICAgY29sdW1uSWQsXHJcbiAgICAgICAgICBjb2x1bW5EZWYsXHJcbiAgICAgICAgICBjb2x1bW5GaWx0ZXJzOiB0aGlzLl9jb2x1bW5GaWx0ZXJzLFxyXG4gICAgICAgICAgb3BlcmF0b3IsXHJcbiAgICAgICAgICBzZWFyY2hUZXJtcyxcclxuICAgICAgICAgIGdyaWQ6IHRoaXMuX2dyaWRcclxuICAgICAgICB9LCBldmVudERhdGEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHVwZGF0ZUNvbHVtbkZpbHRlcnMoc2VhcmNoVGVybXM6IFNlYXJjaFRlcm1bXSB8IHVuZGVmaW5lZCwgY29sdW1uRGVmOiBhbnksIG9wZXJhdG9yPzogT3BlcmF0b3JUeXBlIHwgT3BlcmF0b3JTdHJpbmcpIHtcclxuICAgIGlmIChzZWFyY2hUZXJtcyAmJiBjb2x1bW5EZWYpIHtcclxuICAgICAgdGhpcy5fY29sdW1uRmlsdGVyc1tjb2x1bW5EZWYuaWRdID0ge1xyXG4gICAgICAgIGNvbHVtbklkOiBjb2x1bW5EZWYuaWQsXHJcbiAgICAgICAgY29sdW1uRGVmLFxyXG4gICAgICAgIHNlYXJjaFRlcm1zLFxyXG4gICAgICAgIG9wZXJhdG9yXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiJdfQ==