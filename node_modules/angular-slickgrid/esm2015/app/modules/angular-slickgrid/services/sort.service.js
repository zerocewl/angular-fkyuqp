import { isObservable, Subject } from 'rxjs';
import { EmitterType, FieldType, SortDirection, SortDirectionNumber, } from './../models/index';
import { executeBackendCallback, refreshBackendDataset } from './backend-utilities';
import { getDescendantProperty } from './utilities';
import { sortByFieldType } from '../sorters/sorterUtilities';
export class SortService {
    constructor() {
        this._currentLocalSorters = [];
        this._isBackendGrid = false;
        this.httpCancelRequests$ = new Subject(); // this will be used to cancel any pending http request
        this.onSortChanged = new Subject();
        this.onSortCleared = new Subject();
        this._eventHandler = new Slick.EventHandler();
    }
    /** Getter of the SlickGrid Event Handler */
    get eventHandler() {
        return this._eventHandler;
    }
    /** Getter for the Grid Options pulled through the Grid Object */
    get _gridOptions() {
        return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
    }
    /** Getter for the Column Definitions pulled through the Grid Object */
    get _columnDefinitions() {
        return (this._grid && this._grid.getColumns) ? this._grid.getColumns() : [];
    }
    /**
     * Bind a backend sort (single/multi) hook to the grid
     * @param grid SlickGrid Grid object
     * @param dataView SlickGrid DataView object
     */
    bindBackendOnSort(grid, dataView) {
        this._isBackendGrid = true;
        this._grid = grid;
        this._dataView = dataView;
        // subscribe to the SlickGrid event and call the backend execution
        this._eventHandler.subscribe(grid.onSort, this.onBackendSortChanged.bind(this));
    }
    /**
     * Bind a local sort (single/multi) hook to the grid
     * @param grid SlickGrid Grid object
     * @param gridOptions Grid Options object
     * @param dataView
     */
    bindLocalOnSort(grid, dataView) {
        this._isBackendGrid = false;
        this._grid = grid;
        this._dataView = dataView;
        this._eventHandler.subscribe(grid.onSort, (e, args) => {
            if (args && (args.sortCols || args.sortCol)) {
                // multiSort and singleSort are not exactly the same, but we want to structure it the same for the (for loop) after
                // also to avoid having to rewrite the for loop in the sort, we will make the singleSort an array of 1 object
                const sortColumns = (args.multiColumnSort) ? args.sortCols : new Array({ sortAsc: args.sortAsc, sortCol: args.sortCol });
                // keep current sorters
                this._currentLocalSorters = []; // reset current local sorters
                if (Array.isArray(sortColumns)) {
                    sortColumns.forEach((sortColumn) => {
                        if (sortColumn.sortCol) {
                            this._currentLocalSorters.push({
                                columnId: sortColumn.sortCol.id,
                                direction: sortColumn.sortAsc ? SortDirection.ASC : SortDirection.DESC
                            });
                        }
                    });
                }
                this.onLocalSortChanged(grid, dataView, sortColumns);
                this.emitSortChanged(EmitterType.local);
            }
        });
    }
    clearSorting(triggerQueryEvent = true) {
        if (this._grid && this._gridOptions && this._dataView) {
            // remove any sort icons (this setSortColumns function call really does only that)
            this._grid.setSortColumns([]);
            // we also need to trigger a sort change
            // for a backend grid, we will trigger a backend sort changed with an empty sort columns array
            // however for a local grid, we need to pass a sort column and so we will sort by the 1st column
            if (triggerQueryEvent) {
                if (this._isBackendGrid) {
                    this.onBackendSortChanged(undefined, { grid: this._grid, sortCols: [], clearSortTriggered: true });
                }
                else {
                    if (this._columnDefinitions && Array.isArray(this._columnDefinitions)) {
                        this.onLocalSortChanged(this._grid, this._dataView, new Array({ sortAsc: true, sortCol: this._columnDefinitions[0], clearSortTriggered: true }));
                    }
                }
            }
            else if (this._isBackendGrid) {
                const backendService = this._gridOptions && this._gridOptions.backendServiceApi && this._gridOptions.backendServiceApi.service;
                if (backendService && backendService.clearSorters) {
                    backendService.clearSorters();
                }
            }
        }
        // set current sorter to empty & emit a sort changed event
        this._currentLocalSorters = [];
        // emit an event when sorts are all cleared
        this.onSortCleared.next(true);
    }
    dispose() {
        // unsubscribe all SlickGrid events
        if (this._eventHandler && this._eventHandler.unsubscribeAll) {
            this._eventHandler.unsubscribeAll();
        }
        if (isObservable(this.httpCancelRequests$)) {
            this.httpCancelRequests$.next(); // this cancels any pending http requests
        }
    }
    /**
     * A simple function that is binded to the subscriber and emit a change when the sort is called.
     * Other services, like Pagination, can then subscribe to it.
     * @param sender
     */
    emitSortChanged(sender, currentLocalSorters) {
        if (sender === EmitterType.remote && this._gridOptions && this._gridOptions.backendServiceApi) {
            let currentSorters = [];
            const backendService = this._gridOptions.backendServiceApi.service;
            if (backendService && backendService.getCurrentSorters) {
                currentSorters = backendService.getCurrentSorters();
            }
            this.onSortChanged.next(currentSorters);
        }
        else if (sender === EmitterType.local) {
            if (currentLocalSorters) {
                this._currentLocalSorters = currentLocalSorters;
            }
            this.onSortChanged.next(this.getCurrentLocalSorters());
        }
    }
    getCurrentLocalSorters() {
        return this._currentLocalSorters;
    }
    /**
     * Get current column sorts,
     * If a column is passed as an argument, that will be exclusion so we won't add this column to our output array since it is already in the array.
     * The usage of this method is that we want to know the sort prior to calling the next sorting command
     */
    getCurrentColumnSorts(excludedColumnId) {
        // getSortColumns() only returns sortAsc & columnId, we want the entire column definition
        const oldSortColumns = this._grid && this._grid.getSortColumns();
        // get the column definition but only keep column which are not equal to our current column
        if (Array.isArray(oldSortColumns)) {
            const sortedCols = oldSortColumns.reduce((cols, col) => {
                if (!excludedColumnId || col.columnId !== excludedColumnId) {
                    cols.push({ sortCol: this._columnDefinitions[this._grid.getColumnIndex(col.columnId)], sortAsc: col.sortAsc });
                }
                return cols;
            }, []);
            return sortedCols;
        }
        return [];
    }
    /** Load defined Sorting (sorters) into the grid */
    loadGridSorters(sorters) {
        this._currentLocalSorters = []; // reset current local sorters
        const sortCols = [];
        if (Array.isArray(sorters)) {
            sorters.forEach((sorter) => {
                const gridColumn = this._columnDefinitions.find((col) => col.id === sorter.columnId);
                if (gridColumn) {
                    sortCols.push({
                        columnId: gridColumn.id,
                        sortAsc: ((sorter.direction.toUpperCase() === SortDirection.ASC) ? true : false),
                        sortCol: gridColumn
                    });
                    // keep current sorters
                    this._currentLocalSorters.push({
                        columnId: gridColumn.id + '',
                        direction: sorter.direction.toUpperCase()
                    });
                }
            });
        }
        if (sortCols.length > 0) {
            this.onLocalSortChanged(this._grid, this._dataView, sortCols);
            this._grid.setSortColumns(sortCols); // use this to add sort icon(s) in UI
        }
        return sortCols;
    }
    onBackendSortChanged(event, args) {
        if (!args || !args.grid) {
            throw new Error('Something went wrong when trying to bind the "onBackendSortChanged(event, args)" function, it seems that "args" is not populated correctly');
        }
        const gridOptions = (args.grid && args.grid.getOptions) ? args.grid.getOptions() : {};
        const backendApi = gridOptions.backendServiceApi;
        if (!backendApi || !backendApi.process || !backendApi.service) {
            throw new Error(`BackendServiceApi requires at least a "process" function and a "service" defined`);
        }
        // keep start time & end timestamps & return it after process execution
        const startTime = new Date();
        if (backendApi.preProcess) {
            backendApi.preProcess();
        }
        // query backend
        const query = backendApi.service.processOnSortChanged(event, args);
        const totalItems = gridOptions && gridOptions.pagination && gridOptions.pagination.totalItems;
        executeBackendCallback(backendApi, query, args, startTime, totalItems, this.emitSortChanged.bind(this), this.httpCancelRequests$);
    }
    onLocalSortChanged(grid, dataView, sortColumns, forceReSort = false) {
        if (grid && dataView) {
            if (forceReSort) {
                dataView.reSort();
            }
            dataView.sort(this.sortComparer.bind(this, sortColumns));
            grid.invalidate();
            grid.render();
        }
    }
    sortComparer(sortColumns, dataRow1, dataRow2) {
        if (Array.isArray(sortColumns)) {
            for (let i = 0, l = sortColumns.length; i < l; i++) {
                const columnSortObj = sortColumns[i];
                if (columnSortObj && columnSortObj.sortCol) {
                    const sortDirection = columnSortObj.sortAsc ? SortDirectionNumber.asc : SortDirectionNumber.desc;
                    const sortField = columnSortObj.sortCol.queryFieldSorter || columnSortObj.sortCol.queryField || columnSortObj.sortCol.field;
                    const fieldType = columnSortObj.sortCol.type || FieldType.string;
                    let value1 = dataRow1[sortField];
                    let value2 = dataRow2[sortField];
                    // when item is a complex object (dot "." notation), we need to filter the value contained in the object tree
                    if (sortField && sortField.indexOf('.') >= 0) {
                        value1 = getDescendantProperty(dataRow1, sortField);
                        value2 = getDescendantProperty(dataRow2, sortField);
                    }
                    // user could provide his own custom Sorter
                    if (columnSortObj.sortCol && columnSortObj.sortCol.sorter) {
                        const customSortResult = columnSortObj.sortCol.sorter(value1, value2, sortDirection, columnSortObj.sortCol);
                        if (customSortResult !== SortDirectionNumber.neutral) {
                            return customSortResult;
                        }
                    }
                    else {
                        const sortResult = sortByFieldType(fieldType, value1, value2, sortDirection, columnSortObj.sortCol);
                        if (sortResult !== SortDirectionNumber.neutral) {
                            return sortResult;
                        }
                    }
                }
            }
        }
        return SortDirectionNumber.neutral;
    }
    /**
     * Update Sorting (sorters) dynamically just by providing an array of sorter(s).
     * You can also choose emit (default) a Sort Changed event that will be picked by the Grid State Service.
     *
     * Also for backend service only, you can choose to trigger a backend query (default) or not if you wish to do it later,
     * this could be useful when using updateFilters & updateSorting and you wish to only send the backend query once.
     * @param sorters array
     * @param triggerEvent defaults to True, do we want to emit a sort changed event?
     * @param triggerBackendQuery defaults to True, which will query the backend.
     */
    updateSorting(sorters, emitChangedEvent = true, triggerBackendQuery = true) {
        if (!this._gridOptions || !this._gridOptions.enableSorting) {
            throw new Error('[Angular-Slickgrid] in order to use "updateSorting" method, you need to have Sortable Columns defined in your grid and "enableSorting" set in your Grid Options');
        }
        if (Array.isArray(sorters)) {
            const backendApi = this._gridOptions && this._gridOptions.backendServiceApi;
            if (backendApi) {
                const backendApiService = backendApi && backendApi.service;
                if (backendApiService) {
                    backendApiService.updateSorters(undefined, sorters);
                    if (triggerBackendQuery) {
                        refreshBackendDataset(this._gridOptions);
                    }
                }
            }
            else {
                this.loadGridSorters(sorters);
            }
            if (emitChangedEvent) {
                const emitterType = backendApi ? EmitterType.remote : EmitterType.local;
                this.emitSortChanged(emitterType);
            }
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ydC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1zbGlja2dyaWQvIiwic291cmNlcyI6WyJhcHAvbW9kdWxlcy9hbmd1bGFyLXNsaWNrZ3JpZC9zZXJ2aWNlcy9zb3J0LnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFlBQVksRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFFN0MsT0FBTyxFQUlMLFdBQVcsRUFDWCxTQUFTLEVBR1QsYUFBYSxFQUNiLG1CQUFtQixHQUVwQixNQUFNLG1CQUFtQixDQUFDO0FBQzNCLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3BGLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUNwRCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFLN0QsTUFBTSxPQUFPLFdBQVc7SUFVdEI7UUFUUSx5QkFBb0IsR0FBb0IsRUFBRSxDQUFDO1FBSTNDLG1CQUFjLEdBQUcsS0FBSyxDQUFDO1FBQ3ZCLHdCQUFtQixHQUFrQixJQUFJLE9BQU8sRUFBUSxDQUFDLENBQUMsdURBQXVEO1FBQ3pILGtCQUFhLEdBQUcsSUFBSSxPQUFPLEVBQW1CLENBQUM7UUFDL0Msa0JBQWEsR0FBRyxJQUFJLE9BQU8sRUFBVyxDQUFDO1FBR3JDLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxLQUFLLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDaEQsQ0FBQztJQUVELDRDQUE0QztJQUM1QyxJQUFJLFlBQVk7UUFDZCxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUM7SUFDNUIsQ0FBQztJQUVELGlFQUFpRTtJQUNqRSxJQUFZLFlBQVk7UUFDdEIsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFD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LGlCQUFpQixFQUFFO29CQUNyQixpQkFBaUIsQ0FBQyxhQUFhLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO29CQUNwRCxJQUFJLG1CQUFtQixFQUFFO3dCQUN2QixxQkFBcUIsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7cUJBQzFDO2lCQUNGO2FBQ0Y7aUJBQU07Z0JBQ0wsSUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQzthQUMvQjtZQUVELElBQUksZ0JBQWdCLEVBQUU7Z0JBQ3BCLE1BQU0sV0FBVyxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQztnQkFDeEUsSUFBSSxDQUFDLGVBQWUsQ0FBQyxXQUFXLENBQUMsQ0FBQzthQUNuQztTQUNGO0lBQ0gsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XHJcblxyXG5pbXBvcnQge1xyXG4gIENvbHVtbixcclxuICBDb2x1bW5Tb3J0LFxyXG4gIEN1cnJlbnRTb3J0ZXIsXHJcbiAgRW1pdHRlclR5cGUsXHJcbiAgRmllbGRUeXBlLFxyXG4gIEdyaWRPcHRpb24sXHJcbiAgU2xpY2tFdmVudEhhbmRsZXIsXHJcbiAgU29ydERpcmVjdGlvbixcclxuICBTb3J0RGlyZWN0aW9uTnVtYmVyLFxyXG4gIFNvcnREaXJlY3Rpb25TdHJpbmcsXHJcbn0gZnJvbSAnLi8uLi9tb2RlbHMvaW5kZXgnO1xyXG5pbXBvcnQgeyBleGVjdXRlQmFja2VuZENhbGxiYWNrLCByZWZyZXNoQmFja2VuZERhdGFzZXQgfSBmcm9tICcuL2JhY2tlbmQtdXRpbGl0aWVzJztcclxuaW1wb3J0IHsgZ2V0RGVzY2VuZGFudFByb3BlcnR5IH0gZnJvbSAnLi91dGlsaXRpZXMnO1xyXG5pbXBvcnQgeyBzb3J0QnlGaWVsZFR5cGUgfSBmcm9tICcuLi9zb3J0ZXJzL3NvcnRlclV0aWxpdGllcyc7XHJcblxyXG4vLyB1c2luZyBleHRlcm5hbCBub24tdHlwZWQganMgbGlicmFyaWVzXHJcbmRlY2xhcmUgdmFyIFNsaWNrOiBhbnk7XHJcblxyXG5leHBvcnQgY2xhc3MgU29ydFNlcnZpY2Uge1xyXG4gIHByaXZhdGUgX2N1cnJlbnRMb2NhbFNvcnRlcnM6IEN1cnJlbnRTb3J0ZXJbXSA9IFtdO1xyXG4gIHByaXZhdGUgX2V2ZW50SGFuZGxlcjogU2xpY2tFdmVudEhhbmRsZXI7XHJcbiAgcHJpdmF0ZSBfZGF0YVZpZXc6IGFueTtcclxuICBwcml2YXRlIF9ncmlkOiBhbnk7XHJcbiAgcHJpdmF0ZSBfaXNCYWNrZW5kR3JpZCA9IGZhbHNlO1xyXG4gIHByaXZhdGUgaHR0cENhbmNlbFJlcXVlc3RzJDogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7IC8vIHRoaXMgd2lsbCBiZSB1c2VkIHRvIGNhbmNlbCBhbnkgcGVuZGluZyBodHRwIHJlcXVlc3RcclxuICBvblNvcnRDaGFuZ2VkID0gbmV3IFN1YmplY3Q8Q3VycmVudFNvcnRlcltdPigpO1xyXG4gIG9uU29ydENsZWFyZWQgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuX2V2ZW50SGFuZGxlciA9IG5ldyBTbGljay5FdmVudEhhbmRsZXIoKTtcclxuICB9XHJcblxyXG4gIC8qKiBHZXR0ZXIgb2YgdGhlIFNsaWNrR3JpZCBFdmVudCBIYW5kbGVyICovXHJcbiAgZ2V0IGV2ZW50SGFuZGxlcigpOiBTbGlja0V2ZW50SGFuZGxlciB7XHJcbiAgICByZXR1cm4gdGhpcy5fZXZlbnRIYW5kbGVyO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBmb3IgdGhlIEdyaWQgT3B0aW9ucyBwdWxsZWQgdGhyb3VnaCB0aGUgR3JpZCBPYmplY3QgKi9cclxuICBwcml2YXRlIGdldCBfZ3JpZE9wdGlvbnMoKTogR3JpZE9wdGlvbiB7XHJcbiAgICByZXR1cm4gKHRoaXMuX2dyaWQgJiYgdGhpcy5fZ3JpZC5nZXRPcHRpb25zKSA/IHRoaXMuX2dyaWQuZ2V0T3B0aW9ucygpIDoge307XHJcbiAgfVxyXG5cclxuICAvKiogR2V0dGVyIGZvciB0aGUgQ29sdW1uIERlZmluaXRpb25zIHB1bGxlZCB0aHJvdWdoIHRoZSBHcmlkIE9iamVjdCAqL1xyXG4gIHByaXZhdGUgZ2V0IF9jb2x1bW5EZWZpbml0aW9ucygpOiBDb2x1bW5bXSB7XHJcbiAgICByZXR1cm4gKHRoaXMuX2dyaWQgJiYgdGhpcy5fZ3JpZC5nZXRDb2x1bW5zKSA/IHRoaXMuX2dyaWQuZ2V0Q29sdW1ucygpIDogW107XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCaW5kIGEgYmFja2VuZCBzb3J0IChzaW5nbGUvbXVsdGkpIGhvb2sgdG8gdGhlIGdyaWRcclxuICAgKiBAcGFyYW0gZ3JpZCBTbGlja0dyaWQgR3JpZCBvYmplY3RcclxuICAgKiBAcGFyYW0gZGF0YVZpZXcgU2xpY2tHcmlkIERhdGFWaWV3IG9iamVjdFxyXG4gICAqL1xyXG4gIGJpbmRCYWNrZW5kT25Tb3J0KGdyaWQ6IGFueSwgZGF0YVZpZXc6IGFueSkge1xyXG4gICAgdGhpcy5faXNCYWNrZW5kR3JpZCA9IHRydWU7XHJcbiAgICB0aGlzLl9ncmlkID0gZ3JpZDtcclxuICAgIHRoaXMuX2RhdGFWaWV3ID0gZGF0YVZpZXc7XHJcblxyXG4gICAgLy8gc3Vic2NyaWJlIHRvIHRoZSBTbGlja0dyaWQgZXZlbnQgYW5kIGNhbGwgdGhlIGJhY2tlbmQgZXhlY3V0aW9uXHJcbiAgICB0aGlzLl9ldmVudEhhbmRsZXIuc3Vic2NyaWJlKGdyaWQub25Tb3J0LCB0aGlzLm9uQmFja2VuZFNvcnRDaGFuZ2VkLmJpbmQodGhpcykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQmluZCBhIGxvY2FsIHNvcnQgKHNpbmdsZS9tdWx0aSkgaG9vayB0byB0aGUgZ3JpZFxyXG4gICAqIEBwYXJhbSBncmlkIFNsaWNrR3JpZCBHcmlkIG9iamVjdFxyXG4gICAqIEBwYXJhbSBncmlkT3B0aW9ucyBHcmlkIE9wdGlvbnMgb2JqZWN0XHJcbiAgICogQHBhcmFtIGRhdGFWaWV3XHJcbiAgICovXHJcbiAgYmluZExvY2FsT25Tb3J0KGdyaWQ6IGFueSwgZGF0YVZpZXc6IGFueSkge1xyXG4gICAgdGhpcy5faXNCYWNrZW5kR3JpZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fZ3JpZCA9IGdyaWQ7XHJcbiAgICB0aGlzLl9kYXRhVmlldyA9IGRhdGFWaWV3O1xyXG5cclxuICAgIHRoaXMuX2V2ZW50SGFuZGxlci5zdWJzY3JpYmUoZ3JpZC5vblNvcnQsIChlOiBhbnksIGFyZ3M6IGFueSkgPT4ge1xyXG4gICAgICBpZiAoYXJncyAmJiAoYXJncy5zb3J0Q29scyB8fCBhcmdzLnNvcnRDb2wpKSB7XHJcbiAgICAgICAgLy8gbXVsdGlTb3J0IGFuZCBzaW5nbGVTb3J0IGFyZSBub3QgZXhhY3RseSB0aGUgc2FtZSwgYnV0IHdlIHdhbnQgdG8gc3RydWN0dXJlIGl0IHRoZSBzYW1lIGZvciB0aGUgKGZvciBsb29wKSBhZnRlclxyXG4gICAgICAgIC8vIGFsc28gdG8gYXZvaWQgaGF2aW5nIHRvIHJld3JpdGUgdGhlIGZvciBsb29wIGluIHRoZSBzb3J0LCB3ZSB3aWxsIG1ha2UgdGhlIHNpbmdsZVNvcnQgYW4gYXJyYXkgb2YgMSBvYmplY3RcclxuICAgICAgICBjb25zdCBzb3J0Q29sdW1ucyA9IChhcmdzLm11bHRpQ29sdW1uU29ydCkgPyBhcmdzLnNvcnRDb2xzIDogbmV3IEFycmF5KHsgc29ydEFzYzogYXJncy5zb3J0QXNjLCBzb3J0Q29sOiBhcmdzLnNvcnRDb2wgfSk7XHJcblxyXG4gICAgICAgIC8vIGtlZXAgY3VycmVudCBzb3J0ZXJzXHJcbiAgICAgICAgdGhpcy5fY3VycmVudExvY2FsU29ydGVycyA9IFtdOyAvLyByZXNldCBjdXJyZW50IGxvY2FsIHNvcnRlcnNcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzb3J0Q29sdW1ucykpIHtcclxuICAgICAgICAgIHNvcnRDb2x1bW5zLmZvckVhY2goKHNvcnRDb2x1bW46IHsgc29ydENvbDogQ29sdW1uLCBzb3J0QXNjOiBib29sZWFuIH0pID0+IHtcclxuICAgICAgICAgICAgaWYgKHNvcnRDb2x1bW4uc29ydENvbCkge1xyXG4gICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMb2NhbFNvcnRlcnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW5JZDogc29ydENvbHVtbi5zb3J0Q29sLmlkLFxyXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBzb3J0Q29sdW1uLnNvcnRBc2MgPyBTb3J0RGlyZWN0aW9uLkFTQyA6IFNvcnREaXJlY3Rpb24uREVTQ1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMub25Mb2NhbFNvcnRDaGFuZ2VkKGdyaWQsIGRhdGFWaWV3LCBzb3J0Q29sdW1ucyk7XHJcbiAgICAgICAgdGhpcy5lbWl0U29ydENoYW5nZWQoRW1pdHRlclR5cGUubG9jYWwpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGNsZWFyU29ydGluZyh0cmlnZ2VyUXVlcnlFdmVudCA9IHRydWUpIHtcclxuICAgIGlmICh0aGlzLl9ncmlkICYmIHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2RhdGFWaWV3KSB7XHJcbiAgICAgIC8vIHJlbW92ZSBhbnkgc29ydCBpY29ucyAodGhpcyBzZXRTb3J0Q29sdW1ucyBmdW5jdGlvbiBjYWxsIHJlYWxseSBkb2VzIG9ubHkgdGhhdClcclxuICAgICAgdGhpcy5fZ3JpZC5zZXRTb3J0Q29sdW1ucyhbXSk7XHJcblxyXG4gICAgICAvLyB3ZSBhbHNvIG5lZWQgdG8gdHJpZ2dlciBhIHNvcnQgY2hhbmdlXHJcbiAgICAgIC8vIGZvciBhIGJhY2tlbmQgZ3JpZCwgd2Ugd2lsbCB0cmlnZ2VyIGEgYmFja2VuZCBzb3J0IGNoYW5nZWQgd2l0aCBhbiBlbXB0eSBzb3J0IGNvbHVtbnMgYXJyYXlcclxuICAgICAgLy8gaG93ZXZlciBmb3IgYSBsb2NhbCBncmlkLCB3ZSBuZWVkIHRvIHBhc3MgYSBzb3J0IGNvbHVtbiBhbmQgc28gd2Ugd2lsbCBzb3J0IGJ5IHRoZSAxc3QgY29sdW1uXHJcbiAgICAgIGlmICh0cmlnZ2VyUXVlcnlFdmVudCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9pc0JhY2tlbmRHcmlkKSB7XHJcbiAgICAgICAgICB0aGlzLm9uQmFja2VuZFNvcnRDaGFuZ2VkKHVuZGVmaW5lZCwgeyBncmlkOiB0aGlzLl9ncmlkLCBzb3J0Q29sczogW10sIGNsZWFyU29ydFRyaWdnZXJlZDogdHJ1ZSB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKHRoaXMuX2NvbHVtbkRlZmluaXRpb25zICYmIEFycmF5LmlzQXJyYXkodGhpcy5fY29sdW1uRGVmaW5pdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25Mb2NhbFNvcnRDaGFuZ2VkKHRoaXMuX2dyaWQsIHRoaXMuX2RhdGFWaWV3LCBuZXcgQXJyYXkoeyBzb3J0QXNjOiB0cnVlLCBzb3J0Q29sOiB0aGlzLl9jb2x1bW5EZWZpbml0aW9uc1swXSwgY2xlYXJTb3J0VHJpZ2dlcmVkOiB0cnVlIH0pKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5faXNCYWNrZW5kR3JpZCkge1xyXG4gICAgICAgIGNvbnN0IGJhY2tlbmRTZXJ2aWNlID0gdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuYmFja2VuZFNlcnZpY2VBcGkgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuYmFja2VuZFNlcnZpY2VBcGkuc2VydmljZTtcclxuICAgICAgICBpZiAoYmFja2VuZFNlcnZpY2UgJiYgYmFja2VuZFNlcnZpY2UuY2xlYXJTb3J0ZXJzKSB7XHJcbiAgICAgICAgICBiYWNrZW5kU2VydmljZS5jbGVhclNvcnRlcnMoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBzZXQgY3VycmVudCBzb3J0ZXIgdG8gZW1wdHkgJiBlbWl0IGEgc29ydCBjaGFuZ2VkIGV2ZW50XHJcbiAgICB0aGlzLl9jdXJyZW50TG9jYWxTb3J0ZXJzID0gW107XHJcblxyXG4gICAgLy8gZW1pdCBhbiBldmVudCB3aGVuIHNvcnRzIGFyZSBhbGwgY2xlYXJlZFxyXG4gICAgdGhpcy5vblNvcnRDbGVhcmVkLm5leHQodHJ1ZSk7XHJcbiAgfVxyXG5cclxuICBkaXNwb3NlKCkge1xyXG4gICAgLy8gdW5zdWJzY3JpYmUgYWxsIFNsaWNrR3JpZCBldmVudHNcclxuICAgIGlmICh0aGlzLl9ldmVudEhhbmRsZXIgJiYgdGhpcy5fZXZlbnRIYW5kbGVyLnVuc3Vic2NyaWJlQWxsKSB7XHJcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlci51bnN1YnNjcmliZUFsbCgpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzT2JzZXJ2YWJsZSh0aGlzLmh0dHBDYW5jZWxSZXF1ZXN0cyQpKSB7XHJcbiAgICAgIHRoaXMuaHR0cENhbmNlbFJlcXVlc3RzJC5uZXh0KCk7IC8vIHRoaXMgY2FuY2VscyBhbnkgcGVuZGluZyBodHRwIHJlcXVlc3RzXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIHNpbXBsZSBmdW5jdGlvbiB0aGF0IGlzIGJpbmRlZCB0byB0aGUgc3Vic2NyaWJlciBhbmQgZW1pdCBhIGNoYW5nZSB3aGVuIHRoZSBzb3J0IGlzIGNhbGxlZC5cclxuICAgKiBPdGhlciBzZXJ2aWNlcywgbGlrZSBQYWdpbmF0aW9uLCBjYW4gdGhlbiBzdWJzY3JpYmUgdG8gaXQuXHJcbiAgICogQHBhcmFtIHNlbmRlclxyXG4gICAqL1xyXG4gIGVtaXRTb3J0Q2hhbmdlZChzZW5kZXI6IEVtaXR0ZXJUeXBlLCBjdXJyZW50TG9jYWxTb3J0ZXJzPzogQ3VycmVudFNvcnRlcltdKSB7XHJcbiAgICBpZiAoc2VuZGVyID09PSBFbWl0dGVyVHlwZS5yZW1vdGUgJiYgdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuYmFja2VuZFNlcnZpY2VBcGkpIHtcclxuICAgICAgbGV0IGN1cnJlbnRTb3J0ZXJzOiBDdXJyZW50U29ydGVyW10gPSBbXTtcclxuICAgICAgY29uc3QgYmFja2VuZFNlcnZpY2UgPSB0aGlzLl9ncmlkT3B0aW9ucy5iYWNrZW5kU2VydmljZUFwaS5zZXJ2aWNlO1xyXG4gICAgICBpZiAoYmFja2VuZFNlcnZpY2UgJiYgYmFja2VuZFNlcnZpY2UuZ2V0Q3VycmVudFNvcnRlcnMpIHtcclxuICAgICAgICBjdXJyZW50U29ydGVycyA9IGJhY2tlbmRTZXJ2aWNlLmdldEN1cnJlbnRTb3J0ZXJzKCkgYXMgQ3VycmVudFNvcnRlcltdO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMub25Tb3J0Q2hhbmdlZC5uZXh0KGN1cnJlbnRTb3J0ZXJzKTtcclxuICAgIH0gZWxzZSBpZiAoc2VuZGVyID09PSBFbWl0dGVyVHlwZS5sb2NhbCkge1xyXG4gICAgICBpZiAoY3VycmVudExvY2FsU29ydGVycykge1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRMb2NhbFNvcnRlcnMgPSBjdXJyZW50TG9jYWxTb3J0ZXJzO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMub25Tb3J0Q2hhbmdlZC5uZXh0KHRoaXMuZ2V0Q3VycmVudExvY2FsU29ydGVycygpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldEN1cnJlbnRMb2NhbFNvcnRlcnMoKTogQ3VycmVudFNvcnRlcltdIHtcclxuICAgIHJldHVybiB0aGlzLl9jdXJyZW50TG9jYWxTb3J0ZXJzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGN1cnJlbnQgY29sdW1uIHNvcnRzLFxyXG4gICAqIElmIGEgY29sdW1uIGlzIHBhc3NlZCBhcyBhbiBhcmd1bWVudCwgdGhhdCB3aWxsIGJlIGV4Y2x1c2lvbiBzbyB3ZSB3b24ndCBhZGQgdGhpcyBjb2x1bW4gdG8gb3VyIG91dHB1dCBhcnJheSBzaW5jZSBpdCBpcyBhbHJlYWR5IGluIHRoZSBhcnJheS5cclxuICAgKiBUaGUgdXNhZ2Ugb2YgdGhpcyBtZXRob2QgaXMgdGhhdCB3ZSB3YW50IHRvIGtub3cgdGhlIHNvcnQgcHJpb3IgdG8gY2FsbGluZyB0aGUgbmV4dCBzb3J0aW5nIGNvbW1hbmRcclxuICAgKi9cclxuICBnZXRDdXJyZW50Q29sdW1uU29ydHMoZXhjbHVkZWRDb2x1bW5JZD86IHN0cmluZykge1xyXG4gICAgLy8gZ2V0U29ydENvbHVtbnMoKSBvbmx5IHJldHVybnMgc29ydEFzYyAmIGNvbHVtbklkLCB3ZSB3YW50IHRoZSBlbnRpcmUgY29sdW1uIGRlZmluaXRpb25cclxuICAgIGNvbnN0IG9sZFNvcnRDb2x1bW5zID0gdGhpcy5fZ3JpZCAmJiB0aGlzLl9ncmlkLmdldFNvcnRDb2x1bW5zKCk7XHJcblxyXG4gICAgLy8gZ2V0IHRoZSBjb2x1bW4gZGVmaW5pdGlvbiBidXQgb25seSBrZWVwIGNvbHVtbiB3aGljaCBhcmUgbm90IGVxdWFsIHRvIG91ciBjdXJyZW50IGNvbHVtblxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2xkU29ydENvbHVtbnMpKSB7XHJcbiAgICAgIGNvbnN0IHNvcnRlZENvbHMgPSBvbGRTb3J0Q29sdW1ucy5yZWR1Y2UoKGNvbHMsIGNvbCkgPT4ge1xyXG4gICAgICAgIGlmICghZXhjbHVkZWRDb2x1bW5JZCB8fCBjb2wuY29sdW1uSWQgIT09IGV4Y2x1ZGVkQ29sdW1uSWQpIHtcclxuICAgICAgICAgIGNvbHMucHVzaCh7IHNvcnRDb2w6IHRoaXMuX2NvbHVtbkRlZmluaXRpb25zW3RoaXMuX2dyaWQuZ2V0Q29sdW1uSW5kZXgoY29sLmNvbHVtbklkKV0sIHNvcnRBc2M6IGNvbC5zb3J0QXNjIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29scztcclxuICAgICAgfSwgW10pO1xyXG5cclxuICAgICAgcmV0dXJuIHNvcnRlZENvbHM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG5cclxuICAvKiogTG9hZCBkZWZpbmVkIFNvcnRpbmcgKHNvcnRlcnMpIGludG8gdGhlIGdyaWQgKi9cclxuICBsb2FkR3JpZFNvcnRlcnMoc29ydGVyczogQ3VycmVudFNvcnRlcltdKTogQ29sdW1uU29ydFtdIHtcclxuICAgIHRoaXMuX2N1cnJlbnRMb2NhbFNvcnRlcnMgPSBbXTsgLy8gcmVzZXQgY3VycmVudCBsb2NhbCBzb3J0ZXJzXHJcbiAgICBjb25zdCBzb3J0Q29sczogQ29sdW1uU29ydFtdID0gW107XHJcblxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc29ydGVycykpIHtcclxuICAgICAgc29ydGVycy5mb3JFYWNoKChzb3J0ZXI6IEN1cnJlbnRTb3J0ZXIpID0+IHtcclxuICAgICAgICBjb25zdCBncmlkQ29sdW1uID0gdGhpcy5fY29sdW1uRGVmaW5pdGlvbnMuZmluZCgoY29sOiBDb2x1bW4pID0+IGNvbC5pZCA9PT0gc29ydGVyLmNvbHVtbklkKTtcclxuICAgICAgICBpZiAoZ3JpZENvbHVtbikge1xyXG4gICAgICAgICAgc29ydENvbHMucHVzaCh7XHJcbiAgICAgICAgICAgIGNvbHVtbklkOiBncmlkQ29sdW1uLmlkLFxyXG4gICAgICAgICAgICBzb3J0QXNjOiAoKHNvcnRlci5kaXJlY3Rpb24udG9VcHBlckNhc2UoKSA9PT0gU29ydERpcmVjdGlvbi5BU0MpID8gdHJ1ZSA6IGZhbHNlKSxcclxuICAgICAgICAgICAgc29ydENvbDogZ3JpZENvbHVtblxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgLy8ga2VlcCBjdXJyZW50IHNvcnRlcnNcclxuICAgICAgICAgIHRoaXMuX2N1cnJlbnRMb2NhbFNvcnRlcnMucHVzaCh7XHJcbiAgICAgICAgICAgIGNvbHVtbklkOiBncmlkQ29sdW1uLmlkICsgJycsXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbjogc29ydGVyLmRpcmVjdGlvbi50b1VwcGVyQ2FzZSgpIGFzIFNvcnREaXJlY3Rpb25TdHJpbmdcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNvcnRDb2xzLmxlbmd0aCA+IDApIHtcclxuICAgICAgdGhpcy5vbkxvY2FsU29ydENoYW5nZWQodGhpcy5fZ3JpZCwgdGhpcy5fZGF0YVZpZXcsIHNvcnRDb2xzKTtcclxuICAgICAgdGhpcy5fZ3JpZC5zZXRTb3J0Q29sdW1ucyhzb3J0Q29scyk7IC8vIHVzZSB0aGlzIHRvIGFkZCBzb3J0IGljb24ocykgaW4gVUlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc29ydENvbHM7XHJcbiAgfVxyXG5cclxuICBvbkJhY2tlbmRTb3J0Q2hhbmdlZChldmVudDogRXZlbnQsIGFyZ3M6IHsgbXVsdGlDb2x1bW5Tb3J0PzogYm9vbGVhbjsgZ3JpZDogYW55OyBzb3J0Q29sczogQ29sdW1uU29ydFtdOyBjbGVhclNvcnRUcmlnZ2VyZWQ/OiBib29sZWFuIH0pIHtcclxuICAgIGlmICghYXJncyB8fCAhYXJncy5ncmlkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignU29tZXRoaW5nIHdlbnQgd3Jvbmcgd2hlbiB0cnlpbmcgdG8gYmluZCB0aGUgXCJvbkJhY2tlbmRTb3J0Q2hhbmdlZChldmVudCwgYXJncylcIiBmdW5jdGlvbiwgaXQgc2VlbXMgdGhhdCBcImFyZ3NcIiBpcyBub3QgcG9wdWxhdGVkIGNvcnJlY3RseScpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZ3JpZE9wdGlvbnM6IEdyaWRPcHRpb24gPSAoYXJncy5ncmlkICYmIGFyZ3MuZ3JpZC5nZXRPcHRpb25zKSA/IGFyZ3MuZ3JpZC5nZXRPcHRpb25zKCkgOiB7fTtcclxuICAgIGNvbnN0IGJhY2tlbmRBcGkgPSBncmlkT3B0aW9ucy5iYWNrZW5kU2VydmljZUFwaTtcclxuXHJcbiAgICBpZiAoIWJhY2tlbmRBcGkgfHwgIWJhY2tlbmRBcGkucHJvY2VzcyB8fCAhYmFja2VuZEFwaS5zZXJ2aWNlKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQmFja2VuZFNlcnZpY2VBcGkgcmVxdWlyZXMgYXQgbGVhc3QgYSBcInByb2Nlc3NcIiBmdW5jdGlvbiBhbmQgYSBcInNlcnZpY2VcIiBkZWZpbmVkYCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8ga2VlcCBzdGFydCB0aW1lICYgZW5kIHRpbWVzdGFtcHMgJiByZXR1cm4gaXQgYWZ0ZXIgcHJvY2VzcyBleGVjdXRpb25cclxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XHJcblxyXG4gICAgaWYgKGJhY2tlbmRBcGkucHJlUHJvY2Vzcykge1xyXG4gICAgICBiYWNrZW5kQXBpLnByZVByb2Nlc3MoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBxdWVyeSBiYWNrZW5kXHJcbiAgICBjb25zdCBxdWVyeSA9IGJhY2tlbmRBcGkuc2VydmljZS5wcm9jZXNzT25Tb3J0Q2hhbmdlZChldmVudCwgYXJncyk7XHJcbiAgICBjb25zdCB0b3RhbEl0ZW1zID0gZ3JpZE9wdGlvbnMgJiYgZ3JpZE9wdGlvbnMucGFnaW5hdGlvbiAmJiBncmlkT3B0aW9ucy5wYWdpbmF0aW9uLnRvdGFsSXRlbXM7XHJcbiAgICBleGVjdXRlQmFja2VuZENhbGxiYWNrKGJhY2tlbmRBcGksIHF1ZXJ5LCBhcmdzLCBzdGFydFRpbWUsIHRvdGFsSXRlbXMsIHRoaXMuZW1pdFNvcnRDaGFuZ2VkLmJpbmQodGhpcyksIHRoaXMuaHR0cENhbmNlbFJlcXVlc3RzJCk7XHJcbiAgfVxyXG5cclxuICBvbkxvY2FsU29ydENoYW5nZWQoZ3JpZDogYW55LCBkYXRhVmlldzogYW55LCBzb3J0Q29sdW1uczogQ29sdW1uU29ydFtdLCBmb3JjZVJlU29ydCA9IGZhbHNlKSB7XHJcbiAgICBpZiAoZ3JpZCAmJiBkYXRhVmlldykge1xyXG4gICAgICBpZiAoZm9yY2VSZVNvcnQpIHtcclxuICAgICAgICBkYXRhVmlldy5yZVNvcnQoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZGF0YVZpZXcuc29ydCh0aGlzLnNvcnRDb21wYXJlci5iaW5kKHRoaXMsIHNvcnRDb2x1bW5zKSk7XHJcblxyXG4gICAgICBncmlkLmludmFsaWRhdGUoKTtcclxuICAgICAgZ3JpZC5yZW5kZXIoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNvcnRDb21wYXJlcihzb3J0Q29sdW1uczogQ29sdW1uU29ydFtdLCBkYXRhUm93MTogYW55LCBkYXRhUm93MjogYW55KSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzb3J0Q29sdW1ucykpIHtcclxuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBzb3J0Q29sdW1ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjb2x1bW5Tb3J0T2JqID0gc29ydENvbHVtbnNbaV07XHJcbiAgICAgICAgaWYgKGNvbHVtblNvcnRPYmogJiYgY29sdW1uU29ydE9iai5zb3J0Q29sKSB7XHJcbiAgICAgICAgICBjb25zdCBzb3J0RGlyZWN0aW9uID0gY29sdW1uU29ydE9iai5zb3J0QXNjID8gU29ydERpcmVjdGlvbk51bWJlci5hc2MgOiBTb3J0RGlyZWN0aW9uTnVtYmVyLmRlc2M7XHJcbiAgICAgICAgICBjb25zdCBzb3J0RmllbGQgPSBjb2x1bW5Tb3J0T2JqLnNvcnRDb2wucXVlcnlGaWVsZFNvcnRlciB8fCBjb2x1bW5Tb3J0T2JqLnNvcnRDb2wucXVlcnlGaWVsZCB8fCBjb2x1bW5Tb3J0T2JqLnNvcnRDb2wuZmllbGQ7XHJcbiAgICAgICAgICBjb25zdCBmaWVsZFR5cGUgPSBjb2x1bW5Tb3J0T2JqLnNvcnRDb2wudHlwZSB8fCBGaWVsZFR5cGUuc3RyaW5nO1xyXG4gICAgICAgICAgbGV0IHZhbHVlMSA9IGRhdGFSb3cxW3NvcnRGaWVsZF07XHJcbiAgICAgICAgICBsZXQgdmFsdWUyID0gZGF0YVJvdzJbc29ydEZpZWxkXTtcclxuXHJcbiAgICAgICAgICAvLyB3aGVuIGl0ZW0gaXMgYSBjb21wbGV4IG9iamVjdCAoZG90IFwiLlwiIG5vdGF0aW9uKSwgd2UgbmVlZCB0byBmaWx0ZXIgdGhlIHZhbHVlIGNvbnRhaW5lZCBpbiB0aGUgb2JqZWN0IHRyZWVcclxuICAgICAgICAgIGlmIChzb3J0RmllbGQgJiYgc29ydEZpZWxkLmluZGV4T2YoJy4nKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHZhbHVlMSA9IGdldERlc2NlbmRhbnRQcm9wZXJ0eShkYXRhUm93MSwgc29ydEZpZWxkKTtcclxuICAgICAgICAgICAgdmFsdWUyID0gZ2V0RGVzY2VuZGFudFByb3BlcnR5KGRhdGFSb3cyLCBzb3J0RmllbGQpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIHVzZXIgY291bGQgcHJvdmlkZSBoaXMgb3duIGN1c3RvbSBTb3J0ZXJcclxuICAgICAgICAgIGlmIChjb2x1bW5Tb3J0T2JqLnNvcnRDb2wgJiYgY29sdW1uU29ydE9iai5zb3J0Q29sLnNvcnRlcikge1xyXG4gICAgICAgICAgICBjb25zdCBjdXN0b21Tb3J0UmVzdWx0ID0gY29sdW1uU29ydE9iai5zb3J0Q29sLnNvcnRlcih2YWx1ZTEsIHZhbHVlMiwgc29ydERpcmVjdGlvbiwgY29sdW1uU29ydE9iai5zb3J0Q29sKTtcclxuICAgICAgICAgICAgaWYgKGN1c3RvbVNvcnRSZXN1bHQgIT09IFNvcnREaXJlY3Rpb25OdW1iZXIubmV1dHJhbCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBjdXN0b21Tb3J0UmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzb3J0UmVzdWx0ID0gc29ydEJ5RmllbGRUeXBlKGZpZWxkVHlwZSwgdmFsdWUxLCB2YWx1ZTIsIHNvcnREaXJlY3Rpb24sIGNvbHVtblNvcnRPYmouc29ydENvbCk7XHJcbiAgICAgICAgICAgIGlmIChzb3J0UmVzdWx0ICE9PSBTb3J0RGlyZWN0aW9uTnVtYmVyLm5ldXRyYWwpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gc29ydFJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFNvcnREaXJlY3Rpb25OdW1iZXIubmV1dHJhbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBTb3J0aW5nIChzb3J0ZXJzKSBkeW5hbWljYWxseSBqdXN0IGJ5IHByb3ZpZGluZyBhbiBhcnJheSBvZiBzb3J0ZXIocykuXHJcbiAgICogWW91IGNhbiBhbHNvIGNob29zZSBlbWl0IChkZWZhdWx0KSBhIFNvcnQgQ2hhbmdlZCBldmVudCB0aGF0IHdpbGwgYmUgcGlja2VkIGJ5IHRoZSBHcmlkIFN0YXRlIFNlcnZpY2UuXHJcbiAgICpcclxuICAgKiBBbHNvIGZvciBiYWNrZW5kIHNlcnZpY2Ugb25seSwgeW91IGNhbiBjaG9vc2UgdG8gdHJpZ2dlciBhIGJhY2tlbmQgcXVlcnkgKGRlZmF1bHQpIG9yIG5vdCBpZiB5b3Ugd2lzaCB0byBkbyBpdCBsYXRlcixcclxuICAgKiB0aGlzIGNvdWxkIGJlIHVzZWZ1bCB3aGVuIHVzaW5nIHVwZGF0ZUZpbHRlcnMgJiB1cGRhdGVTb3J0aW5nIGFuZCB5b3Ugd2lzaCB0byBvbmx5IHNlbmQgdGhlIGJhY2tlbmQgcXVlcnkgb25jZS5cclxuICAgKiBAcGFyYW0gc29ydGVycyBhcnJheVxyXG4gICAqIEBwYXJhbSB0cmlnZ2VyRXZlbnQgZGVmYXVsdHMgdG8gVHJ1ZSwgZG8gd2Ugd2FudCB0byBlbWl0IGEgc29ydCBjaGFuZ2VkIGV2ZW50P1xyXG4gICAqIEBwYXJhbSB0cmlnZ2VyQmFja2VuZFF1ZXJ5IGRlZmF1bHRzIHRvIFRydWUsIHdoaWNoIHdpbGwgcXVlcnkgdGhlIGJhY2tlbmQuXHJcbiAgICovXHJcbiAgdXBkYXRlU29ydGluZyhzb3J0ZXJzOiBDdXJyZW50U29ydGVyW10sIGVtaXRDaGFuZ2VkRXZlbnQgPSB0cnVlLCB0cmlnZ2VyQmFja2VuZFF1ZXJ5ID0gdHJ1ZSkge1xyXG4gICAgaWYgKCF0aGlzLl9ncmlkT3B0aW9ucyB8fCAhdGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlU29ydGluZykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tBbmd1bGFyLVNsaWNrZ3JpZF0gaW4gb3JkZXIgdG8gdXNlIFwidXBkYXRlU29ydGluZ1wiIG1ldGhvZCwgeW91IG5lZWQgdG8gaGF2ZSBTb3J0YWJsZSBDb2x1bW5zIGRlZmluZWQgaW4geW91ciBncmlkIGFuZCBcImVuYWJsZVNvcnRpbmdcIiBzZXQgaW4geW91ciBHcmlkIE9wdGlvbnMnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzb3J0ZXJzKSkge1xyXG4gICAgICBjb25zdCBiYWNrZW5kQXBpID0gdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuYmFja2VuZFNlcnZpY2VBcGk7XHJcblxyXG4gICAgICBpZiAoYmFja2VuZEFwaSkge1xyXG4gICAgICAgIGNvbnN0IGJhY2tlbmRBcGlTZXJ2aWNlID0gYmFja2VuZEFwaSAmJiBiYWNrZW5kQXBpLnNlcnZpY2U7XHJcbiAgICAgICAgaWYgKGJhY2tlbmRBcGlTZXJ2aWNlKSB7XHJcbiAgICAgICAgICBiYWNrZW5kQXBpU2VydmljZS51cGRhdGVTb3J0ZXJzKHVuZGVmaW5lZCwgc29ydGVycyk7XHJcbiAgICAgICAgICBpZiAodHJpZ2dlckJhY2tlbmRRdWVyeSkge1xyXG4gICAgICAgICAgICByZWZyZXNoQmFja2VuZERhdGFzZXQodGhpcy5fZ3JpZE9wdGlvbnMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmxvYWRHcmlkU29ydGVycyhzb3J0ZXJzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGVtaXRDaGFuZ2VkRXZlbnQpIHtcclxuICAgICAgICBjb25zdCBlbWl0dGVyVHlwZSA9IGJhY2tlbmRBcGkgPyBFbWl0dGVyVHlwZS5yZW1vdGUgOiBFbWl0dGVyVHlwZS5sb2NhbDtcclxuICAgICAgICB0aGlzLmVtaXRTb3J0Q2hhbmdlZChlbWl0dGVyVHlwZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuIl19