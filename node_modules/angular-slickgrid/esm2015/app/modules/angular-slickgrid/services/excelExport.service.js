import * as tslib_1 from "tslib";
import { Injectable, Optional } from '@angular/core';
import { TranslateService } from '@ngx-translate/core';
import * as ExcelBuilder from 'excel-builder-webpacker';
import { Subject } from 'rxjs';
import * as moment_ from 'moment-mini';
const moment = moment_; // patch to fix rollup "moment has no default export" issue, document here https://github.com/rollup/rollup/issues/670
import { FileType, FieldType, } from '../models/index';
import { Constants } from '../constants';
import { exportWithFormatterWhenDefined } from './export-utilities';
import { addWhiteSpaces, sanitizeHtmlToText, titleCase, mapMomentDateFormatWithFieldType } from './utilities';
let ExcelExportService = class ExcelExportService {
    constructor(translate) {
        this.translate = translate;
        this._fileFormat = FileType.xlsx;
        this._hasGroupedItems = false;
        this.onGridBeforeExportToExcel = new Subject();
        this.onGridAfterExportToExcel = new Subject();
    }
    get datasetIdName() {
        return this._gridOptions && this._gridOptions.datasetIdPropertyName || 'id';
    }
    /** Getter for the Grid Options pulled through the Grid Object */
    get _gridOptions() {
        return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
    }
    /**
     * Initialize the Export Service
     * @param grid
     * @param gridOptions
     * @param dataView
     */
    init(grid, dataView) {
        this._grid = grid;
        this._dataView = dataView;
        // get locales provided by user in forRoot or else use default English locales via the Constants
        this._locales = this._gridOptions && this._gridOptions.locales || Constants.locales;
        if (this._gridOptions.enableTranslate && (!this.translate || !this.translate.instant)) {
            throw new Error('[Angular-Slickgrid] requires "ngx-translate" to be installed and configured when the grid option "enableTranslate" is enabled.');
        }
    }
    /**
     * Function to export the Grid result to an Excel CSV format using javascript for it to produce the CSV file.
     * This is a WYSIWYG export to file output (What You See is What You Get)
     *
     * NOTES: The column position needs to match perfectly the JSON Object position because of the way we are pulling the data,
     * which means that if any column(s) got moved in the UI, it has to be reflected in the JSON array output as well
     *
     * Example: exportToExcel({ format: FileType.csv, delimiter: DelimiterType.comma })
     */
    exportToExcel(options) {
        if (!this._grid || !this._dataView) {
            throw new Error('[Angular-Slickgrid] it seems that the SlickGrid & DataView objects are not initialized did you forget to enable the grid option flag "enableExcelExport"?');
        }
        return new Promise((resolve, reject) => {
            this.onGridBeforeExportToExcel.next(true);
            this._excelExportOptions = $.extend(true, {}, this._gridOptions.excelExportOptions, options);
            this._fileFormat = this._excelExportOptions.format || FileType.xlsx;
            // prepare the Excel Workbook & Sheet
            this._workbook = new ExcelBuilder.Workbook();
            this._sheet = new ExcelBuilder.Worksheet({ name: this._excelExportOptions.sheetName || 'Sheet1' });
            // add any Excel Format/Stylesheet to current Workbook
            this._stylesheet = this._workbook.getStyleSheet();
            const boldFormatter = this._stylesheet.createFormat({ font: { bold: true } });
            const stringFormatter = this._stylesheet.createFormat({ format: '@' });
            const numberFormatter = this._stylesheet.createFormat({ format: '0' });
            const usdFormatter = this._stylesheet.createFormat({ format: '$#,##0.00' });
            this._stylesheetFormats = {
                boldFormatter,
                dollarFormatter: usdFormatter,
                numberFormatter,
                stringFormatter,
            };
            // get the CSV output from the grid data
            const dataOutput = this.getDataOutput();
            // trigger a download file
            // wrap it into a setTimeout so that the EventAggregator has enough time to start a pre-process like showing a spinner
            setTimeout(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    if (this._gridOptions && this._gridOptions.excelExportOptions && this._gridOptions.excelExportOptions.customExcelHeader) {
                        this._gridOptions.excelExportOptions.customExcelHeader(this._workbook, this._sheet);
                    }
                    const currentSheetData = this._sheet.data;
                    let finalOutput = currentSheetData;
                    if (Array.isArray(currentSheetData) && Array.isArray(dataOutput)) {
                        finalOutput = this._sheet.data.concat(dataOutput);
                    }
                    this._sheet.setData(finalOutput);
                    this._workbook.addWorksheet(this._sheet);
                    const excelBlob = yield ExcelBuilder.Builder.createFile(this._workbook, { type: 'blob' });
                    const downloadOptions = {
                        filename: `${this._excelExportOptions.filename}.${this._fileFormat}`,
                        format: this._fileFormat
                    };
                    // start downloading but add the Blob property only on the start download not on the event itself
                    this.startDownloadFile(Object.assign({}, downloadOptions, { blob: excelBlob, data: this._sheet.data }));
                    this.onGridAfterExportToExcel.next(downloadOptions);
                    resolve(true);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    /**
     * Triggers download file with file format.
     * IE(6-10) are not supported
     * All other browsers will use plain javascript on client side to produce a file download.
     * @param options
     */
    startDownloadFile(options) {
        // IE(6-10) don't support javascript download and our service doesn't support either so throw an error, we have to make a round trip to the Web Server for exporting
        if (navigator.appName === 'Microsoft Internet Explorer') {
            throw new Error('Microsoft Internet Explorer 6 to 10 do not support javascript export to Excel. Please upgrade your browser.');
        }
        // when using IE/Edge, then use different download call
        if (typeof navigator.msSaveOrOpenBlob === 'function') {
            navigator.msSaveOrOpenBlob(options.blob, options.filename);
        }
        else {
            // this trick will generate a temp <a /> tag
            // the code will then trigger a hidden click for it to start downloading
            const link = document && document.createElement('a');
            const url = URL.createObjectURL(options.blob);
            if (link && document) {
                link.textContent = 'download';
                link.href = url;
                link.setAttribute('download', options.filename);
                // set the visibility to hidden so there is no effect on your web-layout
                link.style.visibility = 'hidden';
                // this part will append the anchor tag, trigger a click (for download to start) and finally remove the tag once completed
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }
    }
    /** use different Excel Stylesheet Format as per the Field Type */
    useCellFormatByFieldType(data, fieldType) {
        let outputData = data;
        switch (fieldType) {
            case FieldType.dateTime:
            case FieldType.dateTimeIso:
            case FieldType.dateTimeShortIso:
            case FieldType.dateTimeIsoAmPm:
            case FieldType.dateTimeIsoAM_PM:
            case FieldType.dateEuro:
            case FieldType.dateEuroShort:
            case FieldType.dateTimeEuro:
            case FieldType.dateTimeShortEuro:
            case FieldType.dateTimeEuroAmPm:
            case FieldType.dateTimeEuroAM_PM:
            case FieldType.dateTimeEuroShort:
            case FieldType.dateTimeEuroShortAmPm:
            case FieldType.dateUs:
            case FieldType.dateUsShort:
            case FieldType.dateTimeUs:
            case FieldType.dateTimeShortUs:
            case FieldType.dateTimeUsAmPm:
            case FieldType.dateTimeUsAM_PM:
            case FieldType.dateTimeUsShort:
            case FieldType.dateTimeUsShortAmPm:
            case FieldType.dateUtc:
            case FieldType.date:
            case FieldType.dateIso:
                outputData = data;
                if (data) {
                    const defaultDateFormat = mapMomentDateFormatWithFieldType(fieldType);
                    const isDateValid = moment(data, defaultDateFormat, false).isValid();
                    const outputDate = (data && isDateValid) ? moment(data).format(defaultDateFormat) : data;
                    const dateFormatter = this._stylesheet.createFormat({ format: defaultDateFormat });
                    outputData = { value: outputDate, metadata: { style: dateFormatter.id } };
                }
                break;
            case FieldType.number:
                const val = isNaN(+data) ? null : data;
                outputData = { value: val, metadata: { style: this._stylesheetFormats.numberFormatter.id } };
                break;
            default:
                outputData = data;
        }
        return outputData;
    }
    // -----------------------
    // Private functions
    // -----------------------
    getDataOutput() {
        const columns = this._grid && this._grid.getColumns && this._grid.getColumns() || [];
        // data variable which will hold all the fields data of a row
        const outputData = [];
        // get all column headers (it might include a "Group by" title at A1 cell)
        outputData.push(this.getColumnHeaderData(columns, { style: this._stylesheetFormats.boldFormatter.id }));
        // Populate the rest of the Grid Data
        this.pushAllGridRowDataToArray(outputData, columns);
        return outputData;
    }
    /** Get all column headers and format them in Bold */
    getColumnHeaderData(columns, metadata) {
        let outputHeaderTitles = [];
        this._columnHeaders = this.getColumnHeaders(columns) || [];
        if (this._columnHeaders && Array.isArray(this._columnHeaders) && this._columnHeaders.length > 0) {
            // add the header row + add a new line at the end of the row
            outputHeaderTitles = this._columnHeaders.map((header) => ({ value: header.title, metadata }));
        }
        // do we have a Group by title?
        const groupTitle = this.getGroupColumnTitle();
        if (groupTitle) {
            outputHeaderTitles.unshift({ value: groupTitle, metadata });
        }
        return outputHeaderTitles;
    }
    getGroupColumnTitle() {
        // Group By text, it could be set in the export options or from translation or if nothing is found then use the English constant text
        let groupByColumnHeader = this._excelExportOptions.groupingColumnHeaderTitle;
        if (!groupByColumnHeader && this._gridOptions.enableTranslate && this.translate && this.translate.currentLang && this.translate.instant) {
            groupByColumnHeader = this.translate.instant('GROUP_BY');
        }
        else if (!groupByColumnHeader) {
            groupByColumnHeader = this._locales && this._locales.TEXT_GROUP_BY;
        }
        // get grouped column titles and if found, we will add a "Group by" column at the first column index
        // if it's a CSV format, we'll escape the text in double quotes
        const grouping = this._dataView && this._dataView.getGrouping && this._dataView.getGrouping();
        if (grouping && Array.isArray(grouping) && grouping.length > 0) {
            this._hasGroupedItems = true;
            return groupByColumnHeader;
        }
        else {
            this._hasGroupedItems = false;
        }
        return null;
    }
    /**
     * Get all header titles and their keys, translate the title when required.
     * @param columns of the grid
     */
    getColumnHeaders(columns) {
        if (!columns || !Array.isArray(columns) || columns.length === 0) {
            return null;
        }
        const columnHeaders = [];
        // Populate the Column Header, pull the name defined
        columns.forEach((columnDef) => {
            let headerTitle = '';
            if ((columnDef.headerKey || columnDef.nameKey) && this._gridOptions.enableTranslate && this.translate && this.translate.currentLang && this.translate.instant) {
                headerTitle = this.translate.instant((columnDef.headerKey || columnDef.nameKey));
            }
            else {
                headerTitle = columnDef.name || titleCase(columnDef.field);
            }
            const skippedField = columnDef.excludeFromExport || false;
            // if column width is 0, then we consider that field as a hidden field and should not be part of the export
            if ((columnDef.width === undefined || columnDef.width > 0) && !skippedField) {
                columnHeaders.push({
                    key: columnDef.field || columnDef.id,
                    title: headerTitle
                });
            }
        });
        return columnHeaders;
    }
    /**
     * Get all the grid row data and return that as an output string
     */
    pushAllGridRowDataToArray(originalDaraArray, columns) {
        const lineCount = this._dataView && this._dataView.getLength && this._dataView.getLength();
        // loop through all the grid rows of data
        for (let rowNumber = 0; rowNumber < lineCount; rowNumber++) {
            const itemObj = this._dataView.getItem(rowNumber);
            if (itemObj != null) {
                // Normal row (not grouped by anything) would have an ID which was predefined in the Grid Columns definition
                if (itemObj[this.datasetIdName] != null) {
                    // get regular row item data
                    originalDaraArray.push(this.readRegularRowData(columns, rowNumber, itemObj));
                }
                else if (this._hasGroupedItems && itemObj.__groupTotals === undefined) {
                    // get the group row
                    originalDaraArray.push([this.readGroupedTitleRow(itemObj)]);
                }
                else if (itemObj.__groupTotals) {
                    // else if the row is a Group By and we have agreggators, then a property of '__groupTotals' would exist under that object
                    originalDaraArray.push(this.readGroupedTotalRow(columns, itemObj));
                }
            }
        }
        return originalDaraArray;
    }
    /**
     * Get the data of a regular row (a row without grouping)
     * @param row
     * @param itemObj
     */
    readRegularRowData(columns, row, itemObj) {
        let idx = 0;
        const rowOutputStrings = [];
        for (let col = 0, ln = columns.length; col < ln; col++) {
            const columnDef = columns[col];
            const fieldType = columnDef.outputType || columnDef.type || FieldType.string;
            // skip excluded column
            if (columnDef.excludeFromExport) {
                continue;
            }
            // if we are grouping and are on 1st column index, we need to skip this column since it will be used later by the grouping text:: Group by [columnX]
            if (this._hasGroupedItems && idx === 0) {
                rowOutputStrings.push('');
            }
            // get the output by analyzing if we'll pull the value from the cell or from a formatter
            let itemData = exportWithFormatterWhenDefined(row, col, itemObj, columnDef, this._grid, this._excelExportOptions);
            // does the user want to sanitize the output data (remove HTML tags)?
            if (columnDef.sanitizeDataExport || this._excelExportOptions.sanitizeDataExport) {
                itemData = sanitizeHtmlToText(itemData);
            }
            // use different Excel Stylesheet Format as per the Field Type
            if (!columnDef.exportWithFormatter) {
                itemData = this.useCellFormatByFieldType(itemData, fieldType);
            }
            rowOutputStrings.push(itemData);
            idx++;
        }
        return rowOutputStrings;
    }
    /**
     * Get the grouped title(s) and its group title formatter, for example if we grouped by salesRep, the returned result would be:: 'Sales Rep: John Dow (2 items)'
     * @param itemObj
     */
    readGroupedTitleRow(itemObj) {
        const groupName = sanitizeHtmlToText(itemObj.title);
        if (this._excelExportOptions && this._excelExportOptions.addGroupIndentation) {
            const collapsedSymbol = this._excelExportOptions && this._excelExportOptions.groupCollapsedSymbol || '\u25B9';
            const expandedSymbol = this._excelExportOptions && this._excelExportOptions.groupExpandedSymbol || '\u25BF';
            const chevron = itemObj.collapsed ? collapsedSymbol : expandedSymbol;
            return chevron + ' ' + addWhiteSpaces(5 * itemObj.level) + groupName;
        }
        return groupName;
    }
    /**
     * Get the grouped totals (below the regular rows), these are set by Slick Aggregators.
     * For example if we grouped by "salesRep" and we have a Sum Aggregator on "sales", then the returned output would be:: ["Sum 123$"]
     * @param itemObj
     */
    readGroupedTotalRow(columns, itemObj) {
        const groupingAggregatorRowText = this._excelExportOptions.groupingAggregatorRowText || '';
        const outputStrings = [groupingAggregatorRowText];
        columns.forEach((columnDef) => {
            let itemData = '';
            const skippedField = columnDef.excludeFromExport || false;
            // if there's a groupTotalsFormatter, we will re-run it to get the exact same output as what is shown in UI
            if (columnDef.groupTotalsFormatter) {
                itemData = columnDef.groupTotalsFormatter(itemObj, columnDef);
            }
            // does the user want to sanitize the output data (remove HTML tags)?
            if (columnDef.sanitizeDataExport || this._excelExportOptions.sanitizeDataExport) {
                itemData = sanitizeHtmlToText(itemData);
            }
            // add the column (unless user wants to skip it)
            if ((columnDef.width === undefined || columnDef.width > 0) && !skippedField) {
                outputStrings.push(itemData);
            }
        });
        return outputStrings;
    }
};
ExcelExportService = tslib_1.__decorate([
    Injectable(),
    tslib_1.__param(0, Optional()),
    tslib_1.__metadata("design:paramtypes", [TranslateService])
], ExcelExportService);
export { ExcelExportService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhjZWxFeHBvcnQuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItc2xpY2tncmlkLyIsInNvdXJjZXMiOlsiYXBwL21vZHVsZXMvYW5ndWxhci1zbGlja2dyaWQvc2VydmljZXMvZXhjZWxFeHBvcnQuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBRUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDckQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDdkQsT0FBTyxLQUFLLFlBQVksTUFBTSx5QkFBeUIsQ0FBQztBQUN4RCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQy9CLE9BQU8sS0FBSyxPQUFPLE1BQU0sYUFBYSxDQUFDO0FBQ3ZDLE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxDQUFDLHNIQUFzSDtBQUc5SSxPQUFPLEVBS0wsUUFBUSxFQUlSLFNBQVMsR0FFVixNQUFNLGlCQUFpQixDQUFDO0FBQ3pCLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDekMsT0FBTyxFQUFFLDhCQUE4QixFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDcEUsT0FBTyxFQUFFLGNBQWMsRUFBRSxrQkFBa0IsRUFBRSxTQUFTLEVBQUUsZ0NBQWdDLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFNOUcsSUFBYSxrQkFBa0IsR0FBL0IsTUFBYSxrQkFBa0I7SUFnQjdCLFlBQWdDLFNBQTJCO1FBQTNCLGNBQVMsR0FBVCxTQUFTLENBQWtCO1FBZm5ELGdCQUFXLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQztRQU01QixxQkFBZ0IsR0FBRyxLQUFLLENBQUM7UUFNakMsOEJBQXlCLEdBQUcsSUFBSSxPQUFPLEVBQVcsQ0FBQztRQUNuRCw2QkFBd0IsR0FBRyxJQUFJLE9BQU8sRUFBdUQsQ0FBQztJQUUvQixDQUFDO0lBRWhFLElBQVksYUFB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ImltcG9ydCB7IEV4Y2VsV29ya2Jvb2sgfSBmcm9tICcuLy4uL21vZGVscy9leGNlbFdvcmtib29rLmludGVyZmFjZSc7XHJcbmltcG9ydCB7IEV4Y2VsU3R5bGVzaGVldCB9IGZyb20gJy4vLi4vbW9kZWxzL2V4Y2VsU3R5bGVzaGVldC5pbnRlcmZhY2UnO1xyXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBUcmFuc2xhdGVTZXJ2aWNlIH0gZnJvbSAnQG5neC10cmFuc2xhdGUvY29yZSc7XHJcbmltcG9ydCAqIGFzIEV4Y2VsQnVpbGRlciBmcm9tICdleGNlbC1idWlsZGVyLXdlYnBhY2tlcic7XHJcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0ICogYXMgbW9tZW50XyBmcm9tICdtb21lbnQtbWluaSc7XHJcbmNvbnN0IG1vbWVudCA9IG1vbWVudF87IC8vIHBhdGNoIHRvIGZpeCByb2xsdXAgXCJtb21lbnQgaGFzIG5vIGRlZmF1bHQgZXhwb3J0XCIgaXNzdWUsIGRvY3VtZW50IGhlcmUgaHR0cHM6Ly9naXRodWIuY29tL3JvbGx1cC9yb2xsdXAvaXNzdWVzLzY3MFxyXG5cclxuXHJcbmltcG9ydCB7XHJcbiAgQ29sdW1uLFxyXG4gIEV4Y2VsQ2VsbEZvcm1hdCxcclxuICBFeGNlbEV4cG9ydE9wdGlvbixcclxuICBFeGNlbE1ldGFkYXRhLFxyXG4gIEZpbGVUeXBlLFxyXG4gIEdyaWRPcHRpb24sXHJcbiAgS2V5VGl0bGVQYWlyLFxyXG4gIExvY2FsZSxcclxuICBGaWVsZFR5cGUsXHJcbiAgRXhjZWxXb3Jrc2hlZXQsXHJcbn0gZnJvbSAnLi4vbW9kZWxzL2luZGV4JztcclxuaW1wb3J0IHsgQ29uc3RhbnRzIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcclxuaW1wb3J0IHsgZXhwb3J0V2l0aEZvcm1hdHRlcldoZW5EZWZpbmVkIH0gZnJvbSAnLi9leHBvcnQtdXRpbGl0aWVzJztcclxuaW1wb3J0IHsgYWRkV2hpdGVTcGFjZXMsIHNhbml0aXplSHRtbFRvVGV4dCwgdGl0bGVDYXNlLCBtYXBNb21lbnREYXRlRm9ybWF0V2l0aEZpZWxkVHlwZSB9IGZyb20gJy4vdXRpbGl0aWVzJztcclxuXHJcbi8vIHVzaW5nIGV4dGVybmFsIG5vbi10eXBlZCBqcyBsaWJyYXJpZXNcclxuZGVjbGFyZSBsZXQgJDogYW55O1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgRXhjZWxFeHBvcnRTZXJ2aWNlIHtcclxuICBwcml2YXRlIF9maWxlRm9ybWF0ID0gRmlsZVR5cGUueGxzeDtcclxuICBwcml2YXRlIF9kYXRhVmlldzogYW55O1xyXG4gIHByaXZhdGUgX2dyaWQ6IGFueTtcclxuICBwcml2YXRlIF9sb2NhbGVzOiBMb2NhbGU7XHJcbiAgcHJpdmF0ZSBfY29sdW1uSGVhZGVyczogS2V5VGl0bGVQYWlyW107XHJcbiAgcHJpdmF0ZSBfZ3JvdXBlZEhlYWRlcnM6IEtleVRpdGxlUGFpcltdO1xyXG4gIHByaXZhdGUgX2hhc0dyb3VwZWRJdGVtcyA9IGZhbHNlO1xyXG4gIHByaXZhdGUgX2V4Y2VsRXhwb3J0T3B0aW9uczogRXhjZWxFeHBvcnRPcHRpb247XHJcbiAgcHJpdmF0ZSBfc2hlZXQ6IEV4Y2VsV29ya3NoZWV0O1xyXG4gIHByaXZhdGUgX3N0eWxlc2hlZXQ6IEV4Y2VsU3R5bGVzaGVldDtcclxuICBwcml2YXRlIF9zdHlsZXNoZWV0Rm9ybWF0czogYW55O1xyXG4gIHByaXZhdGUgX3dvcmtib29rOiBFeGNlbFdvcmtib29rO1xyXG4gIG9uR3JpZEJlZm9yZUV4cG9ydFRvRXhjZWwgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xyXG4gIG9uR3JpZEFmdGVyRXhwb3J0VG9FeGNlbCA9IG5ldyBTdWJqZWN0PHsgYmxvYj86IEJsb2I7IGZpbGVuYW1lOiBzdHJpbmc7IGZvcm1hdD86IHN0cmluZzsgfT4oKTtcclxuXHJcbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJpdmF0ZSB0cmFuc2xhdGU6IFRyYW5zbGF0ZVNlcnZpY2UpIHsgfVxyXG5cclxuICBwcml2YXRlIGdldCBkYXRhc2V0SWROYW1lKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuZGF0YXNldElkUHJvcGVydHlOYW1lIHx8ICdpZCc7XHJcbiAgfVxyXG5cclxuICAvKiogR2V0dGVyIGZvciB0aGUgR3JpZCBPcHRpb25zIHB1bGxlZCB0aHJvdWdoIHRoZSBHcmlkIE9iamVjdCAqL1xyXG4gIHByaXZhdGUgZ2V0IF9ncmlkT3B0aW9ucygpOiBHcmlkT3B0aW9uIHtcclxuICAgIHJldHVybiAodGhpcy5fZ3JpZCAmJiB0aGlzLl9ncmlkLmdldE9wdGlvbnMpID8gdGhpcy5fZ3JpZC5nZXRPcHRpb25zKCkgOiB7fTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgdGhlIEV4cG9ydCBTZXJ2aWNlXHJcbiAgICogQHBhcmFtIGdyaWRcclxuICAgKiBAcGFyYW0gZ3JpZE9wdGlvbnNcclxuICAgKiBAcGFyYW0gZGF0YVZpZXdcclxuICAgKi9cclxuICBpbml0KGdyaWQ6IGFueSwgZGF0YVZpZXc6IGFueSk6IHZvaWQge1xyXG4gICAgdGhpcy5fZ3JpZCA9IGdyaWQ7XHJcbiAgICB0aGlzLl9kYXRhVmlldyA9IGRhdGFWaWV3O1xyXG5cclxuICAgIC8vIGdldCBsb2NhbGVzIHByb3ZpZGVkIGJ5IHVzZXIgaW4gZm9yUm9vdCBvciBlbHNlIHVzZSBkZWZhdWx0IEVuZ2xpc2ggbG9jYWxlcyB2aWEgdGhlIENvbnN0YW50c1xyXG4gICAgdGhpcy5fbG9jYWxlcyA9IHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLmxvY2FsZXMgfHwgQ29uc3RhbnRzLmxvY2FsZXM7XHJcblxyXG4gICAgaWYgKHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZVRyYW5zbGF0ZSAmJiAoIXRoaXMudHJhbnNsYXRlIHx8ICF0aGlzLnRyYW5zbGF0ZS5pbnN0YW50KSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tBbmd1bGFyLVNsaWNrZ3JpZF0gcmVxdWlyZXMgXCJuZ3gtdHJhbnNsYXRlXCIgdG8gYmUgaW5zdGFsbGVkIGFuZCBjb25maWd1cmVkIHdoZW4gdGhlIGdyaWQgb3B0aW9uIFwiZW5hYmxlVHJhbnNsYXRlXCIgaXMgZW5hYmxlZC4nKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZ1bmN0aW9uIHRvIGV4cG9ydCB0aGUgR3JpZCByZXN1bHQgdG8gYW4gRXhjZWwgQ1NWIGZvcm1hdCB1c2luZyBqYXZhc2NyaXB0IGZvciBpdCB0byBwcm9kdWNlIHRoZSBDU1YgZmlsZS5cclxuICAgKiBUaGlzIGlzIGEgV1lTSVdZRyBleHBvcnQgdG8gZmlsZSBvdXRwdXQgKFdoYXQgWW91IFNlZSBpcyBXaGF0IFlvdSBHZXQpXHJcbiAgICpcclxuICAgKiBOT1RFUzogVGhlIGNvbHVtbiBwb3NpdGlvbiBuZWVkcyB0byBtYXRjaCBwZXJmZWN0bHkgdGhlIEpTT04gT2JqZWN0IHBvc2l0aW9uIGJlY2F1c2Ugb2YgdGhlIHdheSB3ZSBhcmUgcHVsbGluZyB0aGUgZGF0YSxcclxuICAgKiB3aGljaCBtZWFucyB0aGF0IGlmIGFueSBjb2x1bW4ocykgZ290IG1vdmVkIGluIHRoZSBVSSwgaXQgaGFzIHRvIGJlIHJlZmxlY3RlZCBpbiB0aGUgSlNPTiBhcnJheSBvdXRwdXQgYXMgd2VsbFxyXG4gICAqXHJcbiAgICogRXhhbXBsZTogZXhwb3J0VG9FeGNlbCh7IGZvcm1hdDogRmlsZVR5cGUuY3N2LCBkZWxpbWl0ZXI6IERlbGltaXRlclR5cGUuY29tbWEgfSlcclxuICAgKi9cclxuICBleHBvcnRUb0V4Y2VsKG9wdGlvbnM6IEV4Y2VsRXhwb3J0T3B0aW9uKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICBpZiAoIXRoaXMuX2dyaWQgfHwgIXRoaXMuX2RhdGFWaWV3KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignW0FuZ3VsYXItU2xpY2tncmlkXSBpdCBzZWVtcyB0aGF0IHRoZSBTbGlja0dyaWQgJiBEYXRhVmlldyBvYmplY3RzIGFyZSBub3QgaW5pdGlhbGl6ZWQgZGlkIHlvdSBmb3JnZXQgdG8gZW5hYmxlIHRoZSBncmlkIG9wdGlvbiBmbGFnIFwiZW5hYmxlRXhjZWxFeHBvcnRcIj8nKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICB0aGlzLm9uR3JpZEJlZm9yZUV4cG9ydFRvRXhjZWwubmV4dCh0cnVlKTtcclxuICAgICAgdGhpcy5fZXhjZWxFeHBvcnRPcHRpb25zID0gJC5leHRlbmQodHJ1ZSwge30sIHRoaXMuX2dyaWRPcHRpb25zLmV4Y2VsRXhwb3J0T3B0aW9ucywgb3B0aW9ucyk7XHJcbiAgICAgIHRoaXMuX2ZpbGVGb3JtYXQgPSB0aGlzLl9leGNlbEV4cG9ydE9wdGlvbnMuZm9ybWF0IHx8IEZpbGVUeXBlLnhsc3g7XHJcblxyXG4gICAgICAvLyBwcmVwYXJlIHRoZSBFeGNlbCBXb3JrYm9vayAmIFNoZWV0XHJcbiAgICAgIHRoaXMuX3dvcmtib29rID0gbmV3IEV4Y2VsQnVpbGRlci5Xb3JrYm9vaygpO1xyXG4gICAgICB0aGlzLl9zaGVldCA9IG5ldyBFeGNlbEJ1aWxkZXIuV29ya3NoZWV0KHsgbmFtZTogdGhpcy5fZXhjZWxFeHBvcnRPcHRpb25zLnNoZWV0TmFtZSB8fCAnU2hlZXQxJyB9KTtcclxuXHJcbiAgICAgIC8vIGFkZCBhbnkgRXhjZWwgRm9ybWF0L1N0eWxlc2hlZXQgdG8gY3VycmVudCBXb3JrYm9va1xyXG4gICAgICB0aGlzLl9zdHlsZXNoZWV0ID0gdGhpcy5fd29ya2Jvb2suZ2V0U3R5bGVTaGVldCgpO1xyXG4gICAgICBjb25zdCBib2xkRm9ybWF0dGVyID0gdGhpcy5fc3R5bGVzaGVldC5jcmVhdGVGb3JtYXQoeyBmb250OiB7IGJvbGQ6IHRydWUgfSB9KTtcclxuICAgICAgY29uc3Qgc3RyaW5nRm9ybWF0dGVyID0gdGhpcy5fc3R5bGVzaGVldC5jcmVhdGVGb3JtYXQoeyBmb3JtYXQ6ICdAJyB9KTtcclxuICAgICAgY29uc3QgbnVtYmVyRm9ybWF0dGVyID0gdGhpcy5fc3R5bGVzaGVldC5jcmVhdGVGb3JtYXQoeyBmb3JtYXQ6ICcwJyB9KTtcclxuICAgICAgY29uc3QgdXNkRm9ybWF0dGVyID0gdGhpcy5fc3R5bGVzaGVldC5jcmVhdGVGb3JtYXQoeyBmb3JtYXQ6ICckIywjIzAuMDAnIH0pO1xyXG4gICAgICB0aGlzLl9zdHlsZXNoZWV0Rm9ybWF0cyA9IHtcclxuICAgICAgICBib2xkRm9ybWF0dGVyLFxyXG4gICAgICAgIGRvbGxhckZvcm1hdHRlcjogdXNkRm9ybWF0dGVyLFxyXG4gICAgICAgIG51bWJlckZvcm1hdHRlcixcclxuICAgICAgICBzdHJpbmdGb3JtYXR0ZXIsXHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBnZXQgdGhlIENTViBvdXRwdXQgZnJvbSB0aGUgZ3JpZCBkYXRhXHJcbiAgICAgIGNvbnN0IGRhdGFPdXRwdXQgPSB0aGlzLmdldERhdGFPdXRwdXQoKTtcclxuXHJcbiAgICAgIC8vIHRyaWdnZXIgYSBkb3dubG9hZCBmaWxlXHJcbiAgICAgIC8vIHdyYXAgaXQgaW50byBhIHNldFRpbWVvdXQgc28gdGhhdCB0aGUgRXZlbnRBZ2dyZWdhdG9yIGhhcyBlbm91Z2ggdGltZSB0byBzdGFydCBhIHByZS1wcm9jZXNzIGxpa2Ugc2hvd2luZyBhIHNwaW5uZXJcclxuICAgICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGlmICh0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5leGNlbEV4cG9ydE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuZXhjZWxFeHBvcnRPcHRpb25zLmN1c3RvbUV4Y2VsSGVhZGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyaWRPcHRpb25zLmV4Y2VsRXhwb3J0T3B0aW9ucy5jdXN0b21FeGNlbEhlYWRlcih0aGlzLl93b3JrYm9vaywgdGhpcy5fc2hlZXQpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbnN0IGN1cnJlbnRTaGVldERhdGEgPSB0aGlzLl9zaGVldC5kYXRhO1xyXG4gICAgICAgICAgbGV0IGZpbmFsT3V0cHV0ID0gY3VycmVudFNoZWV0RGF0YTtcclxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRTaGVldERhdGEpICYmIEFycmF5LmlzQXJyYXkoZGF0YU91dHB1dCkpIHtcclxuICAgICAgICAgICAgZmluYWxPdXRwdXQgPSB0aGlzLl9zaGVldC5kYXRhLmNvbmNhdChkYXRhT3V0cHV0KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB0aGlzLl9zaGVldC5zZXREYXRhKGZpbmFsT3V0cHV0KTtcclxuICAgICAgICAgIHRoaXMuX3dvcmtib29rLmFkZFdvcmtzaGVldCh0aGlzLl9zaGVldCk7XHJcblxyXG4gICAgICAgICAgY29uc3QgZXhjZWxCbG9iID0gYXdhaXQgRXhjZWxCdWlsZGVyLkJ1aWxkZXIuY3JlYXRlRmlsZSh0aGlzLl93b3JrYm9vaywgeyB0eXBlOiAnYmxvYicgfSk7XHJcbiAgICAgICAgICBjb25zdCBkb3dubG9hZE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGZpbGVuYW1lOiBgJHt0aGlzLl9leGNlbEV4cG9ydE9wdGlvbnMuZmlsZW5hbWV9LiR7dGhpcy5fZmlsZUZvcm1hdH1gLFxyXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuX2ZpbGVGb3JtYXRcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgLy8gc3RhcnQgZG93bmxvYWRpbmcgYnV0IGFkZCB0aGUgQmxvYiBwcm9wZXJ0eSBvbmx5IG9uIHRoZSBzdGFydCBkb3dubG9hZCBub3Qgb24gdGhlIGV2ZW50IGl0c2VsZlxyXG4gICAgICAgICAgdGhpcy5zdGFydERvd25sb2FkRmlsZSh7IC4uLmRvd25sb2FkT3B0aW9ucywgYmxvYjogZXhjZWxCbG9iLCBkYXRhOiB0aGlzLl9zaGVldC5kYXRhIH0pO1xyXG4gICAgICAgICAgdGhpcy5vbkdyaWRBZnRlckV4cG9ydFRvRXhjZWwubmV4dChkb3dubG9hZE9wdGlvbnMpO1xyXG4gICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmlnZ2VycyBkb3dubG9hZCBmaWxlIHdpdGggZmlsZSBmb3JtYXQuXHJcbiAgICogSUUoNi0xMCkgYXJlIG5vdCBzdXBwb3J0ZWRcclxuICAgKiBBbGwgb3RoZXIgYnJvd3NlcnMgd2lsbCB1c2UgcGxhaW4gamF2YXNjcmlwdCBvbiBjbGllbnQgc2lkZSB0byBwcm9kdWNlIGEgZmlsZSBkb3dubG9hZC5cclxuICAgKiBAcGFyYW0gb3B0aW9uc1xyXG4gICAqL1xyXG4gIHN0YXJ0RG93bmxvYWRGaWxlKG9wdGlvbnM6IHsgZmlsZW5hbWU6IHN0cmluZywgYmxvYjogQmxvYiwgZGF0YTogYW55W10gfSkge1xyXG4gICAgLy8gSUUoNi0xMCkgZG9uJ3Qgc3VwcG9ydCBqYXZhc2NyaXB0IGRvd25sb2FkIGFuZCBvdXIgc2VydmljZSBkb2Vzbid0IHN1cHBvcnQgZWl0aGVyIHNvIHRocm93IGFuIGVycm9yLCB3ZSBoYXZlIHRvIG1ha2UgYSByb3VuZCB0cmlwIHRvIHRoZSBXZWIgU2VydmVyIGZvciBleHBvcnRpbmdcclxuICAgIGlmIChuYXZpZ2F0b3IuYXBwTmFtZSA9PT0gJ01pY3Jvc29mdCBJbnRlcm5ldCBFeHBsb3JlcicpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXIgNiB0byAxMCBkbyBub3Qgc3VwcG9ydCBqYXZhc2NyaXB0IGV4cG9ydCB0byBFeGNlbC4gUGxlYXNlIHVwZ3JhZGUgeW91ciBicm93c2VyLicpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHdoZW4gdXNpbmcgSUUvRWRnZSwgdGhlbiB1c2UgZGlmZmVyZW50IGRvd25sb2FkIGNhbGxcclxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgbmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2Iob3B0aW9ucy5ibG9iLCBvcHRpb25zLmZpbGVuYW1lKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIHRoaXMgdHJpY2sgd2lsbCBnZW5lcmF0ZSBhIHRlbXAgPGEgLz4gdGFnXHJcbiAgICAgIC8vIHRoZSBjb2RlIHdpbGwgdGhlbiB0cmlnZ2VyIGEgaGlkZGVuIGNsaWNrIGZvciBpdCB0byBzdGFydCBkb3dubG9hZGluZ1xyXG4gICAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xyXG4gICAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG9wdGlvbnMuYmxvYik7XHJcblxyXG4gICAgICBpZiAobGluayAmJiBkb2N1bWVudCkge1xyXG4gICAgICAgIGxpbmsudGV4dENvbnRlbnQgPSAnZG93bmxvYWQnO1xyXG4gICAgICAgIGxpbmsuaHJlZiA9IHVybDtcclxuICAgICAgICBsaW5rLnNldEF0dHJpYnV0ZSgnZG93bmxvYWQnLCBvcHRpb25zLmZpbGVuYW1lKTtcclxuXHJcbiAgICAgICAgLy8gc2V0IHRoZSB2aXNpYmlsaXR5IHRvIGhpZGRlbiBzbyB0aGVyZSBpcyBubyBlZmZlY3Qgb24geW91ciB3ZWItbGF5b3V0XHJcbiAgICAgICAgbGluay5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XHJcblxyXG4gICAgICAgIC8vIHRoaXMgcGFydCB3aWxsIGFwcGVuZCB0aGUgYW5jaG9yIHRhZywgdHJpZ2dlciBhIGNsaWNrIChmb3IgZG93bmxvYWQgdG8gc3RhcnQpIGFuZCBmaW5hbGx5IHJlbW92ZSB0aGUgdGFnIG9uY2UgY29tcGxldGVkXHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaW5rKTtcclxuICAgICAgICBsaW5rLmNsaWNrKCk7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChsaW5rKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIHVzZSBkaWZmZXJlbnQgRXhjZWwgU3R5bGVzaGVldCBGb3JtYXQgYXMgcGVyIHRoZSBGaWVsZCBUeXBlICovXHJcbiAgdXNlQ2VsbEZvcm1hdEJ5RmllbGRUeXBlKGRhdGE6IHN0cmluZyB8IERhdGUgfCBtb21lbnRfLk1vbWVudCwgZmllbGRUeXBlOiBGaWVsZFR5cGUpOiBFeGNlbENlbGxGb3JtYXQgfCBzdHJpbmcge1xyXG4gICAgbGV0IG91dHB1dERhdGE6IEV4Y2VsQ2VsbEZvcm1hdCB8IHN0cmluZyB8IERhdGUgfCBtb21lbnRfLk1vbWVudCA9IGRhdGE7XHJcbiAgICBzd2l0Y2ggKGZpZWxkVHlwZSkge1xyXG4gICAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZTpcclxuICAgICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVJc286XHJcbiAgICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lU2hvcnRJc286XHJcbiAgICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lSXNvQW1QbTpcclxuICAgICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVJc29BTV9QTTpcclxuICAgICAgY2FzZSBGaWVsZFR5cGUuZGF0ZUV1cm86XHJcbiAgICAgIGNhc2UgRmllbGRUeXBlLmRhdGVFdXJvU2hvcnQ6XHJcbiAgICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lRXVybzpcclxuICAgICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVTaG9ydEV1cm86XHJcbiAgICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lRXVyb0FtUG06XHJcbiAgICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lRXVyb0FNX1BNOlxyXG4gICAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUV1cm9TaG9ydDpcclxuICAgICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVFdXJvU2hvcnRBbVBtOlxyXG4gICAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVXM6XHJcbiAgICAgIGNhc2UgRmllbGRUeXBlLmRhdGVVc1Nob3J0OlxyXG4gICAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVVzOlxyXG4gICAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVNob3J0VXM6XHJcbiAgICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lVXNBbVBtOlxyXG4gICAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVVzQU1fUE06XHJcbiAgICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lVXNTaG9ydDpcclxuICAgICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVVc1Nob3J0QW1QbTpcclxuICAgICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVV0YzpcclxuICAgICAgY2FzZSBGaWVsZFR5cGUuZGF0ZTpcclxuICAgICAgY2FzZSBGaWVsZFR5cGUuZGF0ZUlzbzpcclxuICAgICAgICBvdXRwdXREYXRhID0gZGF0YTtcclxuICAgICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgICAgY29uc3QgZGVmYXVsdERhdGVGb3JtYXQgPSBtYXBNb21lbnREYXRlRm9ybWF0V2l0aEZpZWxkVHlwZShmaWVsZFR5cGUpO1xyXG4gICAgICAgICAgY29uc3QgaXNEYXRlVmFsaWQgPSBtb21lbnQoZGF0YSBhcyBzdHJpbmcsIGRlZmF1bHREYXRlRm9ybWF0LCBmYWxzZSkuaXNWYWxpZCgpO1xyXG4gICAgICAgICAgY29uc3Qgb3V0cHV0RGF0ZSA9IChkYXRhICYmIGlzRGF0ZVZhbGlkKSA/IG1vbWVudChkYXRhIGFzIHN0cmluZykuZm9ybWF0KGRlZmF1bHREYXRlRm9ybWF0KSA6IGRhdGE7XHJcbiAgICAgICAgICBjb25zdCBkYXRlRm9ybWF0dGVyID0gdGhpcy5fc3R5bGVzaGVldC5jcmVhdGVGb3JtYXQoeyBmb3JtYXQ6IGRlZmF1bHREYXRlRm9ybWF0IH0pO1xyXG4gICAgICAgICAgb3V0cHV0RGF0YSA9IHsgdmFsdWU6IG91dHB1dERhdGUsIG1ldGFkYXRhOiB7IHN0eWxlOiBkYXRlRm9ybWF0dGVyLmlkIH0gfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgRmllbGRUeXBlLm51bWJlcjpcclxuICAgICAgICBjb25zdCB2YWwgPSBpc05hTigrZGF0YSkgPyBudWxsIDogZGF0YTtcclxuICAgICAgICBvdXRwdXREYXRhID0geyB2YWx1ZTogdmFsLCBtZXRhZGF0YTogeyBzdHlsZTogdGhpcy5fc3R5bGVzaGVldEZvcm1hdHMubnVtYmVyRm9ybWF0dGVyLmlkIH0gfTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBvdXRwdXREYXRhID0gZGF0YTtcclxuICAgIH1cclxuICAgIHJldHVybiBvdXRwdXREYXRhIGFzIHN0cmluZztcclxuICB9XHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gUHJpdmF0ZSBmdW5jdGlvbnNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICBwcml2YXRlIGdldERhdGFPdXRwdXQoKTogc3RyaW5nW11bXSB8IEV4Y2VsQ2VsbEZvcm1hdFtdW10ge1xyXG4gICAgY29uc3QgY29sdW1ucyA9IHRoaXMuX2dyaWQgJiYgdGhpcy5fZ3JpZC5nZXRDb2x1bW5zICYmIHRoaXMuX2dyaWQuZ2V0Q29sdW1ucygpIHx8IFtdO1xyXG5cclxuICAgIC8vIGRhdGEgdmFyaWFibGUgd2hpY2ggd2lsbCBob2xkIGFsbCB0aGUgZmllbGRzIGRhdGEgb2YgYSByb3dcclxuICAgIGNvbnN0IG91dHB1dERhdGEgPSBbXTtcclxuXHJcbiAgICAvLyBnZXQgYWxsIGNvbHVtbiBoZWFkZXJzIChpdCBtaWdodCBpbmNsdWRlIGEgXCJHcm91cCBieVwiIHRpdGxlIGF0IEExIGNlbGwpXHJcbiAgICBvdXRwdXREYXRhLnB1c2godGhpcy5nZXRDb2x1bW5IZWFkZXJEYXRhKGNvbHVtbnMsIHsgc3R5bGU6IHRoaXMuX3N0eWxlc2hlZXRGb3JtYXRzLmJvbGRGb3JtYXR0ZXIuaWQgfSkpO1xyXG5cclxuICAgIC8vIFBvcHVsYXRlIHRoZSByZXN0IG9mIHRoZSBHcmlkIERhdGFcclxuICAgIHRoaXMucHVzaEFsbEdyaWRSb3dEYXRhVG9BcnJheShvdXRwdXREYXRhLCBjb2x1bW5zKTtcclxuXHJcbiAgICByZXR1cm4gb3V0cHV0RGF0YTtcclxuICB9XHJcblxyXG4gIC8qKiBHZXQgYWxsIGNvbHVtbiBoZWFkZXJzIGFuZCBmb3JtYXQgdGhlbSBpbiBCb2xkICovXHJcbiAgcHJpdmF0ZSBnZXRDb2x1bW5IZWFkZXJEYXRhKGNvbHVtbnM6IENvbHVtbltdLCBtZXRhZGF0YTogRXhjZWxNZXRhZGF0YSk6IHN0cmluZ1tdIHwgRXhjZWxDZWxsRm9ybWF0W10ge1xyXG4gICAgbGV0IG91dHB1dEhlYWRlclRpdGxlczogRXhjZWxDZWxsRm9ybWF0W10gPSBbXTtcclxuXHJcbiAgICB0aGlzLl9jb2x1bW5IZWFkZXJzID0gdGhpcy5nZXRDb2x1bW5IZWFkZXJzKGNvbHVtbnMpIHx8IFtdO1xyXG4gICAgaWYgKHRoaXMuX2NvbHVtbkhlYWRlcnMgJiYgQXJyYXkuaXNBcnJheSh0aGlzLl9jb2x1bW5IZWFkZXJzKSAmJiB0aGlzLl9jb2x1bW5IZWFkZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgLy8gYWRkIHRoZSBoZWFkZXIgcm93ICsgYWRkIGEgbmV3IGxpbmUgYXQgdGhlIGVuZCBvZiB0aGUgcm93XHJcbiAgICAgIG91dHB1dEhlYWRlclRpdGxlcyA9IHRoaXMuX2NvbHVtbkhlYWRlcnMubWFwKChoZWFkZXIpID0+ICh7IHZhbHVlOiBoZWFkZXIudGl0bGUsIG1ldGFkYXRhIH0pKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBkbyB3ZSBoYXZlIGEgR3JvdXAgYnkgdGl0bGU/XHJcbiAgICBjb25zdCBncm91cFRpdGxlID0gdGhpcy5nZXRHcm91cENvbHVtblRpdGxlKCk7XHJcbiAgICBpZiAoZ3JvdXBUaXRsZSkge1xyXG4gICAgICBvdXRwdXRIZWFkZXJUaXRsZXMudW5zaGlmdCh7IHZhbHVlOiBncm91cFRpdGxlLCBtZXRhZGF0YSB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0cHV0SGVhZGVyVGl0bGVzO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBnZXRHcm91cENvbHVtblRpdGxlKCk6IHN0cmluZyB8IG51bGwge1xyXG4gICAgLy8gR3JvdXAgQnkgdGV4dCwgaXQgY291bGQgYmUgc2V0IGluIHRoZSBleHBvcnQgb3B0aW9ucyBvciBmcm9tIHRyYW5zbGF0aW9uIG9yIGlmIG5vdGhpbmcgaXMgZm91bmQgdGhlbiB1c2UgdGhlIEVuZ2xpc2ggY29uc3RhbnQgdGV4dFxyXG4gICAgbGV0IGdyb3VwQnlDb2x1bW5IZWFkZXIgPSB0aGlzLl9leGNlbEV4cG9ydE9wdGlvbnMuZ3JvdXBpbmdDb2x1bW5IZWFkZXJUaXRsZTtcclxuICAgIGlmICghZ3JvdXBCeUNvbHVtbkhlYWRlciAmJiB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVUcmFuc2xhdGUgJiYgdGhpcy50cmFuc2xhdGUgJiYgdGhpcy50cmFuc2xhdGUuY3VycmVudExhbmcgJiYgdGhpcy50cmFuc2xhdGUuaW5zdGFudCkge1xyXG4gICAgICBncm91cEJ5Q29sdW1uSGVhZGVyID0gdGhpcy50cmFuc2xhdGUuaW5zdGFudCgnR1JPVVBfQlknKTtcclxuICAgIH0gZWxzZSBpZiAoIWdyb3VwQnlDb2x1bW5IZWFkZXIpIHtcclxuICAgICAgZ3JvdXBCeUNvbHVtbkhlYWRlciA9IHRoaXMuX2xvY2FsZXMgJiYgdGhpcy5fbG9jYWxlcy5URVhUX0dST1VQX0JZO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGdldCBncm91cGVkIGNvbHVtbiB0aXRsZXMgYW5kIGlmIGZvdW5kLCB3ZSB3aWxsIGFkZCBhIFwiR3JvdXAgYnlcIiBjb2x1bW4gYXQgdGhlIGZpcnN0IGNvbHVtbiBpbmRleFxyXG4gICAgLy8gaWYgaXQncyBhIENTViBmb3JtYXQsIHdlJ2xsIGVzY2FwZSB0aGUgdGV4dCBpbiBkb3VibGUgcXVvdGVzXHJcbiAgICBjb25zdCBncm91cGluZyA9IHRoaXMuX2RhdGFWaWV3ICYmIHRoaXMuX2RhdGFWaWV3LmdldEdyb3VwaW5nICYmIHRoaXMuX2RhdGFWaWV3LmdldEdyb3VwaW5nKCk7XHJcbiAgICBpZiAoZ3JvdXBpbmcgJiYgQXJyYXkuaXNBcnJheShncm91cGluZykgJiYgZ3JvdXBpbmcubGVuZ3RoID4gMCkge1xyXG4gICAgICB0aGlzLl9oYXNHcm91cGVkSXRlbXMgPSB0cnVlO1xyXG4gICAgICByZXR1cm4gZ3JvdXBCeUNvbHVtbkhlYWRlcjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX2hhc0dyb3VwZWRJdGVtcyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgYWxsIGhlYWRlciB0aXRsZXMgYW5kIHRoZWlyIGtleXMsIHRyYW5zbGF0ZSB0aGUgdGl0bGUgd2hlbiByZXF1aXJlZC5cclxuICAgKiBAcGFyYW0gY29sdW1ucyBvZiB0aGUgZ3JpZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0Q29sdW1uSGVhZGVycyhjb2x1bW5zOiBDb2x1bW5bXSk6IEtleVRpdGxlUGFpcltdIHtcclxuICAgIGlmICghY29sdW1ucyB8fCAhQXJyYXkuaXNBcnJheShjb2x1bW5zKSB8fCBjb2x1bW5zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IGNvbHVtbkhlYWRlcnMgPSBbXTtcclxuXHJcbiAgICAvLyBQb3B1bGF0ZSB0aGUgQ29sdW1uIEhlYWRlciwgcHVsbCB0aGUgbmFtZSBkZWZpbmVkXHJcbiAgICBjb2x1bW5zLmZvckVhY2goKGNvbHVtbkRlZikgPT4ge1xyXG4gICAgICBsZXQgaGVhZGVyVGl0bGUgPSAnJztcclxuICAgICAgaWYgKChjb2x1bW5EZWYuaGVhZGVyS2V5IHx8IGNvbHVtbkRlZi5uYW1lS2V5KSAmJiB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVUcmFuc2xhdGUgJiYgdGhpcy50cmFuc2xhdGUgJiYgdGhpcy50cmFuc2xhdGUuY3VycmVudExhbmcgJiYgdGhpcy50cmFuc2xhdGUuaW5zdGFudCkge1xyXG4gICAgICAgIGhlYWRlclRpdGxlID0gdGhpcy50cmFuc2xhdGUuaW5zdGFudCgoY29sdW1uRGVmLmhlYWRlcktleSB8fCBjb2x1bW5EZWYubmFtZUtleSkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGhlYWRlclRpdGxlID0gY29sdW1uRGVmLm5hbWUgfHwgdGl0bGVDYXNlKGNvbHVtbkRlZi5maWVsZCk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgc2tpcHBlZEZpZWxkID0gY29sdW1uRGVmLmV4Y2x1ZGVGcm9tRXhwb3J0IHx8IGZhbHNlO1xyXG5cclxuICAgICAgLy8gaWYgY29sdW1uIHdpZHRoIGlzIDAsIHRoZW4gd2UgY29uc2lkZXIgdGhhdCBmaWVsZCBhcyBhIGhpZGRlbiBmaWVsZCBhbmQgc2hvdWxkIG5vdCBiZSBwYXJ0IG9mIHRoZSBleHBvcnRcclxuICAgICAgaWYgKChjb2x1bW5EZWYud2lkdGggPT09IHVuZGVmaW5lZCB8fCBjb2x1bW5EZWYud2lkdGggPiAwKSAmJiAhc2tpcHBlZEZpZWxkKSB7XHJcbiAgICAgICAgY29sdW1uSGVhZGVycy5wdXNoKHtcclxuICAgICAgICAgIGtleTogY29sdW1uRGVmLmZpZWxkIHx8IGNvbHVtbkRlZi5pZCxcclxuICAgICAgICAgIHRpdGxlOiBoZWFkZXJUaXRsZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gY29sdW1uSGVhZGVycztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhbGwgdGhlIGdyaWQgcm93IGRhdGEgYW5kIHJldHVybiB0aGF0IGFzIGFuIG91dHB1dCBzdHJpbmdcclxuICAgKi9cclxuICBwcml2YXRlIHB1c2hBbGxHcmlkUm93RGF0YVRvQXJyYXkob3JpZ2luYWxEYXJhQXJyYXk6IHN0cmluZ1tdW10sIGNvbHVtbnM6IENvbHVtbltdKTogc3RyaW5nW11bXSB8IEV4Y2VsQ2VsbEZvcm1hdFtdW10ge1xyXG4gICAgY29uc3QgbGluZUNvdW50ID0gdGhpcy5fZGF0YVZpZXcgJiYgdGhpcy5fZGF0YVZpZXcuZ2V0TGVuZ3RoICYmIHRoaXMuX2RhdGFWaWV3LmdldExlbmd0aCgpO1xyXG5cclxuICAgIC8vIGxvb3AgdGhyb3VnaCBhbGwgdGhlIGdyaWQgcm93cyBvZiBkYXRhXHJcbiAgICBmb3IgKGxldCByb3dOdW1iZXIgPSAwOyByb3dOdW1iZXIgPCBsaW5lQ291bnQ7IHJvd051bWJlcisrKSB7XHJcbiAgICAgIGNvbnN0IGl0ZW1PYmogPSB0aGlzLl9kYXRhVmlldy5nZXRJdGVtKHJvd051bWJlcik7XHJcbiAgICAgIGlmIChpdGVtT2JqICE9IG51bGwpIHtcclxuICAgICAgICAvLyBOb3JtYWwgcm93IChub3QgZ3JvdXBlZCBieSBhbnl0aGluZykgd291bGQgaGF2ZSBhbiBJRCB3aGljaCB3YXMgcHJlZGVmaW5lZCBpbiB0aGUgR3JpZCBDb2x1bW5zIGRlZmluaXRpb25cclxuICAgICAgICBpZiAoaXRlbU9ialt0aGlzLmRhdGFzZXRJZE5hbWVdICE9IG51bGwpIHtcclxuICAgICAgICAgIC8vIGdldCByZWd1bGFyIHJvdyBpdGVtIGRhdGFcclxuICAgICAgICAgIG9yaWdpbmFsRGFyYUFycmF5LnB1c2godGhpcy5yZWFkUmVndWxhclJvd0RhdGEoY29sdW1ucywgcm93TnVtYmVyLCBpdGVtT2JqKSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9oYXNHcm91cGVkSXRlbXMgJiYgaXRlbU9iai5fX2dyb3VwVG90YWxzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIC8vIGdldCB0aGUgZ3JvdXAgcm93XHJcbiAgICAgICAgICBvcmlnaW5hbERhcmFBcnJheS5wdXNoKFt0aGlzLnJlYWRHcm91cGVkVGl0bGVSb3coaXRlbU9iaildKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGl0ZW1PYmouX19ncm91cFRvdGFscykge1xyXG4gICAgICAgICAgLy8gZWxzZSBpZiB0aGUgcm93IGlzIGEgR3JvdXAgQnkgYW5kIHdlIGhhdmUgYWdyZWdnYXRvcnMsIHRoZW4gYSBwcm9wZXJ0eSBvZiAnX19ncm91cFRvdGFscycgd291bGQgZXhpc3QgdW5kZXIgdGhhdCBvYmplY3RcclxuICAgICAgICAgIG9yaWdpbmFsRGFyYUFycmF5LnB1c2godGhpcy5yZWFkR3JvdXBlZFRvdGFsUm93KGNvbHVtbnMsIGl0ZW1PYmopKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvcmlnaW5hbERhcmFBcnJheTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZGF0YSBvZiBhIHJlZ3VsYXIgcm93IChhIHJvdyB3aXRob3V0IGdyb3VwaW5nKVxyXG4gICAqIEBwYXJhbSByb3dcclxuICAgKiBAcGFyYW0gaXRlbU9ialxyXG4gICAqL1xyXG4gIHByaXZhdGUgcmVhZFJlZ3VsYXJSb3dEYXRhKGNvbHVtbnM6IENvbHVtbltdLCByb3c6IG51bWJlciwgaXRlbU9iajogYW55KTogc3RyaW5nW10ge1xyXG4gICAgbGV0IGlkeCA9IDA7XHJcbiAgICBjb25zdCByb3dPdXRwdXRTdHJpbmdzID0gW107XHJcblxyXG4gICAgZm9yIChsZXQgY29sID0gMCwgbG4gPSBjb2x1bW5zLmxlbmd0aDsgY29sIDwgbG47IGNvbCsrKSB7XHJcbiAgICAgIGNvbnN0IGNvbHVtbkRlZiA9IGNvbHVtbnNbY29sXTtcclxuICAgICAgY29uc3QgZmllbGRUeXBlID0gY29sdW1uRGVmLm91dHB1dFR5cGUgfHwgY29sdW1uRGVmLnR5cGUgfHwgRmllbGRUeXBlLnN0cmluZztcclxuXHJcbiAgICAgIC8vIHNraXAgZXhjbHVkZWQgY29sdW1uXHJcbiAgICAgIGlmIChjb2x1bW5EZWYuZXhjbHVkZUZyb21FeHBvcnQpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gaWYgd2UgYXJlIGdyb3VwaW5nIGFuZCBhcmUgb24gMXN0IGNvbHVtbiBpbmRleCwgd2UgbmVlZCB0byBza2lwIHRoaXMgY29sdW1uIHNpbmNlIGl0IHdpbGwgYmUgdXNlZCBsYXRlciBieSB0aGUgZ3JvdXBpbmcgdGV4dDo6IEdyb3VwIGJ5IFtjb2x1bW5YXVxyXG4gICAgICBpZiAodGhpcy5faGFzR3JvdXBlZEl0ZW1zICYmIGlkeCA9PT0gMCkge1xyXG4gICAgICAgIHJvd091dHB1dFN0cmluZ3MucHVzaCgnJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGdldCB0aGUgb3V0cHV0IGJ5IGFuYWx5emluZyBpZiB3ZSdsbCBwdWxsIHRoZSB2YWx1ZSBmcm9tIHRoZSBjZWxsIG9yIGZyb20gYSBmb3JtYXR0ZXJcclxuICAgICAgbGV0IGl0ZW1EYXRhOiBFeGNlbENlbGxGb3JtYXQgfCBzdHJpbmcgPSBleHBvcnRXaXRoRm9ybWF0dGVyV2hlbkRlZmluZWQocm93LCBjb2wsIGl0ZW1PYmosIGNvbHVtbkRlZiwgdGhpcy5fZ3JpZCwgdGhpcy5fZXhjZWxFeHBvcnRPcHRpb25zKTtcclxuXHJcbiAgICAgIC8vIGRvZXMgdGhlIHVzZXIgd2FudCB0byBzYW5pdGl6ZSB0aGUgb3V0cHV0IGRhdGEgKHJlbW92ZSBIVE1MIHRhZ3MpP1xyXG4gICAgICBpZiAoY29sdW1uRGVmLnNhbml0aXplRGF0YUV4cG9ydCB8fCB0aGlzLl9leGNlbEV4cG9ydE9wdGlvbnMuc2FuaXRpemVEYXRhRXhwb3J0KSB7XHJcbiAgICAgICAgaXRlbURhdGEgPSBzYW5pdGl6ZUh0bWxUb1RleHQoaXRlbURhdGEgYXMgc3RyaW5nKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gdXNlIGRpZmZlcmVudCBFeGNlbCBTdHlsZXNoZWV0IEZvcm1hdCBhcyBwZXIgdGhlIEZpZWxkIFR5cGVcclxuICAgICAgaWYgKCFjb2x1bW5EZWYuZXhwb3J0V2l0aEZvcm1hdHRlcikge1xyXG4gICAgICAgIGl0ZW1EYXRhID0gdGhpcy51c2VDZWxsRm9ybWF0QnlGaWVsZFR5cGUoaXRlbURhdGEgYXMgc3RyaW5nLCBmaWVsZFR5cGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByb3dPdXRwdXRTdHJpbmdzLnB1c2goaXRlbURhdGEpO1xyXG4gICAgICBpZHgrKztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcm93T3V0cHV0U3RyaW5ncztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZ3JvdXBlZCB0aXRsZShzKSBhbmQgaXRzIGdyb3VwIHRpdGxlIGZvcm1hdHRlciwgZm9yIGV4YW1wbGUgaWYgd2UgZ3JvdXBlZCBieSBzYWxlc1JlcCwgdGhlIHJldHVybmVkIHJlc3VsdCB3b3VsZCBiZTo6ICdTYWxlcyBSZXA6IEpvaG4gRG93ICgyIGl0ZW1zKSdcclxuICAgKiBAcGFyYW0gaXRlbU9ialxyXG4gICAqL1xyXG4gIHByaXZhdGUgcmVhZEdyb3VwZWRUaXRsZVJvdyhpdGVtT2JqOiBhbnkpOiBzdHJpbmcge1xyXG4gICAgY29uc3QgZ3JvdXBOYW1lID0gc2FuaXRpemVIdG1sVG9UZXh0KGl0ZW1PYmoudGl0bGUpO1xyXG5cclxuICAgIGlmICh0aGlzLl9leGNlbEV4cG9ydE9wdGlvbnMgJiYgdGhpcy5fZXhjZWxFeHBvcnRPcHRpb25zLmFkZEdyb3VwSW5kZW50YXRpb24pIHtcclxuICAgICAgY29uc3QgY29sbGFwc2VkU3ltYm9sID0gdGhpcy5fZXhjZWxFeHBvcnRPcHRpb25zICYmIHRoaXMuX2V4Y2VsRXhwb3J0T3B0aW9ucy5ncm91cENvbGxhcHNlZFN5bWJvbCB8fCAnXFx1MjVCOSc7XHJcbiAgICAgIGNvbnN0IGV4cGFuZGVkU3ltYm9sID0gdGhpcy5fZXhjZWxFeHBvcnRPcHRpb25zICYmIHRoaXMuX2V4Y2VsRXhwb3J0T3B0aW9ucy5ncm91cEV4cGFuZGVkU3ltYm9sIHx8ICdcXHUyNUJGJztcclxuICAgICAgY29uc3QgY2hldnJvbiA9IGl0ZW1PYmouY29sbGFwc2VkID8gY29sbGFwc2VkU3ltYm9sIDogZXhwYW5kZWRTeW1ib2w7XHJcbiAgICAgIHJldHVybiBjaGV2cm9uICsgJyAnICsgYWRkV2hpdGVTcGFjZXMoNSAqIGl0ZW1PYmoubGV2ZWwpICsgZ3JvdXBOYW1lO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdyb3VwTmFtZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZ3JvdXBlZCB0b3RhbHMgKGJlbG93IHRoZSByZWd1bGFyIHJvd3MpLCB0aGVzZSBhcmUgc2V0IGJ5IFNsaWNrIEFnZ3JlZ2F0b3JzLlxyXG4gICAqIEZvciBleGFtcGxlIGlmIHdlIGdyb3VwZWQgYnkgXCJzYWxlc1JlcFwiIGFuZCB3ZSBoYXZlIGEgU3VtIEFnZ3JlZ2F0b3Igb24gXCJzYWxlc1wiLCB0aGVuIHRoZSByZXR1cm5lZCBvdXRwdXQgd291bGQgYmU6OiBbXCJTdW0gMTIzJFwiXVxyXG4gICAqIEBwYXJhbSBpdGVtT2JqXHJcbiAgICovXHJcbiAgcHJpdmF0ZSByZWFkR3JvdXBlZFRvdGFsUm93KGNvbHVtbnM6IENvbHVtbltdLCBpdGVtT2JqOiBhbnkpOiBzdHJpbmdbXSB7XHJcbiAgICBjb25zdCBncm91cGluZ0FnZ3JlZ2F0b3JSb3dUZXh0ID0gdGhpcy5fZXhjZWxFeHBvcnRPcHRpb25zLmdyb3VwaW5nQWdncmVnYXRvclJvd1RleHQgfHwgJyc7XHJcbiAgICBjb25zdCBvdXRwdXRTdHJpbmdzID0gW2dyb3VwaW5nQWdncmVnYXRvclJvd1RleHRdO1xyXG5cclxuICAgIGNvbHVtbnMuZm9yRWFjaCgoY29sdW1uRGVmKSA9PiB7XHJcbiAgICAgIGxldCBpdGVtRGF0YSA9ICcnO1xyXG5cclxuICAgICAgY29uc3Qgc2tpcHBlZEZpZWxkID0gY29sdW1uRGVmLmV4Y2x1ZGVGcm9tRXhwb3J0IHx8IGZhbHNlO1xyXG5cclxuICAgICAgLy8gaWYgdGhlcmUncyBhIGdyb3VwVG90YWxzRm9ybWF0dGVyLCB3ZSB3aWxsIHJlLXJ1biBpdCB0byBnZXQgdGhlIGV4YWN0IHNhbWUgb3V0cHV0IGFzIHdoYXQgaXMgc2hvd24gaW4gVUlcclxuICAgICAgaWYgKGNvbHVtbkRlZi5ncm91cFRvdGFsc0Zvcm1hdHRlcikge1xyXG4gICAgICAgIGl0ZW1EYXRhID0gY29sdW1uRGVmLmdyb3VwVG90YWxzRm9ybWF0dGVyKGl0ZW1PYmosIGNvbHVtbkRlZik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGRvZXMgdGhlIHVzZXIgd2FudCB0byBzYW5pdGl6ZSB0aGUgb3V0cHV0IGRhdGEgKHJlbW92ZSBIVE1MIHRhZ3MpP1xyXG4gICAgICBpZiAoY29sdW1uRGVmLnNhbml0aXplRGF0YUV4cG9ydCB8fCB0aGlzLl9leGNlbEV4cG9ydE9wdGlvbnMuc2FuaXRpemVEYXRhRXhwb3J0KSB7XHJcbiAgICAgICAgaXRlbURhdGEgPSBzYW5pdGl6ZUh0bWxUb1RleHQoaXRlbURhdGEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBhZGQgdGhlIGNvbHVtbiAodW5sZXNzIHVzZXIgd2FudHMgdG8gc2tpcCBpdClcclxuICAgICAgaWYgKChjb2x1bW5EZWYud2lkdGggPT09IHVuZGVmaW5lZCB8fCBjb2x1bW5EZWYud2lkdGggPiAwKSAmJiAhc2tpcHBlZEZpZWxkKSB7XHJcbiAgICAgICAgb3V0cHV0U3RyaW5ncy5wdXNoKGl0ZW1EYXRhKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIG91dHB1dFN0cmluZ3M7XHJcbiAgfVxyXG59XHJcbiJdfQ==