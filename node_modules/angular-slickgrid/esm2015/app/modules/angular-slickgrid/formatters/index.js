import { FieldType } from '../models/index';
import { getAssociatedDateFormatter } from './formatterUtilities';
import { arrayObjectToCsvFormatter } from './arrayObjectToCsvFormatter';
import { arrayToCsvFormatter } from './arrayToCsvFormatter';
import { boldFormatter } from './boldFormatter';
import { checkboxFormatter } from './checkboxFormatter';
import { checkmarkFormatter } from './checkmarkFormatter';
import { collectionFormatter } from './collectionFormatter';
import { collectionEditorFormatter } from './collectionEditorFormatter';
import { complexObjectFormatter } from './complexObjectFormatter';
import { decimalFormatter } from './decimalFormatter';
import { deleteIconFormatter } from './deleteIconFormatter';
import { dollarColoredBoldFormatter } from './dollarColoredBoldFormatter';
import { dollarColoredFormatter } from './dollarColoredFormatter';
import { dollarFormatter } from './dollarFormatter';
import { editIconFormatter } from './editIconFormatter';
import { hyperlinkFormatter } from './hyperlinkFormatter';
import { iconFormatter } from './iconFormatter';
import { infoIconFormatter } from './infoIconFormatter';
import { italicFormatter } from './italicFormatter';
import { lowercaseFormatter } from './lowercaseFormatter';
import { maskFormatter } from './maskFormatter';
import { multipleFormatter } from './multipleFormatter';
import { percentFormatter } from './percentFormatter';
import { percentCompleteBarFormatter } from './percentCompleteBarFormatter';
import { percentCompleteFormatter } from './percentCompleteFormatter';
import { percentSymbolFormatter } from './percentSymbolFormatter';
import { progressBarFormatter } from './progressBarFormatter';
import { translateFormatter } from './translateFormatter';
import { translateBooleanFormatter } from './translateBooleanFormatter';
import { uppercaseFormatter } from './uppercaseFormatter';
import { yesNoFormatter } from './yesNoFormatter';
import { bsDropdownFormatter } from './bsDropdownFormatter';
/** Provides a list of different Formatters that will change the cell value displayed in the UI */
export const Formatters = {
    /**
     * Takes an array of complex objects converts it to a comma delimited string.
     * Requires to pass an array of "propertyNames" in the column definition the generic "params" property
     * For example, if we have an array of user objects that have the property of firstName & lastName then we need to pass in your column definition::
     * params: { propertyNames: ['firtName', 'lastName'] } => 'John Doe, Jane Doe'
     */
    arrayObjectToCsv: arrayObjectToCsvFormatter,
    /** Takes an array of string and converts it to a comma delimited string */
    arrayToCsv: arrayToCsvFormatter,
    /** show value in bold font weight */
    bold: boldFormatter,
    /** boostrap dropdown formatter */
    bsDropdown: bsDropdownFormatter,
    /** When value is filled (true), it will display a checkbox Unicode icon */
    checkbox: checkboxFormatter,
    /**
     * When value is filled, or if the value is a number and is bigger than 0, it will display a Font-Awesome icon (fa-check).
     * The icon will NOT be displayed when the value is any of the following ("false", false, "0", 0, -0.5, null, undefined)
     * Anything else than the condition specified will display the icon, so a text with "00123" will display the icon but "0" will not.
     * Also note that a string ("null", "undefined") will display the icon but (null, undefined) will not, so the typeof is also important
     */
    checkmark: checkmarkFormatter,
    /**
     * Takes a complex data object and return the data under that property (for example: "user.firstName" will return the first name "John")
     * You can pass the complex structure in the "field" or the "params: { complexField: string }" properties.
     * For example::
     * this.columnDefs = [{ id: 'username', field: 'user.firstName', ... }]
     * OR this.columnDefs = [{ id: 'username', field: 'user', params: { complexField: 'user.firstName' }, ... }]
     */
    complexObject: complexObjectFormatter,
    /**
     * Looks up values from the columnDefinition.params.collection property and displays the label in CSV or string format
     * @example
     * // the grid will display 'foo' and 'bar' and not 1 and 2 from your dataset
     * { params: { collection: [{ value: 1, label: 'foo'}, {value: 2, label: 'bar' }] }}
     * const dataset = [1, 2];
     */
    collection: collectionFormatter,
    /**
     * Roughly the same as the "collectionFormatter" except that it
     * looks up values from the columnDefinition.editor.collection (instead of params) property and displays the label in CSV or string format
     * @example
     * // the grid will display 'foo' and 'bar' and not 1 and 2 from your dataset
     * { editor: { collection: [{ value: 1, label: 'foo'}, {value: 2, label: 'bar' }] }}
     * const dataset = [1, 2];
     */
    collectionEditor: collectionEditorFormatter,
    /** Takes a Date object and displays it as an ISO Date format (YYYY-MM-DD) */
    dateIso: getAssociatedDateFormatter(FieldType.dateIso, '-'),
    /** Takes a Date object and displays it as an ISO Date+Time format (YYYY-MM-DD HH:mm:ss) */
    dateTimeIso: getAssociatedDateFormatter(FieldType.dateTimeIso, '-'),
    /** Takes a Date object and displays it as an ISO Date+Time (without seconds) format (YYYY-MM-DD HH:mm) */
    dateTimeShortIso: getAssociatedDateFormatter(FieldType.dateTimeShortIso, '-'),
    /** Takes a Date object and displays it as an ISO Date+Time+(am/pm) format (YYYY-MM-DD h:mm:ss a) */
    dateTimeIsoAmPm: getAssociatedDateFormatter(FieldType.dateTimeIsoAmPm, '-'),
    /** Takes a Date object and displays it as an Euro Date format (DD/MM/YYYY) */
    dateEuro: getAssociatedDateFormatter(FieldType.dateEuro, '/'),
    /** Takes a Date object and displays it as an Euro Date+Time format (DD/MM/YYYY HH:mm:ss) */
    dateTimeEuro: getAssociatedDateFormatter(FieldType.dateTimeEuro, '/'),
    /** Takes a Date object and displays it as an Euro Date+Time (without seconds) format (DD/MM/YYYY HH:mm) */
    dateTimeShortEuro: getAssociatedDateFormatter(FieldType.dateTimeShortEuro, '/'),
    /** Takes a Date object and displays it as an Euro Date+Time+(am/pm) format (DD/MM/YYYY hh:mm:ss a) */
    dateTimeEuroAmPm: getAssociatedDateFormatter(FieldType.dateTimeEuroAmPm, '/'),
    /** Takes a Date object and displays it as an US Date format (MM/DD/YYYY) */
    dateUs: getAssociatedDateFormatter(FieldType.dateUs, '/'),
    /** Takes a Date object and displays it as an US Date+Time format (MM/DD/YYYY HH:mm:ss) */
    dateTimeUs: getAssociatedDateFormatter(FieldType.dateTimeUs, '/'),
    /** Takes a Date object and displays it as an US Date+Time (without seconds) format (MM/DD/YYYY HH:mm:ss) */
    dateTimeShortUs: getAssociatedDateFormatter(FieldType.dateTimeShortUs, '/'),
    /** Takes a Date object and displays it as an US Date+Time+(am/pm) format (MM/DD/YYYY hh:mm:ss a) */
    dateTimeUsAmPm: getAssociatedDateFormatter(FieldType.dateTimeUsAmPm, '/'),
    /** Displays a Font-Awesome delete icon (fa-trash) */
    deleteIcon: deleteIconFormatter,
    /**
     * Display the value as x decimals formatted, defaults to 2 decimals.
     * You can pass "decimalPlaces" or "minDecimalPlaces" and/or "maxDecimalPlaces" to the "params" property.
     * For example:: `{ formatter: Formatters.decimal, params: { decimalPlaces: 3 }}`
     * The property "decimalPlaces" is an alias of "minDecimalPlaces"
     */
    decimal: decimalFormatter,
    /** Display the value as 2 decimals formatted with dollar sign '$' at the end of of the value */
    dollar: dollarFormatter,
    /** Display the value as 2 decimals formatted with dollar sign '$' at the end of of the value, change color of text to red/green on negative/positive value */
    dollarColored: dollarColoredFormatter,
    /** Display the value as 2 decimals formatted with dollar sign '$' at the end of of the value, change color of text to red/green on negative/positive value, show it in bold font weight as well */
    dollarColoredBold: dollarColoredBoldFormatter,
    /** Displays a Font-Awesome edit icon (fa-pencil) */
    editIcon: editIconFormatter,
    /**
     * Takes an hyperlink cell value and transforms it into a real hyperlink, given that the value starts with 1 of these (http|ftp|https).
     * The structure will be "<a href="hyperlink">hyperlink</a>"
     *
     * You can optionally change the hyperlink text displayed by using the generic params "hyperlinkText" in the column definition
     * For example: { id: 'link', field: 'link', params: { hyperlinkText: 'Company Website' } } will display "<a href="link">Company Website</a>"
     *
     * You can also optionally provide the hyperlink URL by using the generic params "hyperlinkUrl" in the column definition
     * For example: { id: 'link', field: 'link', params: {  hyperlinkText: 'Company Website', hyperlinkUrl: 'http://www.somewhere.com' } } will display "<a href="http://www.somewhere.com">Company Website</a>"
     */
    hyperlink: hyperlinkFormatter,
    /** Display whichever icon you want (library agnostic, it could be Font-Awesome or any other) */
    icon: iconFormatter,
    /** Displays a Font-Awesome edit icon (fa-info-circle) */
    infoIcon: infoIconFormatter,
    /** show input text value as italic text */
    italic: italicFormatter,
    /** Takes a value and displays it all lowercase */
    lowercase: lowercaseFormatter,
    /**
     * Takes a value display it according to a mask provided
     * e.: 1234567890 with mask "(000) 000-0000" will display "(123) 456-7890"
     */
    mask: maskFormatter,
    /**
     * You can pipe multiple formatters (executed in sequence), use params to pass the list of formatters.
     * Requires to pass an array of "formatters" in the column definition the generic "params" property
     * For example::
     * { field: 'title', formatter: Formatters.multiple, params: { formatters: [ Formatters.lowercase, Formatters.uppercase ] }
     */
    multiple: multipleFormatter,
    /** Takes a cell value number (between 0.0-1.0) and displays a red (<50) or green (>=50) bar */
    percent: percentFormatter,
    /** Takes a cell value number (between 0.0-100) and displays a red (<50) or green (>=50) bar */
    percentComplete: percentCompleteFormatter,
    /** Takes a cell value number (between 0-100) and displays Bootstrap "percent-complete-bar" a red (<30), silver (>30 & <70) or green (>=70) bar */
    percentCompleteBar: percentCompleteBarFormatter,
    /** Takes a cell value number (between 0-100) and add the "%" after the number */
    percentSymbol: percentSymbolFormatter,
    /** Takes a cell value number (between 0-100) and displays Bootstrap "progress-bar" a red (<30), silver (>30 & <70) or green (>=70) bar */
    progressBar: progressBarFormatter,
    /** Takes a cell value and translates it (i18n). Requires an instance of the Translate Service:: `i18n: this.translate */
    translate: translateFormatter,
    /** Takes a boolean value, cast it to upperCase string and finally translates it (i18n). */
    translateBoolean: translateBooleanFormatter,
    /** Takes a value and displays it all uppercase */
    uppercase: uppercaseFormatter,
    /** Takes a boolean value and display a string 'Yes' or 'No' */
    yesNo: yesNoFormatter
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyLXNsaWNrZ3JpZC8iLCJzb3VyY2VzIjpbImFwcC9tb2R1bGVzL2FuZ3VsYXItc2xpY2tncmlkL2Zvcm1hdHRlcnMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzVDLE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ2xFLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQ3hFLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzVELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNoRCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN4RCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUMxRCxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUM1RCxPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUN4RSxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUNsRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUN0RCxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUM1RCxPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUMxRSxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUNsRSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDcEQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDeEQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDMUQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ2hELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3hELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNwRCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUMxRCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDaEQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDeEQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDdEQsT0FBTyxFQUFFLDJCQUEyQixFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFDNUUsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDdEUsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDbEUsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDOUQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDMUQsT0FBTyxFQUFFLHlCQUF5QixFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFDeEUsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDMUQsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ2xELE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRTVELGtHQUFrRztBQUNsRyxNQUFNLENBQUMsTUFBTSxVQUFVLEdBQUc7SUFDeEI7Ozs7O09BS0c7SUFDSCxnQkFBZ0IsRUFBRSx5QkFBeUI7SUFFM0MsMkVBQTJFO0lBQzNFLFVBQVUsRUFBRSxtQkFBbUI7SUFFL0IscUNBQXFDO0lBQ3JDLElBQUksRUFBRSxhQUFhO0lBRW5CLGtDQUFrQztJQUNsQyxVQUFVLEVBQUUsbUJBQW1CO0lBRS9CLDJFQUEyRTtJQUMzRSxRQUFRLEVBQUUsaUJBQWlCO0lBRTNCOzs7OztPQUtHO0lBQ0gsU0FBUyxFQUFFLGtCQUFrQjtJQUU3Qjs7Ozs7O09BTUc7SUFDSCxhQUFhLEVBQUUsc0JBQXNCO0lBRXJDOzs7Ozs7T0FNRztJQUNILFVBQVUsRUFBRSxtQkFBbUI7SUFFL0I7Ozs7Ozs7T0FPRztJQUNILGdCQUFnQixFQUFFLHlCQUF5QjtJQUUzQyw2RUFBNkU7SUFDN0UsT0FBTyxFQUFFLDBCQUEwQixDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFDO0lBRTNELDJGQUEyRjtJQUMzRixXQUFXLEVBQUUsMEJBQTBCLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBRSxHQUFHLENBQUM7SUFFbkUsMEdBQTBHO0lBQzFHLGdCQUFnQixFQUFFLDBCQUEwQixDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsRUFBRSxHQUFHLENBQUM7SUFFN0Usb0dBQW9HO0lBQ3BHLGVBQWUsRUFBRSwwQkFBMEIsQ0FBQyxTQUFTLENBQUMsZUFBZSxFQUFFLEdBQUcsQ0FBQztJQUUzRSw4RUFBOEU7SUFDOUUsUUFBUSxFQUFFLDBCQUEwQixDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDO0lBRTdELDRGQUE0RjtJQUM1RixZQUFZLEVBQUUsMEJBQTBCLENBQUMsU0FBUyxDQUFDLFlBQVksRUFBRSxHQUFHLENBQUM7SUFFckUsMkdBQTJHO0lBQzNHLGlCQUFpQixFQUFFLDBCQUEwQixDQUFDLFNBQVMsQ0FBQyxpQkFBaUIsRUFBRSxHQUFHLENBQUM7SUFFL0Usc0dBQXNHO0lBQ3RHLGdCQUFnQixFQUFFLDBCQUEwQixDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsRUFBRSxHQUFHLENBQUM7SUFFN0UsNEVBQTRFO0lBQzVFLE1BQU0sRUFBRSwwQkFBMEIsQ0FBQyxTQUFTLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQztJQUV6RCwwRkFBMEY7SUFDMUYsVUFBVSxFQUFFLDBCQUEwQixDQUFDLFNBQVMsQ0FBQyxVQUFVLEVBQUUsR0FBRyxDQUFDO0lBRWpFLDRHQUE0RztJQUM1RyxlQUFlLEVBQUUsMEJBQTBCLENBQUMsU0FBUyxDQUFDLGVBQWUsRUFBRSxHQUFHLENBQUM7SUFFM0Usb0dBQW9HO0lBQ3BHLGNBQWMsRUFBRSwwQkFBMEIsQ0FBQyxTQUFTLENBQUMsY0FBYyxFQUFFLEdBQUcsQ0FBQztJQUV6RSxxREFBcUQ7SUFDckQsVUFBVSxFQUFFLG1CQUFtQjtJQUUvQjs7Ozs7T0FLRztJQUNILE9BQU8sRUFBRSxnQkFBZ0I7SUFFekIsZ0dBQWdHO0lBQ2hHLE1BQU0sRUFBRSxlQUFlO0lBRXZCLDhKQUE4SjtJQUM5SixhQUFhLEVBQUUsc0JBQXNCO0lBRXJDLG1NQUFtTTtJQUNuTSxpQkFBaUIsRUFBRSwwQkFBMEI7SUFFN0Msb0RBQW9EO0lBQ3BELFFBQVEsRUFBRSxpQkFBaUI7SUFFM0I7Ozs7Ozs7OztPQVNHO0lBQ0gsU0FBUyxFQUFFLGtCQUFrQjtJQUU3QixnR0FBZ0c7SUFDaEcsSUFBSSxFQUFFLGFBQWE7SUFFbkIseURBQXlEO0lBQ3pELFFBQVEsRUFBRSxpQkFBaUI7SUFFM0IsMkNBQTJDO0lBQzNDLE1BQU0sRUFBRSxlQUFlO0lBRXZCLGtEQUFrRDtJQUNsRCxTQUFTLEVBQUUsa0JBQWtCO0lBRTdCOzs7T0FHRztJQUNILElBQUksRUFBRSxhQUFhO0lBRW5COzs7OztPQUtHO0lBQ0gsUUFBUSxFQUFFLGlCQUFpQjtJQUUzQiwrRkFBK0Y7SUFDL0YsT0FBTyxFQUFFLGdCQUFnQjtJQUV6QiwrRkFBK0Y7SUFDL0YsZUFBZSxFQUFFLHdCQUF3QjtJQUV6QyxrSkFBa0o7SUFDbEosa0JBQWtCLEVBQUUsMkJBQTJCO0lBRS9DLGlGQUFpRjtJQUNqRixhQUFhLEVBQUUsc0JBQXNCO0lBRXJDLDBJQUEwSTtJQUMxSSxXQUFXLEVBQUUsb0JBQW9CO0lBRWpDLHlIQUF5SDtJQUN6SCxTQUFTLEVBQUUsa0JBQWtCO0lBRTdCLDJGQUEyRjtJQUMzRixnQkFBZ0IsRUFBRSx5QkFBeUI7SUFFM0Msa0RBQWtEO0lBQ2xELFNBQVMsRUFBRSxrQkFBa0I7SUFFN0IsK0RBQStEO0lBQy9ELEtBQUssRUFBRSxjQUFjO0NBQ3RCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBGaWVsZFR5cGUgfSBmcm9tICcuLi9tb2RlbHMvaW5kZXgnO1xuaW1wb3J0IHsgZ2V0QXNzb2NpYXRlZERhdGVGb3JtYXR0ZXIgfSBmcm9tICcuL2Zvcm1hdHRlclV0aWxpdGllcyc7XG5pbXBvcnQgeyBhcnJheU9iamVjdFRvQ3N2Rm9ybWF0dGVyIH0gZnJvbSAnLi9hcnJheU9iamVjdFRvQ3N2Rm9ybWF0dGVyJztcbmltcG9ydCB7IGFycmF5VG9Dc3ZGb3JtYXR0ZXIgfSBmcm9tICcuL2FycmF5VG9Dc3ZGb3JtYXR0ZXInO1xuaW1wb3J0IHsgYm9sZEZvcm1hdHRlciB9IGZyb20gJy4vYm9sZEZvcm1hdHRlcic7XG5pbXBvcnQgeyBjaGVja2JveEZvcm1hdHRlciB9IGZyb20gJy4vY2hlY2tib3hGb3JtYXR0ZXInO1xuaW1wb3J0IHsgY2hlY2ttYXJrRm9ybWF0dGVyIH0gZnJvbSAnLi9jaGVja21hcmtGb3JtYXR0ZXInO1xuaW1wb3J0IHsgY29sbGVjdGlvbkZvcm1hdHRlciB9IGZyb20gJy4vY29sbGVjdGlvbkZvcm1hdHRlcic7XG5pbXBvcnQgeyBjb2xsZWN0aW9uRWRpdG9yRm9ybWF0dGVyIH0gZnJvbSAnLi9jb2xsZWN0aW9uRWRpdG9yRm9ybWF0dGVyJztcbmltcG9ydCB7IGNvbXBsZXhPYmplY3RGb3JtYXR0ZXIgfSBmcm9tICcuL2NvbXBsZXhPYmplY3RGb3JtYXR0ZXInO1xuaW1wb3J0IHsgZGVjaW1hbEZvcm1hdHRlciB9IGZyb20gJy4vZGVjaW1hbEZvcm1hdHRlcic7XG5pbXBvcnQgeyBkZWxldGVJY29uRm9ybWF0dGVyIH0gZnJvbSAnLi9kZWxldGVJY29uRm9ybWF0dGVyJztcbmltcG9ydCB7IGRvbGxhckNvbG9yZWRCb2xkRm9ybWF0dGVyIH0gZnJvbSAnLi9kb2xsYXJDb2xvcmVkQm9sZEZvcm1hdHRlcic7XG5pbXBvcnQgeyBkb2xsYXJDb2xvcmVkRm9ybWF0dGVyIH0gZnJvbSAnLi9kb2xsYXJDb2xvcmVkRm9ybWF0dGVyJztcbmltcG9ydCB7IGRvbGxhckZvcm1hdHRlciB9IGZyb20gJy4vZG9sbGFyRm9ybWF0dGVyJztcbmltcG9ydCB7IGVkaXRJY29uRm9ybWF0dGVyIH0gZnJvbSAnLi9lZGl0SWNvbkZvcm1hdHRlcic7XG5pbXBvcnQgeyBoeXBlcmxpbmtGb3JtYXR0ZXIgfSBmcm9tICcuL2h5cGVybGlua0Zvcm1hdHRlcic7XG5pbXBvcnQgeyBpY29uRm9ybWF0dGVyIH0gZnJvbSAnLi9pY29uRm9ybWF0dGVyJztcbmltcG9ydCB7IGluZm9JY29uRm9ybWF0dGVyIH0gZnJvbSAnLi9pbmZvSWNvbkZvcm1hdHRlcic7XG5pbXBvcnQgeyBpdGFsaWNGb3JtYXR0ZXIgfSBmcm9tICcuL2l0YWxpY0Zvcm1hdHRlcic7XG5pbXBvcnQgeyBsb3dlcmNhc2VGb3JtYXR0ZXIgfSBmcm9tICcuL2xvd2VyY2FzZUZvcm1hdHRlcic7XG5pbXBvcnQgeyBtYXNrRm9ybWF0dGVyIH0gZnJvbSAnLi9tYXNrRm9ybWF0dGVyJztcbmltcG9ydCB7IG11bHRpcGxlRm9ybWF0dGVyIH0gZnJvbSAnLi9tdWx0aXBsZUZvcm1hdHRlcic7XG5pbXBvcnQgeyBwZXJjZW50Rm9ybWF0dGVyIH0gZnJvbSAnLi9wZXJjZW50Rm9ybWF0dGVyJztcbmltcG9ydCB7IHBlcmNlbnRDb21wbGV0ZUJhckZvcm1hdHRlciB9IGZyb20gJy4vcGVyY2VudENvbXBsZXRlQmFyRm9ybWF0dGVyJztcbmltcG9ydCB7IHBlcmNlbnRDb21wbGV0ZUZvcm1hdHRlciB9IGZyb20gJy4vcGVyY2VudENvbXBsZXRlRm9ybWF0dGVyJztcbmltcG9ydCB7IHBlcmNlbnRTeW1ib2xGb3JtYXR0ZXIgfSBmcm9tICcuL3BlcmNlbnRTeW1ib2xGb3JtYXR0ZXInO1xuaW1wb3J0IHsgcHJvZ3Jlc3NCYXJGb3JtYXR0ZXIgfSBmcm9tICcuL3Byb2dyZXNzQmFyRm9ybWF0dGVyJztcbmltcG9ydCB7IHRyYW5zbGF0ZUZvcm1hdHRlciB9IGZyb20gJy4vdHJhbnNsYXRlRm9ybWF0dGVyJztcbmltcG9ydCB7IHRyYW5zbGF0ZUJvb2xlYW5Gb3JtYXR0ZXIgfSBmcm9tICcuL3RyYW5zbGF0ZUJvb2xlYW5Gb3JtYXR0ZXInO1xuaW1wb3J0IHsgdXBwZXJjYXNlRm9ybWF0dGVyIH0gZnJvbSAnLi91cHBlcmNhc2VGb3JtYXR0ZXInO1xuaW1wb3J0IHsgeWVzTm9Gb3JtYXR0ZXIgfSBmcm9tICcuL3llc05vRm9ybWF0dGVyJztcbmltcG9ydCB7IGJzRHJvcGRvd25Gb3JtYXR0ZXIgfSBmcm9tICcuL2JzRHJvcGRvd25Gb3JtYXR0ZXInO1xuXG4vKiogUHJvdmlkZXMgYSBsaXN0IG9mIGRpZmZlcmVudCBGb3JtYXR0ZXJzIHRoYXQgd2lsbCBjaGFuZ2UgdGhlIGNlbGwgdmFsdWUgZGlzcGxheWVkIGluIHRoZSBVSSAqL1xuZXhwb3J0IGNvbnN0IEZvcm1hdHRlcnMgPSB7XG4gIC8qKlxuICAgKiBUYWtlcyBhbiBhcnJheSBvZiBjb21wbGV4IG9iamVjdHMgY29udmVydHMgaXQgdG8gYSBjb21tYSBkZWxpbWl0ZWQgc3RyaW5nLlxuICAgKiBSZXF1aXJlcyB0byBwYXNzIGFuIGFycmF5IG9mIFwicHJvcGVydHlOYW1lc1wiIGluIHRoZSBjb2x1bW4gZGVmaW5pdGlvbiB0aGUgZ2VuZXJpYyBcInBhcmFtc1wiIHByb3BlcnR5XG4gICAqIEZvciBleGFtcGxlLCBpZiB3ZSBoYXZlIGFuIGFycmF5IG9mIHVzZXIgb2JqZWN0cyB0aGF0IGhhdmUgdGhlIHByb3BlcnR5IG9mIGZpcnN0TmFtZSAmIGxhc3ROYW1lIHRoZW4gd2UgbmVlZCB0byBwYXNzIGluIHlvdXIgY29sdW1uIGRlZmluaXRpb246OlxuICAgKiBwYXJhbXM6IHsgcHJvcGVydHlOYW1lczogWydmaXJ0TmFtZScsICdsYXN0TmFtZSddIH0gPT4gJ0pvaG4gRG9lLCBKYW5lIERvZSdcbiAgICovXG4gIGFycmF5T2JqZWN0VG9Dc3Y6IGFycmF5T2JqZWN0VG9Dc3ZGb3JtYXR0ZXIsXG5cbiAgLyoqIFRha2VzIGFuIGFycmF5IG9mIHN0cmluZyBhbmQgY29udmVydHMgaXQgdG8gYSBjb21tYSBkZWxpbWl0ZWQgc3RyaW5nICovXG4gIGFycmF5VG9Dc3Y6IGFycmF5VG9Dc3ZGb3JtYXR0ZXIsXG5cbiAgLyoqIHNob3cgdmFsdWUgaW4gYm9sZCBmb250IHdlaWdodCAqL1xuICBib2xkOiBib2xkRm9ybWF0dGVyLFxuXG4gIC8qKiBib29zdHJhcCBkcm9wZG93biBmb3JtYXR0ZXIgKi9cbiAgYnNEcm9wZG93bjogYnNEcm9wZG93bkZvcm1hdHRlcixcblxuICAvKiogV2hlbiB2YWx1ZSBpcyBmaWxsZWQgKHRydWUpLCBpdCB3aWxsIGRpc3BsYXkgYSBjaGVja2JveCBVbmljb2RlIGljb24gKi9cbiAgY2hlY2tib3g6IGNoZWNrYm94Rm9ybWF0dGVyLFxuXG4gIC8qKlxuICAgKiBXaGVuIHZhbHVlIGlzIGZpbGxlZCwgb3IgaWYgdGhlIHZhbHVlIGlzIGEgbnVtYmVyIGFuZCBpcyBiaWdnZXIgdGhhbiAwLCBpdCB3aWxsIGRpc3BsYXkgYSBGb250LUF3ZXNvbWUgaWNvbiAoZmEtY2hlY2spLlxuICAgKiBUaGUgaWNvbiB3aWxsIE5PVCBiZSBkaXNwbGF5ZWQgd2hlbiB0aGUgdmFsdWUgaXMgYW55IG9mIHRoZSBmb2xsb3dpbmcgKFwiZmFsc2VcIiwgZmFsc2UsIFwiMFwiLCAwLCAtMC41LCBudWxsLCB1bmRlZmluZWQpXG4gICAqIEFueXRoaW5nIGVsc2UgdGhhbiB0aGUgY29uZGl0aW9uIHNwZWNpZmllZCB3aWxsIGRpc3BsYXkgdGhlIGljb24sIHNvIGEgdGV4dCB3aXRoIFwiMDAxMjNcIiB3aWxsIGRpc3BsYXkgdGhlIGljb24gYnV0IFwiMFwiIHdpbGwgbm90LlxuICAgKiBBbHNvIG5vdGUgdGhhdCBhIHN0cmluZyAoXCJudWxsXCIsIFwidW5kZWZpbmVkXCIpIHdpbGwgZGlzcGxheSB0aGUgaWNvbiBidXQgKG51bGwsIHVuZGVmaW5lZCkgd2lsbCBub3QsIHNvIHRoZSB0eXBlb2YgaXMgYWxzbyBpbXBvcnRhbnRcbiAgICovXG4gIGNoZWNrbWFyazogY2hlY2ttYXJrRm9ybWF0dGVyLFxuXG4gIC8qKlxuICAgKiBUYWtlcyBhIGNvbXBsZXggZGF0YSBvYmplY3QgYW5kIHJldHVybiB0aGUgZGF0YSB1bmRlciB0aGF0IHByb3BlcnR5IChmb3IgZXhhbXBsZTogXCJ1c2VyLmZpcnN0TmFtZVwiIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBuYW1lIFwiSm9oblwiKVxuICAgKiBZb3UgY2FuIHBhc3MgdGhlIGNvbXBsZXggc3RydWN0dXJlIGluIHRoZSBcImZpZWxkXCIgb3IgdGhlIFwicGFyYW1zOiB7IGNvbXBsZXhGaWVsZDogc3RyaW5nIH1cIiBwcm9wZXJ0aWVzLlxuICAgKiBGb3IgZXhhbXBsZTo6XG4gICAqIHRoaXMuY29sdW1uRGVmcyA9IFt7IGlkOiAndXNlcm5hbWUnLCBmaWVsZDogJ3VzZXIuZmlyc3ROYW1lJywgLi4uIH1dXG4gICAqIE9SIHRoaXMuY29sdW1uRGVmcyA9IFt7IGlkOiAndXNlcm5hbWUnLCBmaWVsZDogJ3VzZXInLCBwYXJhbXM6IHsgY29tcGxleEZpZWxkOiAndXNlci5maXJzdE5hbWUnIH0sIC4uLiB9XVxuICAgKi9cbiAgY29tcGxleE9iamVjdDogY29tcGxleE9iamVjdEZvcm1hdHRlcixcblxuICAvKipcbiAgICogTG9va3MgdXAgdmFsdWVzIGZyb20gdGhlIGNvbHVtbkRlZmluaXRpb24ucGFyYW1zLmNvbGxlY3Rpb24gcHJvcGVydHkgYW5kIGRpc3BsYXlzIHRoZSBsYWJlbCBpbiBDU1Ygb3Igc3RyaW5nIGZvcm1hdFxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyB0aGUgZ3JpZCB3aWxsIGRpc3BsYXkgJ2ZvbycgYW5kICdiYXInIGFuZCBub3QgMSBhbmQgMiBmcm9tIHlvdXIgZGF0YXNldFxuICAgKiB7IHBhcmFtczogeyBjb2xsZWN0aW9uOiBbeyB2YWx1ZTogMSwgbGFiZWw6ICdmb28nfSwge3ZhbHVlOiAyLCBsYWJlbDogJ2JhcicgfV0gfX1cbiAgICogY29uc3QgZGF0YXNldCA9IFsxLCAyXTtcbiAgICovXG4gIGNvbGxlY3Rpb246IGNvbGxlY3Rpb25Gb3JtYXR0ZXIsXG5cbiAgLyoqXG4gICAqIFJvdWdobHkgdGhlIHNhbWUgYXMgdGhlIFwiY29sbGVjdGlvbkZvcm1hdHRlclwiIGV4Y2VwdCB0aGF0IGl0XG4gICAqIGxvb2tzIHVwIHZhbHVlcyBmcm9tIHRoZSBjb2x1bW5EZWZpbml0aW9uLmVkaXRvci5jb2xsZWN0aW9uIChpbnN0ZWFkIG9mIHBhcmFtcykgcHJvcGVydHkgYW5kIGRpc3BsYXlzIHRoZSBsYWJlbCBpbiBDU1Ygb3Igc3RyaW5nIGZvcm1hdFxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyB0aGUgZ3JpZCB3aWxsIGRpc3BsYXkgJ2ZvbycgYW5kICdiYXInIGFuZCBub3QgMSBhbmQgMiBmcm9tIHlvdXIgZGF0YXNldFxuICAgKiB7IGVkaXRvcjogeyBjb2xsZWN0aW9uOiBbeyB2YWx1ZTogMSwgbGFiZWw6ICdmb28nfSwge3ZhbHVlOiAyLCBsYWJlbDogJ2JhcicgfV0gfX1cbiAgICogY29uc3QgZGF0YXNldCA9IFsxLCAyXTtcbiAgICovXG4gIGNvbGxlY3Rpb25FZGl0b3I6IGNvbGxlY3Rpb25FZGl0b3JGb3JtYXR0ZXIsXG5cbiAgLyoqIFRha2VzIGEgRGF0ZSBvYmplY3QgYW5kIGRpc3BsYXlzIGl0IGFzIGFuIElTTyBEYXRlIGZvcm1hdCAoWVlZWS1NTS1ERCkgKi9cbiAgZGF0ZUlzbzogZ2V0QXNzb2NpYXRlZERhdGVGb3JtYXR0ZXIoRmllbGRUeXBlLmRhdGVJc28sICctJyksXG5cbiAgLyoqIFRha2VzIGEgRGF0ZSBvYmplY3QgYW5kIGRpc3BsYXlzIGl0IGFzIGFuIElTTyBEYXRlK1RpbWUgZm9ybWF0IChZWVlZLU1NLUREIEhIOm1tOnNzKSAqL1xuICBkYXRlVGltZUlzbzogZ2V0QXNzb2NpYXRlZERhdGVGb3JtYXR0ZXIoRmllbGRUeXBlLmRhdGVUaW1lSXNvLCAnLScpLFxuXG4gIC8qKiBUYWtlcyBhIERhdGUgb2JqZWN0IGFuZCBkaXNwbGF5cyBpdCBhcyBhbiBJU08gRGF0ZStUaW1lICh3aXRob3V0IHNlY29uZHMpIGZvcm1hdCAoWVlZWS1NTS1ERCBISDptbSkgKi9cbiAgZGF0ZVRpbWVTaG9ydElzbzogZ2V0QXNzb2NpYXRlZERhdGVGb3JtYXR0ZXIoRmllbGRUeXBlLmRhdGVUaW1lU2hvcnRJc28sICctJyksXG5cbiAgLyoqIFRha2VzIGEgRGF0ZSBvYmplY3QgYW5kIGRpc3BsYXlzIGl0IGFzIGFuIElTTyBEYXRlK1RpbWUrKGFtL3BtKSBmb3JtYXQgKFlZWVktTU0tREQgaDptbTpzcyBhKSAqL1xuICBkYXRlVGltZUlzb0FtUG06IGdldEFzc29jaWF0ZWREYXRlRm9ybWF0dGVyKEZpZWxkVHlwZS5kYXRlVGltZUlzb0FtUG0sICctJyksXG5cbiAgLyoqIFRha2VzIGEgRGF0ZSBvYmplY3QgYW5kIGRpc3BsYXlzIGl0IGFzIGFuIEV1cm8gRGF0ZSBmb3JtYXQgKEREL01NL1lZWVkpICovXG4gIGRhdGVFdXJvOiBnZXRBc3NvY2lhdGVkRGF0ZUZvcm1hdHRlcihGaWVsZFR5cGUuZGF0ZUV1cm8sICcvJyksXG5cbiAgLyoqIFRha2VzIGEgRGF0ZSBvYmplY3QgYW5kIGRpc3BsYXlzIGl0IGFzIGFuIEV1cm8gRGF0ZStUaW1lIGZvcm1hdCAoREQvTU0vWVlZWSBISDptbTpzcykgKi9cbiAgZGF0ZVRpbWVFdXJvOiBnZXRBc3NvY2lhdGVkRGF0ZUZvcm1hdHRlcihGaWVsZFR5cGUuZGF0ZVRpbWVFdXJvLCAnLycpLFxuXG4gIC8qKiBUYWtlcyBhIERhdGUgb2JqZWN0IGFuZCBkaXNwbGF5cyBpdCBhcyBhbiBFdXJvIERhdGUrVGltZSAod2l0aG91dCBzZWNvbmRzKSBmb3JtYXQgKEREL01NL1lZWVkgSEg6bW0pICovXG4gIGRhdGVUaW1lU2hvcnRFdXJvOiBnZXRBc3NvY2lhdGVkRGF0ZUZvcm1hdHRlcihGaWVsZFR5cGUuZGF0ZVRpbWVTaG9ydEV1cm8sICcvJyksXG5cbiAgLyoqIFRha2VzIGEgRGF0ZSBvYmplY3QgYW5kIGRpc3BsYXlzIGl0IGFzIGFuIEV1cm8gRGF0ZStUaW1lKyhhbS9wbSkgZm9ybWF0IChERC9NTS9ZWVlZIGhoOm1tOnNzIGEpICovXG4gIGRhdGVUaW1lRXVyb0FtUG06IGdldEFzc29jaWF0ZWREYXRlRm9ybWF0dGVyKEZpZWxkVHlwZS5kYXRlVGltZUV1cm9BbVBtLCAnLycpLFxuXG4gIC8qKiBUYWtlcyBhIERhdGUgb2JqZWN0IGFuZCBkaXNwbGF5cyBpdCBhcyBhbiBVUyBEYXRlIGZvcm1hdCAoTU0vREQvWVlZWSkgKi9cbiAgZGF0ZVVzOiBnZXRBc3NvY2lhdGVkRGF0ZUZvcm1hdHRlcihGaWVsZFR5cGUuZGF0ZVVzLCAnLycpLFxuXG4gIC8qKiBUYWtlcyBhIERhdGUgb2JqZWN0IGFuZCBkaXNwbGF5cyBpdCBhcyBhbiBVUyBEYXRlK1RpbWUgZm9ybWF0IChNTS9ERC9ZWVlZIEhIOm1tOnNzKSAqL1xuICBkYXRlVGltZVVzOiBnZXRBc3NvY2lhdGVkRGF0ZUZvcm1hdHRlcihGaWVsZFR5cGUuZGF0ZVRpbWVVcywgJy8nKSxcblxuICAvKiogVGFrZXMgYSBEYXRlIG9iamVjdCBhbmQgZGlzcGxheXMgaXQgYXMgYW4gVVMgRGF0ZStUaW1lICh3aXRob3V0IHNlY29uZHMpIGZvcm1hdCAoTU0vREQvWVlZWSBISDptbTpzcykgKi9cbiAgZGF0ZVRpbWVTaG9ydFVzOiBnZXRBc3NvY2lhdGVkRGF0ZUZvcm1hdHRlcihGaWVsZFR5cGUuZGF0ZVRpbWVTaG9ydFVzLCAnLycpLFxuXG4gIC8qKiBUYWtlcyBhIERhdGUgb2JqZWN0IGFuZCBkaXNwbGF5cyBpdCBhcyBhbiBVUyBEYXRlK1RpbWUrKGFtL3BtKSBmb3JtYXQgKE1NL0REL1lZWVkgaGg6bW06c3MgYSkgKi9cbiAgZGF0ZVRpbWVVc0FtUG06IGdldEFzc29jaWF0ZWREYXRlRm9ybWF0dGVyKEZpZWxkVHlwZS5kYXRlVGltZVVzQW1QbSwgJy8nKSxcblxuICAvKiogRGlzcGxheXMgYSBGb250LUF3ZXNvbWUgZGVsZXRlIGljb24gKGZhLXRyYXNoKSAqL1xuICBkZWxldGVJY29uOiBkZWxldGVJY29uRm9ybWF0dGVyLFxuXG4gIC8qKlxuICAgKiBEaXNwbGF5IHRoZSB2YWx1ZSBhcyB4IGRlY2ltYWxzIGZvcm1hdHRlZCwgZGVmYXVsdHMgdG8gMiBkZWNpbWFscy5cbiAgICogWW91IGNhbiBwYXNzIFwiZGVjaW1hbFBsYWNlc1wiIG9yIFwibWluRGVjaW1hbFBsYWNlc1wiIGFuZC9vciBcIm1heERlY2ltYWxQbGFjZXNcIiB0byB0aGUgXCJwYXJhbXNcIiBwcm9wZXJ0eS5cbiAgICogRm9yIGV4YW1wbGU6OiBgeyBmb3JtYXR0ZXI6IEZvcm1hdHRlcnMuZGVjaW1hbCwgcGFyYW1zOiB7IGRlY2ltYWxQbGFjZXM6IDMgfX1gXG4gICAqIFRoZSBwcm9wZXJ0eSBcImRlY2ltYWxQbGFjZXNcIiBpcyBhbiBhbGlhcyBvZiBcIm1pbkRlY2ltYWxQbGFjZXNcIlxuICAgKi9cbiAgZGVjaW1hbDogZGVjaW1hbEZvcm1hdHRlcixcblxuICAvKiogRGlzcGxheSB0aGUgdmFsdWUgYXMgMiBkZWNpbWFscyBmb3JtYXR0ZWQgd2l0aCBkb2xsYXIgc2lnbiAnJCcgYXQgdGhlIGVuZCBvZiBvZiB0aGUgdmFsdWUgKi9cbiAgZG9sbGFyOiBkb2xsYXJGb3JtYXR0ZXIsXG5cbiAgLyoqIERpc3BsYXkgdGhlIHZhbHVlIGFzIDIgZGVjaW1hbHMgZm9ybWF0dGVkIHdpdGggZG9sbGFyIHNpZ24gJyQnIGF0IHRoZSBlbmQgb2Ygb2YgdGhlIHZhbHVlLCBjaGFuZ2UgY29sb3Igb2YgdGV4dCB0byByZWQvZ3JlZW4gb24gbmVnYXRpdmUvcG9zaXRpdmUgdmFsdWUgKi9cbiAgZG9sbGFyQ29sb3JlZDogZG9sbGFyQ29sb3JlZEZvcm1hdHRlcixcblxuICAvKiogRGlzcGxheSB0aGUgdmFsdWUgYXMgMiBkZWNpbWFscyBmb3JtYXR0ZWQgd2l0aCBkb2xsYXIgc2lnbiAnJCcgYXQgdGhlIGVuZCBvZiBvZiB0aGUgdmFsdWUsIGNoYW5nZSBjb2xvciBvZiB0ZXh0IHRvIHJlZC9ncmVlbiBvbiBuZWdhdGl2ZS9wb3NpdGl2ZSB2YWx1ZSwgc2hvdyBpdCBpbiBib2xkIGZvbnQgd2VpZ2h0IGFzIHdlbGwgKi9cbiAgZG9sbGFyQ29sb3JlZEJvbGQ6IGRvbGxhckNvbG9yZWRCb2xkRm9ybWF0dGVyLFxuXG4gIC8qKiBEaXNwbGF5cyBhIEZvbnQtQXdlc29tZSBlZGl0IGljb24gKGZhLXBlbmNpbCkgKi9cbiAgZWRpdEljb246IGVkaXRJY29uRm9ybWF0dGVyLFxuXG4gIC8qKlxuICAgKiBUYWtlcyBhbiBoeXBlcmxpbmsgY2VsbCB2YWx1ZSBhbmQgdHJhbnNmb3JtcyBpdCBpbnRvIGEgcmVhbCBoeXBlcmxpbmssIGdpdmVuIHRoYXQgdGhlIHZhbHVlIHN0YXJ0cyB3aXRoIDEgb2YgdGhlc2UgKGh0dHB8ZnRwfGh0dHBzKS5cbiAgICogVGhlIHN0cnVjdHVyZSB3aWxsIGJlIFwiPGEgaHJlZj1cImh5cGVybGlua1wiPmh5cGVybGluazwvYT5cIlxuICAgKlxuICAgKiBZb3UgY2FuIG9wdGlvbmFsbHkgY2hhbmdlIHRoZSBoeXBlcmxpbmsgdGV4dCBkaXNwbGF5ZWQgYnkgdXNpbmcgdGhlIGdlbmVyaWMgcGFyYW1zIFwiaHlwZXJsaW5rVGV4dFwiIGluIHRoZSBjb2x1bW4gZGVmaW5pdGlvblxuICAgKiBGb3IgZXhhbXBsZTogeyBpZDogJ2xpbmsnLCBmaWVsZDogJ2xpbmsnLCBwYXJhbXM6IHsgaHlwZXJsaW5rVGV4dDogJ0NvbXBhbnkgV2Vic2l0ZScgfSB9IHdpbGwgZGlzcGxheSBcIjxhIGhyZWY9XCJsaW5rXCI+Q29tcGFueSBXZWJzaXRlPC9hPlwiXG4gICAqXG4gICAqIFlvdSBjYW4gYWxzbyBvcHRpb25hbGx5IHByb3ZpZGUgdGhlIGh5cGVybGluayBVUkwgYnkgdXNpbmcgdGhlIGdlbmVyaWMgcGFyYW1zIFwiaHlwZXJsaW5rVXJsXCIgaW4gdGhlIGNvbHVtbiBkZWZpbml0aW9uXG4gICAqIEZvciBleGFtcGxlOiB7IGlkOiAnbGluaycsIGZpZWxkOiAnbGluaycsIHBhcmFtczogeyAgaHlwZXJsaW5rVGV4dDogJ0NvbXBhbnkgV2Vic2l0ZScsIGh5cGVybGlua1VybDogJ2h0dHA6Ly93d3cuc29tZXdoZXJlLmNvbScgfSB9IHdpbGwgZGlzcGxheSBcIjxhIGhyZWY9XCJodHRwOi8vd3d3LnNvbWV3aGVyZS5jb21cIj5Db21wYW55IFdlYnNpdGU8L2E+XCJcbiAgICovXG4gIGh5cGVybGluazogaHlwZXJsaW5rRm9ybWF0dGVyLFxuXG4gIC8qKiBEaXNwbGF5IHdoaWNoZXZlciBpY29uIHlvdSB3YW50IChsaWJyYXJ5IGFnbm9zdGljLCBpdCBjb3VsZCBiZSBGb250LUF3ZXNvbWUgb3IgYW55IG90aGVyKSAqL1xuICBpY29uOiBpY29uRm9ybWF0dGVyLFxuXG4gIC8qKiBEaXNwbGF5cyBhIEZvbnQtQXdlc29tZSBlZGl0IGljb24gKGZhLWluZm8tY2lyY2xlKSAqL1xuICBpbmZvSWNvbjogaW5mb0ljb25Gb3JtYXR0ZXIsXG5cbiAgLyoqIHNob3cgaW5wdXQgdGV4dCB2YWx1ZSBhcyBpdGFsaWMgdGV4dCAqL1xuICBpdGFsaWM6IGl0YWxpY0Zvcm1hdHRlcixcblxuICAvKiogVGFrZXMgYSB2YWx1ZSBhbmQgZGlzcGxheXMgaXQgYWxsIGxvd2VyY2FzZSAqL1xuICBsb3dlcmNhc2U6IGxvd2VyY2FzZUZvcm1hdHRlcixcblxuICAvKipcbiAgICogVGFrZXMgYSB2YWx1ZSBkaXNwbGF5IGl0IGFjY29yZGluZyB0byBhIG1hc2sgcHJvdmlkZWRcbiAgICogZS46IDEyMzQ1Njc4OTAgd2l0aCBtYXNrIFwiKDAwMCkgMDAwLTAwMDBcIiB3aWxsIGRpc3BsYXkgXCIoMTIzKSA0NTYtNzg5MFwiXG4gICAqL1xuICBtYXNrOiBtYXNrRm9ybWF0dGVyLFxuXG4gIC8qKlxuICAgKiBZb3UgY2FuIHBpcGUgbXVsdGlwbGUgZm9ybWF0dGVycyAoZXhlY3V0ZWQgaW4gc2VxdWVuY2UpLCB1c2UgcGFyYW1zIHRvIHBhc3MgdGhlIGxpc3Qgb2YgZm9ybWF0dGVycy5cbiAgICogUmVxdWlyZXMgdG8gcGFzcyBhbiBhcnJheSBvZiBcImZvcm1hdHRlcnNcIiBpbiB0aGUgY29sdW1uIGRlZmluaXRpb24gdGhlIGdlbmVyaWMgXCJwYXJhbXNcIiBwcm9wZXJ0eVxuICAgKiBGb3IgZXhhbXBsZTo6XG4gICAqIHsgZmllbGQ6ICd0aXRsZScsIGZvcm1hdHRlcjogRm9ybWF0dGVycy5tdWx0aXBsZSwgcGFyYW1zOiB7IGZvcm1hdHRlcnM6IFsgRm9ybWF0dGVycy5sb3dlcmNhc2UsIEZvcm1hdHRlcnMudXBwZXJjYXNlIF0gfVxuICAgKi9cbiAgbXVsdGlwbGU6IG11bHRpcGxlRm9ybWF0dGVyLFxuXG4gIC8qKiBUYWtlcyBhIGNlbGwgdmFsdWUgbnVtYmVyIChiZXR3ZWVuIDAuMC0xLjApIGFuZCBkaXNwbGF5cyBhIHJlZCAoPDUwKSBvciBncmVlbiAoPj01MCkgYmFyICovXG4gIHBlcmNlbnQ6IHBlcmNlbnRGb3JtYXR0ZXIsXG5cbiAgLyoqIFRha2VzIGEgY2VsbCB2YWx1ZSBudW1iZXIgKGJldHdlZW4gMC4wLTEwMCkgYW5kIGRpc3BsYXlzIGEgcmVkICg8NTApIG9yIGdyZWVuICg+PTUwKSBiYXIgKi9cbiAgcGVyY2VudENvbXBsZXRlOiBwZXJjZW50Q29tcGxldGVGb3JtYXR0ZXIsXG5cbiAgLyoqIFRha2VzIGEgY2VsbCB2YWx1ZSBudW1iZXIgKGJldHdlZW4gMC0xMDApIGFuZCBkaXNwbGF5cyBCb290c3RyYXAgXCJwZXJjZW50LWNvbXBsZXRlLWJhclwiIGEgcmVkICg8MzApLCBzaWx2ZXIgKD4zMCAmIDw3MCkgb3IgZ3JlZW4gKD49NzApIGJhciAqL1xuICBwZXJjZW50Q29tcGxldGVCYXI6IHBlcmNlbnRDb21wbGV0ZUJhckZvcm1hdHRlcixcblxuICAvKiogVGFrZXMgYSBjZWxsIHZhbHVlIG51bWJlciAoYmV0d2VlbiAwLTEwMCkgYW5kIGFkZCB0aGUgXCIlXCIgYWZ0ZXIgdGhlIG51bWJlciAqL1xuICBwZXJjZW50U3ltYm9sOiBwZXJjZW50U3ltYm9sRm9ybWF0dGVyLFxuXG4gIC8qKiBUYWtlcyBhIGNlbGwgdmFsdWUgbnVtYmVyIChiZXR3ZWVuIDAtMTAwKSBhbmQgZGlzcGxheXMgQm9vdHN0cmFwIFwicHJvZ3Jlc3MtYmFyXCIgYSByZWQgKDwzMCksIHNpbHZlciAoPjMwICYgPDcwKSBvciBncmVlbiAoPj03MCkgYmFyICovXG4gIHByb2dyZXNzQmFyOiBwcm9ncmVzc0JhckZvcm1hdHRlcixcblxuICAvKiogVGFrZXMgYSBjZWxsIHZhbHVlIGFuZCB0cmFuc2xhdGVzIGl0IChpMThuKS4gUmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgdGhlIFRyYW5zbGF0ZSBTZXJ2aWNlOjogYGkxOG46IHRoaXMudHJhbnNsYXRlICovXG4gIHRyYW5zbGF0ZTogdHJhbnNsYXRlRm9ybWF0dGVyLFxuXG4gIC8qKiBUYWtlcyBhIGJvb2xlYW4gdmFsdWUsIGNhc3QgaXQgdG8gdXBwZXJDYXNlIHN0cmluZyBhbmQgZmluYWxseSB0cmFuc2xhdGVzIGl0IChpMThuKS4gKi9cbiAgdHJhbnNsYXRlQm9vbGVhbjogdHJhbnNsYXRlQm9vbGVhbkZvcm1hdHRlcixcblxuICAvKiogVGFrZXMgYSB2YWx1ZSBhbmQgZGlzcGxheXMgaXQgYWxsIHVwcGVyY2FzZSAqL1xuICB1cHBlcmNhc2U6IHVwcGVyY2FzZUZvcm1hdHRlcixcblxuICAvKiogVGFrZXMgYSBib29sZWFuIHZhbHVlIGFuZCBkaXNwbGF5IGEgc3RyaW5nICdZZXMnIG9yICdObycgKi9cbiAgeWVzTm86IHllc05vRm9ybWF0dGVyXG59O1xuIl19