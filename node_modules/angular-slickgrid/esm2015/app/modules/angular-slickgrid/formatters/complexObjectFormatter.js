export const complexObjectFormatter = (row, cell, cellValue, columnDef, dataContext) => {
    if (!columnDef) {
        return '';
    }
    const columnParams = columnDef.params || {};
    const complexFieldLabel = columnParams && columnParams.complexFieldLabel || columnDef.field;
    if (!complexFieldLabel) {
        throw new Error(`For the Formatters.complexObject to work properly, you need to tell it which property of the complex object to use.
      There are 3 ways to provide it:
      1- via the generic "params" with a "complexFieldLabel" property on your Column Definition, example: this.columnDefs = [{ id: 'user', field: 'user', params: { complexFieldLabel: 'user.firstName' } }]
      2- via the generic "params" with a "complexFieldLabel" and a "labelKey" property on your Column Definition, example: this.columnDefs = [{ id: 'user', field: 'user', labelKey: 'firstName' params: { complexFieldLabel: 'user' } }]
      3- via the field name that includes a dot notation, example: this.columnDefs = [{ id: 'user', field: 'user.firstName'}] `);
    }
    if (columnDef.labelKey && dataContext.hasOwnProperty(complexFieldLabel)) {
        return dataContext[complexFieldLabel] && dataContext[complexFieldLabel][columnDef.labelKey];
    }
    // when complexFieldLabel includes the dot ".", we will do the split and get the value from the complex object
    // however we also need to make sure that the complex objet exist, else we'll return the cell value (original value)
    if (typeof complexFieldLabel === 'string' && complexFieldLabel.indexOf('.') > 0) {
        return complexFieldLabel.split('.').reduce((obj, i) => (obj && obj.hasOwnProperty(i) ? obj[i] : cellValue), dataContext);
    }
    return cellValue;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGxleE9iamVjdEZvcm1hdHRlci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItc2xpY2tncmlkLyIsInNvdXJjZXMiOlsiYXBwL21vZHVsZXMvYW5ndWxhci1zbGlja2dyaWQvZm9ybWF0dGVycy9jb21wbGV4T2JqZWN0Rm9ybWF0dGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUdBLE1BQU0sQ0FBQyxNQUFNLHNCQUFzQixHQUFjLENBQUMsR0FBVyxFQUFFLElBQVksRUFBRSxTQUFjLEVBQUUsU0FBaUIsRUFBRSxXQUFnQixFQUFFLEVBQUU7SUFDbEksSUFBSSxDQUFDLFNBQVMsRUFBRTtRQUNkLE9BQU8sRUFBRSxDQUFDO0tBQ1g7SUFFRCxNQUFNLFlBQVksR0FBRyxTQUFTLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQztJQUM1QyxNQUFNLGlCQUFpQixHQUFHLFlBQVksSUFBSSxZQUFZLENBQUMsaUJBQWlCLElBQUksU0FBUyxDQUFDLEtBQUssQ0FBQztJQUU1RixJQUFJLENBQUMsaUJBQWlCLEVBQUU7UUFDdEIsTUFBTSxJQUFJLEtBQUssQ0FBQzs7OzsrSEFJMkcsQ0FBQyxDQUFDO0tBQzlIO0lBRUQsSUFBSSxTQUFTLENBQUMsUUFBUSxJQUFJLFdBQVcsQ0FBQyxjQUFjLENBQUMsaUJBQWlCLENBQUMsRUFBRTtRQUN2RSxPQUFPLFdBQVcsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQztLQUM3RjtJQUVELDhHQUE4RztJQUM5RyxvSEFBb0g7SUFDcEgsSUFBSSxPQUFPLGlCQUFpQixLQUFLLFFBQVEsSUFBSSxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQy9FLE9BQU8saUJBQWlCLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEVBQUUsV0FBVyxDQUFDLENBQUM7S0FDMUg7SUFDRCxPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb2x1bW4gfSBmcm9tICcuLy4uL21vZGVscy9jb2x1bW4uaW50ZXJmYWNlJztcclxuaW1wb3J0IHsgRm9ybWF0dGVyIH0gZnJvbSAnLi8uLi9tb2RlbHMvZm9ybWF0dGVyLmludGVyZmFjZSc7XHJcblxyXG5leHBvcnQgY29uc3QgY29tcGxleE9iamVjdEZvcm1hdHRlcjogRm9ybWF0dGVyID0gKHJvdzogbnVtYmVyLCBjZWxsOiBudW1iZXIsIGNlbGxWYWx1ZTogYW55LCBjb2x1bW5EZWY6IENvbHVtbiwgZGF0YUNvbnRleHQ6IGFueSkgPT4ge1xyXG4gIGlmICghY29sdW1uRGVmKSB7XHJcbiAgICByZXR1cm4gJyc7XHJcbiAgfVxyXG5cclxuICBjb25zdCBjb2x1bW5QYXJhbXMgPSBjb2x1bW5EZWYucGFyYW1zIHx8IHt9O1xyXG4gIGNvbnN0IGNvbXBsZXhGaWVsZExhYmVsID0gY29sdW1uUGFyYW1zICYmIGNvbHVtblBhcmFtcy5jb21wbGV4RmllbGRMYWJlbCB8fCBjb2x1bW5EZWYuZmllbGQ7XHJcblxyXG4gIGlmICghY29tcGxleEZpZWxkTGFiZWwpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgRm9yIHRoZSBGb3JtYXR0ZXJzLmNvbXBsZXhPYmplY3QgdG8gd29yayBwcm9wZXJseSwgeW91IG5lZWQgdG8gdGVsbCBpdCB3aGljaCBwcm9wZXJ0eSBvZiB0aGUgY29tcGxleCBvYmplY3QgdG8gdXNlLlxyXG4gICAgICBUaGVyZSBhcmUgMyB3YXlzIHRvIHByb3ZpZGUgaXQ6XHJcbiAgICAgIDEtIHZpYSB0aGUgZ2VuZXJpYyBcInBhcmFtc1wiIHdpdGggYSBcImNvbXBsZXhGaWVsZExhYmVsXCIgcHJvcGVydHkgb24geW91ciBDb2x1bW4gRGVmaW5pdGlvbiwgZXhhbXBsZTogdGhpcy5jb2x1bW5EZWZzID0gW3sgaWQ6ICd1c2VyJywgZmllbGQ6ICd1c2VyJywgcGFyYW1zOiB7IGNvbXBsZXhGaWVsZExhYmVsOiAndXNlci5maXJzdE5hbWUnIH0gfV1cclxuICAgICAgMi0gdmlhIHRoZSBnZW5lcmljIFwicGFyYW1zXCIgd2l0aCBhIFwiY29tcGxleEZpZWxkTGFiZWxcIiBhbmQgYSBcImxhYmVsS2V5XCIgcHJvcGVydHkgb24geW91ciBDb2x1bW4gRGVmaW5pdGlvbiwgZXhhbXBsZTogdGhpcy5jb2x1bW5EZWZzID0gW3sgaWQ6ICd1c2VyJywgZmllbGQ6ICd1c2VyJywgbGFiZWxLZXk6ICdmaXJzdE5hbWUnIHBhcmFtczogeyBjb21wbGV4RmllbGRMYWJlbDogJ3VzZXInIH0gfV1cclxuICAgICAgMy0gdmlhIHRoZSBmaWVsZCBuYW1lIHRoYXQgaW5jbHVkZXMgYSBkb3Qgbm90YXRpb24sIGV4YW1wbGU6IHRoaXMuY29sdW1uRGVmcyA9IFt7IGlkOiAndXNlcicsIGZpZWxkOiAndXNlci5maXJzdE5hbWUnfV0gYCk7XHJcbiAgfVxyXG5cclxuICBpZiAoY29sdW1uRGVmLmxhYmVsS2V5ICYmIGRhdGFDb250ZXh0Lmhhc093blByb3BlcnR5KGNvbXBsZXhGaWVsZExhYmVsKSkge1xyXG4gICAgcmV0dXJuIGRhdGFDb250ZXh0W2NvbXBsZXhGaWVsZExhYmVsXSAmJiBkYXRhQ29udGV4dFtjb21wbGV4RmllbGRMYWJlbF1bY29sdW1uRGVmLmxhYmVsS2V5XTtcclxuICB9XHJcblxyXG4gIC8vIHdoZW4gY29tcGxleEZpZWxkTGFiZWwgaW5jbHVkZXMgdGhlIGRvdCBcIi5cIiwgd2Ugd2lsbCBkbyB0aGUgc3BsaXQgYW5kIGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgY29tcGxleCBvYmplY3RcclxuICAvLyBob3dldmVyIHdlIGFsc28gbmVlZCB0byBtYWtlIHN1cmUgdGhhdCB0aGUgY29tcGxleCBvYmpldCBleGlzdCwgZWxzZSB3ZSdsbCByZXR1cm4gdGhlIGNlbGwgdmFsdWUgKG9yaWdpbmFsIHZhbHVlKVxyXG4gIGlmICh0eXBlb2YgY29tcGxleEZpZWxkTGFiZWwgPT09ICdzdHJpbmcnICYmIGNvbXBsZXhGaWVsZExhYmVsLmluZGV4T2YoJy4nKSA+IDApIHtcclxuICAgIHJldHVybiBjb21wbGV4RmllbGRMYWJlbC5zcGxpdCgnLicpLnJlZHVjZSgob2JqLCBpKSA9PiAob2JqICYmIG9iai5oYXNPd25Qcm9wZXJ0eShpKSA/IG9ialtpXSA6IGNlbGxWYWx1ZSksIGRhdGFDb250ZXh0KTtcclxuICB9XHJcbiAgcmV0dXJuIGNlbGxWYWx1ZTtcclxufTtcclxuIl19