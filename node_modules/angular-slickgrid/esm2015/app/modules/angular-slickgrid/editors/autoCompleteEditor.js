import { FieldType, KeyCode, } from './../models/index';
import { Constants } from './../constants';
import { findOrDefault, getDescendantProperty, setDeepValue } from '../services/utilities';
// minimum length of chars to type before starting to start querying
const MIN_LENGTH = 3;
/*
 * An example of a 'detached' editor.
 * KeyDown events are also handled to provide handling for Tab, Shift-Tab, Esc and Ctrl-Enter.
 */
export class AutoCompleteEditor {
    constructor(args) {
        this.args = args;
        if (!args) {
            throw new Error('[Angular-SlickGrid] Something is wrong with this grid, an Editor must always have valid arguments.');
        }
        this.grid = args.grid;
        this.init();
    }
    /** Getter for the Autocomplete Option */
    get autoCompleteOptions() {
        return this._autoCompleteOptions || {};
    }
    /** Get the Collection */
    get editorCollection() {
        return this.columnDef && this.columnDef.internalColumnEditor && this.columnDef.internalColumnEditor.collection || [];
    }
    /** Get the Final Collection used in the AutoCompleted Source (this may vary from the "collection" especially when providing a customStructure) */
    get elementCollection() {
        return this._elementCollection;
    }
    /** Get Column Definition object */
    get columnDef() {
        return this.args && this.args.column;
    }
    /** Get Column Editor object */
    get columnEditor() {
        return this.columnDef && this.columnDef.internalColumnEditor || {};
    }
    /** Getter for the Custom Structure if exist */
    get customStructure() {
        return this.columnDef && this.columnDef.internalColumnEditor && this.columnDef.internalColumnEditor.customStructure;
    }
    get hasAutoCommitEdit() {
        return this.grid.getOptions().autoCommitEdit;
    }
    /** Get the Validator function, can be passed in Editor property or Column Definition */
    get validator() {
        return this.columnEditor.validator || this.columnDef.validator;
    }
    get editorOptions() {
        return this.columnEditor && this.columnEditor.editorOptions || {};
    }
    /** Get the Editor DOM Element */
    get editorDomElement() {
        return this._$editorElm;
    }
    init() {
        this.labelName = this.customStructure && this.customStructure.label || 'label';
        this.valueName = this.customStructure && this.customStructure.value || 'value';
        // always render the DOM element, even if user passed a "collectionAsync",
        const newCollection = this.columnEditor.collection || [];
        this.renderDomElement(newCollection);
    }
    destroy() {
        this._$editorElm.off('keydown.nav').remove();
    }
    focus() {
        this._$editorElm.focus().select();
    }
    getValue() {
        return this._$editorElm.val();
    }
    setValue(value) {
        this._$editorElm.val(value);
    }
    applyValue(item, state) {
        let newValue = state;
        const fieldName = this.columnDef && this.columnDef.field;
        // if we have a collection defined, we will try to find the string within the collection and return it
        if (Array.isArray(this.editorCollection) && this.editorCollection.length > 0) {
            newValue = findOrDefault(this.editorCollection, (collectionItem) => {
                if (collectionItem && typeof state === 'object' && collectionItem.hasOwnProperty(this.labelName)) {
                    return (collectionItem.hasOwnProperty(this.labelName) && collectionItem[this.labelName].toString()) === (state.hasOwnProperty(this.labelName) && state[this.labelName].toString());
                }
                else if (collectionItem && typeof state === 'string' && collectionItem.hasOwnProperty(this.labelName)) {
                    return (collectionItem.hasOwnProperty(this.labelName) && collectionItem[this.labelName].toString()) === state;
                }
                return collectionItem && collectionItem.toString() === state;
            });
        }
        // is the field a complex object, "address.streetNumber"
        const isComplexObject = fieldName.indexOf('.') > 0;
        // validate the value before applying it (if not valid we'll set an empty string)
        const validation = this.validate(newValue);
        newValue = (validation && validation.valid) ? newValue : '';
        // set the new value to the item datacontext
        if (isComplexObject) {
            setDeepValue(item, fieldName, newValue);
        }
        else {
            item[fieldName] = newValue;
        }
    }
    isValueChanged() {
        const lastEvent = this._lastInputEvent && this._lastInputEvent.keyCode;
        if (this.columnEditor && this.columnEditor.alwaysSaveOnEnterKey && lastEvent === KeyCode.ENTER) {
            return true;
        }
        return (!(this._$editorElm.val() === '' && this._defaultTextValue === null)) && (this._$editorElm.val() !== this._defaultTextValue);
    }
    loadValue(item) {
        const fieldName = this.columnDef && this.columnDef.field;
        // is the field a complex object, "address.streetNumber"
        const isComplexObject = fieldName.indexOf('.') > 0;
        if (item && this.columnDef && (item.hasOwnProperty(fieldName) || isComplexObject)) {
            const data = (isComplexObject) ? getDescendantProperty(item, fieldName) : item[fieldName];
            this._currentValue = data;
            this._defaultTextValue = typeof data === 'string' ? data : data[this.labelName];
            this._$editorElm.val(this._defaultTextValue);
            this._$editorElm.select();
        }
    }
    save() {
        const validation = this.validate();
        if (validation && validation.valid && this.isValueChanged()) {
            if (this.hasAutoCommitEdit) {
                this.grid.getEditorLock().commitCurrentEdit();
            }
            else {
                this.args.commitChanges();
            }
        }
    }
    serializeValue() {
        // if you want to add the autocomplete functionality but want the user to be able to input a new option
        if (this.editorOptions.forceUserInput) {
            const minLength = this.editorOptions && this.editorOptions.hasOwnProperty('minLength') ? this.editorOptions.minLength : MIN_LENGTH;
            this._currentValue = this._$editorElm.val().length > minLength ? this._$editorElm.val() : this._currentValue;
        }
        // if user provided a custom structure, we will serialize the value returned from the object with custom structure
        if (this.customStructure && this._currentValue && this._currentValue.hasOwnProperty(this.labelName)) {
            return this._currentValue[this.labelName];
        }
        else if (this._currentValue && this._currentValue.label) {
            if (this.columnDef.type === FieldType.object) {
                return {
                    [this.labelName]: this._currentValue.label,
                    [this.valueName]: this._currentValue.value
                };
            }
            return this._currentValue.label;
        }
        return this._currentValue;
    }
    validate(inputValue) {
        const isRequired = this.columnEditor.required;
        const elmValue = (inputValue !== undefined) ? inputValue : this._$editorElm && this._$editorElm.val && this._$editorElm.val();
        const errorMsg = this.columnEditor.errorMessage;
        if (this.validator) {
            return this.validator(elmValue, this.args);
        }
        // by default the editor is almost always valid (except when it's required but not provided)
        if (isRequired && elmValue === '') {
            return {
                valid: false,
                msg: errorMsg || Constants.VALIDATION_REQUIRED_FIELD
            };
        }
        return {
            valid: true,
            msg: null
        };
    }
    //
    // private functions
    // ------------------
    // this function should be PRIVATE but for unit tests purposes we'll make it public until a better solution is found
    // a better solution would be to get the autocomplete DOM element to work with selection but I couldn't find how to do that in Jest
    onSelect(event, ui) {
        if (ui && ui.item) {
            this._currentValue = ui && ui.item;
            const itemLabel = typeof ui.item === 'string' ? ui.item : ui.item.label;
            this.setValue(itemLabel);
            if (this.hasAutoCommitEdit) {
                // do not use args.commitChanges() as this sets the focus to the next row.
                const validation = this.validate();
                if (validation && validation.valid) {
                    this.grid.getEditorLock().commitCurrentEdit();
                }
            }
        }
        return false;
    }
    renderDomElement(collection) {
        if (!Array.isArray(collection)) {
            throw new Error('The "collection" passed to the Autocomplete Editor is not a valid array.');
        }
        const columnId = this.columnDef && this.columnDef.id;
        const placeholder = this.columnEditor && this.columnEditor.placeholder || '';
        const title = this.columnEditor && this.columnEditor.title || '';
        this._$editorElm = $(`<input type="text" role="presentation" autocomplete="off" class="autocomplete editor-text editor-${columnId}" placeholder="${placeholder}" title="${title}" />`)
            .appendTo(this.args.container)
            .on('keydown.nav', (event) => {
            this._lastInputEvent = event;
            if (event.keyCode === KeyCode.LEFT || event.keyCode === KeyCode.RIGHT) {
                event.stopImmediatePropagation();
            }
        });
        // user might pass his own autocomplete options
        const autoCompleteOptions = this.columnEditor.editorOptions;
        // assign the collection to a temp variable before filtering/sorting the collection
        let finalCollection = collection;
        // user might provide his own custom structure
        // jQuery UI autocomplete requires a label/value pair, so we must remap them when user provide different ones
        if (Array.isArray(finalCollection) && this.customStructure) {
            finalCollection = finalCollection.map((item) => {
                return { label: item[this.labelName], value: item[this.valueName] };
            });
        }
        // keep the final source collection used in the AutoComplete as reference
        this._elementCollection = finalCollection;
        // when user passes it's own autocomplete options
        // we still need to provide our own "select" callback implementation
        if (autoCompleteOptions) {
            autoCompleteOptions.select = (event, ui) => this.onSelect(event, ui);
            this._autoCompleteOptions = Object.assign({}, autoCompleteOptions);
            this._$editorElm.autocomplete(autoCompleteOptions);
        }
        else {
            const definedOptions = {
                source: finalCollection,
                minLength: 0,
                select: (event, ui) => this.onSelect(event, ui),
            };
            this._autoCompleteOptions = Object.assign({}, definedOptions, this.columnEditor.editorOptions);
            this._$editorElm.autocomplete(this._autoCompleteOptions);
        }
        setTimeout(() => this.focus(), 50);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0b0NvbXBsZXRlRWRpdG9yLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1zbGlja2dyaWQvIiwic291cmNlcyI6WyJhcHAvbW9kdWxlcy9hbmd1bGFyLXNsaWNrZ3JpZC9lZGl0b3JzL2F1dG9Db21wbGV0ZUVkaXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBU0wsU0FBUyxFQUNULE9BQU8sR0FDUixNQUFNLG1CQUFtQixDQUFDO0FBQzNCLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMzQyxPQUFPLEVBQUUsYUFBYSxFQUFFLHFCQUFxQixFQUFFLFlBQVksRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBSzNGLG9FQUFvRTtBQUNwRSxNQUFNLFVBQVUsR0FBRyxDQUFDLENBQUM7QUFFckI7OztHQUdHO0FBQ0gsTUFBTSxPQUFPLGtCQUFrQjtJQXFCN0IsWUFBb0IsSUFBcUI7UUFBckIsU0FBSSxHQUFKLElBQUksQ0FBaUI7UUFDdkMsSUFBSSxDQUFDLElBQUksRUFBRTtZQUNULE1BQU0sSUFBSSxLQUFLLENBQUMsb0dBQW9HLENBQUMsQ0FBQztTQUN2SDtRQUNELElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztRQUN0QixJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDZCxDQUFDO0lBRUQseUNBQXlDO0lBQ3pDLElBQUksbUJBQW1CO1FBQ3JCLE9BQU8sSUFBSSxDQUFDLG9CQUFvQixJQUFJLEVBQUUsQ0FBQztJQUN6QyxDQUFDO0lBRUQseUJBQXlCO0lBQ3pCLElBQUksZ0JBQWdCO1FBQ2xCLE9BQU8sSUFBSSxDQUFDLFNBQVMsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLG9CQUFvQixJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsb0JBQW9CLENBQUMsVUFBVSxJQUFJLEVBQUUsQ0FBQztJQUN2SCxDQUFDO0lBRUQsa0pBQWtKO0lBQ2xKLElBQUksaUJBQWlCO1FBQ25C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QUFLLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDO1lBQ3RFLENBQUMsQ0FBQyxDQUFDO1NBQ0o7UUFFRCx5RUFBeUU7UUFDekUsSUFBSSxDQUFDLGtCQUFrQixHQUFHLGVBQWUsQ0FBQztRQUUxQyxpREFBaUQ7UUFDakQsb0VBQW9FO1FBQ3BFLElBQUksbUJBQW1CLEVBQUU7WUFDdkIsbUJBQW1CLENBQUMsTUFBTSxHQUFHLENBQUMsS0FBWSxFQUFFLEVBQU8sRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDakYsSUFBSSxDQUFDLG9CQUFvQixxQkFBUSxtQkFBbUIsQ0FBRSxDQUFDO1lBQ3ZELElBQUksQ0FBQyxXQUFXLENBQUMsWUFBWSxDQUFDLG1CQUFtQixDQUFDLENBQUM7U0FDcEQ7YUFBTTtZQUNMLE1BQU0sY0FBYyxHQUF1QjtnQkFDekMsTUFBTSxFQUFFLGVBQWU7Z0JBQ3ZCLFNBQVMsRUFBRSxDQUFDO2dCQUNaLE1BQU0sRUFBRSxDQUFDLEtBQVksRUFBRSxFQUFPLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQzthQUM1RCxDQUFDO1lBQ0YsSUFBSSxDQUFDLG9CQUFvQixxQkFBUSxjQUFjLEVBQU0sSUFBSSxDQUFDLFlBQVksQ0FBQyxhQUFvQyxDQUFFLENBQUM7WUFDOUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUM7U0FDMUQ7UUFFRCxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgQXV0b2NvbXBsZXRlT3B0aW9uLFxyXG4gIENvbGxlY3Rpb25DdXN0b21TdHJ1Y3R1cmUsXHJcbiAgQ29sdW1uLFxyXG4gIENvbHVtbkVkaXRvcixcclxuICBFZGl0b3IsXHJcbiAgRWRpdG9yQXJndW1lbnRzLFxyXG4gIEVkaXRvclZhbGlkYXRvcixcclxuICBFZGl0b3JWYWxpZGF0b3JPdXRwdXQsXHJcbiAgRmllbGRUeXBlLFxyXG4gIEtleUNvZGUsXHJcbn0gZnJvbSAnLi8uLi9tb2RlbHMvaW5kZXgnO1xyXG5pbXBvcnQgeyBDb25zdGFudHMgfSBmcm9tICcuLy4uL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7IGZpbmRPckRlZmF1bHQsIGdldERlc2NlbmRhbnRQcm9wZXJ0eSwgc2V0RGVlcFZhbHVlIH0gZnJvbSAnLi4vc2VydmljZXMvdXRpbGl0aWVzJztcclxuXHJcbi8vIHVzaW5nIGV4dGVybmFsIG5vbi10eXBlZCBqcyBsaWJyYXJpZXNcclxuZGVjbGFyZSB2YXIgJDogYW55O1xyXG5cclxuLy8gbWluaW11bSBsZW5ndGggb2YgY2hhcnMgdG8gdHlwZSBiZWZvcmUgc3RhcnRpbmcgdG8gc3RhcnQgcXVlcnlpbmdcclxuY29uc3QgTUlOX0xFTkdUSCA9IDM7XHJcblxyXG4vKlxyXG4gKiBBbiBleGFtcGxlIG9mIGEgJ2RldGFjaGVkJyBlZGl0b3IuXHJcbiAqIEtleURvd24gZXZlbnRzIGFyZSBhbHNvIGhhbmRsZWQgdG8gcHJvdmlkZSBoYW5kbGluZyBmb3IgVGFiLCBTaGlmdC1UYWIsIEVzYyBhbmQgQ3RybC1FbnRlci5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBBdXRvQ29tcGxldGVFZGl0b3IgaW1wbGVtZW50cyBFZGl0b3Ige1xyXG4gIHByaXZhdGUgX2F1dG9Db21wbGV0ZU9wdGlvbnM6IEF1dG9jb21wbGV0ZU9wdGlvbjtcclxuICBwcml2YXRlIF9jdXJyZW50VmFsdWU6IGFueTtcclxuICBwcml2YXRlIF9kZWZhdWx0VGV4dFZhbHVlOiBzdHJpbmc7XHJcbiAgcHJpdmF0ZSBfZWxlbWVudENvbGxlY3Rpb246IGFueVtdO1xyXG4gIHByaXZhdGUgX2xhc3RJbnB1dEV2ZW50OiBLZXlib2FyZEV2ZW50O1xyXG5cclxuICAvKiogVGhlIEpRdWVyeSBET00gZWxlbWVudCAqL1xyXG4gIHByaXZhdGUgXyRlZGl0b3JFbG06IGFueTtcclxuXHJcbiAgLyoqIFNsaWNrR3JpZCBHcmlkIG9iamVjdCAqL1xyXG4gIGdyaWQ6IGFueTtcclxuXHJcbiAgLyoqIFRoZSBwcm9wZXJ0eSBuYW1lIGZvciBsYWJlbHMgaW4gdGhlIGNvbGxlY3Rpb24gKi9cclxuICBsYWJlbE5hbWU6IHN0cmluZztcclxuXHJcbiAgLyoqIFRoZSBwcm9wZXJ0eSBuYW1lIGZvciB2YWx1ZXMgaW4gdGhlIGNvbGxlY3Rpb24gKi9cclxuICB2YWx1ZU5hbWU6IHN0cmluZztcclxuXHJcbiAgZm9yY2VVc2VySW5wdXQ6IGJvb2xlYW47XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgYXJnczogRWRpdG9yQXJndW1lbnRzKSB7XHJcbiAgICBpZiAoIWFyZ3MpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbQW5ndWxhci1TbGlja0dyaWRdIFNvbWV0aGluZyBpcyB3cm9uZyB3aXRoIHRoaXMgZ3JpZCwgYW4gRWRpdG9yIG11c3QgYWx3YXlzIGhhdmUgdmFsaWQgYXJndW1lbnRzLicpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5ncmlkID0gYXJncy5ncmlkO1xyXG4gICAgdGhpcy5pbml0KCk7XHJcbiAgfVxyXG5cclxuICAvKiogR2V0dGVyIGZvciB0aGUgQXV0b2NvbXBsZXRlIE9wdGlvbiAqL1xyXG4gIGdldCBhdXRvQ29tcGxldGVPcHRpb25zKCk6IFBhcnRpYWw8QXV0b2NvbXBsZXRlT3B0aW9uPiB7XHJcbiAgICByZXR1cm4gdGhpcy5fYXV0b0NvbXBsZXRlT3B0aW9ucyB8fCB7fTtcclxuICB9XHJcblxyXG4gIC8qKiBHZXQgdGhlIENvbGxlY3Rpb24gKi9cclxuICBnZXQgZWRpdG9yQ29sbGVjdGlvbigpOiBhbnlbXSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb2x1bW5EZWYgJiYgdGhpcy5jb2x1bW5EZWYuaW50ZXJuYWxDb2x1bW5FZGl0b3IgJiYgdGhpcy5jb2x1bW5EZWYuaW50ZXJuYWxDb2x1bW5FZGl0b3IuY29sbGVjdGlvbiB8fCBbXTtcclxuICB9XHJcblxyXG4gIC8qKiBHZXQgdGhlIEZpbmFsIENvbGxlY3Rpb24gdXNlZCBpbiB0aGUgQXV0b0NvbXBsZXRlZCBTb3VyY2UgKHRoaXMgbWF5IHZhcnkgZnJvbSB0aGUgXCJjb2xsZWN0aW9uXCIgZXNwZWNpYWxseSB3aGVuIHByb3ZpZGluZyBhIGN1c3RvbVN0cnVjdHVyZSkgKi9cclxuICBnZXQgZWxlbWVudENvbGxlY3Rpb24oKTogYW55W10ge1xyXG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRDb2xsZWN0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldCBDb2x1bW4gRGVmaW5pdGlvbiBvYmplY3QgKi9cclxuICBnZXQgY29sdW1uRGVmKCk6IENvbHVtbiB8IHVuZGVmaW5lZCB7XHJcbiAgICByZXR1cm4gdGhpcy5hcmdzICYmIHRoaXMuYXJncy5jb2x1bW47XHJcbiAgfVxyXG5cclxuICAvKiogR2V0IENvbHVtbiBFZGl0b3Igb2JqZWN0ICovXHJcbiAgZ2V0IGNvbHVtbkVkaXRvcigpOiBDb2x1bW5FZGl0b3Ige1xyXG4gICAgcmV0dXJuIHRoaXMuY29sdW1uRGVmICYmIHRoaXMuY29sdW1uRGVmLmludGVybmFsQ29sdW1uRWRpdG9yIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBmb3IgdGhlIEN1c3RvbSBTdHJ1Y3R1cmUgaWYgZXhpc3QgKi9cclxuICBnZXQgY3VzdG9tU3RydWN0dXJlKCk6IENvbGxlY3Rpb25DdXN0b21TdHJ1Y3R1cmUge1xyXG4gICAgcmV0dXJuIHRoaXMuY29sdW1uRGVmICYmIHRoaXMuY29sdW1uRGVmLmludGVybmFsQ29sdW1uRWRpdG9yICYmIHRoaXMuY29sdW1uRGVmLmludGVybmFsQ29sdW1uRWRpdG9yLmN1c3RvbVN0cnVjdHVyZTtcclxuICB9XHJcblxyXG4gIGdldCBoYXNBdXRvQ29tbWl0RWRpdCgpIHtcclxuICAgIHJldHVybiB0aGlzLmdyaWQuZ2V0T3B0aW9ucygpLmF1dG9Db21taXRFZGl0O1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldCB0aGUgVmFsaWRhdG9yIGZ1bmN0aW9uLCBjYW4gYmUgcGFzc2VkIGluIEVkaXRvciBwcm9wZXJ0eSBvciBDb2x1bW4gRGVmaW5pdGlvbiAqL1xyXG4gIGdldCB2YWxpZGF0b3IoKTogRWRpdG9yVmFsaWRhdG9yIHtcclxuICAgIHJldHVybiB0aGlzLmNvbHVtbkVkaXRvci52YWxpZGF0b3IgfHwgdGhpcy5jb2x1bW5EZWYudmFsaWRhdG9yO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGVkaXRvck9wdGlvbnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb2x1bW5FZGl0b3IgJiYgdGhpcy5jb2x1bW5FZGl0b3IuZWRpdG9yT3B0aW9ucyB8fCB7fTtcclxuICB9XHJcblxyXG4gIC8qKiBHZXQgdGhlIEVkaXRvciBET00gRWxlbWVudCAqL1xyXG4gIGdldCBlZGl0b3JEb21FbGVtZW50KCk6IGFueSB7XHJcbiAgICByZXR1cm4gdGhpcy5fJGVkaXRvckVsbTtcclxuICB9XHJcblxyXG4gIGluaXQoKSB7XHJcbiAgICB0aGlzLmxhYmVsTmFtZSA9IHRoaXMuY3VzdG9tU3RydWN0dXJlICYmIHRoaXMuY3VzdG9tU3RydWN0dXJlLmxhYmVsIHx8ICdsYWJlbCc7XHJcbiAgICB0aGlzLnZhbHVlTmFtZSA9IHRoaXMuY3VzdG9tU3RydWN0dXJlICYmIHRoaXMuY3VzdG9tU3RydWN0dXJlLnZhbHVlIHx8ICd2YWx1ZSc7XHJcblxyXG4gICAgLy8gYWx3YXlzIHJlbmRlciB0aGUgRE9NIGVsZW1lbnQsIGV2ZW4gaWYgdXNlciBwYXNzZWQgYSBcImNvbGxlY3Rpb25Bc3luY1wiLFxyXG4gICAgY29uc3QgbmV3Q29sbGVjdGlvbiA9IHRoaXMuY29sdW1uRWRpdG9yLmNvbGxlY3Rpb24gfHwgW107XHJcbiAgICB0aGlzLnJlbmRlckRvbUVsZW1lbnQobmV3Q29sbGVjdGlvbik7XHJcbiAgfVxyXG5cclxuICBkZXN0cm95KCkge1xyXG4gICAgdGhpcy5fJGVkaXRvckVsbS5vZmYoJ2tleWRvd24ubmF2JykucmVtb3ZlKCk7XHJcbiAgfVxyXG5cclxuICBmb2N1cygpIHtcclxuICAgIHRoaXMuXyRlZGl0b3JFbG0uZm9jdXMoKS5zZWxlY3QoKTtcclxuICB9XHJcblxyXG4gIGdldFZhbHVlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuXyRlZGl0b3JFbG0udmFsKCk7XHJcbiAgfVxyXG5cclxuICBzZXRWYWx1ZSh2YWx1ZTogc3RyaW5nKSB7XHJcbiAgICB0aGlzLl8kZWRpdG9yRWxtLnZhbCh2YWx1ZSk7XHJcbiAgfVxyXG5cclxuICBhcHBseVZhbHVlKGl0ZW06IGFueSwgc3RhdGU6IGFueSkge1xyXG4gICAgbGV0IG5ld1ZhbHVlID0gc3RhdGU7XHJcbiAgICBjb25zdCBmaWVsZE5hbWUgPSB0aGlzLmNvbHVtbkRlZiAmJiB0aGlzLmNvbHVtbkRlZi5maWVsZDtcclxuXHJcbiAgICAvLyBpZiB3ZSBoYXZlIGEgY29sbGVjdGlvbiBkZWZpbmVkLCB3ZSB3aWxsIHRyeSB0byBmaW5kIHRoZSBzdHJpbmcgd2l0aGluIHRoZSBjb2xsZWN0aW9uIGFuZCByZXR1cm4gaXRcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZWRpdG9yQ29sbGVjdGlvbikgJiYgdGhpcy5lZGl0b3JDb2xsZWN0aW9uLmxlbmd0aCA+IDApIHtcclxuICAgICAgbmV3VmFsdWUgPSBmaW5kT3JEZWZhdWx0KHRoaXMuZWRpdG9yQ29sbGVjdGlvbiwgKGNvbGxlY3Rpb25JdGVtOiBhbnkpID0+IHtcclxuICAgICAgICBpZiAoY29sbGVjdGlvbkl0ZW0gJiYgdHlwZW9mIHN0YXRlID09PSAnb2JqZWN0JyAmJiBjb2xsZWN0aW9uSXRlbS5oYXNPd25Qcm9wZXJ0eSh0aGlzLmxhYmVsTmFtZSkpIHtcclxuICAgICAgICAgIHJldHVybiAoY29sbGVjdGlvbkl0ZW0uaGFzT3duUHJvcGVydHkodGhpcy5sYWJlbE5hbWUpICYmIGNvbGxlY3Rpb25JdGVtW3RoaXMubGFiZWxOYW1lXS50b1N0cmluZygpKSA9PT0gKHN0YXRlLmhhc093blByb3BlcnR5KHRoaXMubGFiZWxOYW1lKSAmJiBzdGF0ZVt0aGlzLmxhYmVsTmFtZV0udG9TdHJpbmcoKSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjb2xsZWN0aW9uSXRlbSAmJiB0eXBlb2Ygc3RhdGUgPT09ICdzdHJpbmcnICYmIGNvbGxlY3Rpb25JdGVtLmhhc093blByb3BlcnR5KHRoaXMubGFiZWxOYW1lKSkge1xyXG4gICAgICAgICAgcmV0dXJuIChjb2xsZWN0aW9uSXRlbS5oYXNPd25Qcm9wZXJ0eSh0aGlzLmxhYmVsTmFtZSkgJiYgY29sbGVjdGlvbkl0ZW1bdGhpcy5sYWJlbE5hbWVdLnRvU3RyaW5nKCkpID09PSBzdGF0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25JdGVtICYmIGNvbGxlY3Rpb25JdGVtLnRvU3RyaW5nKCkgPT09IHN0YXRlO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpcyB0aGUgZmllbGQgYSBjb21wbGV4IG9iamVjdCwgXCJhZGRyZXNzLnN0cmVldE51bWJlclwiXHJcbiAgICBjb25zdCBpc0NvbXBsZXhPYmplY3QgPSBmaWVsZE5hbWUuaW5kZXhPZignLicpID4gMDtcclxuXHJcbiAgICAvLyB2YWxpZGF0ZSB0aGUgdmFsdWUgYmVmb3JlIGFwcGx5aW5nIGl0IChpZiBub3QgdmFsaWQgd2UnbGwgc2V0IGFuIGVtcHR5IHN0cmluZylcclxuICAgIGNvbnN0IHZhbGlkYXRpb24gPSB0aGlzLnZhbGlkYXRlKG5ld1ZhbHVlKTtcclxuICAgIG5ld1ZhbHVlID0gKHZhbGlkYXRpb24gJiYgdmFsaWRhdGlvbi52YWxpZCkgPyBuZXdWYWx1ZSA6ICcnO1xyXG5cclxuICAgIC8vIHNldCB0aGUgbmV3IHZhbHVlIHRvIHRoZSBpdGVtIGRhdGFjb250ZXh0XHJcbiAgICBpZiAoaXNDb21wbGV4T2JqZWN0KSB7XHJcbiAgICAgIHNldERlZXBWYWx1ZShpdGVtLCBmaWVsZE5hbWUsIG5ld1ZhbHVlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGl0ZW1bZmllbGROYW1lXSA9IG5ld1ZhbHVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaXNWYWx1ZUNoYW5nZWQoKTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCBsYXN0RXZlbnQgPSB0aGlzLl9sYXN0SW5wdXRFdmVudCAmJiB0aGlzLl9sYXN0SW5wdXRFdmVudC5rZXlDb2RlO1xyXG4gICAgaWYgKHRoaXMuY29sdW1uRWRpdG9yICYmIHRoaXMuY29sdW1uRWRpdG9yLmFsd2F5c1NhdmVPbkVudGVyS2V5ICYmIGxhc3RFdmVudCA9PT0gS2V5Q29kZS5FTlRFUikge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiAoISh0aGlzLl8kZWRpdG9yRWxtLnZhbCgpID09PSAnJyAmJiB0aGlzLl9kZWZhdWx0VGV4dFZhbHVlID09PSBudWxsKSkgJiYgKHRoaXMuXyRlZGl0b3JFbG0udmFsKCkgIT09IHRoaXMuX2RlZmF1bHRUZXh0VmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgbG9hZFZhbHVlKGl0ZW06IGFueSkge1xyXG4gICAgY29uc3QgZmllbGROYW1lID0gdGhpcy5jb2x1bW5EZWYgJiYgdGhpcy5jb2x1bW5EZWYuZmllbGQ7XHJcblxyXG4gICAgLy8gaXMgdGhlIGZpZWxkIGEgY29tcGxleCBvYmplY3QsIFwiYWRkcmVzcy5zdHJlZXROdW1iZXJcIlxyXG4gICAgY29uc3QgaXNDb21wbGV4T2JqZWN0ID0gZmllbGROYW1lLmluZGV4T2YoJy4nKSA+IDA7XHJcblxyXG4gICAgaWYgKGl0ZW0gJiYgdGhpcy5jb2x1bW5EZWYgJiYgKGl0ZW0uaGFzT3duUHJvcGVydHkoZmllbGROYW1lKSB8fCBpc0NvbXBsZXhPYmplY3QpKSB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSAoaXNDb21wbGV4T2JqZWN0KSA/IGdldERlc2NlbmRhbnRQcm9wZXJ0eShpdGVtLCBmaWVsZE5hbWUpIDogaXRlbVtmaWVsZE5hbWVdO1xyXG4gICAgICB0aGlzLl9jdXJyZW50VmFsdWUgPSBkYXRhO1xyXG4gICAgICB0aGlzLl9kZWZhdWx0VGV4dFZhbHVlID0gdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID8gZGF0YSA6IGRhdGFbdGhpcy5sYWJlbE5hbWVdO1xyXG4gICAgICB0aGlzLl8kZWRpdG9yRWxtLnZhbCh0aGlzLl9kZWZhdWx0VGV4dFZhbHVlKTtcclxuICAgICAgdGhpcy5fJGVkaXRvckVsbS5zZWxlY3QoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNhdmUoKSB7XHJcbiAgICBjb25zdCB2YWxpZGF0aW9uID0gdGhpcy52YWxpZGF0ZSgpO1xyXG4gICAgaWYgKHZhbGlkYXRpb24gJiYgdmFsaWRhdGlvbi52YWxpZCAmJiB0aGlzLmlzVmFsdWVDaGFuZ2VkKCkpIHtcclxuICAgICAgaWYgKHRoaXMuaGFzQXV0b0NvbW1pdEVkaXQpIHtcclxuICAgICAgICB0aGlzLmdyaWQuZ2V0RWRpdG9yTG9jaygpLmNvbW1pdEN1cnJlbnRFZGl0KCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5hcmdzLmNvbW1pdENoYW5nZXMoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc2VyaWFsaXplVmFsdWUoKTogYW55IHtcclxuICAgIC8vIGlmIHlvdSB3YW50IHRvIGFkZCB0aGUgYXV0b2NvbXBsZXRlIGZ1bmN0aW9uYWxpdHkgYnV0IHdhbnQgdGhlIHVzZXIgdG8gYmUgYWJsZSB0byBpbnB1dCBhIG5ldyBvcHRpb25cclxuICAgIGlmICh0aGlzLmVkaXRvck9wdGlvbnMuZm9yY2VVc2VySW5wdXQpIHtcclxuICAgICAgY29uc3QgbWluTGVuZ3RoID0gdGhpcy5lZGl0b3JPcHRpb25zICYmIHRoaXMuZWRpdG9yT3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnbWluTGVuZ3RoJykgPyB0aGlzLmVkaXRvck9wdGlvbnMubWluTGVuZ3RoIDogTUlOX0xFTkdUSDtcclxuICAgICAgdGhpcy5fY3VycmVudFZhbHVlID0gdGhpcy5fJGVkaXRvckVsbS52YWwoKS5sZW5ndGggPiBtaW5MZW5ndGggPyB0aGlzLl8kZWRpdG9yRWxtLnZhbCgpIDogdGhpcy5fY3VycmVudFZhbHVlO1xyXG4gICAgfVxyXG4gICAgLy8gaWYgdXNlciBwcm92aWRlZCBhIGN1c3RvbSBzdHJ1Y3R1cmUsIHdlIHdpbGwgc2VyaWFsaXplIHRoZSB2YWx1ZSByZXR1cm5lZCBmcm9tIHRoZSBvYmplY3Qgd2l0aCBjdXN0b20gc3RydWN0dXJlXHJcbiAgICBpZiAodGhpcy5jdXN0b21TdHJ1Y3R1cmUgJiYgdGhpcy5fY3VycmVudFZhbHVlICYmIHRoaXMuX2N1cnJlbnRWYWx1ZS5oYXNPd25Qcm9wZXJ0eSh0aGlzLmxhYmVsTmFtZSkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRWYWx1ZVt0aGlzLmxhYmVsTmFtZV07XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2N1cnJlbnRWYWx1ZSAmJiB0aGlzLl9jdXJyZW50VmFsdWUubGFiZWwpIHtcclxuICAgICAgaWYgKHRoaXMuY29sdW1uRGVmLnR5cGUgPT09IEZpZWxkVHlwZS5vYmplY3QpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgW3RoaXMubGFiZWxOYW1lXTogdGhpcy5fY3VycmVudFZhbHVlLmxhYmVsLFxyXG4gICAgICAgICAgW3RoaXMudmFsdWVOYW1lXTogdGhpcy5fY3VycmVudFZhbHVlLnZhbHVlXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5fY3VycmVudFZhbHVlLmxhYmVsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRWYWx1ZTtcclxuICB9XHJcblxyXG4gIHZhbGlkYXRlKGlucHV0VmFsdWU/OiBhbnkpOiBFZGl0b3JWYWxpZGF0b3JPdXRwdXQge1xyXG4gICAgY29uc3QgaXNSZXF1aXJlZCA9IHRoaXMuY29sdW1uRWRpdG9yLnJlcXVpcmVkO1xyXG4gICAgY29uc3QgZWxtVmFsdWUgPSAoaW5wdXRWYWx1ZSAhPT0gdW5kZWZpbmVkKSA/IGlucHV0VmFsdWUgOiB0aGlzLl8kZWRpdG9yRWxtICYmIHRoaXMuXyRlZGl0b3JFbG0udmFsICYmIHRoaXMuXyRlZGl0b3JFbG0udmFsKCk7XHJcbiAgICBjb25zdCBlcnJvck1zZyA9IHRoaXMuY29sdW1uRWRpdG9yLmVycm9yTWVzc2FnZTtcclxuXHJcbiAgICBpZiAodGhpcy52YWxpZGF0b3IpIHtcclxuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdG9yKGVsbVZhbHVlLCB0aGlzLmFyZ3MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGJ5IGRlZmF1bHQgdGhlIGVkaXRvciBpcyBhbG1vc3QgYWx3YXlzIHZhbGlkIChleGNlcHQgd2hlbiBpdCdzIHJlcXVpcmVkIGJ1dCBub3QgcHJvdmlkZWQpXHJcbiAgICBpZiAoaXNSZXF1aXJlZCAmJiBlbG1WYWx1ZSA9PT0gJycpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB2YWxpZDogZmFsc2UsXHJcbiAgICAgICAgbXNnOiBlcnJvck1zZyB8fCBDb25zdGFudHMuVkFMSURBVElPTl9SRVFVSVJFRF9GSUVMRFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHZhbGlkOiB0cnVlLFxyXG4gICAgICBtc2c6IG51bGxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvL1xyXG4gIC8vIHByaXZhdGUgZnVuY3Rpb25zXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIFBSSVZBVEUgYnV0IGZvciB1bml0IHRlc3RzIHB1cnBvc2VzIHdlJ2xsIG1ha2UgaXQgcHVibGljIHVudGlsIGEgYmV0dGVyIHNvbHV0aW9uIGlzIGZvdW5kXHJcbiAgLy8gYSBiZXR0ZXIgc29sdXRpb24gd291bGQgYmUgdG8gZ2V0IHRoZSBhdXRvY29tcGxldGUgRE9NIGVsZW1lbnQgdG8gd29yayB3aXRoIHNlbGVjdGlvbiBidXQgSSBjb3VsZG4ndCBmaW5kIGhvdyB0byBkbyB0aGF0IGluIEplc3RcclxuICBvblNlbGVjdChldmVudDogRXZlbnQsIHVpOiBhbnkpOiBib29sZWFuIHtcclxuICAgIGlmICh1aSAmJiB1aS5pdGVtKSB7XHJcbiAgICAgIHRoaXMuX2N1cnJlbnRWYWx1ZSA9IHVpICYmIHVpLml0ZW07XHJcbiAgICAgIGNvbnN0IGl0ZW1MYWJlbCA9IHR5cGVvZiB1aS5pdGVtID09PSAnc3RyaW5nJyA/IHVpLml0ZW0gOiB1aS5pdGVtLmxhYmVsO1xyXG4gICAgICB0aGlzLnNldFZhbHVlKGl0ZW1MYWJlbCk7XHJcblxyXG4gICAgICBpZiAodGhpcy5oYXNBdXRvQ29tbWl0RWRpdCkge1xyXG4gICAgICAgIC8vIGRvIG5vdCB1c2UgYXJncy5jb21taXRDaGFuZ2VzKCkgYXMgdGhpcyBzZXRzIHRoZSBmb2N1cyB0byB0aGUgbmV4dCByb3cuXHJcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHRoaXMudmFsaWRhdGUoKTtcclxuICAgICAgICBpZiAodmFsaWRhdGlvbiAmJiB2YWxpZGF0aW9uLnZhbGlkKSB7XHJcbiAgICAgICAgICB0aGlzLmdyaWQuZ2V0RWRpdG9yTG9jaygpLmNvbW1pdEN1cnJlbnRFZGl0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHJlbmRlckRvbUVsZW1lbnQoY29sbGVjdGlvbjogYW55W10pIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShjb2xsZWN0aW9uKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBcImNvbGxlY3Rpb25cIiBwYXNzZWQgdG8gdGhlIEF1dG9jb21wbGV0ZSBFZGl0b3IgaXMgbm90IGEgdmFsaWQgYXJyYXkuJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb2x1bW5JZCA9IHRoaXMuY29sdW1uRGVmICYmIHRoaXMuY29sdW1uRGVmLmlkO1xyXG4gICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLmNvbHVtbkVkaXRvciAmJiB0aGlzLmNvbHVtbkVkaXRvci5wbGFjZWhvbGRlciB8fCAnJztcclxuICAgIGNvbnN0IHRpdGxlID0gdGhpcy5jb2x1bW5FZGl0b3IgJiYgdGhpcy5jb2x1bW5FZGl0b3IudGl0bGUgfHwgJyc7XHJcblxyXG4gICAgdGhpcy5fJGVkaXRvckVsbSA9ICQoYDxpbnB1dCB0eXBlPVwidGV4dFwiIHJvbGU9XCJwcmVzZW50YXRpb25cIiBhdXRvY29tcGxldGU9XCJvZmZcIiBjbGFzcz1cImF1dG9jb21wbGV0ZSBlZGl0b3ItdGV4dCBlZGl0b3ItJHtjb2x1bW5JZH1cIiBwbGFjZWhvbGRlcj1cIiR7cGxhY2Vob2xkZXJ9XCIgdGl0bGU9XCIke3RpdGxlfVwiIC8+YClcclxuICAgICAgLmFwcGVuZFRvKHRoaXMuYXJncy5jb250YWluZXIpXHJcbiAgICAgIC5vbigna2V5ZG93bi5uYXYnLCAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLl9sYXN0SW5wdXRFdmVudCA9IGV2ZW50O1xyXG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBLZXlDb2RlLkxFRlQgfHwgZXZlbnQua2V5Q29kZSA9PT0gS2V5Q29kZS5SSUdIVCkge1xyXG4gICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyB1c2VyIG1pZ2h0IHBhc3MgaGlzIG93biBhdXRvY29tcGxldGUgb3B0aW9uc1xyXG4gICAgY29uc3QgYXV0b0NvbXBsZXRlT3B0aW9uczogQXV0b2NvbXBsZXRlT3B0aW9uID0gdGhpcy5jb2x1bW5FZGl0b3IuZWRpdG9yT3B0aW9ucztcclxuXHJcbiAgICAvLyBhc3NpZ24gdGhlIGNvbGxlY3Rpb24gdG8gYSB0ZW1wIHZhcmlhYmxlIGJlZm9yZSBmaWx0ZXJpbmcvc29ydGluZyB0aGUgY29sbGVjdGlvblxyXG4gICAgbGV0IGZpbmFsQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XHJcblxyXG4gICAgLy8gdXNlciBtaWdodCBwcm92aWRlIGhpcyBvd24gY3VzdG9tIHN0cnVjdHVyZVxyXG4gICAgLy8galF1ZXJ5IFVJIGF1dG9jb21wbGV0ZSByZXF1aXJlcyBhIGxhYmVsL3ZhbHVlIHBhaXIsIHNvIHdlIG11c3QgcmVtYXAgdGhlbSB3aGVuIHVzZXIgcHJvdmlkZSBkaWZmZXJlbnQgb25lc1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmluYWxDb2xsZWN0aW9uKSAmJiB0aGlzLmN1c3RvbVN0cnVjdHVyZSkge1xyXG4gICAgICBmaW5hbENvbGxlY3Rpb24gPSBmaW5hbENvbGxlY3Rpb24ubWFwKChpdGVtKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHsgbGFiZWw6IGl0ZW1bdGhpcy5sYWJlbE5hbWVdLCB2YWx1ZTogaXRlbVt0aGlzLnZhbHVlTmFtZV0gfTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8ga2VlcCB0aGUgZmluYWwgc291cmNlIGNvbGxlY3Rpb24gdXNlZCBpbiB0aGUgQXV0b0NvbXBsZXRlIGFzIHJlZmVyZW5jZVxyXG4gICAgdGhpcy5fZWxlbWVudENvbGxlY3Rpb24gPSBmaW5hbENvbGxlY3Rpb247XHJcblxyXG4gICAgLy8gd2hlbiB1c2VyIHBhc3NlcyBpdCdzIG93biBhdXRvY29tcGxldGUgb3B0aW9uc1xyXG4gICAgLy8gd2Ugc3RpbGwgbmVlZCB0byBwcm92aWRlIG91ciBvd24gXCJzZWxlY3RcIiBjYWxsYmFjayBpbXBsZW1lbnRhdGlvblxyXG4gICAgaWYgKGF1dG9Db21wbGV0ZU9wdGlvbnMpIHtcclxuICAgICAgYXV0b0NvbXBsZXRlT3B0aW9ucy5zZWxlY3QgPSAoZXZlbnQ6IEV2ZW50LCB1aTogYW55KSA9PiB0aGlzLm9uU2VsZWN0KGV2ZW50LCB1aSk7XHJcbiAgICAgIHRoaXMuX2F1dG9Db21wbGV0ZU9wdGlvbnMgPSB7IC4uLmF1dG9Db21wbGV0ZU9wdGlvbnMgfTtcclxuICAgICAgdGhpcy5fJGVkaXRvckVsbS5hdXRvY29tcGxldGUoYXV0b0NvbXBsZXRlT3B0aW9ucyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBkZWZpbmVkT3B0aW9uczogQXV0b2NvbXBsZXRlT3B0aW9uID0ge1xyXG4gICAgICAgIHNvdXJjZTogZmluYWxDb2xsZWN0aW9uLFxyXG4gICAgICAgIG1pbkxlbmd0aDogMCxcclxuICAgICAgICBzZWxlY3Q6IChldmVudDogRXZlbnQsIHVpOiBhbnkpID0+IHRoaXMub25TZWxlY3QoZXZlbnQsIHVpKSxcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5fYXV0b0NvbXBsZXRlT3B0aW9ucyA9IHsgLi4uZGVmaW5lZE9wdGlvbnMsIC4uLih0aGlzLmNvbHVtbkVkaXRvci5lZGl0b3JPcHRpb25zIGFzIEF1dG9jb21wbGV0ZU9wdGlvbikgfTtcclxuICAgICAgdGhpcy5fJGVkaXRvckVsbS5hdXRvY29tcGxldGUodGhpcy5fYXV0b0NvbXBsZXRlT3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmZvY3VzKCksIDUwKTtcclxuICB9XHJcbn1cclxuIl19