import * as tslib_1 from "tslib";
import { Optional } from '@angular/core';
import { TranslateService } from '@ngx-translate/core';
import { mapFlatpickrDateFormatWithFieldType, mapMomentDateFormatWithFieldType } from '../services/utilities';
import { FieldType, OperatorType, } from '../models/index';
import Flatpickr from 'flatpickr';
import * as moment_ from 'moment-mini';
const moment = moment_; // patch to fix rollup "moment has no default export" issue, document here https://github.com/rollup/rollup/issues/670
require('flatpickr');
let DateRangeFilter = class DateRangeFilter {
    constructor(translate) {
        this.translate = translate;
        this._clearFilterTriggered = false;
        this._shouldTriggerQuery = true;
    }
    /** Getter for the Grid Options pulled through the Grid Object */
    get gridOptions() {
        return (this.grid && this.grid.getOptions) ? this.grid.getOptions() : {};
    }
    /** Getter for the Column Filter */
    get columnFilter() {
        return this.columnDef && this.columnDef.filter || {};
    }
    /** Getter for the Current Dates selected */
    get currentDates() {
        return this._currentDates;
    }
    /** Getter to know what would be the default operator when none is specified */
    get defaultOperator() {
        return this.gridOptions.defaultFilterRangeOperator || OperatorType.rangeExclusive;
    }
    /** Getter for the Flatpickr Options */
    get flatpickrOptions() {
        return this._flatpickrOptions || {};
    }
    /** Getter of the Operator to use when doing the filter comparing */
    get operator() {
        return this.columnFilter && this.columnFilter.operator || this.defaultOperator;
    }
    /** Setter for the filter operator */
    set operator(operator) {
        if (this.columnFilter) {
            this.columnFilter.operator = operator;
        }
    }
    /**
     * Initialize the Filter
     */
    init(args) {
        if (!args) {
            throw new Error('[Angular-SlickGrid] A filter must always have an "init()" with valid arguments.');
        }
        this.grid = args.grid;
        this.callback = args.callback;
        this.columnDef = args.columnDef;
        this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];
        // step 1, create the DOM Element of the filter which contain the compound Operator+Input
        this.$filterElm = this.createDomElement(this.searchTerms);
        // step 3, subscribe to the keyup event and run the callback when that happens
        // also add/remove "filled" class for styling purposes
        this.$filterInputElm.keyup((e) => {
            this.onTriggerEvent(e);
        });
    }
    /**
     * Clear the filter value
     */
    clear(shouldTriggerQuery = true) {
        if (this.flatInstance) {
            this._clearFilterTriggered = true;
            this._shouldTriggerQuery = shouldTriggerQuery;
            this.searchTerms = [];
            this.flatInstance.clear();
        }
    }
    /**
     * destroy the filter
     */
    destroy() {
        if (this.$filterElm) {
            this.$filterElm.off('keyup').remove();
        }
        if (this.flatInstance && typeof this.flatInstance.destroy === 'function') {
            this.flatInstance.destroy();
        }
    }
    hide() {
        if (this.flatInstance && typeof this.flatInstance.close === 'function') {
            this.flatInstance.close();
        }
    }
    show() {
        if (this.flatInstance && typeof this.flatInstance.open === 'function') {
            this.flatInstance.open();
        }
    }
    /**
     * Set value(s) on the DOM element
     * @params searchTerms
     */
    setValues(searchTerms, operator) {
        let pickerValues = [];
        // get the picker values, if it's a string with the "..", we'll do the split else we'll use the array of search terms
        if (typeof searchTerms === 'string' || (Array.isArray(searchTerms) && typeof searchTerms[0] === 'string') && searchTerms[0].indexOf('..') > 0) {
            pickerValues = (typeof searchTerms === 'string') ? [searchTerms] : searchTerms[0].split('..');
        }
        else if (Array.isArray(searchTerms)) {
            pickerValues = searchTerms;
        }
        if (this.flatInstance && searchTerms) {
            this._currentDates = pickerValues;
            this.flatInstance.setDate(pickerValues);
        }
        // set the operator when defined
        this.operator = operator || this.defaultOperator;
    }
    //
    // private functions
    // ------------------
    buildDatePickerInput(searchTerms) {
        const columnId = this.columnDef && this.columnDef.id;
        const inputFormat = mapFlatpickrDateFormatWithFieldType(this.columnDef.type || FieldType.dateIso);
        const outputFormat = mapFlatpickrDateFormatWithFieldType(this.columnDef.outputType || this.columnDef.type || FieldType.dateUtc);
        const userFilterOptions = (this.columnFilter && this.columnFilter.filterOptions || {});
        // get current locale, if user defined a custom locale just use or get it the Translate Service if it exist else just use English
        let currentLocale = (userFilterOptions && userFilterOptions.locale) || (this.translate && this.translate.currentLang) || this.gridOptions.locale || 'en';
        if (currentLocale.length > 2) {
            currentLocale = currentLocale.substring(0, 2);
        }
        let pickerValues = [];
        // get the picker values, if it's a string with the "..", we'll do the split else we'll use the array of search terms
        if (typeof searchTerms === 'string' || (Array.isArray(searchTerms) && typeof searchTerms[0] === 'string') && searchTerms[0].indexOf('..') > 0) {
            pickerValues = (typeof searchTerms === 'string') ? [searchTerms] : searchTerms[0].split('..');
        }
        else if (Array.isArray(searchTerms)) {
            pickerValues = searchTerms;
        }
        // if we are preloading searchTerms, we'll keep them for reference
        if (pickerValues) {
            this._currentDates = pickerValues;
            const outFormat = mapMomentDateFormatWithFieldType(this.columnDef.type || FieldType.dateIso);
            this._currentDateStrings = pickerValues.map(date => moment(date).format(outFormat));
        }
        const pickerOptions = {
            defaultDate: pickerValues || '',
            altInput: true,
            altFormat: outputFormat,
            dateFormat: inputFormat,
            mode: 'range',
            wrap: true,
            closeOnSelect: true,
            locale: (currentLocale !== 'en') ? this.loadFlatpickrLocale(currentLocale) : 'en',
            onChange: (selectedDates, dateStr, instance) => {
                if (Array.isArray(selectedDates)) {
                    this._currentDates = selectedDates;
                    const outFormat = mapMomentDateFormatWithFieldType(this.columnDef.outputType || this.columnDef.type || FieldType.dateIso);
                    this._currentDateStrings = selectedDates.map(date => moment(date).format(outFormat));
                    this._currentValue = this._currentDateStrings.join('..');
                }
                // when using the time picker, we can simulate a keyup event to avoid multiple backend request
                // since backend request are only executed after user start typing, changing the time should be treated the same way
                const newEvent = pickerOptions.enableTime ? new CustomEvent('keyup') : undefined;
                this.onTriggerEvent(newEvent);
            }
        };
        // add the time picker when format is UTC (Z) or has the 'h' (meaning hours)
        if (outputFormat && (outputFormat === 'Z' || outputFormat.toLowerCase().includes('h'))) {
            pickerOptions.enableTime = true;
        }
        // merge options with optional user's custom options
        this._flatpickrOptions = Object.assign({}, pickerOptions, userFilterOptions);
        let placeholder = (this.gridOptions) ? (this.gridOptions.defaultFilterPlaceholder || '') : '';
        if (this.columnFilter && this.columnFilter.placeholder) {
            placeholder = this.columnFilter.placeholder;
        }
        const $filterInputElm = $(`<div class="flatpickr search-filter filter-${columnId}"><input type="text" class="form-control" data-input placeholder="${placeholder}"></div>`);
        this.flatInstance = ($filterInputElm[0] && typeof $filterInputElm[0].flatpickr === 'function') ? $filterInputElm[0].flatpickr(this._flatpickrOptions) : Flatpickr($filterInputElm, this._flatpickrOptions);
        return $filterInputElm;
    }
    /**
     * Create the DOM element
     * @params searchTerms
     */
    createDomElement(searchTerms) {
        const fieldId = this.columnDef && this.columnDef.id;
        const $headerElm = this.grid.getHeaderRowColumn(fieldId);
        $($headerElm).empty();
        // create the DOM Select dropdown for the Operator
        this.$filterInputElm = this.buildDatePickerInput(searchTerms);
        /* the DOM element final structure will be
          <div class=flatpickr>
            <input type="text" class="form-control" data-input>
          </div>
        */
        // create the DOM element & add an ID and filter class
        this.$filterInputElm.data('columnId', fieldId);
        // if there's a search term, we will add the "filled" class for styling purposes
        if (Array.isArray(searchTerms) && searchTerms.length > 0 && searchTerms[0] !== '') {
            this.$filterInputElm.addClass('filled');
            this._currentDates = searchTerms;
            this._currentValue = searchTerms[0];
        }
        // append the new DOM element to the header row
        if (this.$filterInputElm && typeof this.$filterInputElm.appendTo === 'function') {
            this.$filterInputElm.appendTo($headerElm);
        }
        return this.$filterInputElm;
    }
    /** Load a different set of locales for Flatpickr to be localized */
    loadFlatpickrLocale(language) {
        let locales = 'en';
        try {
            if (language !== 'en') {
                // change locale if needed, Flatpickr reference: https://chmln.github.io/flatpickr/localization/
                const localeDefault = require(`flatpickr/dist/l10n/${language}.js`).default;
                locales = (localeDefault && localeDefault[language]) ? localeDefault[language] : 'en';
            }
        }
        catch (e) {
            console.warn(`[Angular-Slickgrid - DateRange Filter] It seems that "${language}" is not a locale supported by Flatpickr, we will use "en" instead. `
                + `To avoid seeing this message, you can specifically set "filter: { filterOptions: { locale: 'en' } }" in your column definition.`);
            return 'en';
        }
        return locales;
    }
    onTriggerEvent(e) {
        if (this._clearFilterTriggered) {
            this.callback(e, { columnDef: this.columnDef, clearFilterTriggered: this._clearFilterTriggered, shouldTriggerQuery: this._shouldTriggerQuery });
            this.$filterElm.removeClass('filled');
        }
        else {
            (this._currentDateStrings) ? this.$filterElm.addClass('filled') : this.$filterElm.removeClass('filled');
            this.callback(e, { columnDef: this.columnDef, searchTerms: (this._currentDateStrings ? this._currentDateStrings : [this._currentValue]), operator: this.operator || '', shouldTriggerQuery: this._shouldTriggerQuery });
        }
        // reset both flags for next use
        this._clearFilterTriggered = false;
        this._shouldTriggerQuery = true;
    }
};
DateRangeFilter = tslib_1.__decorate([
    tslib_1.__param(0, Optional()),
    tslib_1.__metadata("design:paramtypes", [TranslateService])
], DateRangeFilter);
export { DateRangeFilter };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZVJhbmdlRmlsdGVyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1zbGlja2dyaWQvIiwic291cmNlcyI6WyJhcHAvbW9kdWxlcy9hbmd1bGFyLXNsaWNrZ3JpZC9maWx0ZXJzL2RhdGVSYW5nZUZpbHRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN6QyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN2RCxPQUFPLEVBQUUsbUNBQW1DLEVBQUUsZ0NBQWdDLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUM5RyxPQUFPLEVBR0wsU0FBUyxFQU9ULFlBQVksR0FFYixNQUFNLGlCQUFpQixDQUFDO0FBQ3pCLE9BQU8sU0FBUyxNQUFNLFdBQVcsQ0FBQztBQUVsQyxPQUFPLEtBQUssT0FBTyxNQUFNLGFBQWEsQ0FBQztBQUN2QyxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsQ0FBQyxzSEFBc0g7QUFJOUksT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBS3JCLElBQWEsZUFBZSxHQUE1QixNQUFhLGVBQWU7SUFlMUIsWUFBZ0MsU0FBMkI7UUFBM0IsY0FBUyxHQUFULFNBQVMsQ0FBa0I7UUFkbkQsMEJBQXFCLEdBQUcsS0FBSyxDQUFDO1FBSzlCLHdCQUFtQixHQUFHLElBQUksQ0FBQztJQVM0QixDQUFDO0lBRWhFLGlFQUFpRTtJQUNqRSxJQUFZLFdBQVc7UUFDckIsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQzNFLENBQUM7SUFFRCxtQ0FBbUM7SUFDbkMsSUFBSSxZQUFZO1FBQ2QsT0FBTyxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxT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LEVBQUU7WUFDOUIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLFNBQVMsRUFBRSxvQkFBb0IsRUFBRSxJQUFJLENBQUMscUJBQXFCLEVBQUUsa0JBQWtCLEVBQUUsSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUMsQ0FBQztZQUNoSixJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUN2QzthQUFNO1lBQ0wsQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3hHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLEVBQUUsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTLEVBQUUsV0FBVyxFQUFFLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFRLElBQUksRUFBRSxFQUFFLGtCQUFrQixFQUFFLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDLENBQUM7U0FDek47UUFDRCxnQ0FBZ0M7UUFDaEMsSUFBSSxDQUFDLHFCQUFxQixHQUFHLEtBQUssQ0FBQztRQUNuQyxJQUFJLENBQUMsbUJBQW1CLEdBQUcsSUFBSSxDQUFDO0lBQ2xDLENBQUM7Q0FDRixDQUFBO0FBbFJZLGVBQWU7SUFlYixtQkFBQSxRQUFRLEVBQUUsQ0FBQTs2Q0FBb0IsZ0JBQWdCO0dBZmhELGVBQWUsQ0FrUjNCO1NBbFJZLGVBQWUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBUcmFuc2xhdGVTZXJ2aWNlIH0gZnJvbSAnQG5neC10cmFuc2xhdGUvY29yZSc7XHJcbmltcG9ydCB7IG1hcEZsYXRwaWNrckRhdGVGb3JtYXRXaXRoRmllbGRUeXBlLCBtYXBNb21lbnREYXRlRm9ybWF0V2l0aEZpZWxkVHlwZSB9IGZyb20gJy4uL3NlcnZpY2VzL3V0aWxpdGllcyc7XHJcbmltcG9ydCB7XHJcbiAgQ29sdW1uLFxyXG4gIENvbHVtbkZpbHRlcixcclxuICBGaWVsZFR5cGUsXHJcbiAgRmlsdGVyLFxyXG4gIEZpbHRlckFyZ3VtZW50cyxcclxuICBGaWx0ZXJDYWxsYmFjayxcclxuICBGbGF0cGlja3JPcHRpb24sXHJcbiAgR3JpZE9wdGlvbixcclxuICBPcGVyYXRvclN0cmluZyxcclxuICBPcGVyYXRvclR5cGUsXHJcbiAgU2VhcmNoVGVybSxcclxufSBmcm9tICcuLi9tb2RlbHMvaW5kZXgnO1xyXG5pbXBvcnQgRmxhdHBpY2tyIGZyb20gJ2ZsYXRwaWNrcic7XHJcbmltcG9ydCB7IEJhc2VPcHRpb25zIGFzIEZsYXRwaWNrckJhc2VPcHRpb25zIH0gZnJvbSAnZmxhdHBpY2tyL2Rpc3QvdHlwZXMvb3B0aW9ucyc7XHJcbmltcG9ydCAqIGFzIG1vbWVudF8gZnJvbSAnbW9tZW50LW1pbmknO1xyXG5jb25zdCBtb21lbnQgPSBtb21lbnRfOyAvLyBwYXRjaCB0byBmaXggcm9sbHVwIFwibW9tZW50IGhhcyBubyBkZWZhdWx0IGV4cG9ydFwiIGlzc3VlLCBkb2N1bWVudCBoZXJlIGh0dHBzOi8vZ2l0aHViLmNvbS9yb2xsdXAvcm9sbHVwL2lzc3Vlcy82NzBcclxuXHJcbi8vIHVzZSBGbGF0cGlja3IgZnJvbSBpbXBvcnQgb3IgJ3JlcXVpcmUnLCB3aGljaGV2ZXIgd29ya3MgZmlyc3RcclxuZGVjbGFyZSBmdW5jdGlvbiByZXF1aXJlKG5hbWU6IHN0cmluZyk6IGFueTtcclxucmVxdWlyZSgnZmxhdHBpY2tyJyk7XHJcblxyXG4vLyB1c2luZyBleHRlcm5hbCBub24tdHlwZWQganMgbGlicmFyaWVzXHJcbmRlY2xhcmUgdmFyICQ6IGFueTtcclxuXHJcbmV4cG9ydCBjbGFzcyBEYXRlUmFuZ2VGaWx0ZXIgaW1wbGVtZW50cyBGaWx0ZXIge1xyXG4gIHByaXZhdGUgX2NsZWFyRmlsdGVyVHJpZ2dlcmVkID0gZmFsc2U7XHJcbiAgcHJpdmF0ZSBfY3VycmVudFZhbHVlOiBzdHJpbmc7XHJcbiAgcHJpdmF0ZSBfY3VycmVudERhdGVzOiBEYXRlW107XHJcbiAgcHJpdmF0ZSBfY3VycmVudERhdGVTdHJpbmdzOiBzdHJpbmdbXTtcclxuICBwcml2YXRlIF9mbGF0cGlja3JPcHRpb25zOiBGbGF0cGlja3JPcHRpb247XHJcbiAgcHJpdmF0ZSBfc2hvdWxkVHJpZ2dlclF1ZXJ5ID0gdHJ1ZTtcclxuICBwcml2YXRlICRmaWx0ZXJFbG06IGFueTtcclxuICBwcml2YXRlICRmaWx0ZXJJbnB1dEVsbTogYW55O1xyXG4gIGZsYXRJbnN0YW5jZTogYW55O1xyXG4gIGdyaWQ6IGFueTtcclxuICBzZWFyY2hUZXJtczogU2VhcmNoVGVybVtdO1xyXG4gIGNvbHVtbkRlZjogQ29sdW1uO1xyXG4gIGNhbGxiYWNrOiBGaWx0ZXJDYWxsYmFjaztcclxuXHJcbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJpdmF0ZSB0cmFuc2xhdGU6IFRyYW5zbGF0ZVNlcnZpY2UpIHsgfVxyXG5cclxuICAvKiogR2V0dGVyIGZvciB0aGUgR3JpZCBPcHRpb25zIHB1bGxlZCB0aHJvdWdoIHRoZSBHcmlkIE9iamVjdCAqL1xyXG4gIHByaXZhdGUgZ2V0IGdyaWRPcHRpb25zKCk6IEdyaWRPcHRpb24ge1xyXG4gICAgcmV0dXJuICh0aGlzLmdyaWQgJiYgdGhpcy5ncmlkLmdldE9wdGlvbnMpID8gdGhpcy5ncmlkLmdldE9wdGlvbnMoKSA6IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBmb3IgdGhlIENvbHVtbiBGaWx0ZXIgKi9cclxuICBnZXQgY29sdW1uRmlsdGVyKCk6IENvbHVtbkZpbHRlciB7XHJcbiAgICByZXR1cm4gdGhpcy5jb2x1bW5EZWYgJiYgdGhpcy5jb2x1bW5EZWYuZmlsdGVyIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBmb3IgdGhlIEN1cnJlbnQgRGF0ZXMgc2VsZWN0ZWQgKi9cclxuICBnZXQgY3VycmVudERhdGVzKCk6IERhdGVbXSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudERhdGVzO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciB0byBrbm93IHdoYXQgd291bGQgYmUgdGhlIGRlZmF1bHQgb3BlcmF0b3Igd2hlbiBub25lIGlzIHNwZWNpZmllZCAqL1xyXG4gIGdldCBkZWZhdWx0T3BlcmF0b3IoKTogT3BlcmF0b3JUeXBlIHwgT3BlcmF0b3JTdHJpbmcge1xyXG4gICAgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMuZGVmYXVsdEZpbHRlclJhbmdlT3BlcmF0b3IgfHwgT3BlcmF0b3JUeXBlLnJhbmdlRXhjbHVzaXZlO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBmb3IgdGhlIEZsYXRwaWNrciBPcHRpb25zICovXHJcbiAgZ2V0IGZsYXRwaWNrck9wdGlvbnMoKTogRmxhdHBpY2tyT3B0aW9uIHtcclxuICAgIHJldHVybiB0aGlzLl9mbGF0cGlja3JPcHRpb25zIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBvZiB0aGUgT3BlcmF0b3IgdG8gdXNlIHdoZW4gZG9pbmcgdGhlIGZpbHRlciBjb21wYXJpbmcgKi9cclxuICBnZXQgb3BlcmF0b3IoKTogT3BlcmF0b3JUeXBlIHwgT3BlcmF0b3JTdHJpbmcge1xyXG4gICAgcmV0dXJuIHRoaXMuY29sdW1uRmlsdGVyICYmIHRoaXMuY29sdW1uRmlsdGVyLm9wZXJhdG9yIHx8IHRoaXMuZGVmYXVsdE9wZXJhdG9yO1xyXG4gIH1cclxuXHJcbiAgLyoqIFNldHRlciBmb3IgdGhlIGZpbHRlciBvcGVyYXRvciAqL1xyXG4gIHNldCBvcGVyYXRvcihvcGVyYXRvcjogT3BlcmF0b3JUeXBlIHwgT3BlcmF0b3JTdHJpbmcpIHtcclxuICAgIGlmICh0aGlzLmNvbHVtbkZpbHRlcikge1xyXG4gICAgICB0aGlzLmNvbHVtbkZpbHRlci5vcGVyYXRvciA9IG9wZXJhdG9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSB0aGUgRmlsdGVyXHJcbiAgICovXHJcbiAgaW5pdChhcmdzOiBGaWx0ZXJBcmd1bWVudHMpIHtcclxuICAgIGlmICghYXJncykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tBbmd1bGFyLVNsaWNrR3JpZF0gQSBmaWx0ZXIgbXVzdCBhbHdheXMgaGF2ZSBhbiBcImluaXQoKVwiIHdpdGggdmFsaWQgYXJndW1lbnRzLicpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZ3JpZCA9IGFyZ3MuZ3JpZDtcclxuICAgIHRoaXMuY2FsbGJhY2sgPSBhcmdzLmNhbGxiYWNrO1xyXG4gICAgdGhpcy5jb2x1bW5EZWYgPSBhcmdzLmNvbHVtbkRlZjtcclxuICAgIHRoaXMuc2VhcmNoVGVybXMgPSAoYXJncy5oYXNPd25Qcm9wZXJ0eSgnc2VhcmNoVGVybXMnKSA/IGFyZ3Muc2VhcmNoVGVybXMgOiBbXSkgfHwgW107XHJcblxyXG4gICAgLy8gc3RlcCAxLCBjcmVhdGUgdGhlIERPTSBFbGVtZW50IG9mIHRoZSBmaWx0ZXIgd2hpY2ggY29udGFpbiB0aGUgY29tcG91bmQgT3BlcmF0b3IrSW5wdXRcclxuICAgIHRoaXMuJGZpbHRlckVsbSA9IHRoaXMuY3JlYXRlRG9tRWxlbWVudCh0aGlzLnNlYXJjaFRlcm1zKTtcclxuXHJcbiAgICAvLyBzdGVwIDMsIHN1YnNjcmliZSB0byB0aGUga2V5dXAgZXZlbnQgYW5kIHJ1biB0aGUgY2FsbGJhY2sgd2hlbiB0aGF0IGhhcHBlbnNcclxuICAgIC8vIGFsc28gYWRkL3JlbW92ZSBcImZpbGxlZFwiIGNsYXNzIGZvciBzdHlsaW5nIHB1cnBvc2VzXHJcbiAgICB0aGlzLiRmaWx0ZXJJbnB1dEVsbS5rZXl1cCgoZTogYW55KSA9PiB7XHJcbiAgICAgIHRoaXMub25UcmlnZ2VyRXZlbnQoZSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsZWFyIHRoZSBmaWx0ZXIgdmFsdWVcclxuICAgKi9cclxuICBjbGVhcihzaG91bGRUcmlnZ2VyUXVlcnkgPSB0cnVlKSB7XHJcbiAgICBpZiAodGhpcy5mbGF0SW5zdGFuY2UpIHtcclxuICAgICAgdGhpcy5fY2xlYXJGaWx0ZXJUcmlnZ2VyZWQgPSB0cnVlO1xyXG4gICAgICB0aGlzLl9zaG91bGRUcmlnZ2VyUXVlcnkgPSBzaG91bGRUcmlnZ2VyUXVlcnk7XHJcbiAgICAgIHRoaXMuc2VhcmNoVGVybXMgPSBbXTtcclxuICAgICAgdGhpcy5mbGF0SW5zdGFuY2UuY2xlYXIoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGRlc3Ryb3kgdGhlIGZpbHRlclxyXG4gICAqL1xyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICBpZiAodGhpcy4kZmlsdGVyRWxtKSB7XHJcbiAgICAgIHRoaXMuJGZpbHRlckVsbS5vZmYoJ2tleXVwJykucmVtb3ZlKCk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5mbGF0SW5zdGFuY2UgJiYgdHlwZW9mIHRoaXMuZmxhdEluc3RhbmNlLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhpcy5mbGF0SW5zdGFuY2UuZGVzdHJveSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaGlkZSgpIHtcclxuICAgIGlmICh0aGlzLmZsYXRJbnN0YW5jZSAmJiB0eXBlb2YgdGhpcy5mbGF0SW5zdGFuY2UuY2xvc2UgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhpcy5mbGF0SW5zdGFuY2UuY2xvc2UoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNob3coKSB7XHJcbiAgICBpZiAodGhpcy5mbGF0SW5zdGFuY2UgJiYgdHlwZW9mIHRoaXMuZmxhdEluc3RhbmNlLm9wZW4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhpcy5mbGF0SW5zdGFuY2Uub3BlbigpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHZhbHVlKHMpIG9uIHRoZSBET00gZWxlbWVudFxyXG4gICAqIEBwYXJhbXMgc2VhcmNoVGVybXNcclxuICAgKi9cclxuICBzZXRWYWx1ZXMoc2VhcmNoVGVybXM6IFNlYXJjaFRlcm1bXSwgb3BlcmF0b3I/OiBPcGVyYXRvclR5cGUgfCBPcGVyYXRvclN0cmluZykge1xyXG4gICAgbGV0IHBpY2tlclZhbHVlcyA9IFtdO1xyXG5cclxuICAgIC8vIGdldCB0aGUgcGlja2VyIHZhbHVlcywgaWYgaXQncyBhIHN0cmluZyB3aXRoIHRoZSBcIi4uXCIsIHdlJ2xsIGRvIHRoZSBzcGxpdCBlbHNlIHdlJ2xsIHVzZSB0aGUgYXJyYXkgb2Ygc2VhcmNoIHRlcm1zXHJcbiAgICBpZiAodHlwZW9mIHNlYXJjaFRlcm1zID09PSAnc3RyaW5nJyB8fCAoQXJyYXkuaXNBcnJheShzZWFyY2hUZXJtcykgJiYgdHlwZW9mIHNlYXJjaFRlcm1zWzBdID09PSAnc3RyaW5nJykgJiYgKHNlYXJjaFRlcm1zWzBdIGFzIHN0cmluZykuaW5kZXhPZignLi4nKSA+IDApIHtcclxuICAgICAgcGlja2VyVmFsdWVzID0gKHR5cGVvZiBzZWFyY2hUZXJtcyA9PT0gJ3N0cmluZycpID8gWyhzZWFyY2hUZXJtcyBhcyBzdHJpbmcpXSA6IChzZWFyY2hUZXJtc1swXSBhcyBzdHJpbmcpLnNwbGl0KCcuLicpO1xyXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNlYXJjaFRlcm1zKSkge1xyXG4gICAgICBwaWNrZXJWYWx1ZXMgPSBzZWFyY2hUZXJtcztcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5mbGF0SW5zdGFuY2UgJiYgc2VhcmNoVGVybXMpIHtcclxuICAgICAgdGhpcy5fY3VycmVudERhdGVzID0gcGlja2VyVmFsdWVzO1xyXG4gICAgICB0aGlzLmZsYXRJbnN0YW5jZS5zZXREYXRlKHBpY2tlclZhbHVlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2V0IHRoZSBvcGVyYXRvciB3aGVuIGRlZmluZWRcclxuICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvciB8fCB0aGlzLmRlZmF1bHRPcGVyYXRvcjtcclxuICB9XHJcblxyXG4gIC8vXHJcbiAgLy8gcHJpdmF0ZSBmdW5jdGlvbnNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cclxuICBwcml2YXRlIGJ1aWxkRGF0ZVBpY2tlcklucHV0KHNlYXJjaFRlcm1zPzogU2VhcmNoVGVybSB8IFNlYXJjaFRlcm1bXSkge1xyXG4gICAgY29uc3QgY29sdW1uSWQgPSB0aGlzLmNvbHVtbkRlZiAmJiB0aGlzLmNvbHVtbkRlZi5pZDtcclxuICAgIGNvbnN0IGlucHV0Rm9ybWF0ID0gbWFwRmxhdHBpY2tyRGF0ZUZvcm1hdFdpdGhGaWVsZFR5cGUodGhpcy5jb2x1bW5EZWYudHlwZSB8fCBGaWVsZFR5cGUuZGF0ZUlzbyk7XHJcbiAgICBjb25zdCBvdXRwdXRGb3JtYXQgPSBtYXBGbGF0cGlja3JEYXRlRm9ybWF0V2l0aEZpZWxkVHlwZSh0aGlzLmNvbHVtbkRlZi5vdXRwdXRUeXBlIHx8IHRoaXMuY29sdW1uRGVmLnR5cGUgfHwgRmllbGRUeXBlLmRhdGVVdGMpO1xyXG4gICAgY29uc3QgdXNlckZpbHRlck9wdGlvbnMgPSAodGhpcy5jb2x1bW5GaWx0ZXIgJiYgdGhpcy5jb2x1bW5GaWx0ZXIuZmlsdGVyT3B0aW9ucyB8fCB7fSkgYXMgRmxhdHBpY2tyT3B0aW9uO1xyXG5cclxuICAgIC8vIGdldCBjdXJyZW50IGxvY2FsZSwgaWYgdXNlciBkZWZpbmVkIGEgY3VzdG9tIGxvY2FsZSBqdXN0IHVzZSBvciBnZXQgaXQgdGhlIFRyYW5zbGF0ZSBTZXJ2aWNlIGlmIGl0IGV4aXN0IGVsc2UganVzdCB1c2UgRW5nbGlzaFxyXG4gICAgbGV0IGN1cnJlbnRMb2NhbGUgPSAodXNlckZpbHRlck9wdGlvbnMgJiYgdXNlckZpbHRlck9wdGlvbnMubG9jYWxlKSB8fCAodGhpcy50cmFuc2xhdGUgJiYgdGhpcy50cmFuc2xhdGUuY3VycmVudExhbmcpIHx8IHRoaXMuZ3JpZE9wdGlvbnMubG9jYWxlIHx8ICdlbic7XHJcbiAgICBpZiAoY3VycmVudExvY2FsZS5sZW5ndGggPiAyKSB7XHJcbiAgICAgIGN1cnJlbnRMb2NhbGUgPSBjdXJyZW50TG9jYWxlLnN1YnN0cmluZygwLCAyKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgcGlja2VyVmFsdWVzID0gW107XHJcblxyXG4gICAgLy8gZ2V0IHRoZSBwaWNrZXIgdmFsdWVzLCBpZiBpdCdzIGEgc3RyaW5nIHdpdGggdGhlIFwiLi5cIiwgd2UnbGwgZG8gdGhlIHNwbGl0IGVsc2Ugd2UnbGwgdXNlIHRoZSBhcnJheSBvZiBzZWFyY2ggdGVybXNcclxuICAgIGlmICh0eXBlb2Ygc2VhcmNoVGVybXMgPT09ICdzdHJpbmcnIHx8IChBcnJheS5pc0FycmF5KHNlYXJjaFRlcm1zKSAmJiB0eXBlb2Ygc2VhcmNoVGVybXNbMF0gPT09ICdzdHJpbmcnKSAmJiAoc2VhcmNoVGVybXNbMF0gYXMgc3RyaW5nKS5pbmRleE9mKCcuLicpID4gMCkge1xyXG4gICAgICBwaWNrZXJWYWx1ZXMgPSAodHlwZW9mIHNlYXJjaFRlcm1zID09PSAnc3RyaW5nJykgPyBbKHNlYXJjaFRlcm1zIGFzIHN0cmluZyldIDogKHNlYXJjaFRlcm1zWzBdIGFzIHN0cmluZykuc3BsaXQoJy4uJyk7XHJcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2VhcmNoVGVybXMpKSB7XHJcbiAgICAgIHBpY2tlclZhbHVlcyA9IHNlYXJjaFRlcm1zO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIHdlIGFyZSBwcmVsb2FkaW5nIHNlYXJjaFRlcm1zLCB3ZSdsbCBrZWVwIHRoZW0gZm9yIHJlZmVyZW5jZVxyXG4gICAgaWYgKHBpY2tlclZhbHVlcykge1xyXG4gICAgICB0aGlzLl9jdXJyZW50RGF0ZXMgPSBwaWNrZXJWYWx1ZXM7XHJcbiAgICAgIGNvbnN0IG91dEZvcm1hdCA9IG1hcE1vbWVudERhdGVGb3JtYXRXaXRoRmllbGRUeXBlKHRoaXMuY29sdW1uRGVmLnR5cGUgfHwgRmllbGRUeXBlLmRhdGVJc28pO1xyXG4gICAgICB0aGlzLl9jdXJyZW50RGF0ZVN0cmluZ3MgPSBwaWNrZXJWYWx1ZXMubWFwKGRhdGUgPT4gbW9tZW50KGRhdGUpLmZvcm1hdChvdXRGb3JtYXQpKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwaWNrZXJPcHRpb25zOiBGbGF0cGlja3JPcHRpb24gPSB7XHJcbiAgICAgIGRlZmF1bHREYXRlOiBwaWNrZXJWYWx1ZXMgfHwgJycsXHJcbiAgICAgIGFsdElucHV0OiB0cnVlLFxyXG4gICAgICBhbHRGb3JtYXQ6IG91dHB1dEZvcm1hdCxcclxuICAgICAgZGF0ZUZvcm1hdDogaW5wdXRGb3JtYXQsXHJcbiAgICAgIG1vZGU6ICdyYW5nZScsXHJcbiAgICAgIHdyYXA6IHRydWUsXHJcbiAgICAgIGNsb3NlT25TZWxlY3Q6IHRydWUsXHJcbiAgICAgIGxvY2FsZTogKGN1cnJlbnRMb2NhbGUgIT09ICdlbicpID8gdGhpcy5sb2FkRmxhdHBpY2tyTG9jYWxlKGN1cnJlbnRMb2NhbGUpIDogJ2VuJyxcclxuICAgICAgb25DaGFuZ2U6IChzZWxlY3RlZERhdGVzOiBEYXRlW10gfCBEYXRlLCBkYXRlU3RyOiBzdHJpbmcsIGluc3RhbmNlOiBhbnkpID0+IHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZWxlY3RlZERhdGVzKSkge1xyXG4gICAgICAgICAgdGhpcy5fY3VycmVudERhdGVzID0gc2VsZWN0ZWREYXRlcztcclxuICAgICAgICAgIGNvbnN0IG91dEZvcm1hdCA9IG1hcE1vbWVudERhdGVGb3JtYXRXaXRoRmllbGRUeXBlKHRoaXMuY29sdW1uRGVmLm91dHB1dFR5cGUgfHwgdGhpcy5jb2x1bW5EZWYudHlwZSB8fCBGaWVsZFR5cGUuZGF0ZUlzbyk7XHJcbiAgICAgICAgICB0aGlzLl9jdXJyZW50RGF0ZVN0cmluZ3MgPSBzZWxlY3RlZERhdGVzLm1hcChkYXRlID0+IG1vbWVudChkYXRlKS5mb3JtYXQob3V0Rm9ybWF0KSk7XHJcbiAgICAgICAgICB0aGlzLl9jdXJyZW50VmFsdWUgPSB0aGlzLl9jdXJyZW50RGF0ZVN0cmluZ3Muam9pbignLi4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHdoZW4gdXNpbmcgdGhlIHRpbWUgcGlja2VyLCB3ZSBjYW4gc2ltdWxhdGUgYSBrZXl1cCBldmVudCB0byBhdm9pZCBtdWx0aXBsZSBiYWNrZW5kIHJlcXVlc3RcclxuICAgICAgICAvLyBzaW5jZSBiYWNrZW5kIHJlcXVlc3QgYXJlIG9ubHkgZXhlY3V0ZWQgYWZ0ZXIgdXNlciBzdGFydCB0eXBpbmcsIGNoYW5naW5nIHRoZSB0aW1lIHNob3VsZCBiZSB0cmVhdGVkIHRoZSBzYW1lIHdheVxyXG4gICAgICAgIGNvbnN0IG5ld0V2ZW50ID0gcGlja2VyT3B0aW9ucy5lbmFibGVUaW1lID8gbmV3IEN1c3RvbUV2ZW50KCdrZXl1cCcpIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMub25UcmlnZ2VyRXZlbnQobmV3RXZlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGFkZCB0aGUgdGltZSBwaWNrZXIgd2hlbiBmb3JtYXQgaXMgVVRDIChaKSBvciBoYXMgdGhlICdoJyAobWVhbmluZyBob3VycylcclxuICAgIGlmIChvdXRwdXRGb3JtYXQgJiYgKG91dHB1dEZvcm1hdCA9PT0gJ1onIHx8IG91dHB1dEZvcm1hdC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdoJykpKSB7XHJcbiAgICAgIHBpY2tlck9wdGlvbnMuZW5hYmxlVGltZSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbWVyZ2Ugb3B0aW9ucyB3aXRoIG9wdGlvbmFsIHVzZXIncyBjdXN0b20gb3B0aW9uc1xyXG4gICAgdGhpcy5fZmxhdHBpY2tyT3B0aW9ucyA9IHsgLi4ucGlja2VyT3B0aW9ucywgLi4udXNlckZpbHRlck9wdGlvbnMgfTtcclxuXHJcbiAgICBsZXQgcGxhY2Vob2xkZXIgPSAodGhpcy5ncmlkT3B0aW9ucykgPyAodGhpcy5ncmlkT3B0aW9ucy5kZWZhdWx0RmlsdGVyUGxhY2Vob2xkZXIgfHwgJycpIDogJyc7XHJcbiAgICBpZiAodGhpcy5jb2x1bW5GaWx0ZXIgJiYgdGhpcy5jb2x1bW5GaWx0ZXIucGxhY2Vob2xkZXIpIHtcclxuICAgICAgcGxhY2Vob2xkZXIgPSB0aGlzLmNvbHVtbkZpbHRlci5wbGFjZWhvbGRlcjtcclxuICAgIH1cclxuICAgIGNvbnN0ICRmaWx0ZXJJbnB1dEVsbTogYW55ID0gJChgPGRpdiBjbGFzcz1cImZsYXRwaWNrciBzZWFyY2gtZmlsdGVyIGZpbHRlci0ke2NvbHVtbklkfVwiPjxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgZGF0YS1pbnB1dCBwbGFjZWhvbGRlcj1cIiR7cGxhY2Vob2xkZXJ9XCI+PC9kaXY+YCk7XHJcbiAgICB0aGlzLmZsYXRJbnN0YW5jZSA9ICgkZmlsdGVySW5wdXRFbG1bMF0gJiYgdHlwZW9mICRmaWx0ZXJJbnB1dEVsbVswXS5mbGF0cGlja3IgPT09ICdmdW5jdGlvbicpID8gJGZpbHRlcklucHV0RWxtWzBdLmZsYXRwaWNrcih0aGlzLl9mbGF0cGlja3JPcHRpb25zKSA6IEZsYXRwaWNrcigkZmlsdGVySW5wdXRFbG0sIHRoaXMuX2ZsYXRwaWNrck9wdGlvbnMgYXMgdW5rbm93biBhcyBQYXJ0aWFsPEZsYXRwaWNrckJhc2VPcHRpb25zPik7XHJcbiAgICByZXR1cm4gJGZpbHRlcklucHV0RWxtO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIHRoZSBET00gZWxlbWVudFxyXG4gICAqIEBwYXJhbXMgc2VhcmNoVGVybXNcclxuICAgKi9cclxuICBwcml2YXRlIGNyZWF0ZURvbUVsZW1lbnQoc2VhcmNoVGVybXM/OiBTZWFyY2hUZXJtW10pIHtcclxuICAgIGNvbnN0IGZpZWxkSWQgPSB0aGlzLmNvbHVtbkRlZiAmJiB0aGlzLmNvbHVtbkRlZi5pZDtcclxuICAgIGNvbnN0ICRoZWFkZXJFbG0gPSB0aGlzLmdyaWQuZ2V0SGVhZGVyUm93Q29sdW1uKGZpZWxkSWQpO1xyXG4gICAgJCgkaGVhZGVyRWxtKS5lbXB0eSgpO1xyXG5cclxuICAgIC8vIGNyZWF0ZSB0aGUgRE9NIFNlbGVjdCBkcm9wZG93biBmb3IgdGhlIE9wZXJhdG9yXHJcbiAgICB0aGlzLiRmaWx0ZXJJbnB1dEVsbSA9IHRoaXMuYnVpbGREYXRlUGlja2VySW5wdXQoc2VhcmNoVGVybXMpO1xyXG5cclxuICAgIC8qIHRoZSBET00gZWxlbWVudCBmaW5hbCBzdHJ1Y3R1cmUgd2lsbCBiZVxyXG4gICAgICA8ZGl2IGNsYXNzPWZsYXRwaWNrcj5cclxuICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGRhdGEtaW5wdXQ+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgKi9cclxuXHJcbiAgICAvLyBjcmVhdGUgdGhlIERPTSBlbGVtZW50ICYgYWRkIGFuIElEIGFuZCBmaWx0ZXIgY2xhc3NcclxuICAgIHRoaXMuJGZpbHRlcklucHV0RWxtLmRhdGEoJ2NvbHVtbklkJywgZmllbGRJZCk7XHJcblxyXG4gICAgLy8gaWYgdGhlcmUncyBhIHNlYXJjaCB0ZXJtLCB3ZSB3aWxsIGFkZCB0aGUgXCJmaWxsZWRcIiBjbGFzcyBmb3Igc3R5bGluZyBwdXJwb3Nlc1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2VhcmNoVGVybXMpICYmIHNlYXJjaFRlcm1zLmxlbmd0aCA+IDAgJiYgc2VhcmNoVGVybXNbMF0gIT09ICcnKSB7XHJcbiAgICAgIHRoaXMuJGZpbHRlcklucHV0RWxtLmFkZENsYXNzKCdmaWxsZWQnKTtcclxuICAgICAgdGhpcy5fY3VycmVudERhdGVzID0gc2VhcmNoVGVybXMgYXMgRGF0ZVtdO1xyXG4gICAgICB0aGlzLl9jdXJyZW50VmFsdWUgPSBzZWFyY2hUZXJtc1swXSBhcyBzdHJpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYXBwZW5kIHRoZSBuZXcgRE9NIGVsZW1lbnQgdG8gdGhlIGhlYWRlciByb3dcclxuICAgIGlmICh0aGlzLiRmaWx0ZXJJbnB1dEVsbSAmJiB0eXBlb2YgdGhpcy4kZmlsdGVySW5wdXRFbG0uYXBwZW5kVG8gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhpcy4kZmlsdGVySW5wdXRFbG0uYXBwZW5kVG8oJGhlYWRlckVsbSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuJGZpbHRlcklucHV0RWxtO1xyXG4gIH1cclxuXHJcbiAgLyoqIExvYWQgYSBkaWZmZXJlbnQgc2V0IG9mIGxvY2FsZXMgZm9yIEZsYXRwaWNrciB0byBiZSBsb2NhbGl6ZWQgKi9cclxuICBwcml2YXRlIGxvYWRGbGF0cGlja3JMb2NhbGUobGFuZ3VhZ2U6IHN0cmluZykge1xyXG4gICAgbGV0IGxvY2FsZXMgPSAnZW4nO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGlmIChsYW5ndWFnZSAhPT0gJ2VuJykge1xyXG4gICAgICAgIC8vIGNoYW5nZSBsb2NhbGUgaWYgbmVlZGVkLCBGbGF0cGlja3IgcmVmZXJlbmNlOiBodHRwczovL2NobWxuLmdpdGh1Yi5pby9mbGF0cGlja3IvbG9jYWxpemF0aW9uL1xyXG4gICAgICAgIGNvbnN0IGxvY2FsZURlZmF1bHQ6IGFueSA9IHJlcXVpcmUoYGZsYXRwaWNrci9kaXN0L2wxMG4vJHtsYW5ndWFnZX0uanNgKS5kZWZhdWx0O1xyXG4gICAgICAgIGxvY2FsZXMgPSAobG9jYWxlRGVmYXVsdCAmJiBsb2NhbGVEZWZhdWx0W2xhbmd1YWdlXSkgPyBsb2NhbGVEZWZhdWx0W2xhbmd1YWdlXSA6ICdlbic7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBbQW5ndWxhci1TbGlja2dyaWQgLSBEYXRlUmFuZ2UgRmlsdGVyXSBJdCBzZWVtcyB0aGF0IFwiJHtsYW5ndWFnZX1cIiBpcyBub3QgYSBsb2NhbGUgc3VwcG9ydGVkIGJ5IEZsYXRwaWNrciwgd2Ugd2lsbCB1c2UgXCJlblwiIGluc3RlYWQuIGBcclxuICAgICAgICArIGBUbyBhdm9pZCBzZWVpbmcgdGhpcyBtZXNzYWdlLCB5b3UgY2FuIHNwZWNpZmljYWxseSBzZXQgXCJmaWx0ZXI6IHsgZmlsdGVyT3B0aW9uczogeyBsb2NhbGU6ICdlbicgfSB9XCIgaW4geW91ciBjb2x1bW4gZGVmaW5pdGlvbi5gKTtcclxuICAgICAgcmV0dXJuICdlbic7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxlcztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgb25UcmlnZ2VyRXZlbnQoZTogRXZlbnQgfCB1bmRlZmluZWQpIHtcclxuICAgIGlmICh0aGlzLl9jbGVhckZpbHRlclRyaWdnZXJlZCkge1xyXG4gICAgICB0aGlzLmNhbGxiYWNrKGUsIHsgY29sdW1uRGVmOiB0aGlzLmNvbHVtbkRlZiwgY2xlYXJGaWx0ZXJUcmlnZ2VyZWQ6IHRoaXMuX2NsZWFyRmlsdGVyVHJpZ2dlcmVkLCBzaG91bGRUcmlnZ2VyUXVlcnk6IHRoaXMuX3Nob3VsZFRyaWdnZXJRdWVyeSB9KTtcclxuICAgICAgdGhpcy4kZmlsdGVyRWxtLnJlbW92ZUNsYXNzKCdmaWxsZWQnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICh0aGlzLl9jdXJyZW50RGF0ZVN0cmluZ3MpID8gdGhpcy4kZmlsdGVyRWxtLmFkZENsYXNzKCdmaWxsZWQnKSA6IHRoaXMuJGZpbHRlckVsbS5yZW1vdmVDbGFzcygnZmlsbGVkJyk7XHJcbiAgICAgIHRoaXMuY2FsbGJhY2soZSwgeyBjb2x1bW5EZWY6IHRoaXMuY29sdW1uRGVmLCBzZWFyY2hUZXJtczogKHRoaXMuX2N1cnJlbnREYXRlU3RyaW5ncyA/IHRoaXMuX2N1cnJlbnREYXRlU3RyaW5ncyA6IFt0aGlzLl9jdXJyZW50VmFsdWVdKSwgb3BlcmF0b3I6IHRoaXMub3BlcmF0b3IgfHwgJycsIHNob3VsZFRyaWdnZXJRdWVyeTogdGhpcy5fc2hvdWxkVHJpZ2dlclF1ZXJ5IH0pO1xyXG4gICAgfVxyXG4gICAgLy8gcmVzZXQgYm90aCBmbGFncyBmb3IgbmV4dCB1c2VcclxuICAgIHRoaXMuX2NsZWFyRmlsdGVyVHJpZ2dlcmVkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9zaG91bGRUcmlnZ2VyUXVlcnkgPSB0cnVlO1xyXG4gIH1cclxufVxyXG4iXX0=