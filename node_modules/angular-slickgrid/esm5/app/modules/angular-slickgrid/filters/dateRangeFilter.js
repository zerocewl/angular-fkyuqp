import * as tslib_1 from "tslib";
import { Optional } from '@angular/core';
import { TranslateService } from '@ngx-translate/core';
import { mapFlatpickrDateFormatWithFieldType, mapMomentDateFormatWithFieldType } from '../services/utilities';
import { FieldType, OperatorType, } from '../models/index';
import Flatpickr from 'flatpickr';
import * as moment_ from 'moment-mini';
var moment = moment_; // patch to fix rollup "moment has no default export" issue, document here https://github.com/rollup/rollup/issues/670
require('flatpickr');
var DateRangeFilter = /** @class */ (function () {
    function DateRangeFilter(translate) {
        this.translate = translate;
        this._clearFilterTriggered = false;
        this._shouldTriggerQuery = true;
    }
    Object.defineProperty(DateRangeFilter.prototype, "gridOptions", {
        /** Getter for the Grid Options pulled through the Grid Object */
        get: function () {
            return (this.grid && this.grid.getOptions) ? this.grid.getOptions() : {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateRangeFilter.prototype, "columnFilter", {
        /** Getter for the Column Filter */
        get: function () {
            return this.columnDef && this.columnDef.filter || {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateRangeFilter.prototype, "currentDates", {
        /** Getter for the Current Dates selected */
        get: function () {
            return this._currentDates;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateRangeFilter.prototype, "defaultOperator", {
        /** Getter to know what would be the default operator when none is specified */
        get: function () {
            return this.gridOptions.defaultFilterRangeOperator || OperatorType.rangeExclusive;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateRangeFilter.prototype, "flatpickrOptions", {
        /** Getter for the Flatpickr Options */
        get: function () {
            return this._flatpickrOptions || {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateRangeFilter.prototype, "operator", {
        /** Getter of the Operator to use when doing the filter comparing */
        get: function () {
            return this.columnFilter && this.columnFilter.operator || this.defaultOperator;
        },
        /** Setter for the filter operator */
        set: function (operator) {
            if (this.columnFilter) {
                this.columnFilter.operator = operator;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Initialize the Filter
     */
    DateRangeFilter.prototype.init = function (args) {
        var _this = this;
        if (!args) {
            throw new Error('[Angular-SlickGrid] A filter must always have an "init()" with valid arguments.');
        }
        this.grid = args.grid;
        this.callback = args.callback;
        this.columnDef = args.columnDef;
        this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];
        // step 1, create the DOM Element of the filter which contain the compound Operator+Input
        this.$filterElm = this.createDomElement(this.searchTerms);
        // step 3, subscribe to the keyup event and run the callback when that happens
        // also add/remove "filled" class for styling purposes
        this.$filterInputElm.keyup(function (e) {
            _this.onTriggerEvent(e);
        });
    };
    /**
     * Clear the filter value
     */
    DateRangeFilter.prototype.clear = function (shouldTriggerQuery) {
        if (shouldTriggerQuery === void 0) { shouldTriggerQuery = true; }
        if (this.flatInstance) {
            this._clearFilterTriggered = true;
            this._shouldTriggerQuery = shouldTriggerQuery;
            this.searchTerms = [];
            this.flatInstance.clear();
        }
    };
    /**
     * destroy the filter
     */
    DateRangeFilter.prototype.destroy = function () {
        if (this.$filterElm) {
            this.$filterElm.off('keyup').remove();
        }
        if (this.flatInstance && typeof this.flatInstance.destroy === 'function') {
            this.flatInstance.destroy();
        }
    };
    DateRangeFilter.prototype.hide = function () {
        if (this.flatInstance && typeof this.flatInstance.close === 'function') {
            this.flatInstance.close();
        }
    };
    DateRangeFilter.prototype.show = function () {
        if (this.flatInstance && typeof this.flatInstance.open === 'function') {
            this.flatInstance.open();
        }
    };
    /**
     * Set value(s) on the DOM element
     * @params searchTerms
     */
    DateRangeFilter.prototype.setValues = function (searchTerms, operator) {
        var pickerValues = [];
        // get the picker values, if it's a string with the "..", we'll do the split else we'll use the array of search terms
        if (typeof searchTerms === 'string' || (Array.isArray(searchTerms) && typeof searchTerms[0] === 'string') && searchTerms[0].indexOf('..') > 0) {
            pickerValues = (typeof searchTerms === 'string') ? [searchTerms] : searchTerms[0].split('..');
        }
        else if (Array.isArray(searchTerms)) {
            pickerValues = searchTerms;
        }
        if (this.flatInstance && searchTerms) {
            this._currentDates = pickerValues;
            this.flatInstance.setDate(pickerValues);
        }
        // set the operator when defined
        this.operator = operator || this.defaultOperator;
    };
    //
    // private functions
    // ------------------
    DateRangeFilter.prototype.buildDatePickerInput = function (searchTerms) {
        var _this = this;
        var columnId = this.columnDef && this.columnDef.id;
        var inputFormat = mapFlatpickrDateFormatWithFieldType(this.columnDef.type || FieldType.dateIso);
        var outputFormat = mapFlatpickrDateFormatWithFieldType(this.columnDef.outputType || this.columnDef.type || FieldType.dateUtc);
        var userFilterOptions = (this.columnFilter && this.columnFilter.filterOptions || {});
        // get current locale, if user defined a custom locale just use or get it the Translate Service if it exist else just use English
        var currentLocale = (userFilterOptions && userFilterOptions.locale) || (this.translate && this.translate.currentLang) || this.gridOptions.locale || 'en';
        if (currentLocale.length > 2) {
            currentLocale = currentLocale.substring(0, 2);
        }
        var pickerValues = [];
        // get the picker values, if it's a string with the "..", we'll do the split else we'll use the array of search terms
        if (typeof searchTerms === 'string' || (Array.isArray(searchTerms) && typeof searchTerms[0] === 'string') && searchTerms[0].indexOf('..') > 0) {
            pickerValues = (typeof searchTerms === 'string') ? [searchTerms] : searchTerms[0].split('..');
        }
        else if (Array.isArray(searchTerms)) {
            pickerValues = searchTerms;
        }
        // if we are preloading searchTerms, we'll keep them for reference
        if (pickerValues) {
            this._currentDates = pickerValues;
            var outFormat_1 = mapMomentDateFormatWithFieldType(this.columnDef.type || FieldType.dateIso);
            this._currentDateStrings = pickerValues.map(function (date) { return moment(date).format(outFormat_1); });
        }
        var pickerOptions = {
            defaultDate: pickerValues || '',
            altInput: true,
            altFormat: outputFormat,
            dateFormat: inputFormat,
            mode: 'range',
            wrap: true,
            closeOnSelect: true,
            locale: (currentLocale !== 'en') ? this.loadFlatpickrLocale(currentLocale) : 'en',
            onChange: function (selectedDates, dateStr, instance) {
                if (Array.isArray(selectedDates)) {
                    _this._currentDates = selectedDates;
                    var outFormat_2 = mapMomentDateFormatWithFieldType(_this.columnDef.outputType || _this.columnDef.type || FieldType.dateIso);
                    _this._currentDateStrings = selectedDates.map(function (date) { return moment(date).format(outFormat_2); });
                    _this._currentValue = _this._currentDateStrings.join('..');
                }
                // when using the time picker, we can simulate a keyup event to avoid multiple backend request
                // since backend request are only executed after user start typing, changing the time should be treated the same way
                var newEvent = pickerOptions.enableTime ? new CustomEvent('keyup') : undefined;
                _this.onTriggerEvent(newEvent);
            }
        };
        // add the time picker when format is UTC (Z) or has the 'h' (meaning hours)
        if (outputFormat && (outputFormat === 'Z' || outputFormat.toLowerCase().includes('h'))) {
            pickerOptions.enableTime = true;
        }
        // merge options with optional user's custom options
        this._flatpickrOptions = tslib_1.__assign({}, pickerOptions, userFilterOptions);
        var placeholder = (this.gridOptions) ? (this.gridOptions.defaultFilterPlaceholder || '') : '';
        if (this.columnFilter && this.columnFilter.placeholder) {
            placeholder = this.columnFilter.placeholder;
        }
        var $filterInputElm = $("<div class=\"flatpickr search-filter filter-" + columnId + "\"><input type=\"text\" class=\"form-control\" data-input placeholder=\"" + placeholder + "\"></div>");
        this.flatInstance = ($filterInputElm[0] && typeof $filterInputElm[0].flatpickr === 'function') ? $filterInputElm[0].flatpickr(this._flatpickrOptions) : Flatpickr($filterInputElm, this._flatpickrOptions);
        return $filterInputElm;
    };
    /**
     * Create the DOM element
     * @params searchTerms
     */
    DateRangeFilter.prototype.createDomElement = function (searchTerms) {
        var fieldId = this.columnDef && this.columnDef.id;
        var $headerElm = this.grid.getHeaderRowColumn(fieldId);
        $($headerElm).empty();
        // create the DOM Select dropdown for the Operator
        this.$filterInputElm = this.buildDatePickerInput(searchTerms);
        /* the DOM element final structure will be
          <div class=flatpickr>
            <input type="text" class="form-control" data-input>
          </div>
        */
        // create the DOM element & add an ID and filter class
        this.$filterInputElm.data('columnId', fieldId);
        // if there's a search term, we will add the "filled" class for styling purposes
        if (Array.isArray(searchTerms) && searchTerms.length > 0 && searchTerms[0] !== '') {
            this.$filterInputElm.addClass('filled');
            this._currentDates = searchTerms;
            this._currentValue = searchTerms[0];
        }
        // append the new DOM element to the header row
        if (this.$filterInputElm && typeof this.$filterInputElm.appendTo === 'function') {
            this.$filterInputElm.appendTo($headerElm);
        }
        return this.$filterInputElm;
    };
    /** Load a different set of locales for Flatpickr to be localized */
    DateRangeFilter.prototype.loadFlatpickrLocale = function (language) {
        var locales = 'en';
        try {
            if (language !== 'en') {
                // change locale if needed, Flatpickr reference: https://chmln.github.io/flatpickr/localization/
                var localeDefault = require("flatpickr/dist/l10n/" + language + ".js").default;
                locales = (localeDefault && localeDefault[language]) ? localeDefault[language] : 'en';
            }
        }
        catch (e) {
            console.warn("[Angular-Slickgrid - DateRange Filter] It seems that \"" + language + "\" is not a locale supported by Flatpickr, we will use \"en\" instead. "
                + "To avoid seeing this message, you can specifically set \"filter: { filterOptions: { locale: 'en' } }\" in your column definition.");
            return 'en';
        }
        return locales;
    };
    DateRangeFilter.prototype.onTriggerEvent = function (e) {
        if (this._clearFilterTriggered) {
            this.callback(e, { columnDef: this.columnDef, clearFilterTriggered: this._clearFilterTriggered, shouldTriggerQuery: this._shouldTriggerQuery });
            this.$filterElm.removeClass('filled');
        }
        else {
            (this._currentDateStrings) ? this.$filterElm.addClass('filled') : this.$filterElm.removeClass('filled');
            this.callback(e, { columnDef: this.columnDef, searchTerms: (this._currentDateStrings ? this._currentDateStrings : [this._currentValue]), operator: this.operator || '', shouldTriggerQuery: this._shouldTriggerQuery });
        }
        // reset both flags for next use
        this._clearFilterTriggered = false;
        this._shouldTriggerQuery = true;
    };
    DateRangeFilter = tslib_1.__decorate([
        tslib_1.__param(0, Optional()),
        tslib_1.__metadata("design:paramtypes", [TranslateService])
    ], DateRangeFilter);
    return DateRangeFilter;
}());
export { DateRangeFilter };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZVJhbmdlRmlsdGVyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1zbGlja2dyaWQvIiwic291cmNlcyI6WyJhcHAvbW9kdWxlcy9hbmd1bGFyLXNsaWNrZ3JpZC9maWx0ZXJzL2RhdGVSYW5nZUZpbHRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN6QyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN2RCxPQUFPLEVBQUUsbUNBQW1DLEVBQUUsZ0NBQWdDLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUM5RyxPQUFPLEVBR0wsU0FBUyxFQU9ULFlBQVksR0FFYixNQUFNLGlCQUFpQixDQUFDO0FBQ3pCLE9BQU8sU0FBUyxNQUFNLFdBQVcsQ0FBQztBQUVsQyxPQUFPLEtBQUssT0FBTyxNQUFNLGFBQWEsQ0FBQztBQUN2QyxJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsQ0FBQyxzSEFBc0g7QUFJOUksT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBS3JCO0lBZUUseUJBQWdDLFNBQTJCO1FBQTNCLGNBQVMsR0FBVCxTQUFTLENBQWtCO1FBZG5ELDBCQUFxQixHQUFHLEtBQUssQ0FBQztRQUs5Qix3QkFBbUIsR0FBRyxJQUFJLENBQUM7SUFTNEIsQ0FBQztJQUdoRSxzQkFBWSx3Q0FBVztRQUR2QixpRUFBaUU7YUFDakU7WUFDRSxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDM0UsQ0FBQzs7O09BQUE7SUFHRCxzQkFBSSx5Q0FBWTtRQURoQixtQ0FBbUM7YUFDbkM7WUFDRSxPQUFPLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFNBQVMs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UlUsZUFBZTtRQWViLG1CQUFBLFFBQVEsRUFBRSxDQUFBO2lEQUFvQixnQkFBZ0I7T0FmaEQsZUFBZSxDQWtSM0I7SUFBRCxzQkFBQztDQUFBLEFBbFJELElBa1JDO1NBbFJZLGVBQWUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBUcmFuc2xhdGVTZXJ2aWNlIH0gZnJvbSAnQG5neC10cmFuc2xhdGUvY29yZSc7XHJcbmltcG9ydCB7IG1hcEZsYXRwaWNrckRhdGVGb3JtYXRXaXRoRmllbGRUeXBlLCBtYXBNb21lbnREYXRlRm9ybWF0V2l0aEZpZWxkVHlwZSB9IGZyb20gJy4uL3NlcnZpY2VzL3V0aWxpdGllcyc7XHJcbmltcG9ydCB7XHJcbiAgQ29sdW1uLFxyXG4gIENvbHVtbkZpbHRlcixcclxuICBGaWVsZFR5cGUsXHJcbiAgRmlsdGVyLFxyXG4gIEZpbHRlckFyZ3VtZW50cyxcclxuICBGaWx0ZXJDYWxsYmFjayxcclxuICBGbGF0cGlja3JPcHRpb24sXHJcbiAgR3JpZE9wdGlvbixcclxuICBPcGVyYXRvclN0cmluZyxcclxuICBPcGVyYXRvclR5cGUsXHJcbiAgU2VhcmNoVGVybSxcclxufSBmcm9tICcuLi9tb2RlbHMvaW5kZXgnO1xyXG5pbXBvcnQgRmxhdHBpY2tyIGZyb20gJ2ZsYXRwaWNrcic7XHJcbmltcG9ydCB7IEJhc2VPcHRpb25zIGFzIEZsYXRwaWNrckJhc2VPcHRpb25zIH0gZnJvbSAnZmxhdHBpY2tyL2Rpc3QvdHlwZXMvb3B0aW9ucyc7XHJcbmltcG9ydCAqIGFzIG1vbWVudF8gZnJvbSAnbW9tZW50LW1pbmknO1xyXG5jb25zdCBtb21lbnQgPSBtb21lbnRfOyAvLyBwYXRjaCB0byBmaXggcm9sbHVwIFwibW9tZW50IGhhcyBubyBkZWZhdWx0IGV4cG9ydFwiIGlzc3VlLCBkb2N1bWVudCBoZXJlIGh0dHBzOi8vZ2l0aHViLmNvbS9yb2xsdXAvcm9sbHVwL2lzc3Vlcy82NzBcclxuXHJcbi8vIHVzZSBGbGF0cGlja3IgZnJvbSBpbXBvcnQgb3IgJ3JlcXVpcmUnLCB3aGljaGV2ZXIgd29ya3MgZmlyc3RcclxuZGVjbGFyZSBmdW5jdGlvbiByZXF1aXJlKG5hbWU6IHN0cmluZyk6IGFueTtcclxucmVxdWlyZSgnZmxhdHBpY2tyJyk7XHJcblxyXG4vLyB1c2luZyBleHRlcm5hbCBub24tdHlwZWQganMgbGlicmFyaWVzXHJcbmRlY2xhcmUgdmFyICQ6IGFueTtcclxuXHJcbmV4cG9ydCBjbGFzcyBEYXRlUmFuZ2VGaWx0ZXIgaW1wbGVtZW50cyBGaWx0ZXIge1xyXG4gIHByaXZhdGUgX2NsZWFyRmlsdGVyVHJpZ2dlcmVkID0gZmFsc2U7XHJcbiAgcHJpdmF0ZSBfY3VycmVudFZhbHVlOiBzdHJpbmc7XHJcbiAgcHJpdmF0ZSBfY3VycmVudERhdGVzOiBEYXRlW107XHJcbiAgcHJpdmF0ZSBfY3VycmVudERhdGVTdHJpbmdzOiBzdHJpbmdbXTtcclxuICBwcml2YXRlIF9mbGF0cGlja3JPcHRpb25zOiBGbGF0cGlja3JPcHRpb247XHJcbiAgcHJpdmF0ZSBfc2hvdWxkVHJpZ2dlclF1ZXJ5ID0gdHJ1ZTtcclxuICBwcml2YXRlICRmaWx0ZXJFbG06IGFueTtcclxuICBwcml2YXRlICRmaWx0ZXJJbnB1dEVsbTogYW55O1xyXG4gIGZsYXRJbnN0YW5jZTogYW55O1xyXG4gIGdyaWQ6IGFueTtcclxuICBzZWFyY2hUZXJtczogU2VhcmNoVGVybVtdO1xyXG4gIGNvbHVtbkRlZjogQ29sdW1uO1xyXG4gIGNhbGxiYWNrOiBGaWx0ZXJDYWxsYmFjaztcclxuXHJcbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJpdmF0ZSB0cmFuc2xhdGU6IFRyYW5zbGF0ZVNlcnZpY2UpIHsgfVxyXG5cclxuICAvKiogR2V0dGVyIGZvciB0aGUgR3JpZCBPcHRpb25zIHB1bGxlZCB0aHJvdWdoIHRoZSBHcmlkIE9iamVjdCAqL1xyXG4gIHByaXZhdGUgZ2V0IGdyaWRPcHRpb25zKCk6IEdyaWRPcHRpb24ge1xyXG4gICAgcmV0dXJuICh0aGlzLmdyaWQgJiYgdGhpcy5ncmlkLmdldE9wdGlvbnMpID8gdGhpcy5ncmlkLmdldE9wdGlvbnMoKSA6IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBmb3IgdGhlIENvbHVtbiBGaWx0ZXIgKi9cclxuICBnZXQgY29sdW1uRmlsdGVyKCk6IENvbHVtbkZpbHRlciB7XHJcbiAgICByZXR1cm4gdGhpcy5jb2x1bW5EZWYgJiYgdGhpcy5jb2x1bW5EZWYuZmlsdGVyIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBmb3IgdGhlIEN1cnJlbnQgRGF0ZXMgc2VsZWN0ZWQgKi9cclxuICBnZXQgY3VycmVudERhdGVzKCk6IERhdGVbXSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudERhdGVzO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciB0byBrbm93IHdoYXQgd291bGQgYmUgdGhlIGRlZmF1bHQgb3BlcmF0b3Igd2hlbiBub25lIGlzIHNwZWNpZmllZCAqL1xyXG4gIGdldCBkZWZhdWx0T3BlcmF0b3IoKTogT3BlcmF0b3JUeXBlIHwgT3BlcmF0b3JTdHJpbmcge1xyXG4gICAgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMuZGVmYXVsdEZpbHRlclJhbmdlT3BlcmF0b3IgfHwgT3BlcmF0b3JUeXBlLnJhbmdlRXhjbHVzaXZlO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBmb3IgdGhlIEZsYXRwaWNrciBPcHRpb25zICovXHJcbiAgZ2V0IGZsYXRwaWNrck9wdGlvbnMoKTogRmxhdHBpY2tyT3B0aW9uIHtcclxuICAgIHJldHVybiB0aGlzLl9mbGF0cGlja3JPcHRpb25zIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBvZiB0aGUgT3BlcmF0b3IgdG8gdXNlIHdoZW4gZG9pbmcgdGhlIGZpbHRlciBjb21wYXJpbmcgKi9cclxuICBnZXQgb3BlcmF0b3IoKTogT3BlcmF0b3JUeXBlIHwgT3BlcmF0b3JTdHJpbmcge1xyXG4gICAgcmV0dXJuIHRoaXMuY29sdW1uRmlsdGVyICYmIHRoaXMuY29sdW1uRmlsdGVyLm9wZXJhdG9yIHx8IHRoaXMuZGVmYXVsdE9wZXJhdG9yO1xyXG4gIH1cclxuXHJcbiAgLyoqIFNldHRlciBmb3IgdGhlIGZpbHRlciBvcGVyYXRvciAqL1xyXG4gIHNldCBvcGVyYXRvcihvcGVyYXRvcjogT3BlcmF0b3JUeXBlIHwgT3BlcmF0b3JTdHJpbmcpIHtcclxuICAgIGlmICh0aGlzLmNvbHVtbkZpbHRlcikge1xyXG4gICAgICB0aGlzLmNvbHVtbkZpbHRlci5vcGVyYXRvciA9IG9wZXJhdG9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSB0aGUgRmlsdGVyXHJcbiAgICovXHJcbiAgaW5pdChhcmdzOiBGaWx0ZXJBcmd1bWVudHMpIHtcclxuICAgIGlmICghYXJncykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tBbmd1bGFyLVNsaWNrR3JpZF0gQSBmaWx0ZXIgbXVzdCBhbHdheXMgaGF2ZSBhbiBcImluaXQoKVwiIHdpdGggdmFsaWQgYXJndW1lbnRzLicpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZ3JpZCA9IGFyZ3MuZ3JpZDtcclxuICAgIHRoaXMuY2FsbGJhY2sgPSBhcmdzLmNhbGxiYWNrO1xyXG4gICAgdGhpcy5jb2x1bW5EZWYgPSBhcmdzLmNvbHVtbkRlZjtcclxuICAgIHRoaXMuc2VhcmNoVGVybXMgPSAoYXJncy5oYXNPd25Qcm9wZXJ0eSgnc2VhcmNoVGVybXMnKSA/IGFyZ3Muc2VhcmNoVGVybXMgOiBbXSkgfHwgW107XHJcblxyXG4gICAgLy8gc3RlcCAxLCBjcmVhdGUgdGhlIERPTSBFbGVtZW50IG9mIHRoZSBmaWx0ZXIgd2hpY2ggY29udGFpbiB0aGUgY29tcG91bmQgT3BlcmF0b3IrSW5wdXRcclxuICAgIHRoaXMuJGZpbHRlckVsbSA9IHRoaXMuY3JlYXRlRG9tRWxlbWVudCh0aGlzLnNlYXJjaFRlcm1zKTtcclxuXHJcbiAgICAvLyBzdGVwIDMsIHN1YnNjcmliZSB0byB0aGUga2V5dXAgZXZlbnQgYW5kIHJ1biB0aGUgY2FsbGJhY2sgd2hlbiB0aGF0IGhhcHBlbnNcclxuICAgIC8vIGFsc28gYWRkL3JlbW92ZSBcImZpbGxlZFwiIGNsYXNzIGZvciBzdHlsaW5nIHB1cnBvc2VzXHJcbiAgICB0aGlzLiRmaWx0ZXJJbnB1dEVsbS5rZXl1cCgoZTogYW55KSA9PiB7XHJcbiAgICAgIHRoaXMub25UcmlnZ2VyRXZlbnQoZSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsZWFyIHRoZSBmaWx0ZXIgdmFsdWVcclxuICAgKi9cclxuICBjbGVhcihzaG91bGRUcmlnZ2VyUXVlcnkgPSB0cnVlKSB7XHJcbiAgICBpZiAodGhpcy5mbGF0SW5zdGFuY2UpIHtcclxuICAgICAgdGhpcy5fY2xlYXJGaWx0ZXJUcmlnZ2VyZWQgPSB0cnVlO1xyXG4gICAgICB0aGlzLl9zaG91bGRUcmlnZ2VyUXVlcnkgPSBzaG91bGRUcmlnZ2VyUXVlcnk7XHJcbiAgICAgIHRoaXMuc2VhcmNoVGVybXMgPSBbXTtcclxuICAgICAgdGhpcy5mbGF0SW5zdGFuY2UuY2xlYXIoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGRlc3Ryb3kgdGhlIGZpbHRlclxyXG4gICAqL1xyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICBpZiAodGhpcy4kZmlsdGVyRWxtKSB7XHJcbiAgICAgIHRoaXMuJGZpbHRlckVsbS5vZmYoJ2tleXVwJykucmVtb3ZlKCk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5mbGF0SW5zdGFuY2UgJiYgdHlwZW9mIHRoaXMuZmxhdEluc3RhbmNlLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhpcy5mbGF0SW5zdGFuY2UuZGVzdHJveSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaGlkZSgpIHtcclxuICAgIGlmICh0aGlzLmZsYXRJbnN0YW5jZSAmJiB0eXBlb2YgdGhpcy5mbGF0SW5zdGFuY2UuY2xvc2UgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhpcy5mbGF0SW5zdGFuY2UuY2xvc2UoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNob3coKSB7XHJcbiAgICBpZiAodGhpcy5mbGF0SW5zdGFuY2UgJiYgdHlwZW9mIHRoaXMuZmxhdEluc3RhbmNlLm9wZW4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhpcy5mbGF0SW5zdGFuY2Uub3BlbigpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHZhbHVlKHMpIG9uIHRoZSBET00gZWxlbWVudFxyXG4gICAqIEBwYXJhbXMgc2VhcmNoVGVybXNcclxuICAgKi9cclxuICBzZXRWYWx1ZXMoc2VhcmNoVGVybXM6IFNlYXJjaFRlcm1bXSwgb3BlcmF0b3I/OiBPcGVyYXRvclR5cGUgfCBPcGVyYXRvclN0cmluZykge1xyXG4gICAgbGV0IHBpY2tlclZhbHVlcyA9IFtdO1xyXG5cclxuICAgIC8vIGdldCB0aGUgcGlja2VyIHZhbHVlcywgaWYgaXQncyBhIHN0cmluZyB3aXRoIHRoZSBcIi4uXCIsIHdlJ2xsIGRvIHRoZSBzcGxpdCBlbHNlIHdlJ2xsIHVzZSB0aGUgYXJyYXkgb2Ygc2VhcmNoIHRlcm1zXHJcbiAgICBpZiAodHlwZW9mIHNlYXJjaFRlcm1zID09PSAnc3RyaW5nJyB8fCAoQXJyYXkuaXNBcnJheShzZWFyY2hUZXJtcykgJiYgdHlwZW9mIHNlYXJjaFRlcm1zWzBdID09PSAnc3RyaW5nJykgJiYgKHNlYXJjaFRlcm1zWzBdIGFzIHN0cmluZykuaW5kZXhPZignLi4nKSA+IDApIHtcclxuICAgICAgcGlja2VyVmFsdWVzID0gKHR5cGVvZiBzZWFyY2hUZXJtcyA9PT0gJ3N0cmluZycpID8gWyhzZWFyY2hUZXJtcyBhcyBzdHJpbmcpXSA6IChzZWFyY2hUZXJtc1swXSBhcyBzdHJpbmcpLnNwbGl0KCcuLicpO1xyXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNlYXJjaFRlcm1zKSkge1xyXG4gICAgICBwaWNrZXJWYWx1ZXMgPSBzZWFyY2hUZXJtcztcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5mbGF0SW5zdGFuY2UgJiYgc2VhcmNoVGVybXMpIHtcclxuICAgICAgdGhpcy5fY3VycmVudERhdGVzID0gcGlja2VyVmFsdWVzO1xyXG4gICAgICB0aGlzLmZsYXRJbnN0YW5jZS5zZXREYXRlKHBpY2tlclZhbHVlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2V0IHRoZSBvcGVyYXRvciB3aGVuIGRlZmluZWRcclxuICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvciB8fCB0aGlzLmRlZmF1bHRPcGVyYXRvcjtcclxuICB9XHJcblxyXG4gIC8vXHJcbiAgLy8gcHJpdmF0ZSBmdW5jdGlvbnNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cclxuICBwcml2YXRlIGJ1aWxkRGF0ZVBpY2tlcklucHV0KHNlYXJjaFRlcm1zPzogU2VhcmNoVGVybSB8IFNlYXJjaFRlcm1bXSkge1xyXG4gICAgY29uc3QgY29sdW1uSWQgPSB0aGlzLmNvbHVtbkRlZiAmJiB0aGlzLmNvbHVtbkRlZi5pZDtcclxuICAgIGNvbnN0IGlucHV0Rm9ybWF0ID0gbWFwRmxhdHBpY2tyRGF0ZUZvcm1hdFdpdGhGaWVsZFR5cGUodGhpcy5jb2x1bW5EZWYudHlwZSB8fCBGaWVsZFR5cGUuZGF0ZUlzbyk7XHJcbiAgICBjb25zdCBvdXRwdXRGb3JtYXQgPSBtYXBGbGF0cGlja3JEYXRlRm9ybWF0V2l0aEZpZWxkVHlwZSh0aGlzLmNvbHVtbkRlZi5vdXRwdXRUeXBlIHx8IHRoaXMuY29sdW1uRGVmLnR5cGUgfHwgRmllbGRUeXBlLmRhdGVVdGMpO1xyXG4gICAgY29uc3QgdXNlckZpbHRlck9wdGlvbnMgPSAodGhpcy5jb2x1bW5GaWx0ZXIgJiYgdGhpcy5jb2x1bW5GaWx0ZXIuZmlsdGVyT3B0aW9ucyB8fCB7fSkgYXMgRmxhdHBpY2tyT3B0aW9uO1xyXG5cclxuICAgIC8vIGdldCBjdXJyZW50IGxvY2FsZSwgaWYgdXNlciBkZWZpbmVkIGEgY3VzdG9tIGxvY2FsZSBqdXN0IHVzZSBvciBnZXQgaXQgdGhlIFRyYW5zbGF0ZSBTZXJ2aWNlIGlmIGl0IGV4aXN0IGVsc2UganVzdCB1c2UgRW5nbGlzaFxyXG4gICAgbGV0IGN1cnJlbnRMb2NhbGUgPSAodXNlckZpbHRlck9wdGlvbnMgJiYgdXNlckZpbHRlck9wdGlvbnMubG9jYWxlKSB8fCAodGhpcy50cmFuc2xhdGUgJiYgdGhpcy50cmFuc2xhdGUuY3VycmVudExhbmcpIHx8IHRoaXMuZ3JpZE9wdGlvbnMubG9jYWxlIHx8ICdlbic7XHJcbiAgICBpZiAoY3VycmVudExvY2FsZS5sZW5ndGggPiAyKSB7XHJcbiAgICAgIGN1cnJlbnRMb2NhbGUgPSBjdXJyZW50TG9jYWxlLnN1YnN0cmluZygwLCAyKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgcGlja2VyVmFsdWVzID0gW107XHJcblxyXG4gICAgLy8gZ2V0IHRoZSBwaWNrZXIgdmFsdWVzLCBpZiBpdCdzIGEgc3RyaW5nIHdpdGggdGhlIFwiLi5cIiwgd2UnbGwgZG8gdGhlIHNwbGl0IGVsc2Ugd2UnbGwgdXNlIHRoZSBhcnJheSBvZiBzZWFyY2ggdGVybXNcclxuICAgIGlmICh0eXBlb2Ygc2VhcmNoVGVybXMgPT09ICdzdHJpbmcnIHx8IChBcnJheS5pc0FycmF5KHNlYXJjaFRlcm1zKSAmJiB0eXBlb2Ygc2VhcmNoVGVybXNbMF0gPT09ICdzdHJpbmcnKSAmJiAoc2VhcmNoVGVybXNbMF0gYXMgc3RyaW5nKS5pbmRleE9mKCcuLicpID4gMCkge1xyXG4gICAgICBwaWNrZXJWYWx1ZXMgPSAodHlwZW9mIHNlYXJjaFRlcm1zID09PSAnc3RyaW5nJykgPyBbKHNlYXJjaFRlcm1zIGFzIHN0cmluZyldIDogKHNlYXJjaFRlcm1zWzBdIGFzIHN0cmluZykuc3BsaXQoJy4uJyk7XHJcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2VhcmNoVGVybXMpKSB7XHJcbiAgICAgIHBpY2tlclZhbHVlcyA9IHNlYXJjaFRlcm1zO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIHdlIGFyZSBwcmVsb2FkaW5nIHNlYXJjaFRlcm1zLCB3ZSdsbCBrZWVwIHRoZW0gZm9yIHJlZmVyZW5jZVxyXG4gICAgaWYgKHBpY2tlclZhbHVlcykge1xyXG4gICAgICB0aGlzLl9jdXJyZW50RGF0ZXMgPSBwaWNrZXJWYWx1ZXM7XHJcbiAgICAgIGNvbnN0IG91dEZvcm1hdCA9IG1hcE1vbWVudERhdGVGb3JtYXRXaXRoRmllbGRUeXBlKHRoaXMuY29sdW1uRGVmLnR5cGUgfHwgRmllbGRUeXBlLmRhdGVJc28pO1xyXG4gICAgICB0aGlzLl9jdXJyZW50RGF0ZVN0cmluZ3MgPSBwaWNrZXJWYWx1ZXMubWFwKGRhdGUgPT4gbW9tZW50KGRhdGUpLmZvcm1hdChvdXRGb3JtYXQpKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwaWNrZXJPcHRpb25zOiBGbGF0cGlja3JPcHRpb24gPSB7XHJcbiAgICAgIGRlZmF1bHREYXRlOiBwaWNrZXJWYWx1ZXMgfHwgJycsXHJcbiAgICAgIGFsdElucHV0OiB0cnVlLFxyXG4gICAgICBhbHRGb3JtYXQ6IG91dHB1dEZvcm1hdCxcclxuICAgICAgZGF0ZUZvcm1hdDogaW5wdXRGb3JtYXQsXHJcbiAgICAgIG1vZGU6ICdyYW5nZScsXHJcbiAgICAgIHdyYXA6IHRydWUsXHJcbiAgICAgIGNsb3NlT25TZWxlY3Q6IHRydWUsXHJcbiAgICAgIGxvY2FsZTogKGN1cnJlbnRMb2NhbGUgIT09ICdlbicpID8gdGhpcy5sb2FkRmxhdHBpY2tyTG9jYWxlKGN1cnJlbnRMb2NhbGUpIDogJ2VuJyxcclxuICAgICAgb25DaGFuZ2U6IChzZWxlY3RlZERhdGVzOiBEYXRlW10gfCBEYXRlLCBkYXRlU3RyOiBzdHJpbmcsIGluc3RhbmNlOiBhbnkpID0+IHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZWxlY3RlZERhdGVzKSkge1xyXG4gICAgICAgICAgdGhpcy5fY3VycmVudERhdGVzID0gc2VsZWN0ZWREYXRlcztcclxuICAgICAgICAgIGNvbnN0IG91dEZvcm1hdCA9IG1hcE1vbWVudERhdGVGb3JtYXRXaXRoRmllbGRUeXBlKHRoaXMuY29sdW1uRGVmLm91dHB1dFR5cGUgfHwgdGhpcy5jb2x1bW5EZWYudHlwZSB8fCBGaWVsZFR5cGUuZGF0ZUlzbyk7XHJcbiAgICAgICAgICB0aGlzLl9jdXJyZW50RGF0ZVN0cmluZ3MgPSBzZWxlY3RlZERhdGVzLm1hcChkYXRlID0+IG1vbWVudChkYXRlKS5mb3JtYXQob3V0Rm9ybWF0KSk7XHJcbiAgICAgICAgICB0aGlzLl9jdXJyZW50VmFsdWUgPSB0aGlzLl9jdXJyZW50RGF0ZVN0cmluZ3Muam9pbignLi4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHdoZW4gdXNpbmcgdGhlIHRpbWUgcGlja2VyLCB3ZSBjYW4gc2ltdWxhdGUgYSBrZXl1cCBldmVudCB0byBhdm9pZCBtdWx0aXBsZSBiYWNrZW5kIHJlcXVlc3RcclxuICAgICAgICAvLyBzaW5jZSBiYWNrZW5kIHJlcXVlc3QgYXJlIG9ubHkgZXhlY3V0ZWQgYWZ0ZXIgdXNlciBzdGFydCB0eXBpbmcsIGNoYW5naW5nIHRoZSB0aW1lIHNob3VsZCBiZSB0cmVhdGVkIHRoZSBzYW1lIHdheVxyXG4gICAgICAgIGNvbnN0IG5ld0V2ZW50ID0gcGlja2VyT3B0aW9ucy5lbmFibGVUaW1lID8gbmV3IEN1c3RvbUV2ZW50KCdrZXl1cCcpIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMub25UcmlnZ2VyRXZlbnQobmV3RXZlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGFkZCB0aGUgdGltZSBwaWNrZXIgd2hlbiBmb3JtYXQgaXMgVVRDIChaKSBvciBoYXMgdGhlICdoJyAobWVhbmluZyBob3VycylcclxuICAgIGlmIChvdXRwdXRGb3JtYXQgJiYgKG91dHB1dEZvcm1hdCA9PT0gJ1onIHx8IG91dHB1dEZvcm1hdC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdoJykpKSB7XHJcbiAgICAgIHBpY2tlck9wdGlvbnMuZW5hYmxlVGltZSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbWVyZ2Ugb3B0aW9ucyB3aXRoIG9wdGlvbmFsIHVzZXIncyBjdXN0b20gb3B0aW9uc1xyXG4gICAgdGhpcy5fZmxhdHBpY2tyT3B0aW9ucyA9IHsgLi4ucGlja2VyT3B0aW9ucywgLi4udXNlckZpbHRlck9wdGlvbnMgfTtcclxuXHJcbiAgICBsZXQgcGxhY2Vob2xkZXIgPSAodGhpcy5ncmlkT3B0aW9ucykgPyAodGhpcy5ncmlkT3B0aW9ucy5kZWZhdWx0RmlsdGVyUGxhY2Vob2xkZXIgfHwgJycpIDogJyc7XHJcbiAgICBpZiAodGhpcy5jb2x1bW5GaWx0ZXIgJiYgdGhpcy5jb2x1bW5GaWx0ZXIucGxhY2Vob2xkZXIpIHtcclxuICAgICAgcGxhY2Vob2xkZXIgPSB0aGlzLmNvbHVtbkZpbHRlci5wbGFjZWhvbGRlcjtcclxuICAgIH1cclxuICAgIGNvbnN0ICRmaWx0ZXJJbnB1dEVsbTogYW55ID0gJChgPGRpdiBjbGFzcz1cImZsYXRwaWNrciBzZWFyY2gtZmlsdGVyIGZpbHRlci0ke2NvbHVtbklkfVwiPjxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgZGF0YS1pbnB1dCBwbGFjZWhvbGRlcj1cIiR7cGxhY2Vob2xkZXJ9XCI+PC9kaXY+YCk7XHJcbiAgICB0aGlzLmZsYXRJbnN0YW5jZSA9ICgkZmlsdGVySW5wdXRFbG1bMF0gJiYgdHlwZW9mICRmaWx0ZXJJbnB1dEVsbVswXS5mbGF0cGlja3IgPT09ICdmdW5jdGlvbicpID8gJGZpbHRlcklucHV0RWxtWzBdLmZsYXRwaWNrcih0aGlzLl9mbGF0cGlja3JPcHRpb25zKSA6IEZsYXRwaWNrcigkZmlsdGVySW5wdXRFbG0sIHRoaXMuX2ZsYXRwaWNrck9wdGlvbnMgYXMgdW5rbm93biBhcyBQYXJ0aWFsPEZsYXRwaWNrckJhc2VPcHRpb25zPik7XHJcbiAgICByZXR1cm4gJGZpbHRlcklucHV0RWxtO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIHRoZSBET00gZWxlbWVudFxyXG4gICAqIEBwYXJhbXMgc2VhcmNoVGVybXNcclxuICAgKi9cclxuICBwcml2YXRlIGNyZWF0ZURvbUVsZW1lbnQoc2VhcmNoVGVybXM/OiBTZWFyY2hUZXJtW10pIHtcclxuICAgIGNvbnN0IGZpZWxkSWQgPSB0aGlzLmNvbHVtbkRlZiAmJiB0aGlzLmNvbHVtbkRlZi5pZDtcclxuICAgIGNvbnN0ICRoZWFkZXJFbG0gPSB0aGlzLmdyaWQuZ2V0SGVhZGVyUm93Q29sdW1uKGZpZWxkSWQpO1xyXG4gICAgJCgkaGVhZGVyRWxtKS5lbXB0eSgpO1xyXG5cclxuICAgIC8vIGNyZWF0ZSB0aGUgRE9NIFNlbGVjdCBkcm9wZG93biBmb3IgdGhlIE9wZXJhdG9yXHJcbiAgICB0aGlzLiRmaWx0ZXJJbnB1dEVsbSA9IHRoaXMuYnVpbGREYXRlUGlja2VySW5wdXQoc2VhcmNoVGVybXMpO1xyXG5cclxuICAgIC8qIHRoZSBET00gZWxlbWVudCBmaW5hbCBzdHJ1Y3R1cmUgd2lsbCBiZVxyXG4gICAgICA8ZGl2IGNsYXNzPWZsYXRwaWNrcj5cclxuICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGRhdGEtaW5wdXQ+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgKi9cclxuXHJcbiAgICAvLyBjcmVhdGUgdGhlIERPTSBlbGVtZW50ICYgYWRkIGFuIElEIGFuZCBmaWx0ZXIgY2xhc3NcclxuICAgIHRoaXMuJGZpbHRlcklucHV0RWxtLmRhdGEoJ2NvbHVtbklkJywgZmllbGRJZCk7XHJcblxyXG4gICAgLy8gaWYgdGhlcmUncyBhIHNlYXJjaCB0ZXJtLCB3ZSB3aWxsIGFkZCB0aGUgXCJmaWxsZWRcIiBjbGFzcyBmb3Igc3R5bGluZyBwdXJwb3Nlc1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2VhcmNoVGVybXMpICYmIHNlYXJjaFRlcm1zLmxlbmd0aCA+IDAgJiYgc2VhcmNoVGVybXNbMF0gIT09ICcnKSB7XHJcbiAgICAgIHRoaXMuJGZpbHRlcklucHV0RWxtLmFkZENsYXNzKCdmaWxsZWQnKTtcclxuICAgICAgdGhpcy5fY3VycmVudERhdGVzID0gc2VhcmNoVGVybXMgYXMgRGF0ZVtdO1xyXG4gICAgICB0aGlzLl9jdXJyZW50VmFsdWUgPSBzZWFyY2hUZXJtc1swXSBhcyBzdHJpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYXBwZW5kIHRoZSBuZXcgRE9NIGVsZW1lbnQgdG8gdGhlIGhlYWRlciByb3dcclxuICAgIGlmICh0aGlzLiRmaWx0ZXJJbnB1dEVsbSAmJiB0eXBlb2YgdGhpcy4kZmlsdGVySW5wdXRFbG0uYXBwZW5kVG8gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhpcy4kZmlsdGVySW5wdXRFbG0uYXBwZW5kVG8oJGhlYWRlckVsbSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuJGZpbHRlcklucHV0RWxtO1xyXG4gIH1cclxuXHJcbiAgLyoqIExvYWQgYSBkaWZmZXJlbnQgc2V0IG9mIGxvY2FsZXMgZm9yIEZsYXRwaWNrciB0byBiZSBsb2NhbGl6ZWQgKi9cclxuICBwcml2YXRlIGxvYWRGbGF0cGlja3JMb2NhbGUobGFuZ3VhZ2U6IHN0cmluZykge1xyXG4gICAgbGV0IGxvY2FsZXMgPSAnZW4nO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGlmIChsYW5ndWFnZSAhPT0gJ2VuJykge1xyXG4gICAgICAgIC8vIGNoYW5nZSBsb2NhbGUgaWYgbmVlZGVkLCBGbGF0cGlja3IgcmVmZXJlbmNlOiBodHRwczovL2NobWxuLmdpdGh1Yi5pby9mbGF0cGlja3IvbG9jYWxpemF0aW9uL1xyXG4gICAgICAgIGNvbnN0IGxvY2FsZURlZmF1bHQ6IGFueSA9IHJlcXVpcmUoYGZsYXRwaWNrci9kaXN0L2wxMG4vJHtsYW5ndWFnZX0uanNgKS5kZWZhdWx0O1xyXG4gICAgICAgIGxvY2FsZXMgPSAobG9jYWxlRGVmYXVsdCAmJiBsb2NhbGVEZWZhdWx0W2xhbmd1YWdlXSkgPyBsb2NhbGVEZWZhdWx0W2xhbmd1YWdlXSA6ICdlbic7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBbQW5ndWxhci1TbGlja2dyaWQgLSBEYXRlUmFuZ2UgRmlsdGVyXSBJdCBzZWVtcyB0aGF0IFwiJHtsYW5ndWFnZX1cIiBpcyBub3QgYSBsb2NhbGUgc3VwcG9ydGVkIGJ5IEZsYXRwaWNrciwgd2Ugd2lsbCB1c2UgXCJlblwiIGluc3RlYWQuIGBcclxuICAgICAgICArIGBUbyBhdm9pZCBzZWVpbmcgdGhpcyBtZXNzYWdlLCB5b3UgY2FuIHNwZWNpZmljYWxseSBzZXQgXCJmaWx0ZXI6IHsgZmlsdGVyT3B0aW9uczogeyBsb2NhbGU6ICdlbicgfSB9XCIgaW4geW91ciBjb2x1bW4gZGVmaW5pdGlvbi5gKTtcclxuICAgICAgcmV0dXJuICdlbic7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxlcztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgb25UcmlnZ2VyRXZlbnQoZTogRXZlbnQgfCB1bmRlZmluZWQpIHtcclxuICAgIGlmICh0aGlzLl9jbGVhckZpbHRlclRyaWdnZXJlZCkge1xyXG4gICAgICB0aGlzLmNhbGxiYWNrKGUsIHsgY29sdW1uRGVmOiB0aGlzLmNvbHVtbkRlZiwgY2xlYXJGaWx0ZXJUcmlnZ2VyZWQ6IHRoaXMuX2NsZWFyRmlsdGVyVHJpZ2dlcmVkLCBzaG91bGRUcmlnZ2VyUXVlcnk6IHRoaXMuX3Nob3VsZFRyaWdnZXJRdWVyeSB9KTtcclxuICAgICAgdGhpcy4kZmlsdGVyRWxtLnJlbW92ZUNsYXNzKCdmaWxsZWQnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICh0aGlzLl9jdXJyZW50RGF0ZVN0cmluZ3MpID8gdGhpcy4kZmlsdGVyRWxtLmFkZENsYXNzKCdmaWxsZWQnKSA6IHRoaXMuJGZpbHRlckVsbS5yZW1vdmVDbGFzcygnZmlsbGVkJyk7XHJcbiAgICAgIHRoaXMuY2FsbGJhY2soZSwgeyBjb2x1bW5EZWY6IHRoaXMuY29sdW1uRGVmLCBzZWFyY2hUZXJtczogKHRoaXMuX2N1cnJlbnREYXRlU3RyaW5ncyA/IHRoaXMuX2N1cnJlbnREYXRlU3RyaW5ncyA6IFt0aGlzLl9jdXJyZW50VmFsdWVdKSwgb3BlcmF0b3I6IHRoaXMub3BlcmF0b3IgfHwgJycsIHNob3VsZFRyaWdnZXJRdWVyeTogdGhpcy5fc2hvdWxkVHJpZ2dlclF1ZXJ5IH0pO1xyXG4gICAgfVxyXG4gICAgLy8gcmVzZXQgYm90aCBmbGFncyBmb3IgbmV4dCB1c2VcclxuICAgIHRoaXMuX2NsZWFyRmlsdGVyVHJpZ2dlcmVkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9zaG91bGRUcmlnZ2VyUXVlcnkgPSB0cnVlO1xyXG4gIH1cclxufVxyXG4iXX0=