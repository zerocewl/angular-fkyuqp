import * as tslib_1 from "tslib";
import { InputFilter } from './inputFilter';
var InputMaskFilter = /** @class */ (function (_super) {
    tslib_1.__extends(InputMaskFilter, _super);
    /** Initialize the Filter */
    function InputMaskFilter() {
        var _this = _super.call(this) || this;
        _this.inputType = 'text';
        return _this;
    }
    Object.defineProperty(InputMaskFilter.prototype, "inputMask", {
        /** Getter of the input mask, when provided */
        get: function () {
            return this._inputMask;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Override the Filter init used by SlickGrid
     */
    InputMaskFilter.prototype.init = function (args) {
        var _this = this;
        if (!args) {
            throw new Error('[Angular-SlickGrid] A filter must always have an "init()" with valid arguments.');
        }
        this.grid = args.grid;
        this.callback = args.callback;
        this.columnDef = args.columnDef;
        this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];
        // get input mask from params (can be in columnDef or columnFilter params)
        if (this.columnDef && this.columnDef.params && this.columnDef.params.mask) {
            this._inputMask = this.columnDef.params.mask;
        }
        else if (this.columnFilter && this.columnFilter.params && this.columnFilter.params.mask) {
            this._inputMask = this.columnFilter.params.mask;
        }
        if (!this._inputMask) {
            throw new Error("[Angular-Slickgrid] The Filters.inputMask requires the mask to be passed in the filter params or the column definition params\n        for example:: this.columnDefinitions: [{ id: 'phone', field: 'phone', filter: { model: Filters.inputMask, params: { mask: '000-000-0000' }}}]");
        }
        // filter input can only have 1 search term, so we will use the 1st array index if it exist
        var searchTerm = (Array.isArray(this.searchTerms) && this.searchTerms.length >= 0) ? this.searchTerms[0] : '';
        // step 1, create HTML string template
        var filterTemplate = this.buildTemplateHtmlString();
        // step 2, create the DOM Element of the filter & initialize it if searchTerm is filled
        this.$filterElm = this.createDomElement(filterTemplate, searchTerm);
        // step 3, subscribe to the keyup event and run the callback when that happens
        // also add/remove "filled" class for styling purposes
        this.$filterElm.on('keyup input change', function (e) {
            var value = '';
            if (e && e.target && e.target.value) {
                var targetValue = e.target.value;
                var enableWhiteSpaceTrim = _this.gridOptions.enableFilterTrimWhiteSpace || _this.columnFilter.enableTrimWhiteSpace;
                if (typeof targetValue === 'string' && enableWhiteSpaceTrim) {
                    targetValue = targetValue.trim();
                }
                // if it has a mask, we need to do a bit more work
                // and replace the filter string by the masked output without triggering an event
                var unmaskedValue = _this.unmaskValue(targetValue);
                var maskedValue = _this.maskValue(unmaskedValue);
                value = unmaskedValue;
                if (e.keyCode >= 48) {
                    _this.$filterElm.val(maskedValue); // replace filter string with masked string
                    e.preventDefault();
                }
            }
            if (_this._clearFilterTriggered) {
                _this.callback(e, { columnDef: _this.columnDef, clearFilterTriggered: _this._clearFilterTriggered, shouldTriggerQuery: _this._shouldTriggerQuery });
                _this.$filterElm.removeClass('filled');
            }
            else {
                _this.$filterElm.addClass('filled');
                _this.callback(e, { columnDef: _this.columnDef, operator: _this.operator, searchTerms: [value], shouldTriggerQuery: _this._shouldTriggerQuery });
            }
            // reset both flags for next use
            _this._clearFilterTriggered = false;
            _this._shouldTriggerQuery = true;
        });
    };
    /** From a regular string, we will use the mask to output a new string */
    InputMaskFilter.prototype.maskValue = function (inputValue) {
        var i = 0;
        var maskedValue = '';
        if (this._inputMask) {
            maskedValue = this._inputMask.replace(/[09A]/gi, function (match) {
                // only replace the char when the mask is a 0 or 9 for a digit OR the mask is "A" and the char is a non-digit meaning a string char
                if (((match === '0' || match === '9') && /\d+/g.test(inputValue[i])) // mask is 0 or 9 and value is a digit
                    || (match.toUpperCase() === 'A' && /[^\d]+/gi.test(inputValue[i])) // OR mask is an "A" and value is non-digit
                ) {
                    return inputValue[i++] || '';
                }
                return '';
            });
        }
        return maskedValue;
    };
    /** From a masked string, we will remove the mask and make a regular string again */
    InputMaskFilter.prototype.unmaskValue = function (maskedValue) {
        // remove anything else but digits and chars from both the input mask and the input masked value for later comparison
        // e.g. (000) 000-0000 would return 0000000000
        var valueWithoutSymbols = maskedValue.replace(/[^0-9a-z]*/gi, '');
        var maskWithoutSymbols = this._inputMask.replace(/[^0-9a-z]*/gi, '');
        // then we can analyze if each char on each indexes equals what the mask requires, if not the char will be disregarded from the output
        // basically, if our mask is "0A0" and input value is "2ab", then only "2a" will be returned since the last char "b" is not part of the mask and is invalid
        var output = '';
        for (var i = 0; i < maskWithoutSymbols.length; i++) {
            if (valueWithoutSymbols[i]) {
                if (((maskWithoutSymbols[i] === '0' || maskWithoutSymbols[i] === '9') && /\d+/g.test(valueWithoutSymbols[i])) // mask is 0 or 9 and value is a digit
                    || (maskWithoutSymbols[i].toUpperCase() === 'A' && /[^\d]+/gi.test(valueWithoutSymbols[i])) // OR mask is an "A" and value is non-digit
                ) {
                    output += valueWithoutSymbols[i]; // valid and matches the Mask, so we can add it up to the string output
                }
            }
        }
        return output;
    };
    return InputMaskFilter;
}(InputFilter));
export { InputMaskFilter };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXRNYXNrRmlsdGVyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1zbGlja2dyaWQvIiwic291cmNlcyI6WyJhcHAvbW9kdWxlcy9hbmd1bGFyLXNsaWNrZ3JpZC9maWx0ZXJzL2lucHV0TWFza0ZpbHRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUc1QztJQUFxQywyQ0FBVztJQUc5Qyw0QkFBNEI7SUFDNUI7UUFBQSxZQUNFLGlCQUFPLFNBRVI7UUFEQyxLQUFJLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQzs7SUFDMUIsQ0FBQztJQUdELHNCQUFJLHNDQUFTO1FBRGIsOENBQThDO2FBQzlDO1lBQ0UsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBQ3pCLENBQUM7OztPQUFBO0lBRUQ7O09BRUc7SUFDSCw4QkFBSSxHQUFKLFVBQUssSUFBcUI7UUFBMUIsaUJBaUVDO1FBaEVDLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDVCxNQUFNLElBQUksS0FBSyxDQUFDLGlGQUFpRixDQUFDLENBQUM7U0FDcEc7UUFDRCxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDdEIsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBQzlCLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztRQUNoQyxJQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxDQUFDO1FBRXRGLDBFQUEwRTtRQUMxRSxJQUFJLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMs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RyxXQUFXLENBQUMsT0FBTyxDQUFDLGNBQWMsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUNwRSxJQUFNLGtCQUFrQixHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLGNBQWMsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUV2RSxzSUFBc0k7UUFDdEksMkpBQTJKO1FBQzNKLElBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQztRQUNoQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsa0JBQWtCLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ2xELElBQUksbUJBQW1CLENBQUMsQ0FBQyxDQUFDLEVBQUU7Z0JBQzFCLElBQ0UsQ0FBQyxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsSUFBSSxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBSSxzQ0FBc0M7dUJBQ2hKLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLEtBQUssR0FBRyxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFFLDJDQUEyQztrQkFDeEk7b0JBQ0EsTUFBTSxJQUFJLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsdUVBQXVFO2lCQUMxRzthQUNGO1NBQ0Y7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBQ0gsc0JBQUM7QUFBRCxDQUFDLEFBaElELENBQXFDLFdBQVcsR0FnSS9DIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5wdXRGaWx0ZXIgfSBmcm9tICcuL2lucHV0RmlsdGVyJztcclxuaW1wb3J0IHsgRmlsdGVyQXJndW1lbnRzIH0gZnJvbSAnLi4vbW9kZWxzL2ZpbHRlckFyZ3VtZW50cy5pbnRlcmZhY2UnO1xyXG5cclxuZXhwb3J0IGNsYXNzIElucHV0TWFza0ZpbHRlciBleHRlbmRzIElucHV0RmlsdGVyIHtcclxuICBwcml2YXRlIF9pbnB1dE1hc2s6IHN0cmluZztcclxuXHJcbiAgLyoqIEluaXRpYWxpemUgdGhlIEZpbHRlciAqL1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMuaW5wdXRUeXBlID0gJ3RleHQnO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBvZiB0aGUgaW5wdXQgbWFzaywgd2hlbiBwcm92aWRlZCAqL1xyXG4gIGdldCBpbnB1dE1hc2soKTogc3RyaW5nIHtcclxuICAgIHJldHVybiB0aGlzLl9pbnB1dE1hc2s7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPdmVycmlkZSB0aGUgRmlsdGVyIGluaXQgdXNlZCBieSBTbGlja0dyaWRcclxuICAgKi9cclxuICBpbml0KGFyZ3M6IEZpbHRlckFyZ3VtZW50cykge1xyXG4gICAgaWYgKCFhcmdzKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignW0FuZ3VsYXItU2xpY2tHcmlkXSBBIGZpbHRlciBtdXN0IGFsd2F5cyBoYXZlIGFuIFwiaW5pdCgpXCIgd2l0aCB2YWxpZCBhcmd1bWVudHMuJyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmdyaWQgPSBhcmdzLmdyaWQ7XHJcbiAgICB0aGlzLmNhbGxiYWNrID0gYXJncy5jYWxsYmFjaztcclxuICAgIHRoaXMuY29sdW1uRGVmID0gYXJncy5jb2x1bW5EZWY7XHJcbiAgICB0aGlzLnNlYXJjaFRlcm1zID0gKGFyZ3MuaGFzT3duUHJvcGVydHkoJ3NlYXJjaFRlcm1zJykgPyBhcmdzLnNlYXJjaFRlcm1zIDogW10pIHx8IFtdO1xyXG5cclxuICAgIC8vIGdldCBpbnB1dCBtYXNrIGZyb20gcGFyYW1zIChjYW4gYmUgaW4gY29sdW1uRGVmIG9yIGNvbHVtbkZpbHRlciBwYXJhbXMpXHJcbiAgICBpZiAodGhpcy5jb2x1bW5EZWYgJiYgdGhpcy5jb2x1bW5EZWYucGFyYW1zICYmIHRoaXMuY29sdW1uRGVmLnBhcmFtcy5tYXNrKSB7XHJcbiAgICAgIHRoaXMuX2lucHV0TWFzayA9IHRoaXMuY29sdW1uRGVmLnBhcmFtcy5tYXNrO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLmNvbHVtbkZpbHRlciAmJiB0aGlzLmNvbHVtbkZpbHRlci5wYXJhbXMgJiYgdGhpcy5jb2x1bW5GaWx0ZXIucGFyYW1zLm1hc2spIHtcclxuICAgICAgdGhpcy5faW5wdXRNYXNrID0gdGhpcy5jb2x1bW5GaWx0ZXIucGFyYW1zLm1hc2s7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLl9pbnB1dE1hc2spIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBbQW5ndWxhci1TbGlja2dyaWRdIFRoZSBGaWx0ZXJzLmlucHV0TWFzayByZXF1aXJlcyB0aGUgbWFzayB0byBiZSBwYXNzZWQgaW4gdGhlIGZpbHRlciBwYXJhbXMgb3IgdGhlIGNvbHVtbiBkZWZpbml0aW9uIHBhcmFtc1xyXG4gICAgICAgIGZvciBleGFtcGxlOjogdGhpcy5jb2x1bW5EZWZpbml0aW9uczogW3sgaWQ6ICdwaG9uZScsIGZpZWxkOiAncGhvbmUnLCBmaWx0ZXI6IHsgbW9kZWw6IEZpbHRlcnMuaW5wdXRNYXNrLCBwYXJhbXM6IHsgbWFzazogJzAwMC0wMDAtMDAwMCcgfX19XWApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGZpbHRlciBpbnB1dCBjYW4gb25seSBoYXZlIDEgc2VhcmNoIHRlcm0sIHNvIHdlIHdpbGwgdXNlIHRoZSAxc3QgYXJyYXkgaW5kZXggaWYgaXQgZXhpc3RcclxuICAgIGNvbnN0IHNlYXJjaFRlcm0gPSAoQXJyYXkuaXNBcnJheSh0aGlzLnNlYXJjaFRlcm1zKSAmJiB0aGlzLnNlYXJjaFRlcm1zLmxlbmd0aCA+PSAwKSA/IHRoaXMuc2VhcmNoVGVybXNbMF0gOiAnJztcclxuXHJcbiAgICAvLyBzdGVwIDEsIGNyZWF0ZSBIVE1MIHN0cmluZyB0ZW1wbGF0ZVxyXG4gICAgY29uc3QgZmlsdGVyVGVtcGxhdGUgPSB0aGlzLmJ1aWxkVGVtcGxhdGVIdG1sU3RyaW5nKCk7XHJcblxyXG4gICAgLy8gc3RlcCAyLCBjcmVhdGUgdGhlIERPTSBFbGVtZW50IG9mIHRoZSBmaWx0ZXIgJiBpbml0aWFsaXplIGl0IGlmIHNlYXJjaFRlcm0gaXMgZmlsbGVkXHJcbiAgICB0aGlzLiRmaWx0ZXJFbG0gPSB0aGlzLmNyZWF0ZURvbUVsZW1lbnQoZmlsdGVyVGVtcGxhdGUsIHNlYXJjaFRlcm0pO1xyXG5cclxuICAgIC8vIHN0ZXAgMywgc3Vic2NyaWJlIHRvIHRoZSBrZXl1cCBldmVudCBhbmQgcnVuIHRoZSBjYWxsYmFjayB3aGVuIHRoYXQgaGFwcGVuc1xyXG4gICAgLy8gYWxzbyBhZGQvcmVtb3ZlIFwiZmlsbGVkXCIgY2xhc3MgZm9yIHN0eWxpbmcgcHVycG9zZXNcclxuXHJcbiAgICB0aGlzLiRmaWx0ZXJFbG0ub24oJ2tleXVwIGlucHV0IGNoYW5nZScsIChlOiBhbnkpID0+IHtcclxuICAgICAgbGV0IHZhbHVlID0gJyc7XHJcbiAgICAgIGlmIChlICYmIGUudGFyZ2V0ICYmIGUudGFyZ2V0LnZhbHVlKSB7XHJcbiAgICAgICAgbGV0IHRhcmdldFZhbHVlID0gZS50YXJnZXQudmFsdWU7XHJcbiAgICAgICAgY29uc3QgZW5hYmxlV2hpdGVTcGFjZVRyaW0gPSB0aGlzLmdyaWRPcHRpb25zLmVuYWJsZUZpbHRlclRyaW1XaGl0ZVNwYWNlIHx8IHRoaXMuY29sdW1uRmlsdGVyLmVuYWJsZVRyaW1XaGl0ZVNwYWNlO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0VmFsdWUgPT09ICdzdHJpbmcnICYmIGVuYWJsZVdoaXRlU3BhY2VUcmltKSB7XHJcbiAgICAgICAgICB0YXJnZXRWYWx1ZSA9IHRhcmdldFZhbHVlLnRyaW0oKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGlmIGl0IGhhcyBhIG1hc2ssIHdlIG5lZWQgdG8gZG8gYSBiaXQgbW9yZSB3b3JrXHJcbiAgICAgICAgLy8gYW5kIHJlcGxhY2UgdGhlIGZpbHRlciBzdHJpbmcgYnkgdGhlIG1hc2tlZCBvdXRwdXQgd2l0aG91dCB0cmlnZ2VyaW5nIGFuIGV2ZW50XHJcbiAgICAgICAgY29uc3QgdW5tYXNrZWRWYWx1ZSA9IHRoaXMudW5tYXNrVmFsdWUodGFyZ2V0VmFsdWUpO1xyXG4gICAgICAgIGNvbnN0IG1hc2tlZFZhbHVlID0gdGhpcy5tYXNrVmFsdWUodW5tYXNrZWRWYWx1ZSk7XHJcbiAgICAgICAgdmFsdWUgPSB1bm1hc2tlZFZhbHVlO1xyXG5cclxuICAgICAgICBpZiAoZS5rZXlDb2RlID49IDQ4KSB7XHJcbiAgICAgICAgICB0aGlzLiRmaWx0ZXJFbG0udmFsKG1hc2tlZFZhbHVlKTsgLy8gcmVwbGFjZSBmaWx0ZXIgc3RyaW5nIHdpdGggbWFza2VkIHN0cmluZ1xyXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuX2NsZWFyRmlsdGVyVHJpZ2dlcmVkKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFjayhlLCB7IGNvbHVtbkRlZjogdGhpcy5jb2x1bW5EZWYsIGNsZWFyRmlsdGVyVHJpZ2dlcmVkOiB0aGlzLl9jbGVhckZpbHRlclRyaWdnZXJlZCwgc2hvdWxkVHJpZ2dlclF1ZXJ5OiB0aGlzLl9zaG91bGRUcmlnZ2VyUXVlcnkgfSk7XHJcbiAgICAgICAgdGhpcy4kZmlsdGVyRWxtLnJlbW92ZUNsYXNzKCdmaWxsZWQnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLiRmaWx0ZXJFbG0uYWRkQ2xhc3MoJ2ZpbGxlZCcpO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2soZSwgeyBjb2x1bW5EZWY6IHRoaXMuY29sdW1uRGVmLCBvcGVyYXRvcjogdGhpcy5vcGVyYXRvciwgc2VhcmNoVGVybXM6IFt2YWx1ZV0sIHNob3VsZFRyaWdnZXJRdWVyeTogdGhpcy5fc2hvdWxkVHJpZ2dlclF1ZXJ5IH0pO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIHJlc2V0IGJvdGggZmxhZ3MgZm9yIG5leHQgdXNlXHJcbiAgICAgIHRoaXMuX2NsZWFyRmlsdGVyVHJpZ2dlcmVkID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuX3Nob3VsZFRyaWdnZXJRdWVyeSA9IHRydWU7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKiBGcm9tIGEgcmVndWxhciBzdHJpbmcsIHdlIHdpbGwgdXNlIHRoZSBtYXNrIHRvIG91dHB1dCBhIG5ldyBzdHJpbmcgKi9cclxuICBwcml2YXRlIG1hc2tWYWx1ZShpbnB1dFZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgbGV0IG1hc2tlZFZhbHVlID0gJyc7XHJcblxyXG4gICAgaWYgKHRoaXMuX2lucHV0TWFzaykge1xyXG4gICAgICBtYXNrZWRWYWx1ZSA9IHRoaXMuX2lucHV0TWFzay5yZXBsYWNlKC9bMDlBXS9naSwgKG1hdGNoKSA9PiB7XHJcbiAgICAgICAgLy8gb25seSByZXBsYWNlIHRoZSBjaGFyIHdoZW4gdGhlIG1hc2sgaXMgYSAwIG9yIDkgZm9yIGEgZGlnaXQgT1IgdGhlIG1hc2sgaXMgXCJBXCIgYW5kIHRoZSBjaGFyIGlzIGEgbm9uLWRpZ2l0IG1lYW5pbmcgYSBzdHJpbmcgY2hhclxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICgobWF0Y2ggPT09ICcwJyB8fCBtYXRjaCA9PT0gJzknKSAmJiAvXFxkKy9nLnRlc3QoaW5wdXRWYWx1ZVtpXSkpICAgIC8vIG1hc2sgaXMgMCBvciA5IGFuZCB2YWx1ZSBpcyBhIGRpZ2l0XHJcbiAgICAgICAgICB8fCAobWF0Y2gudG9VcHBlckNhc2UoKSA9PT0gJ0EnICYmIC9bXlxcZF0rL2dpLnRlc3QoaW5wdXRWYWx1ZVtpXSkpICAvLyBPUiBtYXNrIGlzIGFuIFwiQVwiIGFuZCB2YWx1ZSBpcyBub24tZGlnaXRcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHJldHVybiBpbnB1dFZhbHVlW2krK10gfHwgJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG1hc2tlZFZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqIEZyb20gYSBtYXNrZWQgc3RyaW5nLCB3ZSB3aWxsIHJlbW92ZSB0aGUgbWFzayBhbmQgbWFrZSBhIHJlZ3VsYXIgc3RyaW5nIGFnYWluICovXHJcbiAgcHJpdmF0ZSB1bm1hc2tWYWx1ZShtYXNrZWRWYWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIC8vIHJlbW92ZSBhbnl0aGluZyBlbHNlIGJ1dCBkaWdpdHMgYW5kIGNoYXJzIGZyb20gYm90aCB0aGUgaW5wdXQgbWFzayBhbmQgdGhlIGlucHV0IG1hc2tlZCB2YWx1ZSBmb3IgbGF0ZXIgY29tcGFyaXNvblxyXG4gICAgLy8gZS5nLiAoMDAwKSAwMDAtMDAwMCB3b3VsZCByZXR1cm4gMDAwMDAwMDAwMFxyXG4gICAgY29uc3QgdmFsdWVXaXRob3V0U3ltYm9scyA9IG1hc2tlZFZhbHVlLnJlcGxhY2UoL1teMC05YS16XSovZ2ksICcnKTtcclxuICAgIGNvbnN0IG1hc2tXaXRob3V0U3ltYm9scyA9IHRoaXMuX2lucHV0TWFzay5yZXBsYWNlKC9bXjAtOWEtel0qL2dpLCAnJyk7XHJcblxyXG4gICAgLy8gdGhlbiB3ZSBjYW4gYW5hbHl6ZSBpZiBlYWNoIGNoYXIgb24gZWFjaCBpbmRleGVzIGVxdWFscyB3aGF0IHRoZSBtYXNrIHJlcXVpcmVzLCBpZiBub3QgdGhlIGNoYXIgd2lsbCBiZSBkaXNyZWdhcmRlZCBmcm9tIHRoZSBvdXRwdXRcclxuICAgIC8vIGJhc2ljYWxseSwgaWYgb3VyIG1hc2sgaXMgXCIwQTBcIiBhbmQgaW5wdXQgdmFsdWUgaXMgXCIyYWJcIiwgdGhlbiBvbmx5IFwiMmFcIiB3aWxsIGJlIHJldHVybmVkIHNpbmNlIHRoZSBsYXN0IGNoYXIgXCJiXCIgaXMgbm90IHBhcnQgb2YgdGhlIG1hc2sgYW5kIGlzIGludmFsaWRcclxuICAgIGxldCBvdXRwdXQgPSAnJztcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFza1dpdGhvdXRTeW1ib2xzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmICh2YWx1ZVdpdGhvdXRTeW1ib2xzW2ldKSB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgKChtYXNrV2l0aG91dFN5bWJvbHNbaV0gPT09ICcwJyB8fCBtYXNrV2l0aG91dFN5bWJvbHNbaV0gPT09ICc5JykgJiYgL1xcZCsvZy50ZXN0KHZhbHVlV2l0aG91dFN5bWJvbHNbaV0pKSAgICAvLyBtYXNrIGlzIDAgb3IgOSBhbmQgdmFsdWUgaXMgYSBkaWdpdFxyXG4gICAgICAgICAgfHwgKG1hc2tXaXRob3V0U3ltYm9sc1tpXS50b1VwcGVyQ2FzZSgpID09PSAnQScgJiYgL1teXFxkXSsvZ2kudGVzdCh2YWx1ZVdpdGhvdXRTeW1ib2xzW2ldKSkgIC8vIE9SIG1hc2sgaXMgYW4gXCJBXCIgYW5kIHZhbHVlIGlzIG5vbi1kaWdpdFxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgb3V0cHV0ICs9IHZhbHVlV2l0aG91dFN5bWJvbHNbaV07IC8vIHZhbGlkIGFuZCBtYXRjaGVzIHRoZSBNYXNrLCBzbyB3ZSBjYW4gYWRkIGl0IHVwIHRvIHRoZSBzdHJpbmcgb3V0cHV0XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dHB1dDtcclxuICB9XHJcbn1cclxuIl19