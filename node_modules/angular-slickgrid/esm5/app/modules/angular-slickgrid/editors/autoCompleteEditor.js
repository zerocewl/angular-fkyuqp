import * as tslib_1 from "tslib";
import { FieldType, KeyCode, } from './../models/index';
import { Constants } from './../constants';
import { findOrDefault, getDescendantProperty, setDeepValue } from '../services/utilities';
// minimum length of chars to type before starting to start querying
var MIN_LENGTH = 3;
/*
 * An example of a 'detached' editor.
 * KeyDown events are also handled to provide handling for Tab, Shift-Tab, Esc and Ctrl-Enter.
 */
var AutoCompleteEditor = /** @class */ (function () {
    function AutoCompleteEditor(args) {
        this.args = args;
        if (!args) {
            throw new Error('[Angular-SlickGrid] Something is wrong with this grid, an Editor must always have valid arguments.');
        }
        this.grid = args.grid;
        this.init();
    }
    Object.defineProperty(AutoCompleteEditor.prototype, "autoCompleteOptions", {
        /** Getter for the Autocomplete Option */
        get: function () {
            return this._autoCompleteOptions || {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteEditor.prototype, "editorCollection", {
        /** Get the Collection */
        get: function () {
            return this.columnDef && this.columnDef.internalColumnEditor && this.columnDef.internalColumnEditor.collection || [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteEditor.prototype, "elementCollection", {
        /** Get the Final Collection used in the AutoCompleted Source (this may vary from the "collection" especially when providing a customStructure) */
        get: function () {
            return this._elementCollection;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteEditor.prototype, "columnDef", {
        /** Get Column Definition object */
        get: function () {
            return this.args && this.args.column;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteEditor.prototype, "columnEditor", {
        /** Get Column Editor object */
        get: function () {
            return this.columnDef && this.columnDef.internalColumnEditor || {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteEditor.prototype, "customStructure", {
        /** Getter for the Custom Structure if exist */
        get: function () {
            return this.columnDef && this.columnDef.internalColumnEditor && this.columnDef.internalColumnEditor.customStructure;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteEditor.prototype, "hasAutoCommitEdit", {
        get: function () {
            return this.grid.getOptions().autoCommitEdit;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteEditor.prototype, "validator", {
        /** Get the Validator function, can be passed in Editor property or Column Definition */
        get: function () {
            return this.columnEditor.validator || this.columnDef.validator;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteEditor.prototype, "editorOptions", {
        get: function () {
            return this.columnEditor && this.columnEditor.editorOptions || {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteEditor.prototype, "editorDomElement", {
        /** Get the Editor DOM Element */
        get: function () {
            return this._$editorElm;
        },
        enumerable: true,
        configurable: true
    });
    AutoCompleteEditor.prototype.init = function () {
        this.labelName = this.customStructure && this.customStructure.label || 'label';
        this.valueName = this.customStructure && this.customStructure.value || 'value';
        // always render the DOM element, even if user passed a "collectionAsync",
        var newCollection = this.columnEditor.collection || [];
        this.renderDomElement(newCollection);
    };
    AutoCompleteEditor.prototype.destroy = function () {
        this._$editorElm.off('keydown.nav').remove();
    };
    AutoCompleteEditor.prototype.focus = function () {
        this._$editorElm.focus().select();
    };
    AutoCompleteEditor.prototype.getValue = function () {
        return this._$editorElm.val();
    };
    AutoCompleteEditor.prototype.setValue = function (value) {
        this._$editorElm.val(value);
    };
    AutoCompleteEditor.prototype.applyValue = function (item, state) {
        var _this = this;
        var newValue = state;
        var fieldName = this.columnDef && this.columnDef.field;
        // if we have a collection defined, we will try to find the string within the collection and return it
        if (Array.isArray(this.editorCollection) && this.editorCollection.length > 0) {
            newValue = findOrDefault(this.editorCollection, function (collectionItem) {
                if (collectionItem && typeof state === 'object' && collectionItem.hasOwnProperty(_this.labelName)) {
                    return (collectionItem.hasOwnProperty(_this.labelName) && collectionItem[_this.labelName].toString()) === (state.hasOwnProperty(_this.labelName) && state[_this.labelName].toString());
                }
                else if (collectionItem && typeof state === 'string' && collectionItem.hasOwnProperty(_this.labelName)) {
                    return (collectionItem.hasOwnProperty(_this.labelName) && collectionItem[_this.labelName].toString()) === state;
                }
                return collectionItem && collectionItem.toString() === state;
            });
        }
        // is the field a complex object, "address.streetNumber"
        var isComplexObject = fieldName.indexOf('.') > 0;
        // validate the value before applying it (if not valid we'll set an empty string)
        var validation = this.validate(newValue);
        newValue = (validation && validation.valid) ? newValue : '';
        // set the new value to the item datacontext
        if (isComplexObject) {
            setDeepValue(item, fieldName, newValue);
        }
        else {
            item[fieldName] = newValue;
        }
    };
    AutoCompleteEditor.prototype.isValueChanged = function () {
        var lastEvent = this._lastInputEvent && this._lastInputEvent.keyCode;
        if (this.columnEditor && this.columnEditor.alwaysSaveOnEnterKey && lastEvent === KeyCode.ENTER) {
            return true;
        }
        return (!(this._$editorElm.val() === '' && this._defaultTextValue === null)) && (this._$editorElm.val() !== this._defaultTextValue);
    };
    AutoCompleteEditor.prototype.loadValue = function (item) {
        var fieldName = this.columnDef && this.columnDef.field;
        // is the field a complex object, "address.streetNumber"
        var isComplexObject = fieldName.indexOf('.') > 0;
        if (item && this.columnDef && (item.hasOwnProperty(fieldName) || isComplexObject)) {
            var data = (isComplexObject) ? getDescendantProperty(item, fieldName) : item[fieldName];
            this._currentValue = data;
            this._defaultTextValue = typeof data === 'string' ? data : data[this.labelName];
            this._$editorElm.val(this._defaultTextValue);
            this._$editorElm.select();
        }
    };
    AutoCompleteEditor.prototype.save = function () {
        var validation = this.validate();
        if (validation && validation.valid && this.isValueChanged()) {
            if (this.hasAutoCommitEdit) {
                this.grid.getEditorLock().commitCurrentEdit();
            }
            else {
                this.args.commitChanges();
            }
        }
    };
    AutoCompleteEditor.prototype.serializeValue = function () {
        var _a;
        // if you want to add the autocomplete functionality but want the user to be able to input a new option
        if (this.editorOptions.forceUserInput) {
            var minLength = this.editorOptions && this.editorOptions.hasOwnProperty('minLength') ? this.editorOptions.minLength : MIN_LENGTH;
            this._currentValue = this._$editorElm.val().length > minLength ? this._$editorElm.val() : this._currentValue;
        }
        // if user provided a custom structure, we will serialize the value returned from the object with custom structure
        if (this.customStructure && this._currentValue && this._currentValue.hasOwnProperty(this.labelName)) {
            return this._currentValue[this.labelName];
        }
        else if (this._currentValue && this._currentValue.label) {
            if (this.columnDef.type === FieldType.object) {
                return _a = {},
                    _a[this.labelName] = this._currentValue.label,
                    _a[this.valueName] = this._currentValue.value,
                    _a;
            }
            return this._currentValue.label;
        }
        return this._currentValue;
    };
    AutoCompleteEditor.prototype.validate = function (inputValue) {
        var isRequired = this.columnEditor.required;
        var elmValue = (inputValue !== undefined) ? inputValue : this._$editorElm && this._$editorElm.val && this._$editorElm.val();
        var errorMsg = this.columnEditor.errorMessage;
        if (this.validator) {
            return this.validator(elmValue, this.args);
        }
        // by default the editor is almost always valid (except when it's required but not provided)
        if (isRequired && elmValue === '') {
            return {
                valid: false,
                msg: errorMsg || Constants.VALIDATION_REQUIRED_FIELD
            };
        }
        return {
            valid: true,
            msg: null
        };
    };
    //
    // private functions
    // ------------------
    // this function should be PRIVATE but for unit tests purposes we'll make it public until a better solution is found
    // a better solution would be to get the autocomplete DOM element to work with selection but I couldn't find how to do that in Jest
    AutoCompleteEditor.prototype.onSelect = function (event, ui) {
        if (ui && ui.item) {
            this._currentValue = ui && ui.item;
            var itemLabel = typeof ui.item === 'string' ? ui.item : ui.item.label;
            this.setValue(itemLabel);
            if (this.hasAutoCommitEdit) {
                // do not use args.commitChanges() as this sets the focus to the next row.
                var validation = this.validate();
                if (validation && validation.valid) {
                    this.grid.getEditorLock().commitCurrentEdit();
                }
            }
        }
        return false;
    };
    AutoCompleteEditor.prototype.renderDomElement = function (collection) {
        var _this = this;
        if (!Array.isArray(collection)) {
            throw new Error('The "collection" passed to the Autocomplete Editor is not a valid array.');
        }
        var columnId = this.columnDef && this.columnDef.id;
        var placeholder = this.columnEditor && this.columnEditor.placeholder || '';
        var title = this.columnEditor && this.columnEditor.title || '';
        this._$editorElm = $("<input type=\"text\" role=\"presentation\" autocomplete=\"off\" class=\"autocomplete editor-text editor-" + columnId + "\" placeholder=\"" + placeholder + "\" title=\"" + title + "\" />")
            .appendTo(this.args.container)
            .on('keydown.nav', function (event) {
            _this._lastInputEvent = event;
            if (event.keyCode === KeyCode.LEFT || event.keyCode === KeyCode.RIGHT) {
                event.stopImmediatePropagation();
            }
        });
        // user might pass his own autocomplete options
        var autoCompleteOptions = this.columnEditor.editorOptions;
        // assign the collection to a temp variable before filtering/sorting the collection
        var finalCollection = collection;
        // user might provide his own custom structure
        // jQuery UI autocomplete requires a label/value pair, so we must remap them when user provide different ones
        if (Array.isArray(finalCollection) && this.customStructure) {
            finalCollection = finalCollection.map(function (item) {
                return { label: item[_this.labelName], value: item[_this.valueName] };
            });
        }
        // keep the final source collection used in the AutoComplete as reference
        this._elementCollection = finalCollection;
        // when user passes it's own autocomplete options
        // we still need to provide our own "select" callback implementation
        if (autoCompleteOptions) {
            autoCompleteOptions.select = function (event, ui) { return _this.onSelect(event, ui); };
            this._autoCompleteOptions = tslib_1.__assign({}, autoCompleteOptions);
            this._$editorElm.autocomplete(autoCompleteOptions);
        }
        else {
            var definedOptions = {
                source: finalCollection,
                minLength: 0,
                select: function (event, ui) { return _this.onSelect(event, ui); },
            };
            this._autoCompleteOptions = tslib_1.__assign({}, definedOptions, this.columnEditor.editorOptions);
            this._$editorElm.autocomplete(this._autoCompleteOptions);
        }
        setTimeout(function () { return _this.focus(); }, 50);
    };
    return AutoCompleteEditor;
}());
export { AutoCompleteEditor };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0b0NvbXBsZXRlRWRpdG9yLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1zbGlja2dyaWQvIiwic291cmNlcyI6WyJhcHAvbW9kdWxlcy9hbmd1bGFyLXNsaWNrZ3JpZC9lZGl0b3JzL2F1dG9Db21wbGV0ZUVkaXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQVNMLFNBQVMsRUFDVCxPQUFPLEdBQ1IsTUFBTSxtQkFBbUIsQ0FBQztBQUMzQixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDM0MsT0FBTyxFQUFFLGFBQWEsRUFBRSxxQkFBcUIsRUFBRSxZQUFZLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUszRixvRUFBb0U7QUFDcEUsSUFBTSxVQUFVLEdBQUcsQ0FBQyxDQUFDO0FBRXJCOzs7R0FHRztBQUNIO0lBcUJFLDRCQUFvQixJQUFxQjtRQUFyQixTQUFJLEdBQUosSUFBSSxDQUFpQjtRQUN2QyxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ1QsTUFBTSxJQUFJLEtBQUssQ0FBQyxvR0FBb0csQ0FBQyxDQUFDO1NBQ3ZIO1FBQ0QsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO1FBQ3RCLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUNkLENBQUM7SUFHRCxzQkFBSSxtREFBbUI7UUFEdkIseUNBQXlDO2FBQ3pDO1lBQ0UsT0FBTyxJQUFJLENBQUMsb0JBQW9CLElBQUksRUFBRSxDQUFDO1FBQ3pDLENBQUM7OztPQUFBO0lBR0Qsc0JBQUksZ0RBQWdCO1FBRHBCLHlCQUF5QjthQUN6QjtZQUNFLE9BQU8sSUFBSSxDQUFDLFNBQVMsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLG9CQUFvQixJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsb0JBQW9CLENBQUMsVUFBVSxJQUFJLEVBQUUsQ0FBQztRQUN2SCxDQUFDOzs7T0FBQTtJQUdELHNCQUFJLGlEQUFpQjtRQURyQixr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QUFVLENBQUMsY0FBTSxPQUFBLEtBQUksQ0FBQyxLQUFLLEVBQUUsRUFBWixDQUFZLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUNILHlCQUFDO0FBQUQsQ0FBQyxBQTlSRCxJQThSQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgQXV0b2NvbXBsZXRlT3B0aW9uLFxyXG4gIENvbGxlY3Rpb25DdXN0b21TdHJ1Y3R1cmUsXHJcbiAgQ29sdW1uLFxyXG4gIENvbHVtbkVkaXRvcixcclxuICBFZGl0b3IsXHJcbiAgRWRpdG9yQXJndW1lbnRzLFxyXG4gIEVkaXRvclZhbGlkYXRvcixcclxuICBFZGl0b3JWYWxpZGF0b3JPdXRwdXQsXHJcbiAgRmllbGRUeXBlLFxyXG4gIEtleUNvZGUsXHJcbn0gZnJvbSAnLi8uLi9tb2RlbHMvaW5kZXgnO1xyXG5pbXBvcnQgeyBDb25zdGFudHMgfSBmcm9tICcuLy4uL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7IGZpbmRPckRlZmF1bHQsIGdldERlc2NlbmRhbnRQcm9wZXJ0eSwgc2V0RGVlcFZhbHVlIH0gZnJvbSAnLi4vc2VydmljZXMvdXRpbGl0aWVzJztcclxuXHJcbi8vIHVzaW5nIGV4dGVybmFsIG5vbi10eXBlZCBqcyBsaWJyYXJpZXNcclxuZGVjbGFyZSB2YXIgJDogYW55O1xyXG5cclxuLy8gbWluaW11bSBsZW5ndGggb2YgY2hhcnMgdG8gdHlwZSBiZWZvcmUgc3RhcnRpbmcgdG8gc3RhcnQgcXVlcnlpbmdcclxuY29uc3QgTUlOX0xFTkdUSCA9IDM7XHJcblxyXG4vKlxyXG4gKiBBbiBleGFtcGxlIG9mIGEgJ2RldGFjaGVkJyBlZGl0b3IuXHJcbiAqIEtleURvd24gZXZlbnRzIGFyZSBhbHNvIGhhbmRsZWQgdG8gcHJvdmlkZSBoYW5kbGluZyBmb3IgVGFiLCBTaGlmdC1UYWIsIEVzYyBhbmQgQ3RybC1FbnRlci5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBBdXRvQ29tcGxldGVFZGl0b3IgaW1wbGVtZW50cyBFZGl0b3Ige1xyXG4gIHByaXZhdGUgX2F1dG9Db21wbGV0ZU9wdGlvbnM6IEF1dG9jb21wbGV0ZU9wdGlvbjtcclxuICBwcml2YXRlIF9jdXJyZW50VmFsdWU6IGFueTtcclxuICBwcml2YXRlIF9kZWZhdWx0VGV4dFZhbHVlOiBzdHJpbmc7XHJcbiAgcHJpdmF0ZSBfZWxlbWVudENvbGxlY3Rpb246IGFueVtdO1xyXG4gIHByaXZhdGUgX2xhc3RJbnB1dEV2ZW50OiBLZXlib2FyZEV2ZW50O1xyXG5cclxuICAvKiogVGhlIEpRdWVyeSBET00gZWxlbWVudCAqL1xyXG4gIHByaXZhdGUgXyRlZGl0b3JFbG06IGFueTtcclxuXHJcbiAgLyoqIFNsaWNrR3JpZCBHcmlkIG9iamVjdCAqL1xyXG4gIGdyaWQ6IGFueTtcclxuXHJcbiAgLyoqIFRoZSBwcm9wZXJ0eSBuYW1lIGZvciBsYWJlbHMgaW4gdGhlIGNvbGxlY3Rpb24gKi9cclxuICBsYWJlbE5hbWU6IHN0cmluZztcclxuXHJcbiAgLyoqIFRoZSBwcm9wZXJ0eSBuYW1lIGZvciB2YWx1ZXMgaW4gdGhlIGNvbGxlY3Rpb24gKi9cclxuICB2YWx1ZU5hbWU6IHN0cmluZztcclxuXHJcbiAgZm9yY2VVc2VySW5wdXQ6IGJvb2xlYW47XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgYXJnczogRWRpdG9yQXJndW1lbnRzKSB7XHJcbiAgICBpZiAoIWFyZ3MpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbQW5ndWxhci1TbGlja0dyaWRdIFNvbWV0aGluZyBpcyB3cm9uZyB3aXRoIHRoaXMgZ3JpZCwgYW4gRWRpdG9yIG11c3QgYWx3YXlzIGhhdmUgdmFsaWQgYXJndW1lbnRzLicpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5ncmlkID0gYXJncy5ncmlkO1xyXG4gICAgdGhpcy5pbml0KCk7XHJcbiAgfVxyXG5cclxuICAvKiogR2V0dGVyIGZvciB0aGUgQXV0b2NvbXBsZXRlIE9wdGlvbiAqL1xyXG4gIGdldCBhdXRvQ29tcGxldGVPcHRpb25zKCk6IFBhcnRpYWw8QXV0b2NvbXBsZXRlT3B0aW9uPiB7XHJcbiAgICByZXR1cm4gdGhpcy5fYXV0b0NvbXBsZXRlT3B0aW9ucyB8fCB7fTtcclxuICB9XHJcblxyXG4gIC8qKiBHZXQgdGhlIENvbGxlY3Rpb24gKi9cclxuICBnZXQgZWRpdG9yQ29sbGVjdGlvbigpOiBhbnlbXSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb2x1bW5EZWYgJiYgdGhpcy5jb2x1bW5EZWYuaW50ZXJuYWxDb2x1bW5FZGl0b3IgJiYgdGhpcy5jb2x1bW5EZWYuaW50ZXJuYWxDb2x1bW5FZGl0b3IuY29sbGVjdGlvbiB8fCBbXTtcclxuICB9XHJcblxyXG4gIC8qKiBHZXQgdGhlIEZpbmFsIENvbGxlY3Rpb24gdXNlZCBpbiB0aGUgQXV0b0NvbXBsZXRlZCBTb3VyY2UgKHRoaXMgbWF5IHZhcnkgZnJvbSB0aGUgXCJjb2xsZWN0aW9uXCIgZXNwZWNpYWxseSB3aGVuIHByb3ZpZGluZyBhIGN1c3RvbVN0cnVjdHVyZSkgKi9cclxuICBnZXQgZWxlbWVudENvbGxlY3Rpb24oKTogYW55W10ge1xyXG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRDb2xsZWN0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldCBDb2x1bW4gRGVmaW5pdGlvbiBvYmplY3QgKi9cclxuICBnZXQgY29sdW1uRGVmKCk6IENvbHVtbiB8IHVuZGVmaW5lZCB7XHJcbiAgICByZXR1cm4gdGhpcy5hcmdzICYmIHRoaXMuYXJncy5jb2x1bW47XHJcbiAgfVxyXG5cclxuICAvKiogR2V0IENvbHVtbiBFZGl0b3Igb2JqZWN0ICovXHJcbiAgZ2V0IGNvbHVtbkVkaXRvcigpOiBDb2x1bW5FZGl0b3Ige1xyXG4gICAgcmV0dXJuIHRoaXMuY29sdW1uRGVmICYmIHRoaXMuY29sdW1uRGVmLmludGVybmFsQ29sdW1uRWRpdG9yIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBmb3IgdGhlIEN1c3RvbSBTdHJ1Y3R1cmUgaWYgZXhpc3QgKi9cclxuICBnZXQgY3VzdG9tU3RydWN0dXJlKCk6IENvbGxlY3Rpb25DdXN0b21TdHJ1Y3R1cmUge1xyXG4gICAgcmV0dXJuIHRoaXMuY29sdW1uRGVmICYmIHRoaXMuY29sdW1uRGVmLmludGVybmFsQ29sdW1uRWRpdG9yICYmIHRoaXMuY29sdW1uRGVmLmludGVybmFsQ29sdW1uRWRpdG9yLmN1c3RvbVN0cnVjdHVyZTtcclxuICB9XHJcblxyXG4gIGdldCBoYXNBdXRvQ29tbWl0RWRpdCgpIHtcclxuICAgIHJldHVybiB0aGlzLmdyaWQuZ2V0T3B0aW9ucygpLmF1dG9Db21taXRFZGl0O1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldCB0aGUgVmFsaWRhdG9yIGZ1bmN0aW9uLCBjYW4gYmUgcGFzc2VkIGluIEVkaXRvciBwcm9wZXJ0eSBvciBDb2x1bW4gRGVmaW5pdGlvbiAqL1xyXG4gIGdldCB2YWxpZGF0b3IoKTogRWRpdG9yVmFsaWRhdG9yIHtcclxuICAgIHJldHVybiB0aGlzLmNvbHVtbkVkaXRvci52YWxpZGF0b3IgfHwgdGhpcy5jb2x1bW5EZWYudmFsaWRhdG9yO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGVkaXRvck9wdGlvbnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb2x1bW5FZGl0b3IgJiYgdGhpcy5jb2x1bW5FZGl0b3IuZWRpdG9yT3B0aW9ucyB8fCB7fTtcclxuICB9XHJcblxyXG4gIC8qKiBHZXQgdGhlIEVkaXRvciBET00gRWxlbWVudCAqL1xyXG4gIGdldCBlZGl0b3JEb21FbGVtZW50KCk6IGFueSB7XHJcbiAgICByZXR1cm4gdGhpcy5fJGVkaXRvckVsbTtcclxuICB9XHJcblxyXG4gIGluaXQoKSB7XHJcbiAgICB0aGlzLmxhYmVsTmFtZSA9IHRoaXMuY3VzdG9tU3RydWN0dXJlICYmIHRoaXMuY3VzdG9tU3RydWN0dXJlLmxhYmVsIHx8ICdsYWJlbCc7XHJcbiAgICB0aGlzLnZhbHVlTmFtZSA9IHRoaXMuY3VzdG9tU3RydWN0dXJlICYmIHRoaXMuY3VzdG9tU3RydWN0dXJlLnZhbHVlIHx8ICd2YWx1ZSc7XHJcblxyXG4gICAgLy8gYWx3YXlzIHJlbmRlciB0aGUgRE9NIGVsZW1lbnQsIGV2ZW4gaWYgdXNlciBwYXNzZWQgYSBcImNvbGxlY3Rpb25Bc3luY1wiLFxyXG4gICAgY29uc3QgbmV3Q29sbGVjdGlvbiA9IHRoaXMuY29sdW1uRWRpdG9yLmNvbGxlY3Rpb24gfHwgW107XHJcbiAgICB0aGlzLnJlbmRlckRvbUVsZW1lbnQobmV3Q29sbGVjdGlvbik7XHJcbiAgfVxyXG5cclxuICBkZXN0cm95KCkge1xyXG4gICAgdGhpcy5fJGVkaXRvckVsbS5vZmYoJ2tleWRvd24ubmF2JykucmVtb3ZlKCk7XHJcbiAgfVxyXG5cclxuICBmb2N1cygpIHtcclxuICAgIHRoaXMuXyRlZGl0b3JFbG0uZm9jdXMoKS5zZWxlY3QoKTtcclxuICB9XHJcblxyXG4gIGdldFZhbHVlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuXyRlZGl0b3JFbG0udmFsKCk7XHJcbiAgfVxyXG5cclxuICBzZXRWYWx1ZSh2YWx1ZTogc3RyaW5nKSB7XHJcbiAgICB0aGlzLl8kZWRpdG9yRWxtLnZhbCh2YWx1ZSk7XHJcbiAgfVxyXG5cclxuICBhcHBseVZhbHVlKGl0ZW06IGFueSwgc3RhdGU6IGFueSkge1xyXG4gICAgbGV0IG5ld1ZhbHVlID0gc3RhdGU7XHJcbiAgICBjb25zdCBmaWVsZE5hbWUgPSB0aGlzLmNvbHVtbkRlZiAmJiB0aGlzLmNvbHVtbkRlZi5maWVsZDtcclxuXHJcbiAgICAvLyBpZiB3ZSBoYXZlIGEgY29sbGVjdGlvbiBkZWZpbmVkLCB3ZSB3aWxsIHRyeSB0byBmaW5kIHRoZSBzdHJpbmcgd2l0aGluIHRoZSBjb2xsZWN0aW9uIGFuZCByZXR1cm4gaXRcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZWRpdG9yQ29sbGVjdGlvbikgJiYgdGhpcy5lZGl0b3JDb2xsZWN0aW9uLmxlbmd0aCA+IDApIHtcclxuICAgICAgbmV3VmFsdWUgPSBmaW5kT3JEZWZhdWx0KHRoaXMuZWRpdG9yQ29sbGVjdGlvbiwgKGNvbGxlY3Rpb25JdGVtOiBhbnkpID0+IHtcclxuICAgICAgICBpZiAoY29sbGVjdGlvbkl0ZW0gJiYgdHlwZW9mIHN0YXRlID09PSAnb2JqZWN0JyAmJiBjb2xsZWN0aW9uSXRlbS5oYXNPd25Qcm9wZXJ0eSh0aGlzLmxhYmVsTmFtZSkpIHtcclxuICAgICAgICAgIHJldHVybiAoY29sbGVjdGlvbkl0ZW0uaGFzT3duUHJvcGVydHkodGhpcy5sYWJlbE5hbWUpICYmIGNvbGxlY3Rpb25JdGVtW3RoaXMubGFiZWxOYW1lXS50b1N0cmluZygpKSA9PT0gKHN0YXRlLmhhc093blByb3BlcnR5KHRoaXMubGFiZWxOYW1lKSAmJiBzdGF0ZVt0aGlzLmxhYmVsTmFtZV0udG9TdHJpbmcoKSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjb2xsZWN0aW9uSXRlbSAmJiB0eXBlb2Ygc3RhdGUgPT09ICdzdHJpbmcnICYmIGNvbGxlY3Rpb25JdGVtLmhhc093blByb3BlcnR5KHRoaXMubGFiZWxOYW1lKSkge1xyXG4gICAgICAgICAgcmV0dXJuIChjb2xsZWN0aW9uSXRlbS5oYXNPd25Qcm9wZXJ0eSh0aGlzLmxhYmVsTmFtZSkgJiYgY29sbGVjdGlvbkl0ZW1bdGhpcy5sYWJlbE5hbWVdLnRvU3RyaW5nKCkpID09PSBzdGF0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25JdGVtICYmIGNvbGxlY3Rpb25JdGVtLnRvU3RyaW5nKCkgPT09IHN0YXRlO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpcyB0aGUgZmllbGQgYSBjb21wbGV4IG9iamVjdCwgXCJhZGRyZXNzLnN0cmVldE51bWJlclwiXHJcbiAgICBjb25zdCBpc0NvbXBsZXhPYmplY3QgPSBmaWVsZE5hbWUuaW5kZXhPZignLicpID4gMDtcclxuXHJcbiAgICAvLyB2YWxpZGF0ZSB0aGUgdmFsdWUgYmVmb3JlIGFwcGx5aW5nIGl0IChpZiBub3QgdmFsaWQgd2UnbGwgc2V0IGFuIGVtcHR5IHN0cmluZylcclxuICAgIGNvbnN0IHZhbGlkYXRpb24gPSB0aGlzLnZhbGlkYXRlKG5ld1ZhbHVlKTtcclxuICAgIG5ld1ZhbHVlID0gKHZhbGlkYXRpb24gJiYgdmFsaWRhdGlvbi52YWxpZCkgPyBuZXdWYWx1ZSA6ICcnO1xyXG5cclxuICAgIC8vIHNldCB0aGUgbmV3IHZhbHVlIHRvIHRoZSBpdGVtIGRhdGFjb250ZXh0XHJcbiAgICBpZiAoaXNDb21wbGV4T2JqZWN0KSB7XHJcbiAgICAgIHNldERlZXBWYWx1ZShpdGVtLCBmaWVsZE5hbWUsIG5ld1ZhbHVlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGl0ZW1bZmllbGROYW1lXSA9IG5ld1ZhbHVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaXNWYWx1ZUNoYW5nZWQoKTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCBsYXN0RXZlbnQgPSB0aGlzLl9sYXN0SW5wdXRFdmVudCAmJiB0aGlzLl9sYXN0SW5wdXRFdmVudC5rZXlDb2RlO1xyXG4gICAgaWYgKHRoaXMuY29sdW1uRWRpdG9yICYmIHRoaXMuY29sdW1uRWRpdG9yLmFsd2F5c1NhdmVPbkVudGVyS2V5ICYmIGxhc3RFdmVudCA9PT0gS2V5Q29kZS5FTlRFUikge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiAoISh0aGlzLl8kZWRpdG9yRWxtLnZhbCgpID09PSAnJyAmJiB0aGlzLl9kZWZhdWx0VGV4dFZhbHVlID09PSBudWxsKSkgJiYgKHRoaXMuXyRlZGl0b3JFbG0udmFsKCkgIT09IHRoaXMuX2RlZmF1bHRUZXh0VmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgbG9hZFZhbHVlKGl0ZW06IGFueSkge1xyXG4gICAgY29uc3QgZmllbGROYW1lID0gdGhpcy5jb2x1bW5EZWYgJiYgdGhpcy5jb2x1bW5EZWYuZmllbGQ7XHJcblxyXG4gICAgLy8gaXMgdGhlIGZpZWxkIGEgY29tcGxleCBvYmplY3QsIFwiYWRkcmVzcy5zdHJlZXROdW1iZXJcIlxyXG4gICAgY29uc3QgaXNDb21wbGV4T2JqZWN0ID0gZmllbGROYW1lLmluZGV4T2YoJy4nKSA+IDA7XHJcblxyXG4gICAgaWYgKGl0ZW0gJiYgdGhpcy5jb2x1bW5EZWYgJiYgKGl0ZW0uaGFzT3duUHJvcGVydHkoZmllbGROYW1lKSB8fCBpc0NvbXBsZXhPYmplY3QpKSB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSAoaXNDb21wbGV4T2JqZWN0KSA/IGdldERlc2NlbmRhbnRQcm9wZXJ0eShpdGVtLCBmaWVsZE5hbWUpIDogaXRlbVtmaWVsZE5hbWVdO1xyXG4gICAgICB0aGlzLl9jdXJyZW50VmFsdWUgPSBkYXRhO1xyXG4gICAgICB0aGlzLl9kZWZhdWx0VGV4dFZhbHVlID0gdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID8gZGF0YSA6IGRhdGFbdGhpcy5sYWJlbE5hbWVdO1xyXG4gICAgICB0aGlzLl8kZWRpdG9yRWxtLnZhbCh0aGlzLl9kZWZhdWx0VGV4dFZhbHVlKTtcclxuICAgICAgdGhpcy5fJGVkaXRvckVsbS5zZWxlY3QoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNhdmUoKSB7XHJcbiAgICBjb25zdCB2YWxpZGF0aW9uID0gdGhpcy52YWxpZGF0ZSgpO1xyXG4gICAgaWYgKHZhbGlkYXRpb24gJiYgdmFsaWRhdGlvbi52YWxpZCAmJiB0aGlzLmlzVmFsdWVDaGFuZ2VkKCkpIHtcclxuICAgICAgaWYgKHRoaXMuaGFzQXV0b0NvbW1pdEVkaXQpIHtcclxuICAgICAgICB0aGlzLmdyaWQuZ2V0RWRpdG9yTG9jaygpLmNvbW1pdEN1cnJlbnRFZGl0KCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5hcmdzLmNvbW1pdENoYW5nZXMoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc2VyaWFsaXplVmFsdWUoKTogYW55IHtcclxuICAgIC8vIGlmIHlvdSB3YW50IHRvIGFkZCB0aGUgYXV0b2NvbXBsZXRlIGZ1bmN0aW9uYWxpdHkgYnV0IHdhbnQgdGhlIHVzZXIgdG8gYmUgYWJsZSB0byBpbnB1dCBhIG5ldyBvcHRpb25cclxuICAgIGlmICh0aGlzLmVkaXRvck9wdGlvbnMuZm9yY2VVc2VySW5wdXQpIHtcclxuICAgICAgY29uc3QgbWluTGVuZ3RoID0gdGhpcy5lZGl0b3JPcHRpb25zICYmIHRoaXMuZWRpdG9yT3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnbWluTGVuZ3RoJykgPyB0aGlzLmVkaXRvck9wdGlvbnMubWluTGVuZ3RoIDogTUlOX0xFTkdUSDtcclxuICAgICAgdGhpcy5fY3VycmVudFZhbHVlID0gdGhpcy5fJGVkaXRvckVsbS52YWwoKS5sZW5ndGggPiBtaW5MZW5ndGggPyB0aGlzLl8kZWRpdG9yRWxtLnZhbCgpIDogdGhpcy5fY3VycmVudFZhbHVlO1xyXG4gICAgfVxyXG4gICAgLy8gaWYgdXNlciBwcm92aWRlZCBhIGN1c3RvbSBzdHJ1Y3R1cmUsIHdlIHdpbGwgc2VyaWFsaXplIHRoZSB2YWx1ZSByZXR1cm5lZCBmcm9tIHRoZSBvYmplY3Qgd2l0aCBjdXN0b20gc3RydWN0dXJlXHJcbiAgICBpZiAodGhpcy5jdXN0b21TdHJ1Y3R1cmUgJiYgdGhpcy5fY3VycmVudFZhbHVlICYmIHRoaXMuX2N1cnJlbnRWYWx1ZS5oYXNPd25Qcm9wZXJ0eSh0aGlzLmxhYmVsTmFtZSkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRWYWx1ZVt0aGlzLmxhYmVsTmFtZV07XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2N1cnJlbnRWYWx1ZSAmJiB0aGlzLl9jdXJyZW50VmFsdWUubGFiZWwpIHtcclxuICAgICAgaWYgKHRoaXMuY29sdW1uRGVmLnR5cGUgPT09IEZpZWxkVHlwZS5vYmplY3QpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgW3RoaXMubGFiZWxOYW1lXTogdGhpcy5fY3VycmVudFZhbHVlLmxhYmVsLFxyXG4gICAgICAgICAgW3RoaXMudmFsdWVOYW1lXTogdGhpcy5fY3VycmVudFZhbHVlLnZhbHVlXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5fY3VycmVudFZhbHVlLmxhYmVsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRWYWx1ZTtcclxuICB9XHJcblxyXG4gIHZhbGlkYXRlKGlucHV0VmFsdWU/OiBhbnkpOiBFZGl0b3JWYWxpZGF0b3JPdXRwdXQge1xyXG4gICAgY29uc3QgaXNSZXF1aXJlZCA9IHRoaXMuY29sdW1uRWRpdG9yLnJlcXVpcmVkO1xyXG4gICAgY29uc3QgZWxtVmFsdWUgPSAoaW5wdXRWYWx1ZSAhPT0gdW5kZWZpbmVkKSA/IGlucHV0VmFsdWUgOiB0aGlzLl8kZWRpdG9yRWxtICYmIHRoaXMuXyRlZGl0b3JFbG0udmFsICYmIHRoaXMuXyRlZGl0b3JFbG0udmFsKCk7XHJcbiAgICBjb25zdCBlcnJvck1zZyA9IHRoaXMuY29sdW1uRWRpdG9yLmVycm9yTWVzc2FnZTtcclxuXHJcbiAgICBpZiAodGhpcy52YWxpZGF0b3IpIHtcclxuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdG9yKGVsbVZhbHVlLCB0aGlzLmFyZ3MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGJ5IGRlZmF1bHQgdGhlIGVkaXRvciBpcyBhbG1vc3QgYWx3YXlzIHZhbGlkIChleGNlcHQgd2hlbiBpdCdzIHJlcXVpcmVkIGJ1dCBub3QgcHJvdmlkZWQpXHJcbiAgICBpZiAoaXNSZXF1aXJlZCAmJiBlbG1WYWx1ZSA9PT0gJycpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB2YWxpZDogZmFsc2UsXHJcbiAgICAgICAgbXNnOiBlcnJvck1zZyB8fCBDb25zdGFudHMuVkFMSURBVElPTl9SRVFVSVJFRF9GSUVMRFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHZhbGlkOiB0cnVlLFxyXG4gICAgICBtc2c6IG51bGxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvL1xyXG4gIC8vIHByaXZhdGUgZnVuY3Rpb25zXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIFBSSVZBVEUgYnV0IGZvciB1bml0IHRlc3RzIHB1cnBvc2VzIHdlJ2xsIG1ha2UgaXQgcHVibGljIHVudGlsIGEgYmV0dGVyIHNvbHV0aW9uIGlzIGZvdW5kXHJcbiAgLy8gYSBiZXR0ZXIgc29sdXRpb24gd291bGQgYmUgdG8gZ2V0IHRoZSBhdXRvY29tcGxldGUgRE9NIGVsZW1lbnQgdG8gd29yayB3aXRoIHNlbGVjdGlvbiBidXQgSSBjb3VsZG4ndCBmaW5kIGhvdyB0byBkbyB0aGF0IGluIEplc3RcclxuICBvblNlbGVjdChldmVudDogRXZlbnQsIHVpOiBhbnkpOiBib29sZWFuIHtcclxuICAgIGlmICh1aSAmJiB1aS5pdGVtKSB7XHJcbiAgICAgIHRoaXMuX2N1cnJlbnRWYWx1ZSA9IHVpICYmIHVpLml0ZW07XHJcbiAgICAgIGNvbnN0IGl0ZW1MYWJlbCA9IHR5cGVvZiB1aS5pdGVtID09PSAnc3RyaW5nJyA/IHVpLml0ZW0gOiB1aS5pdGVtLmxhYmVsO1xyXG4gICAgICB0aGlzLnNldFZhbHVlKGl0ZW1MYWJlbCk7XHJcblxyXG4gICAgICBpZiAodGhpcy5oYXNBdXRvQ29tbWl0RWRpdCkge1xyXG4gICAgICAgIC8vIGRvIG5vdCB1c2UgYXJncy5jb21taXRDaGFuZ2VzKCkgYXMgdGhpcyBzZXRzIHRoZSBmb2N1cyB0byB0aGUgbmV4dCByb3cuXHJcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHRoaXMudmFsaWRhdGUoKTtcclxuICAgICAgICBpZiAodmFsaWRhdGlvbiAmJiB2YWxpZGF0aW9uLnZhbGlkKSB7XHJcbiAgICAgICAgICB0aGlzLmdyaWQuZ2V0RWRpdG9yTG9jaygpLmNvbW1pdEN1cnJlbnRFZGl0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHJlbmRlckRvbUVsZW1lbnQoY29sbGVjdGlvbjogYW55W10pIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShjb2xsZWN0aW9uKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBcImNvbGxlY3Rpb25cIiBwYXNzZWQgdG8gdGhlIEF1dG9jb21wbGV0ZSBFZGl0b3IgaXMgbm90IGEgdmFsaWQgYXJyYXkuJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb2x1bW5JZCA9IHRoaXMuY29sdW1uRGVmICYmIHRoaXMuY29sdW1uRGVmLmlkO1xyXG4gICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLmNvbHVtbkVkaXRvciAmJiB0aGlzLmNvbHVtbkVkaXRvci5wbGFjZWhvbGRlciB8fCAnJztcclxuICAgIGNvbnN0IHRpdGxlID0gdGhpcy5jb2x1bW5FZGl0b3IgJiYgdGhpcy5jb2x1bW5FZGl0b3IudGl0bGUgfHwgJyc7XHJcblxyXG4gICAgdGhpcy5fJGVkaXRvckVsbSA9ICQoYDxpbnB1dCB0eXBlPVwidGV4dFwiIHJvbGU9XCJwcmVzZW50YXRpb25cIiBhdXRvY29tcGxldGU9XCJvZmZcIiBjbGFzcz1cImF1dG9jb21wbGV0ZSBlZGl0b3ItdGV4dCBlZGl0b3ItJHtjb2x1bW5JZH1cIiBwbGFjZWhvbGRlcj1cIiR7cGxhY2Vob2xkZXJ9XCIgdGl0bGU9XCIke3RpdGxlfVwiIC8+YClcclxuICAgICAgLmFwcGVuZFRvKHRoaXMuYXJncy5jb250YWluZXIpXHJcbiAgICAgIC5vbigna2V5ZG93bi5uYXYnLCAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLl9sYXN0SW5wdXRFdmVudCA9IGV2ZW50O1xyXG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBLZXlDb2RlLkxFRlQgfHwgZXZlbnQua2V5Q29kZSA9PT0gS2V5Q29kZS5SSUdIVCkge1xyXG4gICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyB1c2VyIG1pZ2h0IHBhc3MgaGlzIG93biBhdXRvY29tcGxldGUgb3B0aW9uc1xyXG4gICAgY29uc3QgYXV0b0NvbXBsZXRlT3B0aW9uczogQXV0b2NvbXBsZXRlT3B0aW9uID0gdGhpcy5jb2x1bW5FZGl0b3IuZWRpdG9yT3B0aW9ucztcclxuXHJcbiAgICAvLyBhc3NpZ24gdGhlIGNvbGxlY3Rpb24gdG8gYSB0ZW1wIHZhcmlhYmxlIGJlZm9yZSBmaWx0ZXJpbmcvc29ydGluZyB0aGUgY29sbGVjdGlvblxyXG4gICAgbGV0IGZpbmFsQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XHJcblxyXG4gICAgLy8gdXNlciBtaWdodCBwcm92aWRlIGhpcyBvd24gY3VzdG9tIHN0cnVjdHVyZVxyXG4gICAgLy8galF1ZXJ5IFVJIGF1dG9jb21wbGV0ZSByZXF1aXJlcyBhIGxhYmVsL3ZhbHVlIHBhaXIsIHNvIHdlIG11c3QgcmVtYXAgdGhlbSB3aGVuIHVzZXIgcHJvdmlkZSBkaWZmZXJlbnQgb25lc1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmluYWxDb2xsZWN0aW9uKSAmJiB0aGlzLmN1c3RvbVN0cnVjdHVyZSkge1xyXG4gICAgICBmaW5hbENvbGxlY3Rpb24gPSBmaW5hbENvbGxlY3Rpb24ubWFwKChpdGVtKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHsgbGFiZWw6IGl0ZW1bdGhpcy5sYWJlbE5hbWVdLCB2YWx1ZTogaXRlbVt0aGlzLnZhbHVlTmFtZV0gfTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8ga2VlcCB0aGUgZmluYWwgc291cmNlIGNvbGxlY3Rpb24gdXNlZCBpbiB0aGUgQXV0b0NvbXBsZXRlIGFzIHJlZmVyZW5jZVxyXG4gICAgdGhpcy5fZWxlbWVudENvbGxlY3Rpb24gPSBmaW5hbENvbGxlY3Rpb247XHJcblxyXG4gICAgLy8gd2hlbiB1c2VyIHBhc3NlcyBpdCdzIG93biBhdXRvY29tcGxldGUgb3B0aW9uc1xyXG4gICAgLy8gd2Ugc3RpbGwgbmVlZCB0byBwcm92aWRlIG91ciBvd24gXCJzZWxlY3RcIiBjYWxsYmFjayBpbXBsZW1lbnRhdGlvblxyXG4gICAgaWYgKGF1dG9Db21wbGV0ZU9wdGlvbnMpIHtcclxuICAgICAgYXV0b0NvbXBsZXRlT3B0aW9ucy5zZWxlY3QgPSAoZXZlbnQ6IEV2ZW50LCB1aTogYW55KSA9PiB0aGlzLm9uU2VsZWN0KGV2ZW50LCB1aSk7XHJcbiAgICAgIHRoaXMuX2F1dG9Db21wbGV0ZU9wdGlvbnMgPSB7IC4uLmF1dG9Db21wbGV0ZU9wdGlvbnMgfTtcclxuICAgICAgdGhpcy5fJGVkaXRvckVsbS5hdXRvY29tcGxldGUoYXV0b0NvbXBsZXRlT3B0aW9ucyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBkZWZpbmVkT3B0aW9uczogQXV0b2NvbXBsZXRlT3B0aW9uID0ge1xyXG4gICAgICAgIHNvdXJjZTogZmluYWxDb2xsZWN0aW9uLFxyXG4gICAgICAgIG1pbkxlbmd0aDogMCxcclxuICAgICAgICBzZWxlY3Q6IChldmVudDogRXZlbnQsIHVpOiBhbnkpID0+IHRoaXMub25TZWxlY3QoZXZlbnQsIHVpKSxcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5fYXV0b0NvbXBsZXRlT3B0aW9ucyA9IHsgLi4uZGVmaW5lZE9wdGlvbnMsIC4uLih0aGlzLmNvbHVtbkVkaXRvci5lZGl0b3JPcHRpb25zIGFzIEF1dG9jb21wbGV0ZU9wdGlvbikgfTtcclxuICAgICAgdGhpcy5fJGVkaXRvckVsbS5hdXRvY29tcGxldGUodGhpcy5fYXV0b0NvbXBsZXRlT3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmZvY3VzKCksIDUwKTtcclxuICB9XHJcbn1cclxuIl19