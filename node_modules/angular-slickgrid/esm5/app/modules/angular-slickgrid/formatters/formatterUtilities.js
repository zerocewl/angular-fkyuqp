import { mapMomentDateFormatWithFieldType } from '../services/utilities';
import * as moment_ from 'moment-mini';
var moment = moment_; // patch to fix rollup "moment has no default export" issue, document here https://github.com/rollup/rollup/issues/670
/**
 * Find the option value from the following (in order of execution)
 * 1- Column Definition "params"
 * 2- Grid Options "formatterOptions"
 * 3- nothing found, return default value provided
 */
export function getValueFromParamsOrFormatterOptions(optionName, columnDef, grid, defaultValue) {
    var gridOptions = ((grid && typeof grid.getOptions === 'function') ? grid.getOptions() : {});
    var params = columnDef && columnDef.params;
    if (params && params.hasOwnProperty(optionName)) {
        return params[optionName];
    }
    else if (gridOptions.formatterOptions && gridOptions.formatterOptions.hasOwnProperty(optionName)) {
        return gridOptions.formatterOptions[optionName];
    }
    return defaultValue;
}
/** From a FieldType, return the associated date Formatter */
export function getAssociatedDateFormatter(fieldType, defaultSeparator) {
    var defaultDateFormat = mapMomentDateFormatWithFieldType(fieldType);
    return function (row, cell, value, columnDef, dataContext, grid) {
        var gridOptions = ((grid && typeof grid.getOptions === 'function') ? grid.getOptions() : {});
        var customSeparator = gridOptions && gridOptions.formatterOptions && gridOptions.formatterOptions.dateSeparator || defaultSeparator;
        var isDateValid = moment(value, defaultDateFormat, false).isValid();
        var outputDate = (value && isDateValid) ? moment(value).format(defaultDateFormat) : value;
        // user can customize the separator through the "formatterOptions"
        // if that is the case we need to replace the default "/" to the new separator
        if (outputDate && customSeparator !== defaultSeparator) {
            var regex = new RegExp(defaultSeparator, 'ig'); // find separator globally
            outputDate = outputDate.replace(regex, customSeparator);
        }
        return outputDate;
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9ybWF0dGVyVXRpbGl0aWVzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1zbGlja2dyaWQvIiwic291cmNlcyI6WyJhcHAvbW9kdWxlcy9hbmd1bGFyLXNsaWNrZ3JpZC9mb3JtYXR0ZXJzL2Zvcm1hdHRlclV0aWxpdGllcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsZ0NBQWdDLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUN6RSxPQUFPLEtBQUssT0FBTyxNQUFNLGFBQWEsQ0FBQztBQUN2QyxJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsQ0FBQyxzSEFBc0g7QUFFOUk7Ozs7O0dBS0c7QUFDSCxNQUFNLFVBQVUsb0NBQW9DLENBQUMsVUFBa0IsRUFBRSxTQUFpQixFQUFFLElBQVMsRUFBRSxZQUFrQjtJQUN2SCxJQUFNLFdBQVcsR0FBRyxDQUFDLENBQUMsSUFBSSxJQUFJLE9BQU8sSUFBSSxDQUFDLFVBQVUsS0FBSyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQWUsQ0FBQztJQUM3RyxJQUFNLE1BQU0sR0FBRyxTQUFTLElBQUksU0FBUyxDQUFDLE1BQU0sQ0FBQztJQUU3QyxJQUFJLE1BQU0sSUFBSSxNQUFNLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxFQUFFO1FBQy9DLE9BQU8sTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0tBQzNCO1NBQU0sSUFBSSxXQUFXLENBQUMsZ0JBQWdCLElBQUksV0FBVyxDQUFDLGdCQUFnQixDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsRUFBRTtRQUNsRyxPQUFPLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsQ0FBQztLQUNqRDtJQUNELE9BQU8sWUFBWSxDQUFDO0FBQ3RCLENBQUM7QUFFRCw2REFBNkQ7QUFDN0QsTUFBTSxVQUFVLDBCQUEwQixDQUFDLFNBQW9CLEVBQUUsZ0JBQXdCO0lBQ3ZGLElBQU0saUJBQWlCLEdBQUcsZ0NBQWdDLENBQUMsU0FBUyxDQUFDLENBQUM7SUFFdEUsT0FBTyxVQUFDLEdBQVcsRUFBRSxJQUFZLEVBQUUsS0FBVSxFQUFFLFNBQWlCLEVBQUUsV0FBZ0IsRUFBRSxJQUFTO1FBQzNGLElBQU0sV0FBVyxHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksT0FBTyxJQUFJLENBQUMsVUFBVSxLQUFLLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBZSxDQUFDO1FBQzdHLElBQU0sZUFBZSxHQUFHLFdBQVcsSUFBSSxXQUFXLENBQUMsZ0JBQWdCLElBQUksV0FBVyxDQUFDLGdCQUFnQixDQUFDLGFBQWEsSUFBSSxnQkFBZ0IsQ0FBQztRQUV0SSxJQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsS0FBSyxFQUFFLGlCQUFpQixFQUFFLEtBQUssQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ3RFLElBQUksVUFBVSxHQUFHLENBQUMsS0FBSyxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztRQUUxRixrRUFBa0U7UUFDbEUsOEVBQThFO1FBQzlFLElBQUksVUFBVSxJQUFJLGVBQWUsS0FBSyxnQkFBZ0IsRUFBRTtZQUN0RCxJQUFNLEtBQUssR0FBRyxJQUFJLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLDBCQUEwQjtZQUM1RSxVQUFVLEdBQUcsVUFBVSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsZUFBZSxDQUFDLENBQUM7U0FDekQ7UUFFRCxPQUFPLFVBQVUsQ0FBQztJQUNwQixDQUFDLENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29sdW1uLCBGaWVsZFR5cGUsIEZvcm1hdHRlciwgR3JpZE9wdGlvbiB9IGZyb20gJy4uL21vZGVscy9pbmRleCc7XHJcbmltcG9ydCB7IG1hcE1vbWVudERhdGVGb3JtYXRXaXRoRmllbGRUeXBlIH0gZnJvbSAnLi4vc2VydmljZXMvdXRpbGl0aWVzJztcclxuaW1wb3J0ICogYXMgbW9tZW50XyBmcm9tICdtb21lbnQtbWluaSc7XHJcbmNvbnN0IG1vbWVudCA9IG1vbWVudF87IC8vIHBhdGNoIHRvIGZpeCByb2xsdXAgXCJtb21lbnQgaGFzIG5vIGRlZmF1bHQgZXhwb3J0XCIgaXNzdWUsIGRvY3VtZW50IGhlcmUgaHR0cHM6Ly9naXRodWIuY29tL3JvbGx1cC9yb2xsdXAvaXNzdWVzLzY3MFxyXG5cclxuLyoqXHJcbiAqIEZpbmQgdGhlIG9wdGlvbiB2YWx1ZSBmcm9tIHRoZSBmb2xsb3dpbmcgKGluIG9yZGVyIG9mIGV4ZWN1dGlvbilcclxuICogMS0gQ29sdW1uIERlZmluaXRpb24gXCJwYXJhbXNcIlxyXG4gKiAyLSBHcmlkIE9wdGlvbnMgXCJmb3JtYXR0ZXJPcHRpb25zXCJcclxuICogMy0gbm90aGluZyBmb3VuZCwgcmV0dXJuIGRlZmF1bHQgdmFsdWUgcHJvdmlkZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZUZyb21QYXJhbXNPckZvcm1hdHRlck9wdGlvbnMob3B0aW9uTmFtZTogc3RyaW5nLCBjb2x1bW5EZWY6IENvbHVtbiwgZ3JpZDogYW55LCBkZWZhdWx0VmFsdWU/OiBhbnkpIHtcclxuICBjb25zdCBncmlkT3B0aW9ucyA9ICgoZ3JpZCAmJiB0eXBlb2YgZ3JpZC5nZXRPcHRpb25zID09PSAnZnVuY3Rpb24nKSA/IGdyaWQuZ2V0T3B0aW9ucygpIDoge30pIGFzIEdyaWRPcHRpb247XHJcbiAgY29uc3QgcGFyYW1zID0gY29sdW1uRGVmICYmIGNvbHVtbkRlZi5wYXJhbXM7XHJcblxyXG4gIGlmIChwYXJhbXMgJiYgcGFyYW1zLmhhc093blByb3BlcnR5KG9wdGlvbk5hbWUpKSB7XHJcbiAgICByZXR1cm4gcGFyYW1zW29wdGlvbk5hbWVdO1xyXG4gIH0gZWxzZSBpZiAoZ3JpZE9wdGlvbnMuZm9ybWF0dGVyT3B0aW9ucyAmJiBncmlkT3B0aW9ucy5mb3JtYXR0ZXJPcHRpb25zLmhhc093blByb3BlcnR5KG9wdGlvbk5hbWUpKSB7XHJcbiAgICByZXR1cm4gZ3JpZE9wdGlvbnMuZm9ybWF0dGVyT3B0aW9uc1tvcHRpb25OYW1lXTtcclxuICB9XHJcbiAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcclxufVxyXG5cclxuLyoqIEZyb20gYSBGaWVsZFR5cGUsIHJldHVybiB0aGUgYXNzb2NpYXRlZCBkYXRlIEZvcm1hdHRlciAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXNzb2NpYXRlZERhdGVGb3JtYXR0ZXIoZmllbGRUeXBlOiBGaWVsZFR5cGUsIGRlZmF1bHRTZXBhcmF0b3I6IHN0cmluZyk6IEZvcm1hdHRlciB7XHJcbiAgY29uc3QgZGVmYXVsdERhdGVGb3JtYXQgPSBtYXBNb21lbnREYXRlRm9ybWF0V2l0aEZpZWxkVHlwZShmaWVsZFR5cGUpO1xyXG5cclxuICByZXR1cm4gKHJvdzogbnVtYmVyLCBjZWxsOiBudW1iZXIsIHZhbHVlOiBhbnksIGNvbHVtbkRlZjogQ29sdW1uLCBkYXRhQ29udGV4dDogYW55LCBncmlkOiBhbnkpID0+IHtcclxuICAgIGNvbnN0IGdyaWRPcHRpb25zID0gKChncmlkICYmIHR5cGVvZiBncmlkLmdldE9wdGlvbnMgPT09ICdmdW5jdGlvbicpID8gZ3JpZC5nZXRPcHRpb25zKCkgOiB7fSkgYXMgR3JpZE9wdGlvbjtcclxuICAgIGNvbnN0IGN1c3RvbVNlcGFyYXRvciA9IGdyaWRPcHRpb25zICYmIGdyaWRPcHRpb25zLmZvcm1hdHRlck9wdGlvbnMgJiYgZ3JpZE9wdGlvbnMuZm9ybWF0dGVyT3B0aW9ucy5kYXRlU2VwYXJhdG9yIHx8IGRlZmF1bHRTZXBhcmF0b3I7XHJcblxyXG4gICAgY29uc3QgaXNEYXRlVmFsaWQgPSBtb21lbnQodmFsdWUsIGRlZmF1bHREYXRlRm9ybWF0LCBmYWxzZSkuaXNWYWxpZCgpO1xyXG4gICAgbGV0IG91dHB1dERhdGUgPSAodmFsdWUgJiYgaXNEYXRlVmFsaWQpID8gbW9tZW50KHZhbHVlKS5mb3JtYXQoZGVmYXVsdERhdGVGb3JtYXQpIDogdmFsdWU7XHJcblxyXG4gICAgLy8gdXNlciBjYW4gY3VzdG9taXplIHRoZSBzZXBhcmF0b3IgdGhyb3VnaCB0aGUgXCJmb3JtYXR0ZXJPcHRpb25zXCJcclxuICAgIC8vIGlmIHRoYXQgaXMgdGhlIGNhc2Ugd2UgbmVlZCB0byByZXBsYWNlIHRoZSBkZWZhdWx0IFwiL1wiIHRvIHRoZSBuZXcgc2VwYXJhdG9yXHJcbiAgICBpZiAob3V0cHV0RGF0ZSAmJiBjdXN0b21TZXBhcmF0b3IgIT09IGRlZmF1bHRTZXBhcmF0b3IpIHtcclxuICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGRlZmF1bHRTZXBhcmF0b3IsICdpZycpOyAvLyBmaW5kIHNlcGFyYXRvciBnbG9iYWxseVxyXG4gICAgICBvdXRwdXREYXRlID0gb3V0cHV0RGF0ZS5yZXBsYWNlKHJlZ2V4LCBjdXN0b21TZXBhcmF0b3IpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRwdXREYXRlO1xyXG4gIH07XHJcbn1cclxuIl19