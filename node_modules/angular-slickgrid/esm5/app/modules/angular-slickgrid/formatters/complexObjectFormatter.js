export var complexObjectFormatter = function (row, cell, cellValue, columnDef, dataContext) {
    if (!columnDef) {
        return '';
    }
    var columnParams = columnDef.params || {};
    var complexFieldLabel = columnParams && columnParams.complexFieldLabel || columnDef.field;
    if (!complexFieldLabel) {
        throw new Error("For the Formatters.complexObject to work properly, you need to tell it which property of the complex object to use.\n      There are 3 ways to provide it:\n      1- via the generic \"params\" with a \"complexFieldLabel\" property on your Column Definition, example: this.columnDefs = [{ id: 'user', field: 'user', params: { complexFieldLabel: 'user.firstName' } }]\n      2- via the generic \"params\" with a \"complexFieldLabel\" and a \"labelKey\" property on your Column Definition, example: this.columnDefs = [{ id: 'user', field: 'user', labelKey: 'firstName' params: { complexFieldLabel: 'user' } }]\n      3- via the field name that includes a dot notation, example: this.columnDefs = [{ id: 'user', field: 'user.firstName'}] ");
    }
    if (columnDef.labelKey && dataContext.hasOwnProperty(complexFieldLabel)) {
        return dataContext[complexFieldLabel] && dataContext[complexFieldLabel][columnDef.labelKey];
    }
    // when complexFieldLabel includes the dot ".", we will do the split and get the value from the complex object
    // however we also need to make sure that the complex objet exist, else we'll return the cell value (original value)
    if (typeof complexFieldLabel === 'string' && complexFieldLabel.indexOf('.') > 0) {
        return complexFieldLabel.split('.').reduce(function (obj, i) { return (obj && obj.hasOwnProperty(i) ? obj[i] : cellValue); }, dataContext);
    }
    return cellValue;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGxleE9iamVjdEZvcm1hdHRlci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItc2xpY2tncmlkLyIsInNvdXJjZXMiOlsiYXBwL21vZHVsZXMvYW5ndWxhci1zbGlja2dyaWQvZm9ybWF0dGVycy9jb21wbGV4T2JqZWN0Rm9ybWF0dGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUdBLE1BQU0sQ0FBQyxJQUFNLHNCQUFzQixHQUFjLFVBQUMsR0FBVyxFQUFFLElBQVksRUFBRSxTQUFjLEVBQUUsU0FBaUIsRUFBRSxXQUFnQjtJQUM5SCxJQUFJLENBQUMsU0FBUyxFQUFFO1FBQ2QsT0FBTyxFQUFFLENBQUM7S0FDWDtJQUVELElBQU0sWUFBWSxHQUFHLFNBQVMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDO0lBQzVDLElBQU0saUJBQWlCLEdBQUcsWUFBWSxJQUFJLFlBQVksQ0FBQyxpQkFBaUIsSUFBSSxTQUFTLENBQUMsS0FBSyxDQUFDO0lBRTVGLElBQUksQ0FBQyxpQkFBaUIsRUFBRTtRQUN0QixNQUFNLElBQUksS0FBSyxDQUFDLCt0QkFJMkcsQ0FBQyxDQUFDO0tBQzlIO0lBRUQsSUFBSSxTQUFTLENBQUMsUUFBUSxJQUFJLFdBQVcsQ0FBQyxjQUFjLENBQUMsaUJBQWlCLENBQUMsRUFBRTtRQUN2RSxPQUFPLFdBQVcsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQztLQUM3RjtJQUVELDhHQUE4RztJQUM5RyxvSEFBb0g7SUFDcEgsSUFBSSxPQUFPLGlCQUFpQixLQUFLLFFBQVEsSUFBSSxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQy9FLE9BQU8saUJBQWlCLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFDLEdBQUcsRUFBRSxDQUFDLElBQUssT0FBQSxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxFQUFuRCxDQUFtRCxFQUFFLFdBQVcsQ0FBQyxDQUFDO0tBQzFIO0lBQ0QsT0FBTyxTQUFTLENBQUM7QUFDbkIsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29sdW1uIH0gZnJvbSAnLi8uLi9tb2RlbHMvY29sdW1uLmludGVyZmFjZSc7XHJcbmltcG9ydCB7IEZvcm1hdHRlciB9IGZyb20gJy4vLi4vbW9kZWxzL2Zvcm1hdHRlci5pbnRlcmZhY2UnO1xyXG5cclxuZXhwb3J0IGNvbnN0IGNvbXBsZXhPYmplY3RGb3JtYXR0ZXI6IEZvcm1hdHRlciA9IChyb3c6IG51bWJlciwgY2VsbDogbnVtYmVyLCBjZWxsVmFsdWU6IGFueSwgY29sdW1uRGVmOiBDb2x1bW4sIGRhdGFDb250ZXh0OiBhbnkpID0+IHtcclxuICBpZiAoIWNvbHVtbkRlZikge1xyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgY29sdW1uUGFyYW1zID0gY29sdW1uRGVmLnBhcmFtcyB8fCB7fTtcclxuICBjb25zdCBjb21wbGV4RmllbGRMYWJlbCA9IGNvbHVtblBhcmFtcyAmJiBjb2x1bW5QYXJhbXMuY29tcGxleEZpZWxkTGFiZWwgfHwgY29sdW1uRGVmLmZpZWxkO1xyXG5cclxuICBpZiAoIWNvbXBsZXhGaWVsZExhYmVsKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZvciB0aGUgRm9ybWF0dGVycy5jb21wbGV4T2JqZWN0IHRvIHdvcmsgcHJvcGVybHksIHlvdSBuZWVkIHRvIHRlbGwgaXQgd2hpY2ggcHJvcGVydHkgb2YgdGhlIGNvbXBsZXggb2JqZWN0IHRvIHVzZS5cclxuICAgICAgVGhlcmUgYXJlIDMgd2F5cyB0byBwcm92aWRlIGl0OlxyXG4gICAgICAxLSB2aWEgdGhlIGdlbmVyaWMgXCJwYXJhbXNcIiB3aXRoIGEgXCJjb21wbGV4RmllbGRMYWJlbFwiIHByb3BlcnR5IG9uIHlvdXIgQ29sdW1uIERlZmluaXRpb24sIGV4YW1wbGU6IHRoaXMuY29sdW1uRGVmcyA9IFt7IGlkOiAndXNlcicsIGZpZWxkOiAndXNlcicsIHBhcmFtczogeyBjb21wbGV4RmllbGRMYWJlbDogJ3VzZXIuZmlyc3ROYW1lJyB9IH1dXHJcbiAgICAgIDItIHZpYSB0aGUgZ2VuZXJpYyBcInBhcmFtc1wiIHdpdGggYSBcImNvbXBsZXhGaWVsZExhYmVsXCIgYW5kIGEgXCJsYWJlbEtleVwiIHByb3BlcnR5IG9uIHlvdXIgQ29sdW1uIERlZmluaXRpb24sIGV4YW1wbGU6IHRoaXMuY29sdW1uRGVmcyA9IFt7IGlkOiAndXNlcicsIGZpZWxkOiAndXNlcicsIGxhYmVsS2V5OiAnZmlyc3ROYW1lJyBwYXJhbXM6IHsgY29tcGxleEZpZWxkTGFiZWw6ICd1c2VyJyB9IH1dXHJcbiAgICAgIDMtIHZpYSB0aGUgZmllbGQgbmFtZSB0aGF0IGluY2x1ZGVzIGEgZG90IG5vdGF0aW9uLCBleGFtcGxlOiB0aGlzLmNvbHVtbkRlZnMgPSBbeyBpZDogJ3VzZXInLCBmaWVsZDogJ3VzZXIuZmlyc3ROYW1lJ31dIGApO1xyXG4gIH1cclxuXHJcbiAgaWYgKGNvbHVtbkRlZi5sYWJlbEtleSAmJiBkYXRhQ29udGV4dC5oYXNPd25Qcm9wZXJ0eShjb21wbGV4RmllbGRMYWJlbCkpIHtcclxuICAgIHJldHVybiBkYXRhQ29udGV4dFtjb21wbGV4RmllbGRMYWJlbF0gJiYgZGF0YUNvbnRleHRbY29tcGxleEZpZWxkTGFiZWxdW2NvbHVtbkRlZi5sYWJlbEtleV07XHJcbiAgfVxyXG5cclxuICAvLyB3aGVuIGNvbXBsZXhGaWVsZExhYmVsIGluY2x1ZGVzIHRoZSBkb3QgXCIuXCIsIHdlIHdpbGwgZG8gdGhlIHNwbGl0IGFuZCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIGNvbXBsZXggb2JqZWN0XHJcbiAgLy8gaG93ZXZlciB3ZSBhbHNvIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGNvbXBsZXggb2JqZXQgZXhpc3QsIGVsc2Ugd2UnbGwgcmV0dXJuIHRoZSBjZWxsIHZhbHVlIChvcmlnaW5hbCB2YWx1ZSlcclxuICBpZiAodHlwZW9mIGNvbXBsZXhGaWVsZExhYmVsID09PSAnc3RyaW5nJyAmJiBjb21wbGV4RmllbGRMYWJlbC5pbmRleE9mKCcuJykgPiAwKSB7XHJcbiAgICByZXR1cm4gY29tcGxleEZpZWxkTGFiZWwuc3BsaXQoJy4nKS5yZWR1Y2UoKG9iaiwgaSkgPT4gKG9iaiAmJiBvYmouaGFzT3duUHJvcGVydHkoaSkgPyBvYmpbaV0gOiBjZWxsVmFsdWUpLCBkYXRhQ29udGV4dCk7XHJcbiAgfVxyXG4gIHJldHVybiBjZWxsVmFsdWU7XHJcbn07XHJcbiJdfQ==