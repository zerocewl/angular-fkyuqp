import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { isObservable, Subject } from 'rxjs';
import * as isequal_ from 'lodash.isequal';
var isequal = isequal_; // patch to fix rollup to work
import { EmitterType, FieldType, KeyCode, OperatorType, } from './../models/index';
import { executeBackendCallback, refreshBackendDataset } from './backend-utilities';
import { getDescendantProperty } from './utilities';
import { FilterConditions } from './../filter-conditions';
import { FilterFactory } from '../filters/filterFactory';
import { SharedService } from './shared.service';
// timer for keeping track of user typing waits
var timer;
var DEFAULT_FILTER_TYPING_DEBOUNCE = 500;
var FilterService = /** @class */ (function () {
    function FilterService(filterFactory, sharedService) {
        this.filterFactory = filterFactory;
        this.sharedService = sharedService;
        this._isFilterFirstRender = true;
        this._firstColumnIdRendered = '';
        this._filtersMetadata = [];
        this._columnFilters = {};
        this.httpCancelRequests$ = new Subject(); // this will be used to cancel any pending http request
        this.onFilterChanged = new Subject();
        this.onFilterCleared = new Subject();
        this._eventHandler = new Slick.EventHandler();
        this._onSearchChange = new Slick.Event();
    }
    Object.defineProperty(FilterService.prototype, "eventHandler", {
        /** Getter of the SlickGrid Event Handler */
        get: function () {
            return this._eventHandler;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FilterService.prototype, "isFilterFirstRender", {
        /** Getter to know if the filter was already rendered or if it was its first time render */
        get: function () {
            return this._isFilterFirstRender;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FilterService.prototype, "onSearchChange", {
        /** Getter of the SlickGrid Event Handler */
        get: function () {
            return this._onSearchChange;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FilterService.prototype, "_gridOptions", {
        /** Getter for the Grid Options pulled through the Grid Object */
        get: function () {
            return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FilterService.prototype, "_columnDefinitions", {
        /** Getter for the Column Definitions pulled through the Grid Object */
        get: function () {
            return (this._grid && this._grid.getColumns) ? this._grid.getColumns() : [];
        },
        enumerable: true,
        configurable: true
    });
    FilterService.prototype.init = function (grid) {
        this._grid = grid;
    };
    FilterService.prototype.dispose = function () {
        this.disposeColumnFilters();
        // unsubscribe all SlickGrid events
        if (this._eventHandler && this._eventHandler.unsubscribeAll) {
            this._eventHandler.unsubscribeAll();
        }
        if (isObservable(this.httpCancelRequests$)) {
            this.httpCancelRequests$.next(); // this cancels any pending http requests
        }
    };
    /**
     * Dispose of the filters, since it's a singleton, we don't want to affect other grids with same columns
     */
    FilterService.prototype.disposeColumnFilters = function () {
        // we need to loop through all columnFilters and delete them 1 by 1
        // only trying to make columnFilter an empty (without looping) would not trigger a dataset change
        if (typeof this._columnFilters === 'object') {
            for (var columnId in this._columnFilters) {
                if (columnId && this._columnFilters[columnId]) {
                    delete this._columnFilters[columnId];
                }
            }
        }
        // also destroy each Filter instances
        if (Array.isArray(this._filtersMetadata)) {
            this._filtersMetadata.forEach(function (filter) {
                if (filter && filter.destroy) {
                    filter.destroy(true);
                }
            });
        }
    };
    /**
     * Bind a backend filter hook to the grid
     * @param grid SlickGrid Grid object
     */
    FilterService.prototype.bindBackendOnFilter = function (grid, dataView) {
        var _this = this;
        this._dataView = dataView;
        this._filtersMetadata = [];
        // subscribe to SlickGrid onHeaderRowCellRendered event to create filter template
        this._eventHandler.subscribe(grid.onHeaderRowCellRendered, function (e, args) {
            // firstColumnIdRendered is null at first, so if it changes to being filled and equal, then we would know that it was already rendered
            // this is to avoid rendering the filter twice (only the Select Filter for now), rendering it again also clears the filter which has unwanted side effect
            if (args.column.id === _this._firstColumnIdRendered) {
                _this._isFilterFirstRender = false;
            }
            _this.addFilterTemplateToHeaderRow(args, _this._isFilterFirstRender);
            if (_this._firstColumnIdRendered === '') {
                _this._firstColumnIdRendered = args.column.id;
            }
        });
        // subscribe to the SlickGrid event and call the backend execution
        this._eventHandler.subscribe(this._onSearchChange, this.onBackendFilterChange.bind(this));
    };
    /**
     * Bind a local filter hook to the grid
     * @param grid SlickGrid Grid object
     * @param dataView
     */
    FilterService.prototype.bindLocalOnFilter = function (grid, dataView) {
        var _this = this;
        this._filtersMetadata = [];
        this._dataView = dataView;
        dataView.setFilterArgs({ columnFilters: this._columnFilters, grid: this._grid, dataView: dataView });
        dataView.setFilter(this.customLocalFilter.bind(this));
        this._eventHandler.subscribe(this._onSearchChange, function (e, args) {
            var columnId = args.columnId;
            if (columnId != null) {
                dataView.refresh();
            }
            // emit an onFilterChanged event when it's not called by a clear filter
            if (args && !args.clearFilterTriggered) {
                _this.emitFilterChanged(EmitterType.local);
            }
        });
        // subscribe to SlickGrid onHeaderRowCellRendered event to create filter template
        this._eventHandler.subscribe(grid.onHeaderRowCellRendered, function (e, args) {
            _this.addFilterTemplateToHeaderRow(args);
        });
    };
    FilterService.prototype.clearFilterByColumnId = function (event, columnId) {
        // get current column filter before clearing, this allow us to know if the filter was empty prior to calling the clear filter
        var currentColumnFilters = Object.keys(this._columnFilters);
        var currentColFilter;
        if (Array.isArray(currentColumnFilters)) {
            currentColFilter = currentColumnFilters.find(function (name) { return name === columnId; });
        }
        // find the filter object and call its clear method with true (the argument tells the method it was called by a clear filter)
        var colFilter = this._filtersMetadata.find(function (filter) { return filter.columnDef.id === columnId; });
        if (colFilter && colFilter.clear) {
            colFilter.clear(true);
        }
        var emitter = EmitterType.local;
        var isBackendApi = this._gridOptions && this._gridOptions.backendServiceApi || false;
        // when using a backend service, we need to manually trigger a filter change but only if the filter was previously filled
        if (isBackendApi) {
            emitter = EmitterType.remote;
            if (currentColFilter) {
                this.onBackendFilterChange(event, { grid: this._grid, columnFilters: this._columnFilters });
            }
        }
        // emit an event when filter is cleared
        this.emitFilterChanged(emitter);
    };
    /** Clear the search filters (below the column titles) */
    FilterService.prototype.clearFilters = function (triggerChange) {
        var _this = this;
        if (triggerChange === void 0) { triggerChange = true; }
        this._filtersMetadata.forEach(function (filter) {
            if (filter && filter.clear) {
                // clear element but don't trigger individual clear change,
                // we'll do 1 trigger for all filters at once afterward
                filter.clear(false);
            }
        });
        // we also need to refresh the dataView and optionally the grid (it's optional since we use DataView)
        if (this._dataView && this._grid) {
            this._dataView.refresh();
            this._grid.invalidate();
        }
        // when using backend service, we need to query only once so it's better to do it here
        var backendApi = this._gridOptions && this._gridOptions.backendServiceApi;
        if (backendApi && triggerChange) {
            var callbackArgs_1 = { clearFilterTriggered: true, shouldTriggerQuery: triggerChange, grid: this._grid, columnFilters: this._columnFilters };
            var queryResponse = backendApi.service.processOnFilterChanged(undefined, callbackArgs_1);
            if (queryResponse instanceof Promise && queryResponse.then) {
                // @deprecated, processOnFilterChanged in the future should be returned as a query string NOT as a Promise
                console.warn("[Angular-Slickgrid] please note that the \"processOnFilterChanged\" from your Backend Service, should now return a string instead of a Promise.\n          Returning a Promise will be deprecated in the future.");
                queryResponse.then(function (query) {
                    var totalItems = _this._gridOptions && _this._gridOptions.pagination && _this._gridOptions.pagination.totalItems;
                    executeBackendCallback(backendApi, query, callbackArgs_1, new Date(), totalItems, _this.emitFilterChanged.bind(_this));
                });
            }
            else {
                var query = queryResponse;
                var totalItems = this._gridOptions && this._gridOptions.pagination && this._gridOptions.pagination.totalItems;
                executeBackendCallback(backendApi, query, callbackArgs_1, new Date(), totalItems, this.emitFilterChanged.bind(this));
            }
        }
        // emit an event when filters are all cleared
        if (triggerChange) {
            this.onFilterCleared.next(true);
        }
    };
    FilterService.prototype.customLocalFilter = function (item, args) {
        var e_1, _a;
        var dataView = args && args.dataView;
        var _loop_1 = function (columnId) {
            var columnFilter = args.columnFilters[columnId];
            var columnIndex = args.grid.getColumnIndex(columnId);
            var columnDef = args.grid.getColumns()[columnIndex];
            // it might be a hidden column, if so it won't be part of the getColumns (because it we hide a column via setColumns)
            // when that happens we can try to get the column definition from all defined columns
            if (!columnDef && this_1.sharedService && Array.isArray(this_1.sharedService.allColumns)) {
                columnIndex = this_1.sharedService.allColumns.findIndex(function (col) { return col.field === columnId; });
                columnDef = this_1.sharedService.allColumns[columnIndex];
            }
            // if we still don't have a column definition then we should return then row anyway (true)
            if (!columnDef) {
                return { value: true };
            }
            // Row Detail View plugin, if the row is padding we just get the value we're filtering on from it's parent
            if (this_1._gridOptions.enableRowDetailView) {
                var metadataPrefix = this_1._gridOptions.rowDetailView && this_1._gridOptions.rowDetailView.keyPrefix || '__';
                if (item[metadataPrefix + "isPadding"] && item[metadataPrefix + "parent"]) {
                    item = item[metadataPrefix + "parent"];
                }
            }
            var dataKey = columnDef.dataKey;
            var fieldName = columnDef.queryFieldFilter || columnDef.queryField || columnDef.field;
            var fieldType = columnDef.type || FieldType.string;
            var filterSearchType = (columnDef.filterSearchType) ? columnDef.filterSearchType : null;
            var cellValue = item[fieldName];
            // when item is a complex object (dot "." notation), we need to filter the value contained in the object tree
            if (fieldName.indexOf('.') >= 0) {
                cellValue = getDescendantProperty(item, fieldName);
            }
            // if we find searchTerms use them but make a deep copy so that we don't affect original array
            // we might have to overwrite the value(s) locally that are returned
            // e.g: we don't want to operator within the search value, since it will fail filter condition check trigger afterward
            var searchValues = (columnFilter && columnFilter.searchTerms) ? $.extend(true, [], columnFilter.searchTerms) : null;
            var fieldSearchValue = (Array.isArray(searchValues) && searchValues.length === 1) ? searchValues[0] : '';
            var matches = null;
            if (fieldType !== FieldType.object) {
                fieldSearchValue = '' + fieldSearchValue; // make sure it's a string
                matches = fieldSearchValue.match(/^([<>!=\*]{0,2})(.*[^<>!=\*])([\*]?)$/); // group 1: Operator, 2: searchValue, 3: last char is '*' (meaning starts with, ex.: abc*)
            }
            var operator = columnFilter.operator || ((matches) ? matches[1] : '');
            var searchTerm = (!!matches) ? matches[2] : '';
            var lastValueChar = (!!matches) ? matches[3] : (operator === '*z' ? '*' : '');
            if (searchValues && searchValues.length > 1) {
                fieldSearchValue = searchValues.join(',');
            }
            else if (typeof fieldSearchValue === 'string') {
                // escaping the search value
                fieldSearchValue = fieldSearchValue.replace("'", "''"); // escape single quotes by doubling them
                if (operator === '*' || operator === 'a*' || operator === '*z' || lastValueChar === '*') {
                    operator = (operator === '*' || operator === '*z') ? OperatorType.endsWith : OperatorType.startsWith;
                }
            }
            // no need to query if search value is empty
            if (searchTerm === '' && (!searchValues || (Array.isArray(searchValues) && searchValues.length === 0))) {
                return { value: true };
            }
            // if search value has a regex match we will only keep the value without the operator
            // in this case we need to overwrite the returned search values to truncate operator from the string search
            if (Array.isArray(matches) && matches.length >= 1 && (Array.isArray(searchValues) && searchValues.length === 1)) {
                searchValues[0] = searchTerm;
            }
            // filter search terms should always be string type (even though we permit the end user to input numbers)
            // so make sure each term are strings, if user has some default search terms, we will cast them to string
            if (searchValues && Array.isArray(searchValues) && fieldType !== FieldType.object) {
                for (var k = 0, ln = searchValues.length; k < ln; k++) {
                    // make sure all search terms are strings
                    searchValues[k] = ((searchValues[k] === undefined || searchValues[k] === null) ? '' : searchValues[k]) + '';
                }
            }
            // when using localization (i18n), we should use the formatter output to search as the new cell value
            if (columnDef && columnDef.params && columnDef.params.useFormatterOuputToFilter) {
                var rowIndex = (dataView && typeof dataView.getIdxById === 'function') ? dataView.getIdxById(item.id) : 0;
                cellValue = columnDef.formatter(rowIndex, columnIndex, cellValue, columnDef, item, this_1._grid);
            }
            // make sure cell value is always a string
            if (typeof cellValue === 'number') {
                cellValue = cellValue.toString();
            }
            var conditionOptions = {
                dataKey: dataKey,
                fieldType: fieldType,
                searchTerms: searchValues,
                cellValue: cellValue,
                operator: operator,
                cellValueLastChar: lastValueChar,
                filterSearchType: filterSearchType
            };
            if (!FilterConditions.executeMappedCondition(conditionOptions)) {
                return { value: false };
            }
        };
        var this_1 = this;
        try {
            for (var _b = tslib_1.__values(Object.keys(args.columnFilters)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var columnId = _c.value;
                var state_1 = _loop_1(columnId);
                if (typeof state_1 === "object")
                    return state_1.value;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return true;
    };
    FilterService.prototype.getColumnFilters = function () {
        return this._columnFilters;
    };
    FilterService.prototype.getFiltersMetadata = function () {
        return this._filtersMetadata;
    };
    FilterService.prototype.getCurrentLocalFilters = function () {
        var e_2, _a;
        var currentFilters = [];
        if (this._columnFilters) {
            try {
                for (var _b = tslib_1.__values(Object.keys(this._columnFilters)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var colId = _c.value;
                    var columnFilter = this._columnFilters[colId];
                    var filter = { columnId: colId || '' };
                    if (columnFilter && columnFilter.searchTerms) {
                        filter.searchTerms = columnFilter.searchTerms;
                    }
                    if (columnFilter.operator) {
                        filter.operator = columnFilter.operator;
                    }
                    if (Array.isArray(filter.searchTerms) && filter.searchTerms.length > 0 && filter.searchTerms[0] !== '') {
                        currentFilters.push(filter);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        return currentFilters;
    };
    /**
     * A simple function that is binded to the subscriber and emit a change when the filter is called.
     * Other services, like Pagination, can then subscribe to it.
     * @param caller
     */
    FilterService.prototype.emitFilterChanged = function (caller) {
        if (caller === EmitterType.remote && this._gridOptions && this._gridOptions.backendServiceApi) {
            var currentFilters = [];
            var backendService = this._gridOptions.backendServiceApi.service;
            if (backendService && backendService.getCurrentFilters) {
                currentFilters = backendService.getCurrentFilters();
            }
            this.onFilterChanged.next(currentFilters);
        }
        else if (caller === EmitterType.local) {
            this.onFilterChanged.next(this.getCurrentLocalFilters());
        }
    };
    FilterService.prototype.onBackendFilterChange = function (event, args) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var backendApi, startTime, debounceTypingDelay, isTriggeredByClearFilter, eventType, eventKeyCode, query, totalItems;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!args || !args.grid) {
                            throw new Error('Something went wrong when trying to bind the "onBackendFilterChange(event, args)" function, it seems that "args" is not populated correctly');
                        }
                        backendApi = this._gridOptions.backendServiceApi;
                        if (!backendApi || !backendApi.process || !backendApi.service) {
                            throw new Error("BackendServiceApi requires at least a \"process\" function and a \"service\" defined");
                        }
                        startTime = new Date();
                        // run a preProcess callback if defined
                        if (backendApi.preProcess) {
                            backendApi.preProcess();
                        }
                        debounceTypingDelay = 0;
                        isTriggeredByClearFilter = args && args.clearFilterTriggered;
                        eventType = event && event.type;
                        eventKeyCode = event && event.keyCode;
                        if (!isTriggeredByClearFilter && eventKeyCode !== KeyCode.ENTER && (eventType === 'input' || eventType === 'keyup' || eventType === 'keydown')) {
                            debounceTypingDelay = backendApi.hasOwnProperty('filterTypingDebounce') ? backendApi.filterTypingDebounce : DEFAULT_FILTER_TYPING_DEBOUNCE;
                        }
                        if (!(args && args.shouldTriggerQuery)) return [3 /*break*/, 3];
                        // call the service to get a query back
                        // @deprecated TODO: remove async/await on next major change, refer to processOnFilterChanged in BackendService interface (with @deprecated)
                        clearTimeout(timer);
                        if (!(debounceTypingDelay > 0)) return [3 /*break*/, 1];
                        timer = setTimeout(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            var query, totalItems;
                            return tslib_1.__generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, backendApi.service.processOnFilterChanged(event, args)];
                                    case 1:
                                        query = _a.sent();
                                        totalItems = this._gridOptions && this._gridOptions.pagination && this._gridOptions.pagination.totalItems;
                                        executeBackendCallback(backendApi, query, args, startTime, totalItems, this.emitFilterChanged.bind(this), this.httpCancelRequests$);
                                        return [2 /*return*/];
                                }
                            });
                        }); }, debounceTypingDelay);
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, backendApi.service.processOnFilterChanged(event, args)];
                    case 2:
                        query = _a.sent();
                        totalItems = this._gridOptions && this._gridOptions.pagination && this._gridOptions.pagination.totalItems;
                        executeBackendCallback(backendApi, query, args, startTime, totalItems, this.emitFilterChanged.bind(this), this.httpCancelRequests$);
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * When user passes an array of preset filters, we need to pre-populate each column filter searchTerm(s)
     * The process is to loop through the preset filters array, find the associated column from columnDefinitions and fill in the filter object searchTerm(s)
     * This is basically the same as if we would manually add searchTerm(s) to a column filter object in the column definition, but we do it programmatically.
     * At the end of the day, when creating the Filter (DOM Element), it will use these searchTerm(s) so we can take advantage of that without recoding each Filter type (DOM element)
     */
    FilterService.prototype.populateColumnFilterSearchTermPresets = function (filters) {
        if (Array.isArray(filters) && filters.length > 0) {
            this._columnDefinitions.forEach(function (columnDef) {
                // clear any columnDef searchTerms before applying Presets
                if (columnDef.filter && columnDef.filter.searchTerms) {
                    delete columnDef.filter.searchTerms;
                }
                // from each presets, we will find the associated columnDef and apply the preset searchTerms & operator if there is
                var columnPreset = filters.find(function (presetFilter) {
                    return presetFilter.columnId === columnDef.id;
                });
                if (columnPreset && columnPreset.searchTerms && Array.isArray(columnPreset.searchTerms)) {
                    columnDef.filter = columnDef.filter || {};
                    columnDef.filter.operator = columnPreset.operator || columnDef.filter.operator || '';
                    columnDef.filter.searchTerms = columnPreset.searchTerms;
                }
            });
        }
        return this._columnDefinitions;
    };
    /**
     * Set the sort icons in the UI (ONLY the icons, it does not do any sorting)
     * The column sort icons are not necessarily inter-connected to the sorting functionality itself,
     * you can change the sorting icons separately by passing an array of columnId/sortAsc and that will change ONLY the icons
     * @param sortColumns
     */
    FilterService.prototype.setSortColumnIcons = function (sortColumns) {
        if (this._grid && Array.isArray(sortColumns)) {
            this._grid.setSortColumns(sortColumns);
        }
    };
    /**
     * Update Filters dynamically just by providing an array of filter(s).
     * You can also choose emit (default) a Filter Changed event that will be picked by the Grid State Service.
     *
     * Also for backend service only, you can choose to trigger a backend query (default) or not if you wish to do it later,
     * this could be useful when using updateFilters & updateSorting and you wish to only send the backend query once.
     * @param filters array
     * @param triggerEvent defaults to True, do we want to emit a filter changed event?
     * @param triggerBackendQuery defaults to True, which will query the backend.
     */
    FilterService.prototype.updateFilters = function (filters, emitChangedEvent, triggerBackendQuery) {
        var _this = this;
        if (emitChangedEvent === void 0) { emitChangedEvent = true; }
        if (triggerBackendQuery === void 0) { triggerBackendQuery = true; }
        if (!this._filtersMetadata || this._filtersMetadata.length === 0 || !this._gridOptions || !this._gridOptions.enableFiltering) {
            throw new Error('[Angular-Slickgrid] in order to use "updateFilters" method, you need to have Filterable Columns defined in your grid and "enableFiltering" set in your Grid Options');
        }
        if (Array.isArray(filters)) {
            // start by clearing all filters (without triggering an event) before applying any new filters
            this.clearFilters(false);
            // pre-fill (value + operator) and render all filters in the DOM
            // loop through each Filters provided (which has a columnId property)
            // then find their associated Filter instances that were originally created in the grid
            filters.forEach(function (newFilter) {
                var uiFilter = _this._filtersMetadata.find(function (filter) { return newFilter.columnId === filter.columnDef.id; });
                if (newFilter && uiFilter) {
                    var newOperator = newFilter.operator || uiFilter.defaultOperator;
                    _this.updateColumnFilters(newFilter.searchTerms, uiFilter.columnDef, newOperator);
                    uiFilter.setValues(newFilter.searchTerms, newOperator);
                }
            });
            var backendApi = this._gridOptions && this._gridOptions.backendServiceApi;
            // refresh the DataView and trigger an event after all filters were updated and rendered
            this._dataView.refresh();
            if (backendApi) {
                var backendApiService = backendApi && backendApi.service;
                if (backendApiService) {
                    backendApiService.updateFilters(filters, true);
                    if (triggerBackendQuery) {
                        refreshBackendDataset(this._gridOptions);
                    }
                }
            }
            if (emitChangedEvent) {
                var emitterType = backendApi ? EmitterType.remote : EmitterType.local;
                this.emitFilterChanged(emitterType);
            }
        }
    };
    // --
    // private functions
    // -------------------
    /** Add all created filters (from their template) to the header row section area */
    FilterService.prototype.addFilterTemplateToHeaderRow = function (args, isFilterFirstRender) {
        if (isFilterFirstRender === void 0) { isFilterFirstRender = true; }
        var columnDef = args.column;
        var columnId = columnDef && columnDef.id || '';
        if (columnDef && columnId !== 'selector' && columnDef.filterable) {
            var searchTerms = void 0;
            var operator = void 0;
            var newFilter_1 = this.filterFactory.createFilter(args.column.filter);
            operator = (columnDef && columnDef.filter && columnDef.filter.operator) || (newFilter_1 && newFilter_1.operator) || undefined;
            if (this._columnFilters[columnDef.id]) {
                searchTerms = this._columnFilters[columnDef.id].searchTerms || undefined;
                operator = this._columnFilters[columnDef.id].operator || undefined;
            }
            else if (columnDef.filter) {
                // when hiding/showing (with Column Picker or Grid Menu), it will try to re-create yet again the filters (since SlickGrid does a re-render)
                // because of that we need to first get searchTerm(s) from the columnFilters (that is what the user last typed in a filter search input)
                searchTerms = columnDef.filter.searchTerms || undefined;
                this.updateColumnFilters(searchTerms, columnDef, operator);
            }
            var filterArguments = {
                grid: this._grid,
                operator: operator,
                searchTerms: searchTerms,
                columnDef: columnDef,
                callback: this.callbackSearchEvent.bind(this)
            };
            if (newFilter_1) {
                newFilter_1.init(filterArguments, isFilterFirstRender);
                var filterExistIndex = this._filtersMetadata.findIndex(function (filter) { return newFilter_1.columnDef.id === filter.columnDef.id; });
                // add to the filters arrays or replace it when found
                if (filterExistIndex === -1) {
                    this._filtersMetadata.push(newFilter_1);
                }
                else {
                    this._filtersMetadata[filterExistIndex] = newFilter_1;
                }
                // when hiding/showing (with Column Picker or Grid Menu), it will try to re-create yet again the filters (since SlickGrid does a re-render)
                // we need to also set again the values in the DOM elements if the values were set by a searchTerm(s)
                if (searchTerms && newFilter_1.setValues) {
                    newFilter_1.setValues(searchTerms);
                }
            }
        }
    };
    /**
     * Callback method that is called and executed by the individual Filter (DOM element),
     * for example when user type in a word to search (which uses InputFilter), this Filter will execute the callback from a keyup event.
     */
    FilterService.prototype.callbackSearchEvent = function (event, args) {
        if (args) {
            var searchTerm = ((event && event.target) ? event.target.value : undefined);
            var searchTerms = (args.searchTerms && Array.isArray(args.searchTerms)) ? args.searchTerms : (searchTerm ? [searchTerm] : undefined);
            var columnDef = args.columnDef || null;
            var columnId = columnDef && columnDef.id || '';
            var operator = args.operator || undefined;
            var hasSearchTerms = searchTerms && Array.isArray(searchTerms);
            var termsCount = hasSearchTerms && searchTerms && searchTerms.length;
            var oldColumnFilters = tslib_1.__assign({}, this._columnFilters);
            if (columnDef && columnId) {
                if (!hasSearchTerms || termsCount === 0 || (termsCount === 1 && Array.isArray(searchTerms) && searchTerms[0] === '')) {
                    // delete the property from the columnFilters when it becomes empty
                    // without doing this, it would leave an incorrect state of the previous column filters when filtering on another column
                    delete this._columnFilters[columnId];
                }
                else {
                    var colId = '' + columnId;
                    var colFilter = {
                        columnId: colId,
                        columnDef: columnDef,
                        searchTerms: searchTerms,
                    };
                    if (operator) {
                        colFilter.operator = operator;
                    }
                    this._columnFilters[colId] = colFilter;
                }
            }
            // event might have been created as a CustomEvent (e.g. CompoundDateFilter), without being a valid Slick.EventData,
            // if so we will create a new Slick.EventData and merge it with that CustomEvent to avoid having SlickGrid errors
            var eventData = (event && typeof event.isPropagationStopped !== 'function') ? $.extend({}, new Slick.EventData(), event) : event;
            // trigger an event only if Filters changed or if ENTER key was pressed
            var eventKeyCode = event && event.keyCode;
            if (eventKeyCode === KeyCode.ENTER || !isequal(oldColumnFilters, this._columnFilters)) {
                this._onSearchChange.notify({
                    clearFilterTriggered: args.clearFilterTriggered,
                    shouldTriggerQuery: args.shouldTriggerQuery,
                    columnId: columnId,
                    columnDef: columnDef,
                    columnFilters: this._columnFilters,
                    operator: operator,
                    searchTerms: searchTerms,
                    grid: this._grid
                }, eventData);
            }
        }
    };
    FilterService.prototype.updateColumnFilters = function (searchTerms, columnDef, operator) {
        if (searchTerms && columnDef) {
            this._columnFilters[columnDef.id] = {
                columnId: columnDef.id,
                columnDef: columnDef,
                searchTerms: searchTerms,
                operator: operator
            };
        }
    };
    FilterService = tslib_1.__decorate([
        Injectable(),
        tslib_1.__metadata("design:paramtypes", [FilterFactory, SharedService])
    ], FilterService);
    return FilterService;
}());
export { FilterService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsdGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyLXNsaWNrZ3JpZC8iLCJzb3VyY2VzIjpbImFwcC9tb2R1bGVzL2FuZ3VsYXItc2xpY2tncmlkL3NlcnZpY2VzL2ZpbHRlci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxZQUFZLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBRTdDLE9BQU8sS0FBSyxRQUFRLE1BQU0sZ0JBQWdCLENBQUM7QUFDM0MsSUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLENBQUMsOEJBQThCO0FBRXhELE9BQU8sRUFLTCxXQUFXLEVBQ1gsU0FBUyxFQU1ULE9BQU8sRUFFUCxZQUFZLEdBSWIsTUFBTSxtQkFBbUIsQ0FBQztBQUMzQixPQUFPLEVBQUUsc0JBQXNCLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUNwRixPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDcEQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDMUQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ3pELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQU1qRCwrQ0FBK0M7QUFDL0MsSUFBSSxLQUFVLENBQUM7QUFDZixJQUFNLDhCQUE4QixHQUFHLEdBQUcsQ0FBQztBQUczQztJQWFFLHVCQUFvQixhQUE0QixFQUFVLGFBQTRCO1FBQWxFLGtCQUFhLEdBQWIsYUFBYSxDQUFlO1FBQVUsa0JBQWEsR0FBYixhQUFhLENBQWU7UUFYOUUseUJBQW9CLEdBQUcsSUFBSSxDQUFDO1FBQzVCLDJCQUFzQixHQUFHLEVBQUUsQ0FBQztRQUM1QixxQkFBZ0IsR0FBVSxFQUFFLENBQUM7UUFDN0IsbUJBQWMs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dGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgaXNPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XHJcblxyXG5pbXBvcnQgKiBhcyBpc2VxdWFsXyBmcm9tICdsb2Rhc2guaXNlcXVhbCc7XHJcbmNvbnN0IGlzZXF1YWwgPSBpc2VxdWFsXzsgLy8gcGF0Y2ggdG8gZml4IHJvbGx1cCB0byB3b3JrXHJcblxyXG5pbXBvcnQge1xyXG4gIENvbHVtbixcclxuICBDb2x1bW5GaWx0ZXIsXHJcbiAgQ29sdW1uRmlsdGVycyxcclxuICBDdXJyZW50RmlsdGVyLFxyXG4gIEVtaXR0ZXJUeXBlLFxyXG4gIEZpZWxkVHlwZSxcclxuICBGaWx0ZXIsXHJcbiAgRmlsdGVyQXJndW1lbnRzLFxyXG4gIEZpbHRlckNhbGxiYWNrQXJnLFxyXG4gIEZpbHRlckNoYW5nZWRBcmdzLFxyXG4gIEdyaWRPcHRpb24sXHJcbiAgS2V5Q29kZSxcclxuICBPcGVyYXRvclN0cmluZyxcclxuICBPcGVyYXRvclR5cGUsXHJcbiAgU2VhcmNoVGVybSxcclxuICBTbGlja0V2ZW50LFxyXG4gIFNsaWNrRXZlbnRIYW5kbGVyLFxyXG59IGZyb20gJy4vLi4vbW9kZWxzL2luZGV4JztcclxuaW1wb3J0IHsgZXhlY3V0ZUJhY2tlbmRDYWxsYmFjaywgcmVmcmVzaEJhY2tlbmREYXRhc2V0IH0gZnJvbSAnLi9iYWNrZW5kLXV0aWxpdGllcyc7XHJcbmltcG9ydCB7IGdldERlc2NlbmRhbnRQcm9wZXJ0eSB9IGZyb20gJy4vdXRpbGl0aWVzJztcclxuaW1wb3J0IHsgRmlsdGVyQ29uZGl0aW9ucyB9IGZyb20gJy4vLi4vZmlsdGVyLWNvbmRpdGlvbnMnO1xyXG5pbXBvcnQgeyBGaWx0ZXJGYWN0b3J5IH0gZnJvbSAnLi4vZmlsdGVycy9maWx0ZXJGYWN0b3J5JztcclxuaW1wb3J0IHsgU2hhcmVkU2VydmljZSB9IGZyb20gJy4vc2hhcmVkLnNlcnZpY2UnO1xyXG5cclxuLy8gdXNpbmcgZXh0ZXJuYWwgbm9uLXR5cGVkIGpzIGxpYnJhcmllc1xyXG5kZWNsYXJlIHZhciBTbGljazogYW55O1xyXG5kZWNsYXJlIHZhciAkOiBhbnk7XHJcblxyXG4vLyB0aW1lciBmb3Iga2VlcGluZyB0cmFjayBvZiB1c2VyIHR5cGluZyB3YWl0c1xyXG5sZXQgdGltZXI6IGFueTtcclxuY29uc3QgREVGQVVMVF9GSUxURVJfVFlQSU5HX0RFQk9VTkNFID0gNTAwO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgRmlsdGVyU2VydmljZSB7XHJcbiAgcHJpdmF0ZSBfZXZlbnRIYW5kbGVyOiBTbGlja0V2ZW50SGFuZGxlcjtcclxuICBwcml2YXRlIF9pc0ZpbHRlckZpcnN0UmVuZGVyID0gdHJ1ZTtcclxuICBwcml2YXRlIF9maXJzdENvbHVtbklkUmVuZGVyZWQgPSAnJztcclxuICBwcml2YXRlIF9maWx0ZXJzTWV0YWRhdGE6IGFueVtdID0gW107XHJcbiAgcHJpdmF0ZSBfY29sdW1uRmlsdGVyczogQ29sdW1uRmlsdGVycyA9IHt9O1xyXG4gIHByaXZhdGUgX2RhdGFWaWV3OiBhbnk7XHJcbiAgcHJpdmF0ZSBfZ3JpZDogYW55O1xyXG4gIHByaXZhdGUgX29uU2VhcmNoQ2hhbmdlOiBTbGlja0V2ZW50O1xyXG4gIHByaXZhdGUgaHR0cENhbmNlbFJlcXVlc3RzJDogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7IC8vIHRoaXMgd2lsbCBiZSB1c2VkIHRvIGNhbmNlbCBhbnkgcGVuZGluZyBodHRwIHJlcXVlc3RcclxuICBvbkZpbHRlckNoYW5nZWQgPSBuZXcgU3ViamVjdDxDdXJyZW50RmlsdGVyW10+KCk7XHJcbiAgb25GaWx0ZXJDbGVhcmVkID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBmaWx0ZXJGYWN0b3J5OiBGaWx0ZXJGYWN0b3J5LCBwcml2YXRlIHNoYXJlZFNlcnZpY2U6IFNoYXJlZFNlcnZpY2UpIHtcclxuICAgIHRoaXMuX2V2ZW50SGFuZGxlciA9IG5ldyBTbGljay5FdmVudEhhbmRsZXIoKTtcclxuICAgIHRoaXMuX29uU2VhcmNoQ2hhbmdlID0gbmV3IFNsaWNrLkV2ZW50KCk7XHJcbiAgfVxyXG5cclxuICAvKiogR2V0dGVyIG9mIHRoZSBTbGlja0dyaWQgRXZlbnQgSGFuZGxlciAqL1xyXG4gIGdldCBldmVudEhhbmRsZXIoKTogU2xpY2tFdmVudEhhbmRsZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuX2V2ZW50SGFuZGxlcjtcclxuICB9XHJcblxyXG4gIC8qKiBHZXR0ZXIgdG8ga25vdyBpZiB0aGUgZmlsdGVyIHdhcyBhbHJlYWR5IHJlbmRlcmVkIG9yIGlmIGl0IHdhcyBpdHMgZmlyc3QgdGltZSByZW5kZXIgKi9cclxuICBnZXQgaXNGaWx0ZXJGaXJzdFJlbmRlcigpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLl9pc0ZpbHRlckZpcnN0UmVuZGVyO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBvZiB0aGUgU2xpY2tHcmlkIEV2ZW50IEhhbmRsZXIgKi9cclxuICBnZXQgb25TZWFyY2hDaGFuZ2UoKTogU2xpY2tFdmVudCB7XHJcbiAgICByZXR1cm4gdGhpcy5fb25TZWFyY2hDaGFuZ2U7XHJcbiAgfVxyXG5cclxuICAvKiogR2V0dGVyIGZvciB0aGUgR3JpZCBPcHRpb25zIHB1bGxlZCB0aHJvdWdoIHRoZSBHcmlkIE9iamVjdCAqL1xyXG4gIHByaXZhdGUgZ2V0IF9ncmlkT3B0aW9ucygpOiBHcmlkT3B0aW9uIHtcclxuICAgIHJldHVybiAodGhpcy5fZ3JpZCAmJiB0aGlzLl9ncmlkLmdldE9wdGlvbnMpID8gdGhpcy5fZ3JpZC5nZXRPcHRpb25zKCkgOiB7fTtcclxuICB9XHJcblxyXG4gIC8qKiBHZXR0ZXIgZm9yIHRoZSBDb2x1bW4gRGVmaW5pdGlvbnMgcHVsbGVkIHRocm91Z2ggdGhlIEdyaWQgT2JqZWN0ICovXHJcbiAgcHJpdmF0ZSBnZXQgX2NvbHVtbkRlZmluaXRpb25zKCk6IENvbHVtbltdIHtcclxuICAgIHJldHVybiAodGhpcy5fZ3JpZCAmJiB0aGlzLl9ncmlkLmdldENvbHVtbnMpID8gdGhpcy5fZ3JpZC5nZXRDb2x1bW5zKCkgOiBbXTtcclxuICB9XHJcblxyXG4gIGluaXQoZ3JpZDogYW55KTogdm9pZCB7XHJcbiAgICB0aGlzLl9ncmlkID0gZ3JpZDtcclxuICB9XHJcblxyXG4gIGRpc3Bvc2UoKSB7XHJcbiAgICB0aGlzLmRpc3Bvc2VDb2x1bW5GaWx0ZXJzKCk7XHJcblxyXG4gICAgLy8gdW5zdWJzY3JpYmUgYWxsIFNsaWNrR3JpZCBldmVudHNcclxuICAgIGlmICh0aGlzLl9ldmVudEhhbmRsZXIgJiYgdGhpcy5fZXZlbnRIYW5kbGVyLnVuc3Vic2NyaWJlQWxsKSB7XHJcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlci51bnN1YnNjcmliZUFsbCgpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzT2JzZXJ2YWJsZSh0aGlzLmh0dHBDYW5jZWxSZXF1ZXN0cyQpKSB7XHJcbiAgICAgIHRoaXMuaHR0cENhbmNlbFJlcXVlc3RzJC5uZXh0KCk7IC8vIHRoaXMgY2FuY2VscyBhbnkgcGVuZGluZyBodHRwIHJlcXVlc3RzXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEaXNwb3NlIG9mIHRoZSBmaWx0ZXJzLCBzaW5jZSBpdCdzIGEgc2luZ2xldG9uLCB3ZSBkb24ndCB3YW50IHRvIGFmZmVjdCBvdGhlciBncmlkcyB3aXRoIHNhbWUgY29sdW1uc1xyXG4gICAqL1xyXG4gIGRpc3Bvc2VDb2x1bW5GaWx0ZXJzKCkge1xyXG4gICAgLy8gd2UgbmVlZCB0byBsb29wIHRocm91Z2ggYWxsIGNvbHVtbkZpbHRlcnMgYW5kIGRlbGV0ZSB0aGVtIDEgYnkgMVxyXG4gICAgLy8gb25seSB0cnlpbmcgdG8gbWFrZSBjb2x1bW5GaWx0ZXIgYW4gZW1wdHkgKHdpdGhvdXQgbG9vcGluZykgd291bGQgbm90IHRyaWdnZXIgYSBkYXRhc2V0IGNoYW5nZVxyXG4gICAgaWYgKHR5cGVvZiB0aGlzLl9jb2x1bW5GaWx0ZXJzID09PSAnb2JqZWN0Jykge1xyXG4gICAgICBmb3IgKGNvbnN0IGNvbHVtbklkIGluIHRoaXMuX2NvbHVtbkZpbHRlcnMpIHtcclxuICAgICAgICBpZiAoY29sdW1uSWQgJiYgdGhpcy5fY29sdW1uRmlsdGVyc1tjb2x1bW5JZF0pIHtcclxuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jb2x1bW5GaWx0ZXJzW2NvbHVtbklkXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBhbHNvIGRlc3Ryb3kgZWFjaCBGaWx0ZXIgaW5zdGFuY2VzXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLl9maWx0ZXJzTWV0YWRhdGEpKSB7XHJcbiAgICAgIHRoaXMuX2ZpbHRlcnNNZXRhZGF0YS5mb3JFYWNoKChmaWx0ZXIpID0+IHtcclxuICAgICAgICBpZiAoZmlsdGVyICYmIGZpbHRlci5kZXN0cm95KSB7XHJcbiAgICAgICAgICBmaWx0ZXIuZGVzdHJveSh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQmluZCBhIGJhY2tlbmQgZmlsdGVyIGhvb2sgdG8gdGhlIGdyaWRcclxuICAgKiBAcGFyYW0gZ3JpZCBTbGlja0dyaWQgR3JpZCBvYmplY3RcclxuICAgKi9cclxuICBiaW5kQmFja2VuZE9uRmlsdGVyKGdyaWQ6IGFueSwgZGF0YVZpZXc6IGFueSkge1xyXG4gICAgdGhpcy5fZGF0YVZpZXcgPSBkYXRhVmlldztcclxuICAgIHRoaXMuX2ZpbHRlcnNNZXRhZGF0YSA9IFtdO1xyXG5cclxuICAgIC8vIHN1YnNjcmliZSB0byBTbGlja0dyaWQgb25IZWFkZXJSb3dDZWxsUmVuZGVyZWQgZXZlbnQgdG8gY3JlYXRlIGZpbHRlciB0ZW1wbGF0ZVxyXG4gICAgdGhpcy5fZXZlbnRIYW5kbGVyLnN1YnNjcmliZShncmlkLm9uSGVhZGVyUm93Q2VsbFJlbmRlcmVkLCAoZTogS2V5Ym9hcmRFdmVudCwgYXJnczogYW55KSA9PiB7XHJcbiAgICAgIC8vIGZpcnN0Q29sdW1uSWRSZW5kZXJlZCBpcyBudWxsIGF0IGZpcnN0LCBzbyBpZiBpdCBjaGFuZ2VzIHRvIGJlaW5nIGZpbGxlZCBhbmQgZXF1YWwsIHRoZW4gd2Ugd291bGQga25vdyB0aGF0IGl0IHdhcyBhbHJlYWR5IHJlbmRlcmVkXHJcbiAgICAgIC8vIHRoaXMgaXMgdG8gYXZvaWQgcmVuZGVyaW5nIHRoZSBmaWx0ZXIgdHdpY2UgKG9ubHkgdGhlIFNlbGVjdCBGaWx0ZXIgZm9yIG5vdyksIHJlbmRlcmluZyBpdCBhZ2FpbiBhbHNvIGNsZWFycyB0aGUgZmlsdGVyIHdoaWNoIGhhcyB1bndhbnRlZCBzaWRlIGVmZmVjdFxyXG4gICAgICBpZiAoYXJncy5jb2x1bW4uaWQgPT09IHRoaXMuX2ZpcnN0Q29sdW1uSWRSZW5kZXJlZCkge1xyXG4gICAgICAgIHRoaXMuX2lzRmlsdGVyRmlyc3RSZW5kZXIgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmFkZEZpbHRlclRlbXBsYXRlVG9IZWFkZXJSb3coYXJncywgdGhpcy5faXNGaWx0ZXJGaXJzdFJlbmRlcik7XHJcbiAgICAgIGlmICh0aGlzLl9maXJzdENvbHVtbklkUmVuZGVyZWQgPT09ICcnKSB7XHJcbiAgICAgICAgdGhpcy5fZmlyc3RDb2x1bW5JZFJlbmRlcmVkID0gYXJncy5jb2x1bW4uaWQ7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHN1YnNjcmliZSB0byB0aGUgU2xpY2tHcmlkIGV2ZW50IGFuZCBjYWxsIHRoZSBiYWNrZW5kIGV4ZWN1dGlvblxyXG4gICAgdGhpcy5fZXZlbnRIYW5kbGVyLnN1YnNjcmliZSh0aGlzLl9vblNlYXJjaENoYW5nZSwgdGhpcy5vbkJhY2tlbmRGaWx0ZXJDaGFuZ2UuYmluZCh0aGlzKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCaW5kIGEgbG9jYWwgZmlsdGVyIGhvb2sgdG8gdGhlIGdyaWRcclxuICAgKiBAcGFyYW0gZ3JpZCBTbGlja0dyaWQgR3JpZCBvYmplY3RcclxuICAgKiBAcGFyYW0gZGF0YVZpZXdcclxuICAgKi9cclxuICBiaW5kTG9jYWxPbkZpbHRlcihncmlkOiBhbnksIGRhdGFWaWV3OiBhbnkpIHtcclxuICAgIHRoaXMuX2ZpbHRlcnNNZXRhZGF0YSA9IFtdO1xyXG4gICAgdGhpcy5fZGF0YVZpZXcgPSBkYXRhVmlldztcclxuXHJcbiAgICBkYXRhVmlldy5zZXRGaWx0ZXJBcmdzKHsgY29sdW1uRmlsdGVyczogdGhpcy5fY29sdW1uRmlsdGVycywgZ3JpZDogdGhpcy5fZ3JpZCwgZGF0YVZpZXcgfSk7XHJcbiAgICBkYXRhVmlldy5zZXRGaWx0ZXIodGhpcy5jdXN0b21Mb2NhbEZpbHRlci5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICB0aGlzLl9ldmVudEhhbmRsZXIuc3Vic2NyaWJlKHRoaXMuX29uU2VhcmNoQ2hhbmdlLCAoZTogS2V5Ym9hcmRFdmVudCwgYXJnczogYW55KSA9PiB7XHJcbiAgICAgIGNvbnN0IGNvbHVtbklkID0gYXJncy5jb2x1bW5JZDtcclxuICAgICAgaWYgKGNvbHVtbklkICE9IG51bGwpIHtcclxuICAgICAgICBkYXRhVmlldy5yZWZyZXNoKCk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gZW1pdCBhbiBvbkZpbHRlckNoYW5nZWQgZXZlbnQgd2hlbiBpdCdzIG5vdCBjYWxsZWQgYnkgYSBjbGVhciBmaWx0ZXJcclxuICAgICAgaWYgKGFyZ3MgJiYgIWFyZ3MuY2xlYXJGaWx0ZXJUcmlnZ2VyZWQpIHtcclxuICAgICAgICB0aGlzLmVtaXRGaWx0ZXJDaGFuZ2VkKEVtaXR0ZXJUeXBlLmxvY2FsKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gc3Vic2NyaWJlIHRvIFNsaWNrR3JpZCBvbkhlYWRlclJvd0NlbGxSZW5kZXJlZCBldmVudCB0byBjcmVhdGUgZmlsdGVyIHRlbXBsYXRlXHJcbiAgICB0aGlzLl9ldmVudEhhbmRsZXIuc3Vic2NyaWJlKGdyaWQub25IZWFkZXJSb3dDZWxsUmVuZGVyZWQsIChlOiBLZXlib2FyZEV2ZW50LCBhcmdzOiBhbnkpID0+IHtcclxuICAgICAgdGhpcy5hZGRGaWx0ZXJUZW1wbGF0ZVRvSGVhZGVyUm93KGFyZ3MpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBjbGVhckZpbHRlckJ5Q29sdW1uSWQoZXZlbnQ6IEV2ZW50LCBjb2x1bW5JZDogbnVtYmVyIHwgc3RyaW5nKSB7XHJcbiAgICAvLyBnZXQgY3VycmVudCBjb2x1bW4gZmlsdGVyIGJlZm9yZSBjbGVhcmluZywgdGhpcyBhbGxvdyB1cyB0byBrbm93IGlmIHRoZSBmaWx0ZXIgd2FzIGVtcHR5IHByaW9yIHRvIGNhbGxpbmcgdGhlIGNsZWFyIGZpbHRlclxyXG4gICAgY29uc3QgY3VycmVudENvbHVtbkZpbHRlcnMgPSBPYmplY3Qua2V5cyh0aGlzLl9jb2x1bW5GaWx0ZXJzKSBhcyBDb2x1bW5GaWx0ZXJbXTtcclxuICAgIGxldCBjdXJyZW50Q29sRmlsdGVyOiBDb2x1bW5GaWx0ZXI7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50Q29sdW1uRmlsdGVycykpIHtcclxuICAgICAgY3VycmVudENvbEZpbHRlciA9IGN1cnJlbnRDb2x1bW5GaWx0ZXJzLmZpbmQoKG5hbWUpID0+IG5hbWUgPT09IGNvbHVtbklkKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBmaW5kIHRoZSBmaWx0ZXIgb2JqZWN0IGFuZCBjYWxsIGl0cyBjbGVhciBtZXRob2Qgd2l0aCB0cnVlICh0aGUgYXJndW1lbnQgdGVsbHMgdGhlIG1ldGhvZCBpdCB3YXMgY2FsbGVkIGJ5IGEgY2xlYXIgZmlsdGVyKVxyXG4gICAgY29uc3QgY29sRmlsdGVyOiBGaWx0ZXIgPSB0aGlzLl9maWx0ZXJzTWV0YWRhdGEuZmluZCgoZmlsdGVyOiBGaWx0ZXIpID0+IGZpbHRlci5jb2x1bW5EZWYuaWQgPT09IGNvbHVtbklkKTtcclxuICAgIGlmIChjb2xGaWx0ZXIgJiYgY29sRmlsdGVyLmNsZWFyKSB7XHJcbiAgICAgIGNvbEZpbHRlci5jbGVhcih0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgZW1pdHRlcjogRW1pdHRlclR5cGUgPSBFbWl0dGVyVHlwZS5sb2NhbDtcclxuICAgIGNvbnN0IGlzQmFja2VuZEFwaSA9IHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLmJhY2tlbmRTZXJ2aWNlQXBpIHx8IGZhbHNlO1xyXG5cclxuICAgIC8vIHdoZW4gdXNpbmcgYSBiYWNrZW5kIHNlcnZpY2UsIHdlIG5lZWQgdG8gbWFudWFsbHkgdHJpZ2dlciBhIGZpbHRlciBjaGFuZ2UgYnV0IG9ubHkgaWYgdGhlIGZpbHRlciB3YXMgcHJldmlvdXNseSBmaWxsZWRcclxuICAgIGlmIChpc0JhY2tlbmRBcGkpIHtcclxuICAgICAgZW1pdHRlciA9IEVtaXR0ZXJUeXBlLnJlbW90ZTtcclxuICAgICAgaWYgKGN1cnJlbnRDb2xGaWx0ZXIpIHtcclxuICAgICAgICB0aGlzLm9uQmFja2VuZEZpbHRlckNoYW5nZShldmVudCBhcyBLZXlib2FyZEV2ZW50LCB7IGdyaWQ6IHRoaXMuX2dyaWQsIGNvbHVtbkZpbHRlcnM6IHRoaXMuX2NvbHVtbkZpbHRlcnMgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBlbWl0IGFuIGV2ZW50IHdoZW4gZmlsdGVyIGlzIGNsZWFyZWRcclxuICAgIHRoaXMuZW1pdEZpbHRlckNoYW5nZWQoZW1pdHRlcik7XHJcbiAgfVxyXG5cclxuICAvKiogQ2xlYXIgdGhlIHNlYXJjaCBmaWx0ZXJzIChiZWxvdyB0aGUgY29sdW1uIHRpdGxlcykgKi9cclxuICBjbGVhckZpbHRlcnModHJpZ2dlckNoYW5nZSA9IHRydWUpIHtcclxuICAgIHRoaXMuX2ZpbHRlcnNNZXRhZGF0YS5mb3JFYWNoKChmaWx0ZXI6IEZpbHRlcikgPT4ge1xyXG4gICAgICBpZiAoZmlsdGVyICYmIGZpbHRlci5jbGVhcikge1xyXG4gICAgICAgIC8vIGNsZWFyIGVsZW1lbnQgYnV0IGRvbid0IHRyaWdnZXIgaW5kaXZpZHVhbCBjbGVhciBjaGFuZ2UsXHJcbiAgICAgICAgLy8gd2UnbGwgZG8gMSB0cmlnZ2VyIGZvciBhbGwgZmlsdGVycyBhdCBvbmNlIGFmdGVyd2FyZFxyXG4gICAgICAgIGZpbHRlci5jbGVhcihmYWxzZSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHdlIGFsc28gbmVlZCB0byByZWZyZXNoIHRoZSBkYXRhVmlldyBhbmQgb3B0aW9uYWxseSB0aGUgZ3JpZCAoaXQncyBvcHRpb25hbCBzaW5jZSB3ZSB1c2UgRGF0YVZpZXcpXHJcbiAgICBpZiAodGhpcy5fZGF0YVZpZXcgJiYgdGhpcy5fZ3JpZCkge1xyXG4gICAgICB0aGlzLl9kYXRhVmlldy5yZWZyZXNoKCk7XHJcbiAgICAgIHRoaXMuX2dyaWQuaW52YWxpZGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHdoZW4gdXNpbmcgYmFja2VuZCBzZXJ2aWNlLCB3ZSBuZWVkIHRvIHF1ZXJ5IG9ubHkgb25jZSBzbyBpdCdzIGJldHRlciB0byBkbyBpdCBoZXJlXHJcbiAgICBjb25zdCBiYWNrZW5kQXBpID0gdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuYmFja2VuZFNlcnZpY2VBcGk7XHJcbiAgICBpZiAoYmFja2VuZEFwaSAmJiB0cmlnZ2VyQ2hhbmdlKSB7XHJcbiAgICAgIGNvbnN0IGNhbGxiYWNrQXJncyA9IHsgY2xlYXJGaWx0ZXJUcmlnZ2VyZWQ6IHRydWUsIHNob3VsZFRyaWdnZXJRdWVyeTogdHJpZ2dlckNoYW5nZSwgZ3JpZDogdGhpcy5fZ3JpZCwgY29sdW1uRmlsdGVyczogdGhpcy5fY29sdW1uRmlsdGVycyB9O1xyXG4gICAgICBjb25zdCBxdWVyeVJlc3BvbnNlID0gYmFja2VuZEFwaS5zZXJ2aWNlLnByb2Nlc3NPbkZpbHRlckNoYW5nZWQodW5kZWZpbmVkLCBjYWxsYmFja0FyZ3MgYXMgRmlsdGVyQ2hhbmdlZEFyZ3MpO1xyXG4gICAgICBpZiAocXVlcnlSZXNwb25zZSBpbnN0YW5jZW9mIFByb21pc2UgJiYgcXVlcnlSZXNwb25zZS50aGVuKSB7XHJcbiAgICAgICAgLy8gQGRlcHJlY2F0ZWQsIHByb2Nlc3NPbkZpbHRlckNoYW5nZWQgaW4gdGhlIGZ1dHVyZSBzaG91bGQgYmUgcmV0dXJuZWQgYXMgYSBxdWVyeSBzdHJpbmcgTk9UIGFzIGEgUHJvbWlzZVxyXG4gICAgICAgIGNvbnNvbGUud2FybihgW0FuZ3VsYXItU2xpY2tncmlkXSBwbGVhc2Ugbm90ZSB0aGF0IHRoZSBcInByb2Nlc3NPbkZpbHRlckNoYW5nZWRcIiBmcm9tIHlvdXIgQmFja2VuZCBTZXJ2aWNlLCBzaG91bGQgbm93IHJldHVybiBhIHN0cmluZyBpbnN0ZWFkIG9mIGEgUHJvbWlzZS5cclxuICAgICAgICAgIFJldHVybmluZyBhIFByb21pc2Ugd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUuYCk7XHJcbiAgICAgICAgcXVlcnlSZXNwb25zZS50aGVuKChxdWVyeTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCB0b3RhbEl0ZW1zID0gdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMucGFnaW5hdGlvbiAmJiB0aGlzLl9ncmlkT3B0aW9ucy5wYWdpbmF0aW9uLnRvdGFsSXRlbXM7XHJcbiAgICAgICAgICBleGVjdXRlQmFja2VuZENhbGxiYWNrKGJhY2tlbmRBcGksIHF1ZXJ5LCBjYWxsYmFja0FyZ3MsIG5ldyBEYXRlKCksIHRvdGFsSXRlbXMsIHRoaXMuZW1pdEZpbHRlckNoYW5nZWQuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgcXVlcnkgPSBxdWVyeVJlc3BvbnNlIGFzIHN0cmluZztcclxuICAgICAgICBjb25zdCB0b3RhbEl0ZW1zID0gdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMucGFnaW5hdGlvbiAmJiB0aGlzLl9ncmlkT3B0aW9ucy5wYWdpbmF0aW9uLnRvdGFsSXRlbXM7XHJcbiAgICAgICAgZXhlY3V0ZUJhY2tlbmRDYWxsYmFjayhiYWNrZW5kQXBpLCBxdWVyeSwgY2FsbGJhY2tBcmdzLCBuZXcgRGF0ZSgpLCB0b3RhbEl0ZW1zLCB0aGlzLmVtaXRGaWx0ZXJDaGFuZ2VkLmJpbmQodGhpcykpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZW1pdCBhbiBldmVudCB3aGVuIGZpbHRlcnMgYXJlIGFsbCBjbGVhcmVkXHJcbiAgICBpZiAodHJpZ2dlckNoYW5nZSkge1xyXG4gICAgICB0aGlzLm9uRmlsdGVyQ2xlYXJlZC5uZXh0KHRydWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY3VzdG9tTG9jYWxGaWx0ZXIoaXRlbTogYW55LCBhcmdzOiBhbnkpIHtcclxuICAgIGNvbnN0IGRhdGFWaWV3ID0gYXJncyAmJiBhcmdzLmRhdGFWaWV3O1xyXG4gICAgZm9yIChjb25zdCBjb2x1bW5JZCBvZiBPYmplY3Qua2V5cyhhcmdzLmNvbHVtbkZpbHRlcnMpKSB7XHJcbiAgICAgIGNvbnN0IGNvbHVtbkZpbHRlciA9IGFyZ3MuY29sdW1uRmlsdGVyc1tjb2x1bW5JZF07XHJcbiAgICAgIGxldCBjb2x1bW5JbmRleCA9IGFyZ3MuZ3JpZC5nZXRDb2x1bW5JbmRleChjb2x1bW5JZCk7XHJcbiAgICAgIGxldCBjb2x1bW5EZWYgPSBhcmdzLmdyaWQuZ2V0Q29sdW1ucygpW2NvbHVtbkluZGV4XTtcclxuXHJcbiAgICAgIC8vIGl0IG1pZ2h0IGJlIGEgaGlkZGVuIGNvbHVtbiwgaWYgc28gaXQgd29uJ3QgYmUgcGFydCBvZiB0aGUgZ2V0Q29sdW1ucyAoYmVjYXVzZSBpdCB3ZSBoaWRlIGEgY29sdW1uIHZpYSBzZXRDb2x1bW5zKVxyXG4gICAgICAvLyB3aGVuIHRoYXQgaGFwcGVucyB3ZSBjYW4gdHJ5IHRvIGdldCB0aGUgY29sdW1uIGRlZmluaXRpb24gZnJvbSBhbGwgZGVmaW5lZCBjb2x1bW5zXHJcbiAgICAgIGlmICghY29sdW1uRGVmICYmIHRoaXMuc2hhcmVkU2VydmljZSAmJiBBcnJheS5pc0FycmF5KHRoaXMuc2hhcmVkU2VydmljZS5hbGxDb2x1bW5zKSkge1xyXG4gICAgICAgIGNvbHVtbkluZGV4ID0gdGhpcy5zaGFyZWRTZXJ2aWNlLmFsbENvbHVtbnMuZmluZEluZGV4KChjb2wpID0+IGNvbC5maWVsZCA9PT0gY29sdW1uSWQpO1xyXG4gICAgICAgIGNvbHVtbkRlZiA9IHRoaXMuc2hhcmVkU2VydmljZS5hbGxDb2x1bW5zW2NvbHVtbkluZGV4XTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gaWYgd2Ugc3RpbGwgZG9uJ3QgaGF2ZSBhIGNvbHVtbiBkZWZpbml0aW9uIHRoZW4gd2Ugc2hvdWxkIHJldHVybiB0aGVuIHJvdyBhbnl3YXkgKHRydWUpXHJcbiAgICAgIGlmICghY29sdW1uRGVmKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJvdyBEZXRhaWwgVmlldyBwbHVnaW4sIGlmIHRoZSByb3cgaXMgcGFkZGluZyB3ZSBqdXN0IGdldCB0aGUgdmFsdWUgd2UncmUgZmlsdGVyaW5nIG9uIGZyb20gaXQncyBwYXJlbnRcclxuICAgICAgaWYgKHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZVJvd0RldGFpbFZpZXcpIHtcclxuICAgICAgICBjb25zdCBtZXRhZGF0YVByZWZpeCA9IHRoaXMuX2dyaWRPcHRpb25zLnJvd0RldGFpbFZpZXcgJiYgdGhpcy5fZ3JpZE9wdGlvbnMucm93RGV0YWlsVmlldy5rZXlQcmVmaXggfHwgJ19fJztcclxuICAgICAgICBpZiAoaXRlbVtgJHttZXRhZGF0YVByZWZpeH1pc1BhZGRpbmdgXSAmJiBpdGVtW2Ake21ldGFkYXRhUHJlZml4fXBhcmVudGBdKSB7XHJcbiAgICAgICAgICBpdGVtID0gaXRlbVtgJHttZXRhZGF0YVByZWZpeH1wYXJlbnRgXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGRhdGFLZXkgPSBjb2x1bW5EZWYuZGF0YUtleTtcclxuICAgICAgY29uc3QgZmllbGROYW1lID0gY29sdW1uRGVmLnF1ZXJ5RmllbGRGaWx0ZXIgfHwgY29sdW1uRGVmLnF1ZXJ5RmllbGQgfHwgY29sdW1uRGVmLmZpZWxkO1xyXG4gICAgICBjb25zdCBmaWVsZFR5cGUgPSBjb2x1bW5EZWYudHlwZSB8fCBGaWVsZFR5cGUuc3RyaW5nO1xyXG4gICAgICBjb25zdCBmaWx0ZXJTZWFyY2hUeXBlID0gKGNvbHVtbkRlZi5maWx0ZXJTZWFyY2hUeXBlKSA/IGNvbHVtbkRlZi5maWx0ZXJTZWFyY2hUeXBlIDogbnVsbDtcclxuICAgICAgbGV0IGNlbGxWYWx1ZSA9IGl0ZW1bZmllbGROYW1lXTtcclxuXHJcbiAgICAgIC8vIHdoZW4gaXRlbSBpcyBhIGNvbXBsZXggb2JqZWN0IChkb3QgXCIuXCIgbm90YXRpb24pLCB3ZSBuZWVkIHRvIGZpbHRlciB0aGUgdmFsdWUgY29udGFpbmVkIGluIHRoZSBvYmplY3QgdHJlZVxyXG4gICAgICBpZiAoZmllbGROYW1lLmluZGV4T2YoJy4nKSA+PSAwKSB7XHJcbiAgICAgICAgY2VsbFZhbHVlID0gZ2V0RGVzY2VuZGFudFByb3BlcnR5KGl0ZW0sIGZpZWxkTmFtZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGlmIHdlIGZpbmQgc2VhcmNoVGVybXMgdXNlIHRoZW0gYnV0IG1ha2UgYSBkZWVwIGNvcHkgc28gdGhhdCB3ZSBkb24ndCBhZmZlY3Qgb3JpZ2luYWwgYXJyYXlcclxuICAgICAgLy8gd2UgbWlnaHQgaGF2ZSB0byBvdmVyd3JpdGUgdGhlIHZhbHVlKHMpIGxvY2FsbHkgdGhhdCBhcmUgcmV0dXJuZWRcclxuICAgICAgLy8gZS5nOiB3ZSBkb24ndCB3YW50IHRvIG9wZXJhdG9yIHdpdGhpbiB0aGUgc2VhcmNoIHZhbHVlLCBzaW5jZSBpdCB3aWxsIGZhaWwgZmlsdGVyIGNvbmRpdGlvbiBjaGVjayB0cmlnZ2VyIGFmdGVyd2FyZFxyXG4gICAgICBjb25zdCBzZWFyY2hWYWx1ZXMgPSAoY29sdW1uRmlsdGVyICYmIGNvbHVtbkZpbHRlci5zZWFyY2hUZXJtcykgPyAkLmV4dGVuZCh0cnVlLCBbXSwgY29sdW1uRmlsdGVyLnNlYXJjaFRlcm1zKSA6IG51bGw7XHJcblxyXG4gICAgICBsZXQgZmllbGRTZWFyY2hWYWx1ZSA9IChBcnJheS5pc0FycmF5KHNlYXJjaFZhbHVlcykgJiYgc2VhcmNoVmFsdWVzLmxlbmd0aCA9PT0gMSkgPyBzZWFyY2hWYWx1ZXNbMF0gOiAnJztcclxuXHJcbiAgICAgIGxldCBtYXRjaGVzID0gbnVsbDtcclxuICAgICAgaWYgKGZpZWxkVHlwZSAhPT0gRmllbGRUeXBlLm9iamVjdCkge1xyXG4gICAgICAgIGZpZWxkU2VhcmNoVmFsdWUgPSAnJyArIGZpZWxkU2VhcmNoVmFsdWU7IC8vIG1ha2Ugc3VyZSBpdCdzIGEgc3RyaW5nXHJcbiAgICAgICAgbWF0Y2hlcyA9IGZpZWxkU2VhcmNoVmFsdWUubWF0Y2goL14oWzw+IT1cXCpdezAsMn0pKC4qW148PiE9XFwqXSkoW1xcKl0/KSQvKTsgLy8gZ3JvdXAgMTogT3BlcmF0b3IsIDI6IHNlYXJjaFZhbHVlLCAzOiBsYXN0IGNoYXIgaXMgJyonIChtZWFuaW5nIHN0YXJ0cyB3aXRoLCBleC46IGFiYyopXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBvcGVyYXRvciA9IGNvbHVtbkZpbHRlci5vcGVyYXRvciB8fCAoKG1hdGNoZXMpID8gbWF0Y2hlc1sxXSA6ICcnKTtcclxuICAgICAgY29uc3Qgc2VhcmNoVGVybSA9ICghIW1hdGNoZXMpID8gbWF0Y2hlc1syXSA6ICcnO1xyXG4gICAgICBjb25zdCBsYXN0VmFsdWVDaGFyID0gKCEhbWF0Y2hlcykgPyBtYXRjaGVzWzNdIDogKG9wZXJhdG9yID09PSAnKnonID8gJyonIDogJycpO1xyXG5cclxuICAgICAgaWYgKHNlYXJjaFZhbHVlcyAmJiBzZWFyY2hWYWx1ZXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIGZpZWxkU2VhcmNoVmFsdWUgPSBzZWFyY2hWYWx1ZXMuam9pbignLCcpO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmaWVsZFNlYXJjaFZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIC8vIGVzY2FwaW5nIHRoZSBzZWFyY2ggdmFsdWVcclxuICAgICAgICBmaWVsZFNlYXJjaFZhbHVlID0gZmllbGRTZWFyY2hWYWx1ZS5yZXBsYWNlKGAnYCwgYCcnYCk7IC8vIGVzY2FwZSBzaW5nbGUgcXVvdGVzIGJ5IGRvdWJsaW5nIHRoZW1cclxuICAgICAgICBpZiAob3BlcmF0b3IgPT09ICcqJyB8fCBvcGVyYXRvciA9PT0gJ2EqJyB8fCBvcGVyYXRvciA9PT0gJyp6JyB8fCBsYXN0VmFsdWVDaGFyID09PSAnKicpIHtcclxuICAgICAgICAgIG9wZXJhdG9yID0gKG9wZXJhdG9yID09PSAnKicgfHwgb3BlcmF0b3IgPT09ICcqeicpID8gT3BlcmF0b3JUeXBlLmVuZHNXaXRoIDogT3BlcmF0b3JUeXBlLnN0YXJ0c1dpdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBubyBuZWVkIHRvIHF1ZXJ5IGlmIHNlYXJjaCB2YWx1ZSBpcyBlbXB0eVxyXG4gICAgICBpZiAoc2VhcmNoVGVybSA9PT0gJycgJiYgKCFzZWFyY2hWYWx1ZXMgfHwgKEFycmF5LmlzQXJyYXkoc2VhcmNoVmFsdWVzKSAmJiBzZWFyY2hWYWx1ZXMubGVuZ3RoID09PSAwKSkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gaWYgc2VhcmNoIHZhbHVlIGhhcyBhIHJlZ2V4IG1hdGNoIHdlIHdpbGwgb25seSBrZWVwIHRoZSB2YWx1ZSB3aXRob3V0IHRoZSBvcGVyYXRvclxyXG4gICAgICAvLyBpbiB0aGlzIGNhc2Ugd2UgbmVlZCB0byBvdmVyd3JpdGUgdGhlIHJldHVybmVkIHNlYXJjaCB2YWx1ZXMgdG8gdHJ1bmNhdGUgb3BlcmF0b3IgZnJvbSB0aGUgc3RyaW5nIHNlYXJjaFxyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRjaGVzKSAmJiBtYXRjaGVzLmxlbmd0aCA+PSAxICYmIChBcnJheS5pc0FycmF5KHNlYXJjaFZhbHVlcykgJiYgc2VhcmNoVmFsdWVzLmxlbmd0aCA9PT0gMSkpIHtcclxuICAgICAgICBzZWFyY2hWYWx1ZXNbMF0gPSBzZWFyY2hUZXJtO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBmaWx0ZXIgc2VhcmNoIHRlcm1zIHNob3VsZCBhbHdheXMgYmUgc3RyaW5nIHR5cGUgKGV2ZW4gdGhvdWdoIHdlIHBlcm1pdCB0aGUgZW5kIHVzZXIgdG8gaW5wdXQgbnVtYmVycylcclxuICAgICAgLy8gc28gbWFrZSBzdXJlIGVhY2ggdGVybSBhcmUgc3RyaW5ncywgaWYgdXNlciBoYXMgc29tZSBkZWZhdWx0IHNlYXJjaCB0ZXJtcywgd2Ugd2lsbCBjYXN0IHRoZW0gdG8gc3RyaW5nXHJcbiAgICAgIGlmIChzZWFyY2hWYWx1ZXMgJiYgQXJyYXkuaXNBcnJheShzZWFyY2hWYWx1ZXMpICYmIGZpZWxkVHlwZSAhPT0gRmllbGRUeXBlLm9iamVjdCkge1xyXG4gICAgICAgIGZvciAobGV0IGsgPSAwLCBsbiA9IHNlYXJjaFZhbHVlcy5sZW5ndGg7IGsgPCBsbjsgaysrKSB7XHJcbiAgICAgICAgICAvLyBtYWtlIHN1cmUgYWxsIHNlYXJjaCB0ZXJtcyBhcmUgc3RyaW5nc1xyXG4gICAgICAgICAgc2VhcmNoVmFsdWVzW2tdID0gKChzZWFyY2hWYWx1ZXNba10gPT09IHVuZGVmaW5lZCB8fCBzZWFyY2hWYWx1ZXNba10gPT09IG51bGwpID8gJycgOiBzZWFyY2hWYWx1ZXNba10pICsgJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB3aGVuIHVzaW5nIGxvY2FsaXphdGlvbiAoaTE4biksIHdlIHNob3VsZCB1c2UgdGhlIGZvcm1hdHRlciBvdXRwdXQgdG8gc2VhcmNoIGFzIHRoZSBuZXcgY2VsbCB2YWx1ZVxyXG4gICAgICBpZiAoY29sdW1uRGVmICYmIGNvbHVtbkRlZi5wYXJhbXMgJiYgY29sdW1uRGVmLnBhcmFtcy51c2VGb3JtYXR0ZXJPdXB1dFRvRmlsdGVyKSB7XHJcbiAgICAgICAgY29uc3Qgcm93SW5kZXggPSAoZGF0YVZpZXcgJiYgdHlwZW9mIGRhdGFWaWV3LmdldElkeEJ5SWQgPT09ICdmdW5jdGlvbicpID8gZGF0YVZpZXcuZ2V0SWR4QnlJZChpdGVtLmlkKSA6IDA7XHJcbiAgICAgICAgY2VsbFZhbHVlID0gY29sdW1uRGVmLmZvcm1hdHRlcihyb3dJbmRleCwgY29sdW1uSW5kZXgsIGNlbGxWYWx1ZSwgY29sdW1uRGVmLCBpdGVtLCB0aGlzLl9ncmlkKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gbWFrZSBzdXJlIGNlbGwgdmFsdWUgaXMgYWx3YXlzIGEgc3RyaW5nXHJcbiAgICAgIGlmICh0eXBlb2YgY2VsbFZhbHVlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGNlbGxWYWx1ZSA9IGNlbGxWYWx1ZS50b1N0cmluZygpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBjb25kaXRpb25PcHRpb25zID0ge1xyXG4gICAgICAgIGRhdGFLZXksXHJcbiAgICAgICAgZmllbGRUeXBlLFxyXG4gICAgICAgIHNlYXJjaFRlcm1zOiBzZWFyY2hWYWx1ZXMsXHJcbiAgICAgICAgY2VsbFZhbHVlLFxyXG4gICAgICAgIG9wZXJhdG9yOiBvcGVyYXRvciBhcyBPcGVyYXRvclN0cmluZyxcclxuICAgICAgICBjZWxsVmFsdWVMYXN0Q2hhcjogbGFzdFZhbHVlQ2hhcixcclxuICAgICAgICBmaWx0ZXJTZWFyY2hUeXBlXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBpZiAoIUZpbHRlckNvbmRpdGlvbnMuZXhlY3V0ZU1hcHBlZENvbmRpdGlvbihjb25kaXRpb25PcHRpb25zKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgZ2V0Q29sdW1uRmlsdGVycygpIHtcclxuICAgIHJldHVybiB0aGlzLl9jb2x1bW5GaWx0ZXJzO1xyXG4gIH1cclxuXHJcbiAgZ2V0RmlsdGVyc01ldGFkYXRhKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ZpbHRlcnNNZXRhZGF0YTtcclxuICB9XHJcblxyXG4gIGdldEN1cnJlbnRMb2NhbEZpbHRlcnMoKTogQ3VycmVudEZpbHRlcltdIHtcclxuICAgIGNvbnN0IGN1cnJlbnRGaWx0ZXJzOiBDdXJyZW50RmlsdGVyW10gPSBbXTtcclxuICAgIGlmICh0aGlzLl9jb2x1bW5GaWx0ZXJzKSB7XHJcbiAgICAgIGZvciAoY29uc3QgY29sSWQgb2YgT2JqZWN0LmtleXModGhpcy5fY29sdW1uRmlsdGVycykpIHtcclxuICAgICAgICBjb25zdCBjb2x1bW5GaWx0ZXIgPSB0aGlzLl9jb2x1bW5GaWx0ZXJzW2NvbElkXTtcclxuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7IGNvbHVtbklkOiBjb2xJZCB8fCAnJyB9IGFzIEN1cnJlbnRGaWx0ZXI7XHJcblxyXG4gICAgICAgIGlmIChjb2x1bW5GaWx0ZXIgJiYgY29sdW1uRmlsdGVyLnNlYXJjaFRlcm1zKSB7XHJcbiAgICAgICAgICBmaWx0ZXIuc2VhcmNoVGVybXMgPSBjb2x1bW5GaWx0ZXIuc2VhcmNoVGVybXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb2x1bW5GaWx0ZXIub3BlcmF0b3IpIHtcclxuICAgICAgICAgIGZpbHRlci5vcGVyYXRvciA9IGNvbHVtbkZpbHRlci5vcGVyYXRvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVyLnNlYXJjaFRlcm1zKSAmJiBmaWx0ZXIuc2VhcmNoVGVybXMubGVuZ3RoID4gMCAmJiBmaWx0ZXIuc2VhcmNoVGVybXNbMF0gIT09ICcnKSB7XHJcbiAgICAgICAgICBjdXJyZW50RmlsdGVycy5wdXNoKGZpbHRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3VycmVudEZpbHRlcnM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIHNpbXBsZSBmdW5jdGlvbiB0aGF0IGlzIGJpbmRlZCB0byB0aGUgc3Vic2NyaWJlciBhbmQgZW1pdCBhIGNoYW5nZSB3aGVuIHRoZSBmaWx0ZXIgaXMgY2FsbGVkLlxyXG4gICAqIE90aGVyIHNlcnZpY2VzLCBsaWtlIFBhZ2luYXRpb24sIGNhbiB0aGVuIHN1YnNjcmliZSB0byBpdC5cclxuICAgKiBAcGFyYW0gY2FsbGVyXHJcbiAgICovXHJcbiAgZW1pdEZpbHRlckNoYW5nZWQoY2FsbGVyOiBFbWl0dGVyVHlwZSkge1xyXG4gICAgaWYgKGNhbGxlciA9PT0gRW1pdHRlclR5cGUucmVtb3RlICYmIHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLmJhY2tlbmRTZXJ2aWNlQXBpKSB7XHJcbiAgICAgIGxldCBjdXJyZW50RmlsdGVyczogQ3VycmVudEZpbHRlcltdID0gW107XHJcbiAgICAgIGNvbnN0IGJhY2tlbmRTZXJ2aWNlID0gdGhpcy5fZ3JpZE9wdGlvbnMuYmFja2VuZFNlcnZpY2VBcGkuc2VydmljZTtcclxuICAgICAgaWYgKGJhY2tlbmRTZXJ2aWNlICYmIGJhY2tlbmRTZXJ2aWNlLmdldEN1cnJlbnRGaWx0ZXJzKSB7XHJcbiAgICAgICAgY3VycmVudEZpbHRlcnMgPSBiYWNrZW5kU2VydmljZS5nZXRDdXJyZW50RmlsdGVycygpIGFzIEN1cnJlbnRGaWx0ZXJbXTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm9uRmlsdGVyQ2hhbmdlZC5uZXh0KGN1cnJlbnRGaWx0ZXJzKTtcclxuICAgIH0gZWxzZSBpZiAoY2FsbGVyID09PSBFbWl0dGVyVHlwZS5sb2NhbCkge1xyXG4gICAgICB0aGlzLm9uRmlsdGVyQ2hhbmdlZC5uZXh0KHRoaXMuZ2V0Q3VycmVudExvY2FsRmlsdGVycygpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIG9uQmFja2VuZEZpbHRlckNoYW5nZShldmVudDogS2V5Ym9hcmRFdmVudCwgYXJnczogYW55KSB7XHJcbiAgICBpZiAoIWFyZ3MgfHwgIWFyZ3MuZ3JpZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NvbWV0aGluZyB3ZW50IHdyb25nIHdoZW4gdHJ5aW5nIHRvIGJpbmQgdGhlIFwib25CYWNrZW5kRmlsdGVyQ2hhbmdlKGV2ZW50LCBhcmdzKVwiIGZ1bmN0aW9uLCBpdCBzZWVtcyB0aGF0IFwiYXJnc1wiIGlzIG5vdCBwb3B1bGF0ZWQgY29ycmVjdGx5Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29uc3QgZ3JpZE9wdGlvbnM6IEdyaWRPcHRpb24gPSAoYXJncy5ncmlkICYmIGFyZ3MuZ3JpZC5nZXRPcHRpb25zKSA/IGFyZ3MuZ3JpZC5nZXRPcHRpb25zKCkgOiB7fTtcclxuICAgIGNvbnN0IGJhY2tlbmRBcGkgPSB0aGlzLl9ncmlkT3B0aW9ucy5iYWNrZW5kU2VydmljZUFwaTtcclxuXHJcbiAgICBpZiAoIWJhY2tlbmRBcGkgfHwgIWJhY2tlbmRBcGkucHJvY2VzcyB8fCAhYmFja2VuZEFwaS5zZXJ2aWNlKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQmFja2VuZFNlcnZpY2VBcGkgcmVxdWlyZXMgYXQgbGVhc3QgYSBcInByb2Nlc3NcIiBmdW5jdGlvbiBhbmQgYSBcInNlcnZpY2VcIiBkZWZpbmVkYCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8ga2VlcCBzdGFydCB0aW1lICYgZW5kIHRpbWVzdGFtcHMgJiByZXR1cm4gaXQgYWZ0ZXIgcHJvY2VzcyBleGVjdXRpb25cclxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XHJcblxyXG4gICAgLy8gcnVuIGEgcHJlUHJvY2VzcyBjYWxsYmFjayBpZiBkZWZpbmVkXHJcbiAgICBpZiAoYmFja2VuZEFwaS5wcmVQcm9jZXNzKSB7XHJcbiAgICAgIGJhY2tlbmRBcGkucHJlUHJvY2VzcygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIG9ubHkgYWRkIGEgZGVsYXkgd2hlbiB1c2VyIGlzIHR5cGluZywgb24gc2VsZWN0IGRyb3Bkb3duIGZpbHRlciAob3IgXCJDbGVhciBGaWx0ZXJcIikgaXQgd2lsbCBleGVjdXRlIHJpZ2h0IGF3YXlcclxuICAgIGxldCBkZWJvdW5jZVR5cGluZ0RlbGF5ID0gMDtcclxuICAgIGNvbnN0IGlzVHJpZ2dlcmVkQnlDbGVhckZpbHRlciA9IGFyZ3MgJiYgYXJncy5jbGVhckZpbHRlclRyaWdnZXJlZDsgLy8gd2FzIGl0IHRyaWdnZXIgYnkgYSBcIkNsZWFyIEZpbHRlclwiIGNvbW1hbmQ/XHJcblxyXG4gICAgY29uc3QgZXZlbnRUeXBlID0gZXZlbnQgJiYgZXZlbnQudHlwZTtcclxuICAgIGNvbnN0IGV2ZW50S2V5Q29kZSA9IGV2ZW50ICYmIGV2ZW50LmtleUNvZGU7XHJcbiAgICBpZiAoIWlzVHJpZ2dlcmVkQnlDbGVhckZpbHRlciAmJiBldmVudEtleUNvZGUgIT09IEtleUNvZGUuRU5URVIgJiYgKGV2ZW50VHlwZSA9PT0gJ2lucHV0JyB8fCBldmVudFR5cGUgPT09ICdrZXl1cCcgfHwgZXZlbnRUeXBlID09PSAna2V5ZG93bicpKSB7XHJcbiAgICAgIGRlYm91bmNlVHlwaW5nRGVsYXkgPSBiYWNrZW5kQXBpLmhhc093blByb3BlcnR5KCdmaWx0ZXJUeXBpbmdEZWJvdW5jZScpID8gYmFja2VuZEFwaS5maWx0ZXJUeXBpbmdEZWJvdW5jZSBhcyBudW1iZXIgOiBERUZBVUxUX0ZJTFRFUl9UWVBJTkdfREVCT1VOQ0U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcXVlcnkgYmFja2VuZCwgZXhjZXB0IHdoZW4gaXQncyBjYWxsZWQgYnkgYSBDbGVhckZpbHRlcnMgdGhlbiB3ZSB3b24ndFxyXG4gICAgaWYgKGFyZ3MgJiYgYXJncy5zaG91bGRUcmlnZ2VyUXVlcnkpIHtcclxuICAgICAgLy8gY2FsbCB0aGUgc2VydmljZSB0byBnZXQgYSBxdWVyeSBiYWNrXHJcbiAgICAgIC8vIEBkZXByZWNhdGVkIFRPRE86IHJlbW92ZSBhc3luYy9hd2FpdCBvbiBuZXh0IG1ham9yIGNoYW5nZSwgcmVmZXIgdG8gcHJvY2Vzc09uRmlsdGVyQ2hhbmdlZCBpbiBCYWNrZW5kU2VydmljZSBpbnRlcmZhY2UgKHdpdGggQGRlcHJlY2F0ZWQpXHJcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XHJcbiAgICAgIGlmIChkZWJvdW5jZVR5cGluZ0RlbGF5ID4gMCkge1xyXG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBxdWVyeSA9IGF3YWl0IGJhY2tlbmRBcGkuc2VydmljZS5wcm9jZXNzT25GaWx0ZXJDaGFuZ2VkKGV2ZW50LCBhcmdzKTtcclxuICAgICAgICAgIGNvbnN0IHRvdGFsSXRlbXMgPSB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5wYWdpbmF0aW9uICYmIHRoaXMuX2dyaWRPcHRpb25zLnBhZ2luYXRpb24udG90YWxJdGVtcztcclxuICAgICAgICAgIGV4ZWN1dGVCYWNrZW5kQ2FsbGJhY2soYmFja2VuZEFwaSwgcXVlcnksIGFyZ3MsIHN0YXJ0VGltZSwgdG90YWxJdGVtcywgdGhpcy5lbWl0RmlsdGVyQ2hhbmdlZC5iaW5kKHRoaXMpLCB0aGlzLmh0dHBDYW5jZWxSZXF1ZXN0cyQpO1xyXG4gICAgICAgIH0sIGRlYm91bmNlVHlwaW5nRGVsYXkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gYXdhaXQgYmFja2VuZEFwaS5zZXJ2aWNlLnByb2Nlc3NPbkZpbHRlckNoYW5nZWQoZXZlbnQsIGFyZ3MpO1xyXG4gICAgICAgIGNvbnN0IHRvdGFsSXRlbXMgPSB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5wYWdpbmF0aW9uICYmIHRoaXMuX2dyaWRPcHRpb25zLnBhZ2luYXRpb24udG90YWxJdGVtcztcclxuICAgICAgICBleGVjdXRlQmFja2VuZENhbGxiYWNrKGJhY2tlbmRBcGksIHF1ZXJ5LCBhcmdzLCBzdGFydFRpbWUsIHRvdGFsSXRlbXMsIHRoaXMuZW1pdEZpbHRlckNoYW5nZWQuYmluZCh0aGlzKSwgdGhpcy5odHRwQ2FuY2VsUmVxdWVzdHMkKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogV2hlbiB1c2VyIHBhc3NlcyBhbiBhcnJheSBvZiBwcmVzZXQgZmlsdGVycywgd2UgbmVlZCB0byBwcmUtcG9wdWxhdGUgZWFjaCBjb2x1bW4gZmlsdGVyIHNlYXJjaFRlcm0ocylcclxuICAgKiBUaGUgcHJvY2VzcyBpcyB0byBsb29wIHRocm91Z2ggdGhlIHByZXNldCBmaWx0ZXJzIGFycmF5LCBmaW5kIHRoZSBhc3NvY2lhdGVkIGNvbHVtbiBmcm9tIGNvbHVtbkRlZmluaXRpb25zIGFuZCBmaWxsIGluIHRoZSBmaWx0ZXIgb2JqZWN0IHNlYXJjaFRlcm0ocylcclxuICAgKiBUaGlzIGlzIGJhc2ljYWxseSB0aGUgc2FtZSBhcyBpZiB3ZSB3b3VsZCBtYW51YWxseSBhZGQgc2VhcmNoVGVybShzKSB0byBhIGNvbHVtbiBmaWx0ZXIgb2JqZWN0IGluIHRoZSBjb2x1bW4gZGVmaW5pdGlvbiwgYnV0IHdlIGRvIGl0IHByb2dyYW1tYXRpY2FsbHkuXHJcbiAgICogQXQgdGhlIGVuZCBvZiB0aGUgZGF5LCB3aGVuIGNyZWF0aW5nIHRoZSBGaWx0ZXIgKERPTSBFbGVtZW50KSwgaXQgd2lsbCB1c2UgdGhlc2Ugc2VhcmNoVGVybShzKSBzbyB3ZSBjYW4gdGFrZSBhZHZhbnRhZ2Ugb2YgdGhhdCB3aXRob3V0IHJlY29kaW5nIGVhY2ggRmlsdGVyIHR5cGUgKERPTSBlbGVtZW50KVxyXG4gICAqL1xyXG4gIHBvcHVsYXRlQ29sdW1uRmlsdGVyU2VhcmNoVGVybVByZXNldHMoZmlsdGVyczogQ3VycmVudEZpbHRlcltdKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXJzKSAmJiBmaWx0ZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgdGhpcy5fY29sdW1uRGVmaW5pdGlvbnMuZm9yRWFjaCgoY29sdW1uRGVmOiBDb2x1bW4pID0+IHtcclxuICAgICAgICAvLyBjbGVhciBhbnkgY29sdW1uRGVmIHNlYXJjaFRlcm1zIGJlZm9yZSBhcHBseWluZyBQcmVzZXRzXHJcbiAgICAgICAgaWYgKGNvbHVtbkRlZi5maWx0ZXIgJiYgY29sdW1uRGVmLmZpbHRlci5zZWFyY2hUZXJtcykge1xyXG4gICAgICAgICAgZGVsZXRlIGNvbHVtbkRlZi5maWx0ZXIuc2VhcmNoVGVybXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBmcm9tIGVhY2ggcHJlc2V0cywgd2Ugd2lsbCBmaW5kIHRoZSBhc3NvY2lhdGVkIGNvbHVtbkRlZiBhbmQgYXBwbHkgdGhlIHByZXNldCBzZWFyY2hUZXJtcyAmIG9wZXJhdG9yIGlmIHRoZXJlIGlzXHJcbiAgICAgICAgY29uc3QgY29sdW1uUHJlc2V0ID0gZmlsdGVycy5maW5kKChwcmVzZXRGaWx0ZXI6IEN1cnJlbnRGaWx0ZXIpID0+IHtcclxuICAgICAgICAgIHJldHVybiBwcmVzZXRGaWx0ZXIuY29sdW1uSWQgPT09IGNvbHVtbkRlZi5pZDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoY29sdW1uUHJlc2V0ICYmIGNvbHVtblByZXNldC5zZWFyY2hUZXJtcyAmJiBBcnJheS5pc0FycmF5KGNvbHVtblByZXNldC5zZWFyY2hUZXJtcykpIHtcclxuICAgICAgICAgIGNvbHVtbkRlZi5maWx0ZXIgPSBjb2x1bW5EZWYuZmlsdGVyIHx8IHt9O1xyXG4gICAgICAgICAgY29sdW1uRGVmLmZpbHRlci5vcGVyYXRvciA9IGNvbHVtblByZXNldC5vcGVyYXRvciB8fCBjb2x1bW5EZWYuZmlsdGVyLm9wZXJhdG9yIHx8ICcnO1xyXG4gICAgICAgICAgY29sdW1uRGVmLmZpbHRlci5zZWFyY2hUZXJtcyA9IGNvbHVtblByZXNldC5zZWFyY2hUZXJtcztcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX2NvbHVtbkRlZmluaXRpb25zO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHRoZSBzb3J0IGljb25zIGluIHRoZSBVSSAoT05MWSB0aGUgaWNvbnMsIGl0IGRvZXMgbm90IGRvIGFueSBzb3J0aW5nKVxyXG4gICAqIFRoZSBjb2x1bW4gc29ydCBpY29ucyBhcmUgbm90IG5lY2Vzc2FyaWx5IGludGVyLWNvbm5lY3RlZCB0byB0aGUgc29ydGluZyBmdW5jdGlvbmFsaXR5IGl0c2VsZixcclxuICAgKiB5b3UgY2FuIGNoYW5nZSB0aGUgc29ydGluZyBpY29ucyBzZXBhcmF0ZWx5IGJ5IHBhc3NpbmcgYW4gYXJyYXkgb2YgY29sdW1uSWQvc29ydEFzYyBhbmQgdGhhdCB3aWxsIGNoYW5nZSBPTkxZIHRoZSBpY29uc1xyXG4gICAqIEBwYXJhbSBzb3J0Q29sdW1uc1xyXG4gICAqL1xyXG4gIHNldFNvcnRDb2x1bW5JY29ucyhzb3J0Q29sdW1uczogeyBjb2x1bW5JZDogc3RyaW5nLCBzb3J0QXNjOiBib29sZWFuIH1bXSkge1xyXG4gICAgaWYgKHRoaXMuX2dyaWQgJiYgQXJyYXkuaXNBcnJheShzb3J0Q29sdW1ucykpIHtcclxuICAgICAgdGhpcy5fZ3JpZC5zZXRTb3J0Q29sdW1ucyhzb3J0Q29sdW1ucyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgRmlsdGVycyBkeW5hbWljYWxseSBqdXN0IGJ5IHByb3ZpZGluZyBhbiBhcnJheSBvZiBmaWx0ZXIocykuXHJcbiAgICogWW91IGNhbiBhbHNvIGNob29zZSBlbWl0IChkZWZhdWx0KSBhIEZpbHRlciBDaGFuZ2VkIGV2ZW50IHRoYXQgd2lsbCBiZSBwaWNrZWQgYnkgdGhlIEdyaWQgU3RhdGUgU2VydmljZS5cclxuICAgKlxyXG4gICAqIEFsc28gZm9yIGJhY2tlbmQgc2VydmljZSBvbmx5LCB5b3UgY2FuIGNob29zZSB0byB0cmlnZ2VyIGEgYmFja2VuZCBxdWVyeSAoZGVmYXVsdCkgb3Igbm90IGlmIHlvdSB3aXNoIHRvIGRvIGl0IGxhdGVyLFxyXG4gICAqIHRoaXMgY291bGQgYmUgdXNlZnVsIHdoZW4gdXNpbmcgdXBkYXRlRmlsdGVycyAmIHVwZGF0ZVNvcnRpbmcgYW5kIHlvdSB3aXNoIHRvIG9ubHkgc2VuZCB0aGUgYmFja2VuZCBxdWVyeSBvbmNlLlxyXG4gICAqIEBwYXJhbSBmaWx0ZXJzIGFycmF5XHJcbiAgICogQHBhcmFtIHRyaWdnZXJFdmVudCBkZWZhdWx0cyB0byBUcnVlLCBkbyB3ZSB3YW50IHRvIGVtaXQgYSBmaWx0ZXIgY2hhbmdlZCBldmVudD9cclxuICAgKiBAcGFyYW0gdHJpZ2dlckJhY2tlbmRRdWVyeSBkZWZhdWx0cyB0byBUcnVlLCB3aGljaCB3aWxsIHF1ZXJ5IHRoZSBiYWNrZW5kLlxyXG4gICAqL1xyXG4gIHVwZGF0ZUZpbHRlcnMoZmlsdGVyczogQ3VycmVudEZpbHRlcltdLCBlbWl0Q2hhbmdlZEV2ZW50ID0gdHJ1ZSwgdHJpZ2dlckJhY2tlbmRRdWVyeSA9IHRydWUpIHtcclxuICAgIGlmICghdGhpcy5fZmlsdGVyc01ldGFkYXRhIHx8IHRoaXMuX2ZpbHRlcnNNZXRhZGF0YS5sZW5ndGggPT09IDAgfHwgIXRoaXMuX2dyaWRPcHRpb25zIHx8ICF0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVGaWx0ZXJpbmcpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbQW5ndWxhci1TbGlja2dyaWRdIGluIG9yZGVyIHRvIHVzZSBcInVwZGF0ZUZpbHRlcnNcIiBtZXRob2QsIHlvdSBuZWVkIHRvIGhhdmUgRmlsdGVyYWJsZSBDb2x1bW5zIGRlZmluZWQgaW4geW91ciBncmlkIGFuZCBcImVuYWJsZUZpbHRlcmluZ1wiIHNldCBpbiB5b3VyIEdyaWQgT3B0aW9ucycpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KGZpbHRlcnMpKSB7XHJcbiAgICAgIC8vIHN0YXJ0IGJ5IGNsZWFyaW5nIGFsbCBmaWx0ZXJzICh3aXRob3V0IHRyaWdnZXJpbmcgYW4gZXZlbnQpIGJlZm9yZSBhcHBseWluZyBhbnkgbmV3IGZpbHRlcnNcclxuICAgICAgdGhpcy5jbGVhckZpbHRlcnMoZmFsc2UpO1xyXG5cclxuICAgICAgLy8gcHJlLWZpbGwgKHZhbHVlICsgb3BlcmF0b3IpIGFuZCByZW5kZXIgYWxsIGZpbHRlcnMgaW4gdGhlIERPTVxyXG4gICAgICAvLyBsb29wIHRocm91Z2ggZWFjaCBGaWx0ZXJzIHByb3ZpZGVkICh3aGljaCBoYXMgYSBjb2x1bW5JZCBwcm9wZXJ0eSlcclxuICAgICAgLy8gdGhlbiBmaW5kIHRoZWlyIGFzc29jaWF0ZWQgRmlsdGVyIGluc3RhbmNlcyB0aGF0IHdlcmUgb3JpZ2luYWxseSBjcmVhdGVkIGluIHRoZSBncmlkXHJcbiAgICAgIGZpbHRlcnMuZm9yRWFjaCgobmV3RmlsdGVyKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdWlGaWx0ZXIgPSB0aGlzLl9maWx0ZXJzTWV0YWRhdGEuZmluZCgoZmlsdGVyKSA9PiBuZXdGaWx0ZXIuY29sdW1uSWQgPT09IGZpbHRlci5jb2x1bW5EZWYuaWQpO1xyXG4gICAgICAgIGlmIChuZXdGaWx0ZXIgJiYgdWlGaWx0ZXIpIHtcclxuICAgICAgICAgIGNvbnN0IG5ld09wZXJhdG9yID0gbmV3RmlsdGVyLm9wZXJhdG9yIHx8IHVpRmlsdGVyLmRlZmF1bHRPcGVyYXRvcjtcclxuICAgICAgICAgIHRoaXMudXBkYXRlQ29sdW1uRmlsdGVycyhuZXdGaWx0ZXIuc2VhcmNoVGVybXMsIHVpRmlsdGVyLmNvbHVtbkRlZiwgbmV3T3BlcmF0b3IpO1xyXG4gICAgICAgICAgdWlGaWx0ZXIuc2V0VmFsdWVzKG5ld0ZpbHRlci5zZWFyY2hUZXJtcywgbmV3T3BlcmF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCBiYWNrZW5kQXBpID0gdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuYmFja2VuZFNlcnZpY2VBcGk7XHJcblxyXG4gICAgICAvLyByZWZyZXNoIHRoZSBEYXRhVmlldyBhbmQgdHJpZ2dlciBhbiBldmVudCBhZnRlciBhbGwgZmlsdGVycyB3ZXJlIHVwZGF0ZWQgYW5kIHJlbmRlcmVkXHJcbiAgICAgIHRoaXMuX2RhdGFWaWV3LnJlZnJlc2goKTtcclxuXHJcbiAgICAgIGlmIChiYWNrZW5kQXBpKSB7XHJcbiAgICAgICAgY29uc3QgYmFja2VuZEFwaVNlcnZpY2UgPSBiYWNrZW5kQXBpICYmIGJhY2tlbmRBcGkuc2VydmljZTtcclxuICAgICAgICBpZiAoYmFja2VuZEFwaVNlcnZpY2UpIHtcclxuICAgICAgICAgIGJhY2tlbmRBcGlTZXJ2aWNlLnVwZGF0ZUZpbHRlcnMoZmlsdGVycywgdHJ1ZSk7XHJcbiAgICAgICAgICBpZiAodHJpZ2dlckJhY2tlbmRRdWVyeSkge1xyXG4gICAgICAgICAgICByZWZyZXNoQmFja2VuZERhdGFzZXQodGhpcy5fZ3JpZE9wdGlvbnMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGVtaXRDaGFuZ2VkRXZlbnQpIHtcclxuICAgICAgICBjb25zdCBlbWl0dGVyVHlwZSA9IGJhY2tlbmRBcGkgPyBFbWl0dGVyVHlwZS5yZW1vdGUgOiBFbWl0dGVyVHlwZS5sb2NhbDtcclxuICAgICAgICB0aGlzLmVtaXRGaWx0ZXJDaGFuZ2VkKGVtaXR0ZXJUeXBlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gLS1cclxuICAvLyBwcml2YXRlIGZ1bmN0aW9uc1xyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLyoqIEFkZCBhbGwgY3JlYXRlZCBmaWx0ZXJzIChmcm9tIHRoZWlyIHRlbXBsYXRlKSB0byB0aGUgaGVhZGVyIHJvdyBzZWN0aW9uIGFyZWEgKi9cclxuICBwcml2YXRlIGFkZEZpbHRlclRlbXBsYXRlVG9IZWFkZXJSb3coYXJnczogeyBjb2x1bW46IENvbHVtbjsgZ3JpZDogYW55OyBub2RlOiBIVE1MRWxlbWVudCB9LCBpc0ZpbHRlckZpcnN0UmVuZGVyID0gdHJ1ZSkge1xyXG4gICAgY29uc3QgY29sdW1uRGVmID0gYXJncy5jb2x1bW47XHJcbiAgICBjb25zdCBjb2x1bW5JZCA9IGNvbHVtbkRlZiAmJiBjb2x1bW5EZWYuaWQgfHwgJyc7XHJcblxyXG4gICAgaWYgKGNvbHVtbkRlZiAmJiBjb2x1bW5JZCAhPT0gJ3NlbGVjdG9yJyAmJiBjb2x1bW5EZWYuZmlsdGVyYWJsZSkge1xyXG4gICAgICBsZXQgc2VhcmNoVGVybXM6IFNlYXJjaFRlcm1bXSB8IHVuZGVmaW5lZDtcclxuICAgICAgbGV0IG9wZXJhdG9yOiBPcGVyYXRvclR5cGUgfCBPcGVyYXRvclN0cmluZztcclxuICAgICAgY29uc3QgbmV3RmlsdGVyOiBGaWx0ZXIgfCB1bmRlZmluZWQgPSB0aGlzLmZpbHRlckZhY3RvcnkuY3JlYXRlRmlsdGVyKGFyZ3MuY29sdW1uLmZpbHRlcik7XHJcbiAgICAgIG9wZXJhdG9yID0gKGNvbHVtbkRlZiAmJiBjb2x1bW5EZWYuZmlsdGVyICYmIGNvbHVtbkRlZi5maWx0ZXIub3BlcmF0b3IpIHx8IChuZXdGaWx0ZXIgJiYgbmV3RmlsdGVyLm9wZXJhdG9yKSB8fCB1bmRlZmluZWQ7XHJcblxyXG4gICAgICBpZiAodGhpcy5fY29sdW1uRmlsdGVyc1tjb2x1bW5EZWYuaWRdKSB7XHJcbiAgICAgICAgc2VhcmNoVGVybXMgPSB0aGlzLl9jb2x1bW5GaWx0ZXJzW2NvbHVtbkRlZi5pZF0uc2VhcmNoVGVybXMgfHwgdW5kZWZpbmVkO1xyXG4gICAgICAgIG9wZXJhdG9yID0gdGhpcy5fY29sdW1uRmlsdGVyc1tjb2x1bW5EZWYuaWRdLm9wZXJhdG9yIHx8IHVuZGVmaW5lZDtcclxuICAgICAgfSBlbHNlIGlmIChjb2x1bW5EZWYuZmlsdGVyKSB7XHJcbiAgICAgICAgLy8gd2hlbiBoaWRpbmcvc2hvd2luZyAod2l0aCBDb2x1bW4gUGlja2VyIG9yIEdyaWQgTWVudSksIGl0IHdpbGwgdHJ5IHRvIHJlLWNyZWF0ZSB5ZXQgYWdhaW4gdGhlIGZpbHRlcnMgKHNpbmNlIFNsaWNrR3JpZCBkb2VzIGEgcmUtcmVuZGVyKVxyXG4gICAgICAgIC8vIGJlY2F1c2Ugb2YgdGhhdCB3ZSBuZWVkIHRvIGZpcnN0IGdldCBzZWFyY2hUZXJtKHMpIGZyb20gdGhlIGNvbHVtbkZpbHRlcnMgKHRoYXQgaXMgd2hhdCB0aGUgdXNlciBsYXN0IHR5cGVkIGluIGEgZmlsdGVyIHNlYXJjaCBpbnB1dClcclxuICAgICAgICBzZWFyY2hUZXJtcyA9IGNvbHVtbkRlZi5maWx0ZXIuc2VhcmNoVGVybXMgfHwgdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMudXBkYXRlQ29sdW1uRmlsdGVycyhzZWFyY2hUZXJtcywgY29sdW1uRGVmLCBvcGVyYXRvcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGZpbHRlckFyZ3VtZW50czogRmlsdGVyQXJndW1lbnRzID0ge1xyXG4gICAgICAgIGdyaWQ6IHRoaXMuX2dyaWQsXHJcbiAgICAgICAgb3BlcmF0b3IsXHJcbiAgICAgICAgc2VhcmNoVGVybXMsXHJcbiAgICAgICAgY29sdW1uRGVmLFxyXG4gICAgICAgIGNhbGxiYWNrOiB0aGlzLmNhbGxiYWNrU2VhcmNoRXZlbnQuYmluZCh0aGlzKVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgaWYgKG5ld0ZpbHRlcikge1xyXG4gICAgICAgIG5ld0ZpbHRlci5pbml0KGZpbHRlckFyZ3VtZW50cywgaXNGaWx0ZXJGaXJzdFJlbmRlcik7XHJcbiAgICAgICAgY29uc3QgZmlsdGVyRXhpc3RJbmRleCA9IHRoaXMuX2ZpbHRlcnNNZXRhZGF0YS5maW5kSW5kZXgoKGZpbHRlcikgPT4gbmV3RmlsdGVyLmNvbHVtbkRlZi5pZCA9PT0gZmlsdGVyLmNvbHVtbkRlZi5pZCk7XHJcblxyXG4gICAgICAgIC8vIGFkZCB0byB0aGUgZmlsdGVycyBhcnJheXMgb3IgcmVwbGFjZSBpdCB3aGVuIGZvdW5kXHJcbiAgICAgICAgaWYgKGZpbHRlckV4aXN0SW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICB0aGlzLl9maWx0ZXJzTWV0YWRhdGEucHVzaChuZXdGaWx0ZXIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLl9maWx0ZXJzTWV0YWRhdGFbZmlsdGVyRXhpc3RJbmRleF0gPSBuZXdGaWx0ZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB3aGVuIGhpZGluZy9zaG93aW5nICh3aXRoIENvbHVtbiBQaWNrZXIgb3IgR3JpZCBNZW51KSwgaXQgd2lsbCB0cnkgdG8gcmUtY3JlYXRlIHlldCBhZ2FpbiB0aGUgZmlsdGVycyAoc2luY2UgU2xpY2tHcmlkIGRvZXMgYSByZS1yZW5kZXIpXHJcbiAgICAgICAgLy8gd2UgbmVlZCB0byBhbHNvIHNldCBhZ2FpbiB0aGUgdmFsdWVzIGluIHRoZSBET00gZWxlbWVudHMgaWYgdGhlIHZhbHVlcyB3ZXJlIHNldCBieSBhIHNlYXJjaFRlcm0ocylcclxuICAgICAgICBpZiAoc2VhcmNoVGVybXMgJiYgbmV3RmlsdGVyLnNldFZhbHVlcykge1xyXG4gICAgICAgICAgbmV3RmlsdGVyLnNldFZhbHVlcyhzZWFyY2hUZXJtcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxsYmFjayBtZXRob2QgdGhhdCBpcyBjYWxsZWQgYW5kIGV4ZWN1dGVkIGJ5IHRoZSBpbmRpdmlkdWFsIEZpbHRlciAoRE9NIGVsZW1lbnQpLFxyXG4gICAqIGZvciBleGFtcGxlIHdoZW4gdXNlciB0eXBlIGluIGEgd29yZCB0byBzZWFyY2ggKHdoaWNoIHVzZXMgSW5wdXRGaWx0ZXIpLCB0aGlzIEZpbHRlciB3aWxsIGV4ZWN1dGUgdGhlIGNhbGxiYWNrIGZyb20gYSBrZXl1cCBldmVudC5cclxuICAgKi9cclxuICBwcml2YXRlIGNhbGxiYWNrU2VhcmNoRXZlbnQoZXZlbnQ6IGFueSwgYXJnczogRmlsdGVyQ2FsbGJhY2tBcmcpIHtcclxuICAgIGlmIChhcmdzKSB7XHJcbiAgICAgIGNvbnN0IHNlYXJjaFRlcm0gPSAoKGV2ZW50ICYmIGV2ZW50LnRhcmdldCkgPyAoZXZlbnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQpLnZhbHVlIDogdW5kZWZpbmVkKTtcclxuICAgICAgY29uc3Qgc2VhcmNoVGVybXMgPSAoYXJncy5zZWFyY2hUZXJtcyAmJiBBcnJheS5pc0FycmF5KGFyZ3Muc2VhcmNoVGVybXMpKSA/IGFyZ3Muc2VhcmNoVGVybXMgOiAoc2VhcmNoVGVybSA/IFtzZWFyY2hUZXJtXSA6IHVuZGVmaW5lZCk7XHJcbiAgICAgIGNvbnN0IGNvbHVtbkRlZiA9IGFyZ3MuY29sdW1uRGVmIHx8IG51bGw7XHJcbiAgICAgIGNvbnN0IGNvbHVtbklkID0gY29sdW1uRGVmICYmIGNvbHVtbkRlZi5pZCB8fCAnJztcclxuICAgICAgY29uc3Qgb3BlcmF0b3IgPSBhcmdzLm9wZXJhdG9yIHx8IHVuZGVmaW5lZDtcclxuICAgICAgY29uc3QgaGFzU2VhcmNoVGVybXMgPSBzZWFyY2hUZXJtcyAmJiBBcnJheS5pc0FycmF5KHNlYXJjaFRlcm1zKTtcclxuICAgICAgY29uc3QgdGVybXNDb3VudCA9IGhhc1NlYXJjaFRlcm1zICYmIHNlYXJjaFRlcm1zICYmIHNlYXJjaFRlcm1zLmxlbmd0aDtcclxuICAgICAgY29uc3Qgb2xkQ29sdW1uRmlsdGVycyA9IHsgLi4udGhpcy5fY29sdW1uRmlsdGVycyB9O1xyXG5cclxuICAgICAgaWYgKGNvbHVtbkRlZiAmJiBjb2x1bW5JZCkge1xyXG4gICAgICAgIGlmICghaGFzU2VhcmNoVGVybXMgfHwgdGVybXNDb3VudCA9PT0gMCB8fCAodGVybXNDb3VudCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KHNlYXJjaFRlcm1zKSAmJiBzZWFyY2hUZXJtc1swXSA9PT0gJycpKSB7XHJcbiAgICAgICAgICAvLyBkZWxldGUgdGhlIHByb3BlcnR5IGZyb20gdGhlIGNvbHVtbkZpbHRlcnMgd2hlbiBpdCBiZWNvbWVzIGVtcHR5XHJcbiAgICAgICAgICAvLyB3aXRob3V0IGRvaW5nIHRoaXMsIGl0IHdvdWxkIGxlYXZlIGFuIGluY29ycmVjdCBzdGF0ZSBvZiB0aGUgcHJldmlvdXMgY29sdW1uIGZpbHRlcnMgd2hlbiBmaWx0ZXJpbmcgb24gYW5vdGhlciBjb2x1bW5cclxuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jb2x1bW5GaWx0ZXJzW2NvbHVtbklkXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc3QgY29sSWQgPSAnJyArIGNvbHVtbklkIGFzIHN0cmluZztcclxuICAgICAgICAgIGNvbnN0IGNvbEZpbHRlcjogQ29sdW1uRmlsdGVyID0ge1xyXG4gICAgICAgICAgICBjb2x1bW5JZDogY29sSWQsXHJcbiAgICAgICAgICAgIGNvbHVtbkRlZixcclxuICAgICAgICAgICAgc2VhcmNoVGVybXMsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgaWYgKG9wZXJhdG9yKSB7XHJcbiAgICAgICAgICAgIGNvbEZpbHRlci5vcGVyYXRvciA9IG9wZXJhdG9yO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy5fY29sdW1uRmlsdGVyc1tjb2xJZF0gPSBjb2xGaWx0ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBldmVudCBtaWdodCBoYXZlIGJlZW4gY3JlYXRlZCBhcyBhIEN1c3RvbUV2ZW50IChlLmcuIENvbXBvdW5kRGF0ZUZpbHRlciksIHdpdGhvdXQgYmVpbmcgYSB2YWxpZCBTbGljay5FdmVudERhdGEsXHJcbiAgICAgIC8vIGlmIHNvIHdlIHdpbGwgY3JlYXRlIGEgbmV3IFNsaWNrLkV2ZW50RGF0YSBhbmQgbWVyZ2UgaXQgd2l0aCB0aGF0IEN1c3RvbUV2ZW50IHRvIGF2b2lkIGhhdmluZyBTbGlja0dyaWQgZXJyb3JzXHJcbiAgICAgIGNvbnN0IGV2ZW50RGF0YSA9IChldmVudCAmJiB0eXBlb2YgZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQgIT09ICdmdW5jdGlvbicpID8gJC5leHRlbmQoe30sIG5ldyBTbGljay5FdmVudERhdGEoKSwgZXZlbnQpIDogZXZlbnQ7XHJcblxyXG4gICAgICAvLyB0cmlnZ2VyIGFuIGV2ZW50IG9ubHkgaWYgRmlsdGVycyBjaGFuZ2VkIG9yIGlmIEVOVEVSIGtleSB3YXMgcHJlc3NlZFxyXG4gICAgICBjb25zdCBldmVudEtleUNvZGUgPSBldmVudCAmJiBldmVudC5rZXlDb2RlO1xyXG4gICAgICBpZiAoZXZlbnRLZXlDb2RlID09PSBLZXlDb2RlLkVOVEVSIHx8ICFpc2VxdWFsKG9sZENvbHVtbkZpbHRlcnMsIHRoaXMuX2NvbHVtbkZpbHRlcnMpKSB7XHJcbiAgICAgICAgdGhpcy5fb25TZWFyY2hDaGFuZ2Uubm90aWZ5KHtcclxuICAgICAgICAgIGNsZWFyRmlsdGVyVHJpZ2dlcmVkOiBhcmdzLmNsZWFyRmlsdGVyVHJpZ2dlcmVkLFxyXG4gICAgICAgICAgc2hvdWxkVHJpZ2dlclF1ZXJ5OiBhcmdzLnNob3VsZFRyaWdnZXJRdWVyeSxcclxuICAgICAgICAgIGNvbHVtbklkLFxyXG4gICAgICAgICAgY29sdW1uRGVmLFxyXG4gICAgICAgICAgY29sdW1uRmlsdGVyczogdGhpcy5fY29sdW1uRmlsdGVycyxcclxuICAgICAgICAgIG9wZXJhdG9yLFxyXG4gICAgICAgICAgc2VhcmNoVGVybXMsXHJcbiAgICAgICAgICBncmlkOiB0aGlzLl9ncmlkXHJcbiAgICAgICAgfSwgZXZlbnREYXRhKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSB1cGRhdGVDb2x1bW5GaWx0ZXJzKHNlYXJjaFRlcm1zOiBTZWFyY2hUZXJtW10gfCB1bmRlZmluZWQsIGNvbHVtbkRlZjogYW55LCBvcGVyYXRvcj86IE9wZXJhdG9yVHlwZSB8IE9wZXJhdG9yU3RyaW5nKSB7XHJcbiAgICBpZiAoc2VhcmNoVGVybXMgJiYgY29sdW1uRGVmKSB7XHJcbiAgICAgIHRoaXMuX2NvbHVtbkZpbHRlcnNbY29sdW1uRGVmLmlkXSA9IHtcclxuICAgICAgICBjb2x1bW5JZDogY29sdW1uRGVmLmlkLFxyXG4gICAgICAgIGNvbHVtbkRlZixcclxuICAgICAgICBzZWFyY2hUZXJtcyxcclxuICAgICAgICBvcGVyYXRvclxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iXX0=