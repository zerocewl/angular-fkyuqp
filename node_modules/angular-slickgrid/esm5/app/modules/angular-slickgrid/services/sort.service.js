import { isObservable, Subject } from 'rxjs';
import { EmitterType, FieldType, SortDirection, SortDirectionNumber, } from './../models/index';
import { executeBackendCallback, refreshBackendDataset } from './backend-utilities';
import { getDescendantProperty } from './utilities';
import { sortByFieldType } from '../sorters/sorterUtilities';
var SortService = /** @class */ (function () {
    function SortService() {
        this._currentLocalSorters = [];
        this._isBackendGrid = false;
        this.httpCancelRequests$ = new Subject(); // this will be used to cancel any pending http request
        this.onSortChanged = new Subject();
        this.onSortCleared = new Subject();
        this._eventHandler = new Slick.EventHandler();
    }
    Object.defineProperty(SortService.prototype, "eventHandler", {
        /** Getter of the SlickGrid Event Handler */
        get: function () {
            return this._eventHandler;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SortService.prototype, "_gridOptions", {
        /** Getter for the Grid Options pulled through the Grid Object */
        get: function () {
            return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SortService.prototype, "_columnDefinitions", {
        /** Getter for the Column Definitions pulled through the Grid Object */
        get: function () {
            return (this._grid && this._grid.getColumns) ? this._grid.getColumns() : [];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Bind a backend sort (single/multi) hook to the grid
     * @param grid SlickGrid Grid object
     * @param dataView SlickGrid DataView object
     */
    SortService.prototype.bindBackendOnSort = function (grid, dataView) {
        this._isBackendGrid = true;
        this._grid = grid;
        this._dataView = dataView;
        // subscribe to the SlickGrid event and call the backend execution
        this._eventHandler.subscribe(grid.onSort, this.onBackendSortChanged.bind(this));
    };
    /**
     * Bind a local sort (single/multi) hook to the grid
     * @param grid SlickGrid Grid object
     * @param gridOptions Grid Options object
     * @param dataView
     */
    SortService.prototype.bindLocalOnSort = function (grid, dataView) {
        var _this = this;
        this._isBackendGrid = false;
        this._grid = grid;
        this._dataView = dataView;
        this._eventHandler.subscribe(grid.onSort, function (e, args) {
            if (args && (args.sortCols || args.sortCol)) {
                // multiSort and singleSort are not exactly the same, but we want to structure it the same for the (for loop) after
                // also to avoid having to rewrite the for loop in the sort, we will make the singleSort an array of 1 object
                var sortColumns = (args.multiColumnSort) ? args.sortCols : new Array({ sortAsc: args.sortAsc, sortCol: args.sortCol });
                // keep current sorters
                _this._currentLocalSorters = []; // reset current local sorters
                if (Array.isArray(sortColumns)) {
                    sortColumns.forEach(function (sortColumn) {
                        if (sortColumn.sortCol) {
                            _this._currentLocalSorters.push({
                                columnId: sortColumn.sortCol.id,
                                direction: sortColumn.sortAsc ? SortDirection.ASC : SortDirection.DESC
                            });
                        }
                    });
                }
                _this.onLocalSortChanged(grid, dataView, sortColumns);
                _this.emitSortChanged(EmitterType.local);
            }
        });
    };
    SortService.prototype.clearSorting = function (triggerQueryEvent) {
        if (triggerQueryEvent === void 0) { triggerQueryEvent = true; }
        if (this._grid && this._gridOptions && this._dataView) {
            // remove any sort icons (this setSortColumns function call really does only that)
            this._grid.setSortColumns([]);
            // we also need to trigger a sort change
            // for a backend grid, we will trigger a backend sort changed with an empty sort columns array
            // however for a local grid, we need to pass a sort column and so we will sort by the 1st column
            if (triggerQueryEvent) {
                if (this._isBackendGrid) {
                    this.onBackendSortChanged(undefined, { grid: this._grid, sortCols: [], clearSortTriggered: true });
                }
                else {
                    if (this._columnDefinitions && Array.isArray(this._columnDefinitions)) {
                        this.onLocalSortChanged(this._grid, this._dataView, new Array({ sortAsc: true, sortCol: this._columnDefinitions[0], clearSortTriggered: true }));
                    }
                }
            }
            else if (this._isBackendGrid) {
                var backendService = this._gridOptions && this._gridOptions.backendServiceApi && this._gridOptions.backendServiceApi.service;
                if (backendService && backendService.clearSorters) {
                    backendService.clearSorters();
                }
            }
        }
        // set current sorter to empty & emit a sort changed event
        this._currentLocalSorters = [];
        // emit an event when sorts are all cleared
        this.onSortCleared.next(true);
    };
    SortService.prototype.dispose = function () {
        // unsubscribe all SlickGrid events
        if (this._eventHandler && this._eventHandler.unsubscribeAll) {
            this._eventHandler.unsubscribeAll();
        }
        if (isObservable(this.httpCancelRequests$)) {
            this.httpCancelRequests$.next(); // this cancels any pending http requests
        }
    };
    /**
     * A simple function that is binded to the subscriber and emit a change when the sort is called.
     * Other services, like Pagination, can then subscribe to it.
     * @param sender
     */
    SortService.prototype.emitSortChanged = function (sender, currentLocalSorters) {
        if (sender === EmitterType.remote && this._gridOptions && this._gridOptions.backendServiceApi) {
            var currentSorters = [];
            var backendService = this._gridOptions.backendServiceApi.service;
            if (backendService && backendService.getCurrentSorters) {
                currentSorters = backendService.getCurrentSorters();
            }
            this.onSortChanged.next(currentSorters);
        }
        else if (sender === EmitterType.local) {
            if (currentLocalSorters) {
                this._currentLocalSorters = currentLocalSorters;
            }
            this.onSortChanged.next(this.getCurrentLocalSorters());
        }
    };
    SortService.prototype.getCurrentLocalSorters = function () {
        return this._currentLocalSorters;
    };
    /**
     * Get current column sorts,
     * If a column is passed as an argument, that will be exclusion so we won't add this column to our output array since it is already in the array.
     * The usage of this method is that we want to know the sort prior to calling the next sorting command
     */
    SortService.prototype.getCurrentColumnSorts = function (excludedColumnId) {
        var _this = this;
        // getSortColumns() only returns sortAsc & columnId, we want the entire column definition
        var oldSortColumns = this._grid && this._grid.getSortColumns();
        // get the column definition but only keep column which are not equal to our current column
        if (Array.isArray(oldSortColumns)) {
            var sortedCols = oldSortColumns.reduce(function (cols, col) {
                if (!excludedColumnId || col.columnId !== excludedColumnId) {
                    cols.push({ sortCol: _this._columnDefinitions[_this._grid.getColumnIndex(col.columnId)], sortAsc: col.sortAsc });
                }
                return cols;
            }, []);
            return sortedCols;
        }
        return [];
    };
    /** Load defined Sorting (sorters) into the grid */
    SortService.prototype.loadGridSorters = function (sorters) {
        var _this = this;
        this._currentLocalSorters = []; // reset current local sorters
        var sortCols = [];
        if (Array.isArray(sorters)) {
            sorters.forEach(function (sorter) {
                var gridColumn = _this._columnDefinitions.find(function (col) { return col.id === sorter.columnId; });
                if (gridColumn) {
                    sortCols.push({
                        columnId: gridColumn.id,
                        sortAsc: ((sorter.direction.toUpperCase() === SortDirection.ASC) ? true : false),
                        sortCol: gridColumn
                    });
                    // keep current sorters
                    _this._currentLocalSorters.push({
                        columnId: gridColumn.id + '',
                        direction: sorter.direction.toUpperCase()
                    });
                }
            });
        }
        if (sortCols.length > 0) {
            this.onLocalSortChanged(this._grid, this._dataView, sortCols);
            this._grid.setSortColumns(sortCols); // use this to add sort icon(s) in UI
        }
        return sortCols;
    };
    SortService.prototype.onBackendSortChanged = function (event, args) {
        if (!args || !args.grid) {
            throw new Error('Something went wrong when trying to bind the "onBackendSortChanged(event, args)" function, it seems that "args" is not populated correctly');
        }
        var gridOptions = (args.grid && args.grid.getOptions) ? args.grid.getOptions() : {};
        var backendApi = gridOptions.backendServiceApi;
        if (!backendApi || !backendApi.process || !backendApi.service) {
            throw new Error("BackendServiceApi requires at least a \"process\" function and a \"service\" defined");
        }
        // keep start time & end timestamps & return it after process execution
        var startTime = new Date();
        if (backendApi.preProcess) {
            backendApi.preProcess();
        }
        // query backend
        var query = backendApi.service.processOnSortChanged(event, args);
        var totalItems = gridOptions && gridOptions.pagination && gridOptions.pagination.totalItems;
        executeBackendCallback(backendApi, query, args, startTime, totalItems, this.emitSortChanged.bind(this), this.httpCancelRequests$);
    };
    SortService.prototype.onLocalSortChanged = function (grid, dataView, sortColumns, forceReSort) {
        if (forceReSort === void 0) { forceReSort = false; }
        if (grid && dataView) {
            if (forceReSort) {
                dataView.reSort();
            }
            dataView.sort(this.sortComparer.bind(this, sortColumns));
            grid.invalidate();
            grid.render();
        }
    };
    SortService.prototype.sortComparer = function (sortColumns, dataRow1, dataRow2) {
        if (Array.isArray(sortColumns)) {
            for (var i = 0, l = sortColumns.length; i < l; i++) {
                var columnSortObj = sortColumns[i];
                if (columnSortObj && columnSortObj.sortCol) {
                    var sortDirection = columnSortObj.sortAsc ? SortDirectionNumber.asc : SortDirectionNumber.desc;
                    var sortField = columnSortObj.sortCol.queryFieldSorter || columnSortObj.sortCol.queryField || columnSortObj.sortCol.field;
                    var fieldType = columnSortObj.sortCol.type || FieldType.string;
                    var value1 = dataRow1[sortField];
                    var value2 = dataRow2[sortField];
                    // when item is a complex object (dot "." notation), we need to filter the value contained in the object tree
                    if (sortField && sortField.indexOf('.') >= 0) {
                        value1 = getDescendantProperty(dataRow1, sortField);
                        value2 = getDescendantProperty(dataRow2, sortField);
                    }
                    // user could provide his own custom Sorter
                    if (columnSortObj.sortCol && columnSortObj.sortCol.sorter) {
                        var customSortResult = columnSortObj.sortCol.sorter(value1, value2, sortDirection, columnSortObj.sortCol);
                        if (customSortResult !== SortDirectionNumber.neutral) {
                            return customSortResult;
                        }
                    }
                    else {
                        var sortResult = sortByFieldType(fieldType, value1, value2, sortDirection, columnSortObj.sortCol);
                        if (sortResult !== SortDirectionNumber.neutral) {
                            return sortResult;
                        }
                    }
                }
            }
        }
        return SortDirectionNumber.neutral;
    };
    /**
     * Update Sorting (sorters) dynamically just by providing an array of sorter(s).
     * You can also choose emit (default) a Sort Changed event that will be picked by the Grid State Service.
     *
     * Also for backend service only, you can choose to trigger a backend query (default) or not if you wish to do it later,
     * this could be useful when using updateFilters & updateSorting and you wish to only send the backend query once.
     * @param sorters array
     * @param triggerEvent defaults to True, do we want to emit a sort changed event?
     * @param triggerBackendQuery defaults to True, which will query the backend.
     */
    SortService.prototype.updateSorting = function (sorters, emitChangedEvent, triggerBackendQuery) {
        if (emitChangedEvent === void 0) { emitChangedEvent = true; }
        if (triggerBackendQuery === void 0) { triggerBackendQuery = true; }
        if (!this._gridOptions || !this._gridOptions.enableSorting) {
            throw new Error('[Angular-Slickgrid] in order to use "updateSorting" method, you need to have Sortable Columns defined in your grid and "enableSorting" set in your Grid Options');
        }
        if (Array.isArray(sorters)) {
            var backendApi = this._gridOptions && this._gridOptions.backendServiceApi;
            if (backendApi) {
                var backendApiService = backendApi && backendApi.service;
                if (backendApiService) {
                    backendApiService.updateSorters(undefined, sorters);
                    if (triggerBackendQuery) {
                        refreshBackendDataset(this._gridOptions);
                    }
                }
            }
            else {
                this.loadGridSorters(sorters);
            }
            if (emitChangedEvent) {
                var emitterType = backendApi ? EmitterType.remote : EmitterType.local;
                this.emitSortChanged(emitterType);
            }
        }
    };
    return SortService;
}());
export { SortService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ydC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1zbGlja2dyaWQvIiwic291cmNlcyI6WyJhcHAvbW9kdWxlcy9hbmd1bGFyLXNsaWNrZ3JpZC9zZXJ2aWNlcy9zb3J0LnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFlBQVksRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFFN0MsT0FBTyxFQUlMLFdBQVcsRUFDWCxTQUFTLEVBR1QsYUFBYSxFQUNiLG1CQUFtQixHQUVwQixNQUFNLG1CQUFtQixDQUFDO0FBQzNCLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3BGLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUNwRCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFLN0Q7SUFVRTtRQVRRLHlCQUFvQixHQUFvQixFQUFFLENBQUM7UUFJM0MsbUJBQWMsR0FBRyxLQUFLLENBQUM7UUFDdkIsd0JBQW1CLEdBQWtCLElBQUksT0FBTyxFQUFRLENBQUMsQ0FBQyx1REFBdUQ7UUFDekgsa0JBQWEsR0FBRyxJQUFJLE9BQU8sRUFBbUIsQ0FBQztRQUMvQyxrQkFBYSxHQUFHLElBQUksT0FBTyxFQUFXLENBQUM7UUFHckMsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLEtBQUssQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUNoRCxDQUFDO0lBR0Qsc0JBQUkscUNBQVk7UUFEaEIsNENBQTRDO2FBQzVDO1lBQ0UsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDO1FBQzVCLENBQUM7OztPQUFBO0lBR0Qsc0JBQVkscUNBQVk7UUFEeEIsaUVBQWlFO2FBQ2pFO1lBQ0UsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFB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QyxFQUFFO1lBQzFCLElBQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxpQkFBaUIsQ0FBQztZQUU1RSxJQUFJLFVBQVUsRUFBRTtnQkFDZCxJQUFNLGlCQUFpQixHQUFHLFVBQVUsSUFBSSxVQUFVLENBQUMsT0FBTyxDQUFDO2dCQUMzRCxJQUFJLGlCQUFpQixFQUFFO29CQUNyQixpQkFBaUIsQ0FBQyxhQUFhLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO29CQUNwRCxJQUFJLG1CQUFtQixFQUFFO3dCQUN2QixxQkFBcUIsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7cUJBQzFDO2lCQUNGO2FBQ0Y7aUJBQU07Z0JBQ0wsSUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQzthQUMvQjtZQUVELElBQUksZ0JBQWdCLEVBQUU7Z0JBQ3BCLElBQU0sV0FBVyxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQztnQkFDeEUsSUFBSSxDQUFDLGVBQWUsQ0FBQyxXQUFXLENBQUMsQ0FBQzthQUNuQztTQUNGO0lBQ0gsQ0FBQztJQUNILGtCQUFDO0FBQUQsQ0FBQyxBQXBURCxJQW9UQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xyXG5cclxuaW1wb3J0IHtcclxuICBDb2x1bW4sXHJcbiAgQ29sdW1uU29ydCxcclxuICBDdXJyZW50U29ydGVyLFxyXG4gIEVtaXR0ZXJUeXBlLFxyXG4gIEZpZWxkVHlwZSxcclxuICBHcmlkT3B0aW9uLFxyXG4gIFNsaWNrRXZlbnRIYW5kbGVyLFxyXG4gIFNvcnREaXJlY3Rpb24sXHJcbiAgU29ydERpcmVjdGlvbk51bWJlcixcclxuICBTb3J0RGlyZWN0aW9uU3RyaW5nLFxyXG59IGZyb20gJy4vLi4vbW9kZWxzL2luZGV4JztcclxuaW1wb3J0IHsgZXhlY3V0ZUJhY2tlbmRDYWxsYmFjaywgcmVmcmVzaEJhY2tlbmREYXRhc2V0IH0gZnJvbSAnLi9iYWNrZW5kLXV0aWxpdGllcyc7XHJcbmltcG9ydCB7IGdldERlc2NlbmRhbnRQcm9wZXJ0eSB9IGZyb20gJy4vdXRpbGl0aWVzJztcclxuaW1wb3J0IHsgc29ydEJ5RmllbGRUeXBlIH0gZnJvbSAnLi4vc29ydGVycy9zb3J0ZXJVdGlsaXRpZXMnO1xyXG5cclxuLy8gdXNpbmcgZXh0ZXJuYWwgbm9uLXR5cGVkIGpzIGxpYnJhcmllc1xyXG5kZWNsYXJlIHZhciBTbGljazogYW55O1xyXG5cclxuZXhwb3J0IGNsYXNzIFNvcnRTZXJ2aWNlIHtcclxuICBwcml2YXRlIF9jdXJyZW50TG9jYWxTb3J0ZXJzOiBDdXJyZW50U29ydGVyW10gPSBbXTtcclxuICBwcml2YXRlIF9ldmVudEhhbmRsZXI6IFNsaWNrRXZlbnRIYW5kbGVyO1xyXG4gIHByaXZhdGUgX2RhdGFWaWV3OiBhbnk7XHJcbiAgcHJpdmF0ZSBfZ3JpZDogYW55O1xyXG4gIHByaXZhdGUgX2lzQmFja2VuZEdyaWQgPSBmYWxzZTtcclxuICBwcml2YXRlIGh0dHBDYW5jZWxSZXF1ZXN0cyQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpOyAvLyB0aGlzIHdpbGwgYmUgdXNlZCB0byBjYW5jZWwgYW55IHBlbmRpbmcgaHR0cCByZXF1ZXN0XHJcbiAgb25Tb3J0Q2hhbmdlZCA9IG5ldyBTdWJqZWN0PEN1cnJlbnRTb3J0ZXJbXT4oKTtcclxuICBvblNvcnRDbGVhcmVkID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLl9ldmVudEhhbmRsZXIgPSBuZXcgU2xpY2suRXZlbnRIYW5kbGVyKCk7XHJcbiAgfVxyXG5cclxuICAvKiogR2V0dGVyIG9mIHRoZSBTbGlja0dyaWQgRXZlbnQgSGFuZGxlciAqL1xyXG4gIGdldCBldmVudEhhbmRsZXIoKTogU2xpY2tFdmVudEhhbmRsZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuX2V2ZW50SGFuZGxlcjtcclxuICB9XHJcblxyXG4gIC8qKiBHZXR0ZXIgZm9yIHRoZSBHcmlkIE9wdGlvbnMgcHVsbGVkIHRocm91Z2ggdGhlIEdyaWQgT2JqZWN0ICovXHJcbiAgcHJpdmF0ZSBnZXQgX2dyaWRPcHRpb25zKCk6IEdyaWRPcHRpb24ge1xyXG4gICAgcmV0dXJuICh0aGlzLl9ncmlkICYmIHRoaXMuX2dyaWQuZ2V0T3B0aW9ucykgPyB0aGlzLl9ncmlkLmdldE9wdGlvbnMoKSA6IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBmb3IgdGhlIENvbHVtbiBEZWZpbml0aW9ucyBwdWxsZWQgdGhyb3VnaCB0aGUgR3JpZCBPYmplY3QgKi9cclxuICBwcml2YXRlIGdldCBfY29sdW1uRGVmaW5pdGlvbnMoKTogQ29sdW1uW10ge1xyXG4gICAgcmV0dXJuICh0aGlzLl9ncmlkICYmIHRoaXMuX2dyaWQuZ2V0Q29sdW1ucykgPyB0aGlzLl9ncmlkLmdldENvbHVtbnMoKSA6IFtdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQmluZCBhIGJhY2tlbmQgc29ydCAoc2luZ2xlL211bHRpKSBob29rIHRvIHRoZSBncmlkXHJcbiAgICogQHBhcmFtIGdyaWQgU2xpY2tHcmlkIEdyaWQgb2JqZWN0XHJcbiAgICogQHBhcmFtIGRhdGFWaWV3IFNsaWNrR3JpZCBEYXRhVmlldyBvYmplY3RcclxuICAgKi9cclxuICBiaW5kQmFja2VuZE9uU29ydChncmlkOiBhbnksIGRhdGFWaWV3OiBhbnkpIHtcclxuICAgIHRoaXMuX2lzQmFja2VuZEdyaWQgPSB0cnVlO1xyXG4gICAgdGhpcy5fZ3JpZCA9IGdyaWQ7XHJcbiAgICB0aGlzLl9kYXRhVmlldyA9IGRhdGFWaWV3O1xyXG5cclxuICAgIC8vIHN1YnNjcmliZSB0byB0aGUgU2xpY2tHcmlkIGV2ZW50IGFuZCBjYWxsIHRoZSBiYWNrZW5kIGV4ZWN1dGlvblxyXG4gICAgdGhpcy5fZXZlbnRIYW5kbGVyLnN1YnNjcmliZShncmlkLm9uU29ydCwgdGhpcy5vbkJhY2tlbmRTb3J0Q2hhbmdlZC5iaW5kKHRoaXMpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJpbmQgYSBsb2NhbCBzb3J0IChzaW5nbGUvbXVsdGkpIGhvb2sgdG8gdGhlIGdyaWRcclxuICAgKiBAcGFyYW0gZ3JpZCBTbGlja0dyaWQgR3JpZCBvYmplY3RcclxuICAgKiBAcGFyYW0gZ3JpZE9wdGlvbnMgR3JpZCBPcHRpb25zIG9iamVjdFxyXG4gICAqIEBwYXJhbSBkYXRhVmlld1xyXG4gICAqL1xyXG4gIGJpbmRMb2NhbE9uU29ydChncmlkOiBhbnksIGRhdGFWaWV3OiBhbnkpIHtcclxuICAgIHRoaXMuX2lzQmFja2VuZEdyaWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX2dyaWQgPSBncmlkO1xyXG4gICAgdGhpcy5fZGF0YVZpZXcgPSBkYXRhVmlldztcclxuXHJcbiAgICB0aGlzLl9ldmVudEhhbmRsZXIuc3Vic2NyaWJlKGdyaWQub25Tb3J0LCAoZTogYW55LCBhcmdzOiBhbnkpID0+IHtcclxuICAgICAgaWYgKGFyZ3MgJiYgKGFyZ3Muc29ydENvbHMgfHwgYXJncy5zb3J0Q29sKSkge1xyXG4gICAgICAgIC8vIG11bHRpU29ydCBhbmQgc2luZ2xlU29ydCBhcmUgbm90IGV4YWN0bHkgdGhlIHNhbWUsIGJ1dCB3ZSB3YW50IHRvIHN0cnVjdHVyZSBpdCB0aGUgc2FtZSBmb3IgdGhlIChmb3IgbG9vcCkgYWZ0ZXJcclxuICAgICAgICAvLyBhbHNvIHRvIGF2b2lkIGhhdmluZyB0byByZXdyaXRlIHRoZSBmb3IgbG9vcCBpbiB0aGUgc29ydCwgd2Ugd2lsbCBtYWtlIHRoZSBzaW5nbGVTb3J0IGFuIGFycmF5IG9mIDEgb2JqZWN0XHJcbiAgICAgICAgY29uc3Qgc29ydENvbHVtbnMgPSAoYXJncy5tdWx0aUNvbHVtblNvcnQpID8gYXJncy5zb3J0Q29scyA6IG5ldyBBcnJheSh7IHNvcnRBc2M6IGFyZ3Muc29ydEFzYywgc29ydENvbDogYXJncy5zb3J0Q29sIH0pO1xyXG5cclxuICAgICAgICAvLyBrZWVwIGN1cnJlbnQgc29ydGVyc1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRMb2NhbFNvcnRlcnMgPSBbXTsgLy8gcmVzZXQgY3VycmVudCBsb2NhbCBzb3J0ZXJzXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc29ydENvbHVtbnMpKSB7XHJcbiAgICAgICAgICBzb3J0Q29sdW1ucy5mb3JFYWNoKChzb3J0Q29sdW1uOiB7IHNvcnRDb2w6IENvbHVtbiwgc29ydEFzYzogYm9vbGVhbiB9KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzb3J0Q29sdW1uLnNvcnRDb2wpIHtcclxuICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50TG9jYWxTb3J0ZXJzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgY29sdW1uSWQ6IHNvcnRDb2x1bW4uc29ydENvbC5pZCxcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogc29ydENvbHVtbi5zb3J0QXNjID8gU29ydERpcmVjdGlvbi5BU0MgOiBTb3J0RGlyZWN0aW9uLkRFU0NcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm9uTG9jYWxTb3J0Q2hhbmdlZChncmlkLCBkYXRhVmlldywgc29ydENvbHVtbnMpO1xyXG4gICAgICAgIHRoaXMuZW1pdFNvcnRDaGFuZ2VkKEVtaXR0ZXJUeXBlLmxvY2FsKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBjbGVhclNvcnRpbmcodHJpZ2dlclF1ZXJ5RXZlbnQgPSB0cnVlKSB7XHJcbiAgICBpZiAodGhpcy5fZ3JpZCAmJiB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9kYXRhVmlldykge1xyXG4gICAgICAvLyByZW1vdmUgYW55IHNvcnQgaWNvbnMgKHRoaXMgc2V0U29ydENvbHVtbnMgZnVuY3Rpb24gY2FsbCByZWFsbHkgZG9lcyBvbmx5IHRoYXQpXHJcbiAgICAgIHRoaXMuX2dyaWQuc2V0U29ydENvbHVtbnMoW10pO1xyXG5cclxuICAgICAgLy8gd2UgYWxzbyBuZWVkIHRvIHRyaWdnZXIgYSBzb3J0IGNoYW5nZVxyXG4gICAgICAvLyBmb3IgYSBiYWNrZW5kIGdyaWQsIHdlIHdpbGwgdHJpZ2dlciBhIGJhY2tlbmQgc29ydCBjaGFuZ2VkIHdpdGggYW4gZW1wdHkgc29ydCBjb2x1bW5zIGFycmF5XHJcbiAgICAgIC8vIGhvd2V2ZXIgZm9yIGEgbG9jYWwgZ3JpZCwgd2UgbmVlZCB0byBwYXNzIGEgc29ydCBjb2x1bW4gYW5kIHNvIHdlIHdpbGwgc29ydCBieSB0aGUgMXN0IGNvbHVtblxyXG4gICAgICBpZiAodHJpZ2dlclF1ZXJ5RXZlbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5faXNCYWNrZW5kR3JpZCkge1xyXG4gICAgICAgICAgdGhpcy5vbkJhY2tlbmRTb3J0Q2hhbmdlZCh1bmRlZmluZWQsIHsgZ3JpZDogdGhpcy5fZ3JpZCwgc29ydENvbHM6IFtdLCBjbGVhclNvcnRUcmlnZ2VyZWQ6IHRydWUgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmICh0aGlzLl9jb2x1bW5EZWZpbml0aW9ucyAmJiBBcnJheS5pc0FycmF5KHRoaXMuX2NvbHVtbkRlZmluaXRpb25zKSkge1xyXG4gICAgICAgICAgICB0aGlzLm9uTG9jYWxTb3J0Q2hhbmdlZCh0aGlzLl9ncmlkLCB0aGlzLl9kYXRhVmlldywgbmV3IEFycmF5KHsgc29ydEFzYzogdHJ1ZSwgc29ydENvbDogdGhpcy5fY29sdW1uRGVmaW5pdGlvbnNbMF0sIGNsZWFyU29ydFRyaWdnZXJlZDogdHJ1ZSB9KSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2lzQmFja2VuZEdyaWQpIHtcclxuICAgICAgICBjb25zdCBiYWNrZW5kU2VydmljZSA9IHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLmJhY2tlbmRTZXJ2aWNlQXBpICYmIHRoaXMuX2dyaWRPcHRpb25zLmJhY2tlbmRTZXJ2aWNlQXBpLnNlcnZpY2U7XHJcbiAgICAgICAgaWYgKGJhY2tlbmRTZXJ2aWNlICYmIGJhY2tlbmRTZXJ2aWNlLmNsZWFyU29ydGVycykge1xyXG4gICAgICAgICAgYmFja2VuZFNlcnZpY2UuY2xlYXJTb3J0ZXJzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2V0IGN1cnJlbnQgc29ydGVyIHRvIGVtcHR5ICYgZW1pdCBhIHNvcnQgY2hhbmdlZCBldmVudFxyXG4gICAgdGhpcy5fY3VycmVudExvY2FsU29ydGVycyA9IFtdO1xyXG5cclxuICAgIC8vIGVtaXQgYW4gZXZlbnQgd2hlbiBzb3J0cyBhcmUgYWxsIGNsZWFyZWRcclxuICAgIHRoaXMub25Tb3J0Q2xlYXJlZC5uZXh0KHRydWUpO1xyXG4gIH1cclxuXHJcbiAgZGlzcG9zZSgpIHtcclxuICAgIC8vIHVuc3Vic2NyaWJlIGFsbCBTbGlja0dyaWQgZXZlbnRzXHJcbiAgICBpZiAodGhpcy5fZXZlbnRIYW5kbGVyICYmIHRoaXMuX2V2ZW50SGFuZGxlci51bnN1YnNjcmliZUFsbCkge1xyXG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIudW5zdWJzY3JpYmVBbGwoKTtcclxuICAgIH1cclxuICAgIGlmIChpc09ic2VydmFibGUodGhpcy5odHRwQ2FuY2VsUmVxdWVzdHMkKSkge1xyXG4gICAgICB0aGlzLmh0dHBDYW5jZWxSZXF1ZXN0cyQubmV4dCgpOyAvLyB0aGlzIGNhbmNlbHMgYW55IHBlbmRpbmcgaHR0cCByZXF1ZXN0c1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQSBzaW1wbGUgZnVuY3Rpb24gdGhhdCBpcyBiaW5kZWQgdG8gdGhlIHN1YnNjcmliZXIgYW5kIGVtaXQgYSBjaGFuZ2Ugd2hlbiB0aGUgc29ydCBpcyBjYWxsZWQuXHJcbiAgICogT3RoZXIgc2VydmljZXMsIGxpa2UgUGFnaW5hdGlvbiwgY2FuIHRoZW4gc3Vic2NyaWJlIHRvIGl0LlxyXG4gICAqIEBwYXJhbSBzZW5kZXJcclxuICAgKi9cclxuICBlbWl0U29ydENoYW5nZWQoc2VuZGVyOiBFbWl0dGVyVHlwZSwgY3VycmVudExvY2FsU29ydGVycz86IEN1cnJlbnRTb3J0ZXJbXSkge1xyXG4gICAgaWYgKHNlbmRlciA9PT0gRW1pdHRlclR5cGUucmVtb3RlICYmIHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLmJhY2tlbmRTZXJ2aWNlQXBpKSB7XHJcbiAgICAgIGxldCBjdXJyZW50U29ydGVyczogQ3VycmVudFNvcnRlcltdID0gW107XHJcbiAgICAgIGNvbnN0IGJhY2tlbmRTZXJ2aWNlID0gdGhpcy5fZ3JpZE9wdGlvbnMuYmFja2VuZFNlcnZpY2VBcGkuc2VydmljZTtcclxuICAgICAgaWYgKGJhY2tlbmRTZXJ2aWNlICYmIGJhY2tlbmRTZXJ2aWNlLmdldEN1cnJlbnRTb3J0ZXJzKSB7XHJcbiAgICAgICAgY3VycmVudFNvcnRlcnMgPSBiYWNrZW5kU2VydmljZS5nZXRDdXJyZW50U29ydGVycygpIGFzIEN1cnJlbnRTb3J0ZXJbXTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm9uU29ydENoYW5nZWQubmV4dChjdXJyZW50U29ydGVycyk7XHJcbiAgICB9IGVsc2UgaWYgKHNlbmRlciA9PT0gRW1pdHRlclR5cGUubG9jYWwpIHtcclxuICAgICAgaWYgKGN1cnJlbnRMb2NhbFNvcnRlcnMpIHtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TG9jYWxTb3J0ZXJzID0gY3VycmVudExvY2FsU29ydGVycztcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm9uU29ydENoYW5nZWQubmV4dCh0aGlzLmdldEN1cnJlbnRMb2NhbFNvcnRlcnMoKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXRDdXJyZW50TG9jYWxTb3J0ZXJzKCk6IEN1cnJlbnRTb3J0ZXJbXSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudExvY2FsU29ydGVycztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBjdXJyZW50IGNvbHVtbiBzb3J0cyxcclxuICAgKiBJZiBhIGNvbHVtbiBpcyBwYXNzZWQgYXMgYW4gYXJndW1lbnQsIHRoYXQgd2lsbCBiZSBleGNsdXNpb24gc28gd2Ugd29uJ3QgYWRkIHRoaXMgY29sdW1uIHRvIG91ciBvdXRwdXQgYXJyYXkgc2luY2UgaXQgaXMgYWxyZWFkeSBpbiB0aGUgYXJyYXkuXHJcbiAgICogVGhlIHVzYWdlIG9mIHRoaXMgbWV0aG9kIGlzIHRoYXQgd2Ugd2FudCB0byBrbm93IHRoZSBzb3J0IHByaW9yIHRvIGNhbGxpbmcgdGhlIG5leHQgc29ydGluZyBjb21tYW5kXHJcbiAgICovXHJcbiAgZ2V0Q3VycmVudENvbHVtblNvcnRzKGV4Y2x1ZGVkQ29sdW1uSWQ/OiBzdHJpbmcpIHtcclxuICAgIC8vIGdldFNvcnRDb2x1bW5zKCkgb25seSByZXR1cm5zIHNvcnRBc2MgJiBjb2x1bW5JZCwgd2Ugd2FudCB0aGUgZW50aXJlIGNvbHVtbiBkZWZpbml0aW9uXHJcbiAgICBjb25zdCBvbGRTb3J0Q29sdW1ucyA9IHRoaXMuX2dyaWQgJiYgdGhpcy5fZ3JpZC5nZXRTb3J0Q29sdW1ucygpO1xyXG5cclxuICAgIC8vIGdldCB0aGUgY29sdW1uIGRlZmluaXRpb24gYnV0IG9ubHkga2VlcCBjb2x1bW4gd2hpY2ggYXJlIG5vdCBlcXVhbCB0byBvdXIgY3VycmVudCBjb2x1bW5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KG9sZFNvcnRDb2x1bW5zKSkge1xyXG4gICAgICBjb25zdCBzb3J0ZWRDb2xzID0gb2xkU29ydENvbHVtbnMucmVkdWNlKChjb2xzLCBjb2wpID0+IHtcclxuICAgICAgICBpZiAoIWV4Y2x1ZGVkQ29sdW1uSWQgfHwgY29sLmNvbHVtbklkICE9PSBleGNsdWRlZENvbHVtbklkKSB7XHJcbiAgICAgICAgICBjb2xzLnB1c2goeyBzb3J0Q29sOiB0aGlzLl9jb2x1bW5EZWZpbml0aW9uc1t0aGlzLl9ncmlkLmdldENvbHVtbkluZGV4KGNvbC5jb2x1bW5JZCldLCBzb3J0QXNjOiBjb2wuc29ydEFzYyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbHM7XHJcbiAgICAgIH0sIFtdKTtcclxuXHJcbiAgICAgIHJldHVybiBzb3J0ZWRDb2xzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuXHJcbiAgLyoqIExvYWQgZGVmaW5lZCBTb3J0aW5nIChzb3J0ZXJzKSBpbnRvIHRoZSBncmlkICovXHJcbiAgbG9hZEdyaWRTb3J0ZXJzKHNvcnRlcnM6IEN1cnJlbnRTb3J0ZXJbXSk6IENvbHVtblNvcnRbXSB7XHJcbiAgICB0aGlzLl9jdXJyZW50TG9jYWxTb3J0ZXJzID0gW107IC8vIHJlc2V0IGN1cnJlbnQgbG9jYWwgc29ydGVyc1xyXG4gICAgY29uc3Qgc29ydENvbHM6IENvbHVtblNvcnRbXSA9IFtdO1xyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHNvcnRlcnMpKSB7XHJcbiAgICAgIHNvcnRlcnMuZm9yRWFjaCgoc29ydGVyOiBDdXJyZW50U29ydGVyKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZ3JpZENvbHVtbiA9IHRoaXMuX2NvbHVtbkRlZmluaXRpb25zLmZpbmQoKGNvbDogQ29sdW1uKSA9PiBjb2wuaWQgPT09IHNvcnRlci5jb2x1bW5JZCk7XHJcbiAgICAgICAgaWYgKGdyaWRDb2x1bW4pIHtcclxuICAgICAgICAgIHNvcnRDb2xzLnB1c2goe1xyXG4gICAgICAgICAgICBjb2x1bW5JZDogZ3JpZENvbHVtbi5pZCxcclxuICAgICAgICAgICAgc29ydEFzYzogKChzb3J0ZXIuZGlyZWN0aW9uLnRvVXBwZXJDYXNlKCkgPT09IFNvcnREaXJlY3Rpb24uQVNDKSA/IHRydWUgOiBmYWxzZSksXHJcbiAgICAgICAgICAgIHNvcnRDb2w6IGdyaWRDb2x1bW5cclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIC8vIGtlZXAgY3VycmVudCBzb3J0ZXJzXHJcbiAgICAgICAgICB0aGlzLl9jdXJyZW50TG9jYWxTb3J0ZXJzLnB1c2goe1xyXG4gICAgICAgICAgICBjb2x1bW5JZDogZ3JpZENvbHVtbi5pZCArICcnLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb246IHNvcnRlci5kaXJlY3Rpb24udG9VcHBlckNhc2UoKSBhcyBTb3J0RGlyZWN0aW9uU3RyaW5nXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzb3J0Q29scy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHRoaXMub25Mb2NhbFNvcnRDaGFuZ2VkKHRoaXMuX2dyaWQsIHRoaXMuX2RhdGFWaWV3LCBzb3J0Q29scyk7XHJcbiAgICAgIHRoaXMuX2dyaWQuc2V0U29ydENvbHVtbnMoc29ydENvbHMpOyAvLyB1c2UgdGhpcyB0byBhZGQgc29ydCBpY29uKHMpIGluIFVJXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHNvcnRDb2xzO1xyXG4gIH1cclxuXHJcbiAgb25CYWNrZW5kU29ydENoYW5nZWQoZXZlbnQ6IEV2ZW50LCBhcmdzOiB7IG11bHRpQ29sdW1uU29ydD86IGJvb2xlYW47IGdyaWQ6IGFueTsgc29ydENvbHM6IENvbHVtblNvcnRbXTsgY2xlYXJTb3J0VHJpZ2dlcmVkPzogYm9vbGVhbiB9KSB7XHJcbiAgICBpZiAoIWFyZ3MgfHwgIWFyZ3MuZ3JpZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NvbWV0aGluZyB3ZW50IHdyb25nIHdoZW4gdHJ5aW5nIHRvIGJpbmQgdGhlIFwib25CYWNrZW5kU29ydENoYW5nZWQoZXZlbnQsIGFyZ3MpXCIgZnVuY3Rpb24sIGl0IHNlZW1zIHRoYXQgXCJhcmdzXCIgaXMgbm90IHBvcHVsYXRlZCBjb3JyZWN0bHknKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGdyaWRPcHRpb25zOiBHcmlkT3B0aW9uID0gKGFyZ3MuZ3JpZCAmJiBhcmdzLmdyaWQuZ2V0T3B0aW9ucykgPyBhcmdzLmdyaWQuZ2V0T3B0aW9ucygpIDoge307XHJcbiAgICBjb25zdCBiYWNrZW5kQXBpID0gZ3JpZE9wdGlvbnMuYmFja2VuZFNlcnZpY2VBcGk7XHJcblxyXG4gICAgaWYgKCFiYWNrZW5kQXBpIHx8ICFiYWNrZW5kQXBpLnByb2Nlc3MgfHwgIWJhY2tlbmRBcGkuc2VydmljZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEJhY2tlbmRTZXJ2aWNlQXBpIHJlcXVpcmVzIGF0IGxlYXN0IGEgXCJwcm9jZXNzXCIgZnVuY3Rpb24gYW5kIGEgXCJzZXJ2aWNlXCIgZGVmaW5lZGApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGtlZXAgc3RhcnQgdGltZSAmIGVuZCB0aW1lc3RhbXBzICYgcmV0dXJuIGl0IGFmdGVyIHByb2Nlc3MgZXhlY3V0aW9uXHJcbiAgICBjb25zdCBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xyXG5cclxuICAgIGlmIChiYWNrZW5kQXBpLnByZVByb2Nlc3MpIHtcclxuICAgICAgYmFja2VuZEFwaS5wcmVQcm9jZXNzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcXVlcnkgYmFja2VuZFxyXG4gICAgY29uc3QgcXVlcnkgPSBiYWNrZW5kQXBpLnNlcnZpY2UucHJvY2Vzc09uU29ydENoYW5nZWQoZXZlbnQsIGFyZ3MpO1xyXG4gICAgY29uc3QgdG90YWxJdGVtcyA9IGdyaWRPcHRpb25zICYmIGdyaWRPcHRpb25zLnBhZ2luYXRpb24gJiYgZ3JpZE9wdGlvbnMucGFnaW5hdGlvbi50b3RhbEl0ZW1zO1xyXG4gICAgZXhlY3V0ZUJhY2tlbmRDYWxsYmFjayhiYWNrZW5kQXBpLCBxdWVyeSwgYXJncywgc3RhcnRUaW1lLCB0b3RhbEl0ZW1zLCB0aGlzLmVtaXRTb3J0Q2hhbmdlZC5iaW5kKHRoaXMpLCB0aGlzLmh0dHBDYW5jZWxSZXF1ZXN0cyQpO1xyXG4gIH1cclxuXHJcbiAgb25Mb2NhbFNvcnRDaGFuZ2VkKGdyaWQ6IGFueSwgZGF0YVZpZXc6IGFueSwgc29ydENvbHVtbnM6IENvbHVtblNvcnRbXSwgZm9yY2VSZVNvcnQgPSBmYWxzZSkge1xyXG4gICAgaWYgKGdyaWQgJiYgZGF0YVZpZXcpIHtcclxuICAgICAgaWYgKGZvcmNlUmVTb3J0KSB7XHJcbiAgICAgICAgZGF0YVZpZXcucmVTb3J0KCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGRhdGFWaWV3LnNvcnQodGhpcy5zb3J0Q29tcGFyZXIuYmluZCh0aGlzLCBzb3J0Q29sdW1ucykpO1xyXG5cclxuICAgICAgZ3JpZC5pbnZhbGlkYXRlKCk7XHJcbiAgICAgIGdyaWQucmVuZGVyKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzb3J0Q29tcGFyZXIoc29ydENvbHVtbnM6IENvbHVtblNvcnRbXSwgZGF0YVJvdzE6IGFueSwgZGF0YVJvdzI6IGFueSkge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc29ydENvbHVtbnMpKSB7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gc29ydENvbHVtbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY29sdW1uU29ydE9iaiA9IHNvcnRDb2x1bW5zW2ldO1xyXG4gICAgICAgIGlmIChjb2x1bW5Tb3J0T2JqICYmIGNvbHVtblNvcnRPYmouc29ydENvbCkge1xyXG4gICAgICAgICAgY29uc3Qgc29ydERpcmVjdGlvbiA9IGNvbHVtblNvcnRPYmouc29ydEFzYyA/IFNvcnREaXJlY3Rpb25OdW1iZXIuYXNjIDogU29ydERpcmVjdGlvbk51bWJlci5kZXNjO1xyXG4gICAgICAgICAgY29uc3Qgc29ydEZpZWxkID0gY29sdW1uU29ydE9iai5zb3J0Q29sLnF1ZXJ5RmllbGRTb3J0ZXIgfHwgY29sdW1uU29ydE9iai5zb3J0Q29sLnF1ZXJ5RmllbGQgfHwgY29sdW1uU29ydE9iai5zb3J0Q29sLmZpZWxkO1xyXG4gICAgICAgICAgY29uc3QgZmllbGRUeXBlID0gY29sdW1uU29ydE9iai5zb3J0Q29sLnR5cGUgfHwgRmllbGRUeXBlLnN0cmluZztcclxuICAgICAgICAgIGxldCB2YWx1ZTEgPSBkYXRhUm93MVtzb3J0RmllbGRdO1xyXG4gICAgICAgICAgbGV0IHZhbHVlMiA9IGRhdGFSb3cyW3NvcnRGaWVsZF07XHJcblxyXG4gICAgICAgICAgLy8gd2hlbiBpdGVtIGlzIGEgY29tcGxleCBvYmplY3QgKGRvdCBcIi5cIiBub3RhdGlvbiksIHdlIG5lZWQgdG8gZmlsdGVyIHRoZSB2YWx1ZSBjb250YWluZWQgaW4gdGhlIG9iamVjdCB0cmVlXHJcbiAgICAgICAgICBpZiAoc29ydEZpZWxkICYmIHNvcnRGaWVsZC5pbmRleE9mKCcuJykgPj0gMCkge1xyXG4gICAgICAgICAgICB2YWx1ZTEgPSBnZXREZXNjZW5kYW50UHJvcGVydHkoZGF0YVJvdzEsIHNvcnRGaWVsZCk7XHJcbiAgICAgICAgICAgIHZhbHVlMiA9IGdldERlc2NlbmRhbnRQcm9wZXJ0eShkYXRhUm93Miwgc29ydEZpZWxkKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyB1c2VyIGNvdWxkIHByb3ZpZGUgaGlzIG93biBjdXN0b20gU29ydGVyXHJcbiAgICAgICAgICBpZiAoY29sdW1uU29ydE9iai5zb3J0Q29sICYmIGNvbHVtblNvcnRPYmouc29ydENvbC5zb3J0ZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgY3VzdG9tU29ydFJlc3VsdCA9IGNvbHVtblNvcnRPYmouc29ydENvbC5zb3J0ZXIodmFsdWUxLCB2YWx1ZTIsIHNvcnREaXJlY3Rpb24sIGNvbHVtblNvcnRPYmouc29ydENvbCk7XHJcbiAgICAgICAgICAgIGlmIChjdXN0b21Tb3J0UmVzdWx0ICE9PSBTb3J0RGlyZWN0aW9uTnVtYmVyLm5ldXRyYWwpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gY3VzdG9tU29ydFJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgc29ydFJlc3VsdCA9IHNvcnRCeUZpZWxkVHlwZShmaWVsZFR5cGUsIHZhbHVlMSwgdmFsdWUyLCBzb3J0RGlyZWN0aW9uLCBjb2x1bW5Tb3J0T2JqLnNvcnRDb2wpO1xyXG4gICAgICAgICAgICBpZiAoc29ydFJlc3VsdCAhPT0gU29ydERpcmVjdGlvbk51bWJlci5uZXV0cmFsKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHNvcnRSZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBTb3J0RGlyZWN0aW9uTnVtYmVyLm5ldXRyYWw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgU29ydGluZyAoc29ydGVycykgZHluYW1pY2FsbHkganVzdCBieSBwcm92aWRpbmcgYW4gYXJyYXkgb2Ygc29ydGVyKHMpLlxyXG4gICAqIFlvdSBjYW4gYWxzbyBjaG9vc2UgZW1pdCAoZGVmYXVsdCkgYSBTb3J0IENoYW5nZWQgZXZlbnQgdGhhdCB3aWxsIGJlIHBpY2tlZCBieSB0aGUgR3JpZCBTdGF0ZSBTZXJ2aWNlLlxyXG4gICAqXHJcbiAgICogQWxzbyBmb3IgYmFja2VuZCBzZXJ2aWNlIG9ubHksIHlvdSBjYW4gY2hvb3NlIHRvIHRyaWdnZXIgYSBiYWNrZW5kIHF1ZXJ5IChkZWZhdWx0KSBvciBub3QgaWYgeW91IHdpc2ggdG8gZG8gaXQgbGF0ZXIsXHJcbiAgICogdGhpcyBjb3VsZCBiZSB1c2VmdWwgd2hlbiB1c2luZyB1cGRhdGVGaWx0ZXJzICYgdXBkYXRlU29ydGluZyBhbmQgeW91IHdpc2ggdG8gb25seSBzZW5kIHRoZSBiYWNrZW5kIHF1ZXJ5IG9uY2UuXHJcbiAgICogQHBhcmFtIHNvcnRlcnMgYXJyYXlcclxuICAgKiBAcGFyYW0gdHJpZ2dlckV2ZW50IGRlZmF1bHRzIHRvIFRydWUsIGRvIHdlIHdhbnQgdG8gZW1pdCBhIHNvcnQgY2hhbmdlZCBldmVudD9cclxuICAgKiBAcGFyYW0gdHJpZ2dlckJhY2tlbmRRdWVyeSBkZWZhdWx0cyB0byBUcnVlLCB3aGljaCB3aWxsIHF1ZXJ5IHRoZSBiYWNrZW5kLlxyXG4gICAqL1xyXG4gIHVwZGF0ZVNvcnRpbmcoc29ydGVyczogQ3VycmVudFNvcnRlcltdLCBlbWl0Q2hhbmdlZEV2ZW50ID0gdHJ1ZSwgdHJpZ2dlckJhY2tlbmRRdWVyeSA9IHRydWUpIHtcclxuICAgIGlmICghdGhpcy5fZ3JpZE9wdGlvbnMgfHwgIXRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZVNvcnRpbmcpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbQW5ndWxhci1TbGlja2dyaWRdIGluIG9yZGVyIHRvIHVzZSBcInVwZGF0ZVNvcnRpbmdcIiBtZXRob2QsIHlvdSBuZWVkIHRvIGhhdmUgU29ydGFibGUgQ29sdW1ucyBkZWZpbmVkIGluIHlvdXIgZ3JpZCBhbmQgXCJlbmFibGVTb3J0aW5nXCIgc2V0IGluIHlvdXIgR3JpZCBPcHRpb25zJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc29ydGVycykpIHtcclxuICAgICAgY29uc3QgYmFja2VuZEFwaSA9IHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLmJhY2tlbmRTZXJ2aWNlQXBpO1xyXG5cclxuICAgICAgaWYgKGJhY2tlbmRBcGkpIHtcclxuICAgICAgICBjb25zdCBiYWNrZW5kQXBpU2VydmljZSA9IGJhY2tlbmRBcGkgJiYgYmFja2VuZEFwaS5zZXJ2aWNlO1xyXG4gICAgICAgIGlmIChiYWNrZW5kQXBpU2VydmljZSkge1xyXG4gICAgICAgICAgYmFja2VuZEFwaVNlcnZpY2UudXBkYXRlU29ydGVycyh1bmRlZmluZWQsIHNvcnRlcnMpO1xyXG4gICAgICAgICAgaWYgKHRyaWdnZXJCYWNrZW5kUXVlcnkpIHtcclxuICAgICAgICAgICAgcmVmcmVzaEJhY2tlbmREYXRhc2V0KHRoaXMuX2dyaWRPcHRpb25zKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5sb2FkR3JpZFNvcnRlcnMoc29ydGVycyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChlbWl0Q2hhbmdlZEV2ZW50KSB7XHJcbiAgICAgICAgY29uc3QgZW1pdHRlclR5cGUgPSBiYWNrZW5kQXBpID8gRW1pdHRlclR5cGUucmVtb3RlIDogRW1pdHRlclR5cGUubG9jYWw7XHJcbiAgICAgICAgdGhpcy5lbWl0U29ydENoYW5nZWQoZW1pdHRlclR5cGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiJdfQ==