import * as tslib_1 from "tslib";
import { Injectable, Optional } from '@angular/core';
import { TranslateService } from '@ngx-translate/core';
import { TextEncoder } from 'text-encoding-utf-8';
import { Subject } from 'rxjs';
import { FileType, } from './../models/index';
import { Constants } from './../constants';
import { exportWithFormatterWhenDefined } from './export-utilities';
import { addWhiteSpaces, htmlEntityDecode, sanitizeHtmlToText, titleCase } from './../services/utilities';
var ExportService = /** @class */ (function () {
    function ExportService(translate) {
        this.translate = translate;
        this._delimiter = ',';
        this._fileFormat = FileType.csv;
        this._lineCarriageReturn = '\n';
        this._exportQuoteWrapper = '';
        this._hasGroupedItems = false;
        this.onGridBeforeExportToFile = new Subject();
        this.onGridAfterExportToFile = new Subject();
    }
    Object.defineProperty(ExportService.prototype, "datasetIdName", {
        get: function () {
            return this._gridOptions && this._gridOptions.datasetIdPropertyName || 'id';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExportService.prototype, "_gridOptions", {
        /** Getter for the Grid Options pulled through the Grid Object */
        get: function () {
            return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Initialize the Export Service
     * @param grid
     * @param gridOptions
     * @param dataView
     */
    ExportService.prototype.init = function (grid, dataView) {
        this._grid = grid;
        this._dataView = dataView;
        // get locales provided by user in forRoot or else use default English locales via the Constants
        this._locales = this._gridOptions && this._gridOptions.locales || Constants.locales;
        if (this._gridOptions.enableTranslate && (!this.translate || !this.translate.instant)) {
            throw new Error('[Angular-Slickgrid] requires "ngx-translate" to be installed and configured when the grid option "enableTranslate" is enabled.');
        }
    };
    /**
     * Function to export the Grid result to an Excel CSV format using javascript for it to produce the CSV file.
     * This is a WYSIWYG export to file output (What You See is What You Get)
     *
     * NOTES: The column position needs to match perfectly the JSON Object position because of the way we are pulling the data,
     * which means that if any column(s) got moved in the UI, it has to be reflected in the JSON array output as well
     *
     * Example: exportToFile({ format: FileType.csv, delimiter: DelimiterType.comma })
     */
    ExportService.prototype.exportToFile = function (options) {
        var _this = this;
        if (!this._grid || !this._dataView) {
            throw new Error('[Angular-Slickgrid] it seems that the SlickGrid & DataView objects are not initialized did you forget to enable the grid option flag "enableExcelExport"?');
        }
        return new Promise(function (resolve, reject) {
            _this.onGridBeforeExportToFile.next(true);
            _this._exportOptions = $.extend(true, {}, _this._gridOptions.exportOptions, options);
            _this._delimiter = _this._exportOptions.delimiterOverride || _this._exportOptions.delimiter || '';
            _this._fileFormat = _this._exportOptions.format || FileType.csv;
            // get the CSV output from the grid data
            var dataOutput = _this.getDataOutput();
            // trigger a download file
            // wrap it into a setTimeout so that the EventAggregator has enough time to start a pre-process like showing a spinner
            setTimeout(function () {
                try {
                    var downloadOptions = {
                        filename: _this._exportOptions.filename + "." + _this._fileFormat,
                        format: _this._fileFormat,
                        useUtf8WithBom: _this._exportOptions.hasOwnProperty('useUtf8WithBom') ? _this._exportOptions.useUtf8WithBom : true
                    };
                    // start downloading but add the content property only on the start download not on the event itself
                    _this.startDownloadFile(tslib_1.__assign({}, downloadOptions, { content: dataOutput })); // add content property
                    _this.onGridAfterExportToFile.next(downloadOptions);
                    resolve(true);
                }
                catch (error) {
                    reject(error);
                }
            }, 0);
        });
    };
    /**
     * Triggers download file with file format.
     * IE(6-10) are not supported
     * All other browsers will use plain javascript on client side to produce a file download.
     * @param options
     */
    ExportService.prototype.startDownloadFile = function (options) {
        // IE(6-10) don't support javascript download and our service doesn't support either so throw an error, we have to make a round trip to the Web Server for exporting
        if (navigator.appName === 'Microsoft Internet Explorer') {
            throw new Error('Microsoft Internet Explorer 6 to 10 do not support javascript export to CSV. Please upgrade your browser.');
        }
        // set the correct MIME type
        var mimeType = (options.format === FileType.csv) ? 'text/csv' : 'text/plain';
        // make sure no html entities exist in the data
        var dataContent = htmlEntityDecode(options.content);
        // dealing with Excel CSV export and UTF-8 is a little tricky.. We will use Option #2 to cover older Excel versions
        // Option #1: we need to make Excel knowing that it's dealing with an UTF-8, A correctly formatted UTF8 file can have a Byte Order Mark as its first three octets
        // reference: http://stackoverflow.com/questions/155097/microsoft-excel-mangles-diacritics-in-csv-files
        // Option#2: use a 3rd party extension to javascript encode into UTF-16
        var outputData;
        if (options.format === FileType.csv) {
            outputData = new TextEncoder('utf-8').encode(dataContent);
        }
        else {
            outputData = dataContent;
        }
        // create a Blob object for the download
        var blob = new Blob([options.useUtf8WithBom ? '\uFEFF' : '', outputData], {
            type: mimeType + ";charset=utf-8;"
        });
        // when using IE/Edge, then use different download call
        if (typeof navigator.msSaveOrOpenBlob === 'function') {
            navigator.msSaveOrOpenBlob(blob, options.filename);
        }
        else {
            // this trick will generate a temp <a /> tag
            // the code will then trigger a hidden click for it to start downloading
            var link = document.createElement('a');
            var csvUrl = URL.createObjectURL(blob);
            link.textContent = 'download';
            link.href = csvUrl;
            link.setAttribute('download', options.filename);
            // set the visibility to hidden so there is no effect on your web-layout
            link.style.visibility = 'hidden';
            // this part will append the anchor tag, trigger a click (for download to start) and finally remove the tag once completed
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    };
    // -----------------------
    // Private functions
    // -----------------------
    ExportService.prototype.getDataOutput = function () {
        var _this = this;
        var columns = this._grid.getColumns() || [];
        // Group By text, it could be set in the export options or from translation or if nothing is found then use the English constant text
        var groupByColumnHeader = this._exportOptions.groupingColumnHeaderTitle;
        if (!groupByColumnHeader && this._gridOptions.enableTranslate && this.translate && this.translate.currentLang && this.translate.instant) {
            groupByColumnHeader = this.translate.instant('GROUP_BY');
        }
        else if (!groupByColumnHeader) {
            groupByColumnHeader = this._locales && this._locales.TEXT_GROUP_BY;
        }
        // a CSV needs double quotes wrapper, the other types do not need any wrapper
        this._exportQuoteWrapper = (this._fileFormat === FileType.csv) ? '"' : '';
        // data variable which will hold all the fields data of a row
        var outputDataString = '';
        // get grouped column titles and if found, we will add a "Group by" column at the first column index
        // if it's a CSV format, we'll escape the text in double quotes
        var grouping = this._dataView.getGrouping();
        if (grouping && Array.isArray(grouping) && grouping.length > 0) {
            this._hasGroupedItems = true;
            outputDataString += (this._fileFormat === FileType.csv) ? "\"" + groupByColumnHeader + "\"" + this._delimiter : "" + groupByColumnHeader + this._delimiter;
        }
        else {
            this._hasGroupedItems = false;
        }
        // get all column headers
        this._columnHeaders = this.getColumnHeaders(columns) || [];
        if (this._columnHeaders && Array.isArray(this._columnHeaders) && this._columnHeaders.length > 0) {
            // add the header row + add a new line at the end of the row
            var outputHeaderTitles = this._columnHeaders.map(function (header) {
                return _this._exportQuoteWrapper + header.title + _this._exportQuoteWrapper;
            });
            outputDataString += (outputHeaderTitles.join(this._delimiter) + this._lineCarriageReturn);
        }
        // Populate the rest of the Grid Data
        outputDataString += this.getAllGridRowData(columns, this._lineCarriageReturn);
        return outputDataString;
    };
    /**
     * Get all the grid row data and return that as an output string
     */
    ExportService.prototype.getAllGridRowData = function (columns, lineCarriageReturn) {
        var outputDataStrings = [];
        var lineCount = this._dataView.getLength();
        // loop through all the grid rows of data
        for (var rowNumber = 0; rowNumber < lineCount; rowNumber++) {
            var itemObj = this._dataView.getItem(rowNumber);
            if (itemObj != null) {
                // Normal row (not grouped by anything) would have an ID which was predefined in the Grid Columns definition
                if (itemObj[this.datasetIdName] != null) {
                    // get regular row item data
                    outputDataStrings.push(this.readRegularRowData(columns, rowNumber, itemObj));
                }
                else if (this._hasGroupedItems && itemObj.__groupTotals === undefined) {
                    // get the group row
                    outputDataStrings.push(this.readGroupedTitleRow(itemObj));
                }
                else if (itemObj.__groupTotals) {
                    // else if the row is a Group By and we have agreggators, then a property of '__groupTotals' would exist under that object
                    outputDataStrings.push(this.readGroupedTotalRow(columns, itemObj));
                }
            }
        }
        return outputDataStrings.join(lineCarriageReturn);
    };
    /**
     * Get all header titles and their keys, translate the title when required.
     * @param columns of the grid
     */
    ExportService.prototype.getColumnHeaders = function (columns) {
        var _this = this;
        if (!columns || !Array.isArray(columns) || columns.length === 0) {
            return null;
        }
        var columnHeaders = [];
        // Populate the Column Header, pull the name defined
        columns.forEach(function (columnDef) {
            var headerTitle = '';
            if ((columnDef.headerKey || columnDef.nameKey) && _this._gridOptions.enableTranslate && _this.translate && _this.translate.currentLang && _this.translate.instant) {
                headerTitle = _this.translate.instant((columnDef.headerKey || columnDef.nameKey));
            }
            else {
                headerTitle = columnDef.name || titleCase(columnDef.field);
            }
            var skippedField = columnDef.excludeFromExport || false;
            // if column width is 0, then we consider that field as a hidden field and should not be part of the export
            if ((columnDef.width === undefined || columnDef.width > 0) && !skippedField) {
                columnHeaders.push({
                    key: columnDef.field || columnDef.id,
                    title: headerTitle
                });
            }
        });
        return columnHeaders;
    };
    /**
     * Get the data of a regular row (a row without grouping)
     * @param row
     * @param itemObj
     */
    ExportService.prototype.readRegularRowData = function (columns, row, itemObj) {
        var idx = 0;
        var rowOutputStrings = [];
        var exportQuoteWrapper = this._exportQuoteWrapper;
        for (var col = 0, ln = columns.length; col < ln; col++) {
            var columnDef = columns[col];
            // skip excluded column
            if (columnDef.excludeFromExport) {
                continue;
            }
            // if we are grouping and are on 1st column index, we need to skip this column since it will be used later by the grouping text:: Group by [columnX]
            if (this._hasGroupedItems && idx === 0) {
                var emptyValue = this._fileFormat === FileType.csv ? "\"\"" : '';
                rowOutputStrings.push(emptyValue);
            }
            // get the output by analyzing if we'll pull the value from the cell or from a formatter
            var itemData = exportWithFormatterWhenDefined(row, col, itemObj, columnDef, this._grid, this._exportOptions);
            // does the user want to sanitize the output data (remove HTML tags)?
            if (columnDef.sanitizeDataExport || this._exportOptions.sanitizeDataExport) {
                itemData = sanitizeHtmlToText(itemData);
            }
            // when CSV we also need to escape double quotes twice, so " becomes ""
            if (this._fileFormat === FileType.csv && itemData) {
                itemData = itemData.toString().replace(/"/gi, "\"\"");
            }
            // do we have a wrapper to keep as a string? in certain cases like "1E06", we don't want excel to transform it into exponential (1.0E06)
            // to cancel that effect we can had = in front, ex: ="1E06"
            var keepAsStringWrapper = (columnDef && columnDef.exportCsvForceToKeepAsString) ? '=' : '';
            rowOutputStrings.push(keepAsStringWrapper + exportQuoteWrapper + itemData + exportQuoteWrapper);
            idx++;
        }
        return rowOutputStrings.join(this._delimiter);
    };
    /**
     * Get the grouped title(s) and its group title formatter, for example if we grouped by salesRep, the returned result would be:: 'Sales Rep: John Dow (2 items)'
     * @param itemObj
     */
    ExportService.prototype.readGroupedTitleRow = function (itemObj) {
        var groupName = sanitizeHtmlToText(itemObj.title);
        var exportQuoteWrapper = this._exportQuoteWrapper;
        groupName = addWhiteSpaces(5 * itemObj.level) + groupName;
        if (this._fileFormat === FileType.csv) {
            // when CSV we also need to escape double quotes twice, so " becomes ""
            groupName = groupName.toString().replace(/"/gi, "\"\"");
        }
        return exportQuoteWrapper + groupName + exportQuoteWrapper;
    };
    /**
     * Get the grouped totals (below the regular rows), these are set by Slick Aggregators.
     * For example if we grouped by "salesRep" and we have a Sum Aggregator on "sales", then the returned output would be:: ["Sum 123$"]
     * @param itemObj
     */
    ExportService.prototype.readGroupedTotalRow = function (columns, itemObj) {
        var _this = this;
        var delimiter = this._exportOptions.delimiter;
        var format = this._exportOptions.format;
        var groupingAggregatorRowText = this._exportOptions.groupingAggregatorRowText || '';
        var exportQuoteWrapper = this._exportQuoteWrapper;
        var outputStrings = ["" + exportQuoteWrapper + groupingAggregatorRowText + exportQuoteWrapper];
        columns.forEach(function (columnDef) {
            var itemData = '';
            var skippedField = columnDef.excludeFromExport || false;
            // if there's a groupTotalsFormatter, we will re-run it to get the exact same output as what is shown in UI
            if (columnDef.groupTotalsFormatter) {
                itemData = columnDef.groupTotalsFormatter(itemObj, columnDef);
            }
            // does the user want to sanitize the output data (remove HTML tags)?
            if (columnDef.sanitizeDataExport || _this._exportOptions.sanitizeDataExport) {
                itemData = sanitizeHtmlToText(itemData);
            }
            if (format === FileType.csv) {
                // when CSV we also need to escape double quotes twice, so a double quote " becomes 2x double quotes ""
                itemData = itemData.toString().replace(/"/gi, "\"\"");
            }
            // add the column (unless user wants to skip it)
            if ((columnDef.width === undefined || columnDef.width > 0) && !skippedField) {
                outputStrings.push(exportQuoteWrapper + itemData + exportQuoteWrapper);
            }
        });
        return outputStrings.join(delimiter);
    };
    ExportService = tslib_1.__decorate([
        Injectable(),
        tslib_1.__param(0, Optional()),
        tslib_1.__metadata("design:paramtypes", [TranslateService])
    ], ExportService);
    return ExportService;
}());
export { ExportService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwb3J0LnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyLXNsaWNrZ3JpZC8iLCJzb3VyY2VzIjpbImFwcC9tb2R1bGVzL2FuZ3VsYXItc2xpY2tncmlkL3NlcnZpY2VzL2V4cG9ydC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNyRCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN2RCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDbEQsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUUvQixPQUFPLEVBR0wsUUFBUSxHQUlULE1BQU0sbUJBQW1CLENBQUM7QUFDM0IsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzNDLE9BQU8sRUFBRSw4QkFBOEIsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ3BFLE9BQU8sRUFBRSxjQUFjLEVBQUUsZ0JBQWdCLEVBQUUsa0JBQWtCLEVBQUUsU0FBUyxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFNMUc7SUFlRSx1QkFBZ0MsU0FBMkI7UUFBM0IsY0FBUyxHQUFULFNBQVMsQ0FBa0I7UUFkbkQsZUFBVSxHQUFHLEdBQUcsQ0FBQztRQUNqQixnQkFBVyxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUM7UUFDM0Isd0JBQW1CLEdBQUcsSUFBSSxDQUFDO1FBSTNCLHdCQUFtQixHQUFHLEVBQUUsQ0FBQztRQUd6QixxQkFBZ0IsR0FBRyxLQUFLLENBQUM7UUFFakMsNkJBQXdCLEdBQUcsSUFBSSxPQUFPLEVBQVcsQ0FBQztRQUNsRCw0QkFBdUIsR0FBRyxJQUFJLE9BQU8sRUFBb0YsQ0FBQztJQUUzRCxDQUFDO0lBRWhFLHNCQUFZLHdDQUFhO2FBQXpCO1lBQ0UsT0FBTyxJQUFJLENBQUMsWUFBWSxJQUFJ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QUEyRztZQUMzRyxJQUFJLFNBQVMsQ0FBQyxvQkFBb0IsRUFBRTtnQkFDbEMsUUFBUSxHQUFHLFNBQVMsQ0FBQyxvQkFBb0IsQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUM7YUFDL0Q7WUFFRCxxRUFBcUU7WUFDckUsSUFBSSxTQUFTLENBQUMsa0JBQWtCLElBQUksS0FBSSxDQUFDLGNBQWMsQ0FBQyxrQkFBa0IsRUFBRTtnQkFDMUUsUUFBUSxHQUFHLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxDQUFDO2FBQ3pDO1lBRUQsSUFBSSxNQUFNLEtBQUssUUFBUSxDQUFDLEdBQUcsRUFBRTtnQkFDM0IsdUdBQXVHO2dCQUN2RyxRQUFRLEdBQUcsUUFBUSxDQUFDLFFBQVEsRUFBRSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsTUFBSSxDQUFDLENBQUM7YUFDckQ7WUFFRCxnREFBZ0Q7WUFDaEQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEtBQUssU0FBUyxJQUFJLFNBQVMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUU7Z0JBQzNFLGFBQWEsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLEdBQUcsUUFBUSxHQUFHLGtCQUFrQixDQUFDLENBQUM7YUFDeEU7UUFDSCxDQUFDLENBQUMsQ0FBQztRQUVILE9BQU8sYUFBYSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUN2QyxDQUFDO0lBcFdVLGFBQWE7UUFEekIsVUFBVSxFQUFFO1FBZ0JFLG1CQUFBLFFBQVEsRUFBRSxDQUFBO2lEQUFvQixnQkFBZ0I7T0FmaEQsYUFBYSxDQXFXekI7SUFBRCxvQkFBQztDQUFBLEFBcldELElBcVdDO1NBcldZLGFBQWEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBUcmFuc2xhdGVTZXJ2aWNlIH0gZnJvbSAnQG5neC10cmFuc2xhdGUvY29yZSc7XHJcbmltcG9ydCB7IFRleHRFbmNvZGVyIH0gZnJvbSAndGV4dC1lbmNvZGluZy11dGYtOCc7XHJcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcclxuXHJcbmltcG9ydCB7XHJcbiAgQ29sdW1uLFxyXG4gIEV4cG9ydE9wdGlvbixcclxuICBGaWxlVHlwZSxcclxuICBHcmlkT3B0aW9uLFxyXG4gIEtleVRpdGxlUGFpcixcclxuICBMb2NhbGUsXHJcbn0gZnJvbSAnLi8uLi9tb2RlbHMvaW5kZXgnO1xyXG5pbXBvcnQgeyBDb25zdGFudHMgfSBmcm9tICcuLy4uL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7IGV4cG9ydFdpdGhGb3JtYXR0ZXJXaGVuRGVmaW5lZCB9IGZyb20gJy4vZXhwb3J0LXV0aWxpdGllcyc7XHJcbmltcG9ydCB7IGFkZFdoaXRlU3BhY2VzLCBodG1sRW50aXR5RGVjb2RlLCBzYW5pdGl6ZUh0bWxUb1RleHQsIHRpdGxlQ2FzZSB9IGZyb20gJy4vLi4vc2VydmljZXMvdXRpbGl0aWVzJztcclxuXHJcbi8vIHVzaW5nIGV4dGVybmFsIG5vbi10eXBlZCBqcyBsaWJyYXJpZXNcclxuZGVjbGFyZSBsZXQgJDogYW55O1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgRXhwb3J0U2VydmljZSB7XHJcbiAgcHJpdmF0ZSBfZGVsaW1pdGVyID0gJywnO1xyXG4gIHByaXZhdGUgX2ZpbGVGb3JtYXQgPSBGaWxlVHlwZS5jc3Y7XHJcbiAgcHJpdmF0ZSBfbGluZUNhcnJpYWdlUmV0dXJuID0gJ1xcbic7XHJcbiAgcHJpdmF0ZSBfZGF0YVZpZXc6IGFueTtcclxuICBwcml2YXRlIF9ncmlkOiBhbnk7XHJcbiAgcHJpdmF0ZSBfbG9jYWxlczogTG9jYWxlO1xyXG4gIHByaXZhdGUgX2V4cG9ydFF1b3RlV3JhcHBlciA9ICcnO1xyXG4gIHByaXZhdGUgX2NvbHVtbkhlYWRlcnM6IEtleVRpdGxlUGFpcltdO1xyXG4gIHByaXZhdGUgX2dyb3VwZWRIZWFkZXJzOiBLZXlUaXRsZVBhaXJbXTtcclxuICBwcml2YXRlIF9oYXNHcm91cGVkSXRlbXMgPSBmYWxzZTtcclxuICBwcml2YXRlIF9leHBvcnRPcHRpb25zOiBFeHBvcnRPcHRpb247XHJcbiAgb25HcmlkQmVmb3JlRXhwb3J0VG9GaWxlID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcclxuICBvbkdyaWRBZnRlckV4cG9ydFRvRmlsZSA9IG5ldyBTdWJqZWN0PHsgY29udGVudD86IHN0cmluZzsgZmlsZW5hbWU6IHN0cmluZzsgZm9ybWF0OiBzdHJpbmc7IHVzZVV0ZjhXaXRoQm9tOiBib29sZWFuOyB9PigpO1xyXG5cclxuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBwcml2YXRlIHRyYW5zbGF0ZTogVHJhbnNsYXRlU2VydmljZSkgeyB9XHJcblxyXG4gIHByaXZhdGUgZ2V0IGRhdGFzZXRJZE5hbWUoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5kYXRhc2V0SWRQcm9wZXJ0eU5hbWUgfHwgJ2lkJztcclxuICB9XHJcblxyXG4gIC8qKiBHZXR0ZXIgZm9yIHRoZSBHcmlkIE9wdGlvbnMgcHVsbGVkIHRocm91Z2ggdGhlIEdyaWQgT2JqZWN0ICovXHJcbiAgcHJpdmF0ZSBnZXQgX2dyaWRPcHRpb25zKCk6IEdyaWRPcHRpb24ge1xyXG4gICAgcmV0dXJuICh0aGlzLl9ncmlkICYmIHRoaXMuX2dyaWQuZ2V0T3B0aW9ucykgPyB0aGlzLl9ncmlkLmdldE9wdGlvbnMoKSA6IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSB0aGUgRXhwb3J0IFNlcnZpY2VcclxuICAgKiBAcGFyYW0gZ3JpZFxyXG4gICAqIEBwYXJhbSBncmlkT3B0aW9uc1xyXG4gICAqIEBwYXJhbSBkYXRhVmlld1xyXG4gICAqL1xyXG4gIGluaXQoZ3JpZDogYW55LCBkYXRhVmlldzogYW55KTogdm9pZCB7XHJcbiAgICB0aGlzLl9ncmlkID0gZ3JpZDtcclxuICAgIHRoaXMuX2RhdGFWaWV3ID0gZGF0YVZpZXc7XHJcblxyXG4gICAgLy8gZ2V0IGxvY2FsZXMgcHJvdmlkZWQgYnkgdXNlciBpbiBmb3JSb290IG9yIGVsc2UgdXNlIGRlZmF1bHQgRW5nbGlzaCBsb2NhbGVzIHZpYSB0aGUgQ29uc3RhbnRzXHJcbiAgICB0aGlzLl9sb2NhbGVzID0gdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMubG9jYWxlcyB8fCBDb25zdGFudHMubG9jYWxlcztcclxuXHJcbiAgICBpZiAodGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlVHJhbnNsYXRlICYmICghdGhpcy50cmFuc2xhdGUgfHwgIXRoaXMudHJhbnNsYXRlLmluc3RhbnQpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignW0FuZ3VsYXItU2xpY2tncmlkXSByZXF1aXJlcyBcIm5neC10cmFuc2xhdGVcIiB0byBiZSBpbnN0YWxsZWQgYW5kIGNvbmZpZ3VyZWQgd2hlbiB0aGUgZ3JpZCBvcHRpb24gXCJlbmFibGVUcmFuc2xhdGVcIiBpcyBlbmFibGVkLicpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRnVuY3Rpb24gdG8gZXhwb3J0IHRoZSBHcmlkIHJlc3VsdCB0byBhbiBFeGNlbCBDU1YgZm9ybWF0IHVzaW5nIGphdmFzY3JpcHQgZm9yIGl0IHRvIHByb2R1Y2UgdGhlIENTViBmaWxlLlxyXG4gICAqIFRoaXMgaXMgYSBXWVNJV1lHIGV4cG9ydCB0byBmaWxlIG91dHB1dCAoV2hhdCBZb3UgU2VlIGlzIFdoYXQgWW91IEdldClcclxuICAgKlxyXG4gICAqIE5PVEVTOiBUaGUgY29sdW1uIHBvc2l0aW9uIG5lZWRzIHRvIG1hdGNoIHBlcmZlY3RseSB0aGUgSlNPTiBPYmplY3QgcG9zaXRpb24gYmVjYXVzZSBvZiB0aGUgd2F5IHdlIGFyZSBwdWxsaW5nIHRoZSBkYXRhLFxyXG4gICAqIHdoaWNoIG1lYW5zIHRoYXQgaWYgYW55IGNvbHVtbihzKSBnb3QgbW92ZWQgaW4gdGhlIFVJLCBpdCBoYXMgdG8gYmUgcmVmbGVjdGVkIGluIHRoZSBKU09OIGFycmF5IG91dHB1dCBhcyB3ZWxsXHJcbiAgICpcclxuICAgKiBFeGFtcGxlOiBleHBvcnRUb0ZpbGUoeyBmb3JtYXQ6IEZpbGVUeXBlLmNzdiwgZGVsaW1pdGVyOiBEZWxpbWl0ZXJUeXBlLmNvbW1hIH0pXHJcbiAgICovXHJcbiAgZXhwb3J0VG9GaWxlKG9wdGlvbnM6IEV4cG9ydE9wdGlvbik6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgaWYgKCF0aGlzLl9ncmlkIHx8ICF0aGlzLl9kYXRhVmlldykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tBbmd1bGFyLVNsaWNrZ3JpZF0gaXQgc2VlbXMgdGhhdCB0aGUgU2xpY2tHcmlkICYgRGF0YVZpZXcgb2JqZWN0cyBhcmUgbm90IGluaXRpYWxpemVkIGRpZCB5b3UgZm9yZ2V0IHRvIGVuYWJsZSB0aGUgZ3JpZCBvcHRpb24gZmxhZyBcImVuYWJsZUV4Y2VsRXhwb3J0XCI/Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgdGhpcy5vbkdyaWRCZWZvcmVFeHBvcnRUb0ZpbGUubmV4dCh0cnVlKTtcclxuICAgICAgdGhpcy5fZXhwb3J0T3B0aW9ucyA9ICQuZXh0ZW5kKHRydWUsIHt9LCB0aGlzLl9ncmlkT3B0aW9ucy5leHBvcnRPcHRpb25zLCBvcHRpb25zKTtcclxuICAgICAgdGhpcy5fZGVsaW1pdGVyID0gdGhpcy5fZXhwb3J0T3B0aW9ucy5kZWxpbWl0ZXJPdmVycmlkZSB8fCB0aGlzLl9leHBvcnRPcHRpb25zLmRlbGltaXRlciB8fCAnJztcclxuICAgICAgdGhpcy5fZmlsZUZvcm1hdCA9IHRoaXMuX2V4cG9ydE9wdGlvbnMuZm9ybWF0IHx8IEZpbGVUeXBlLmNzdjtcclxuXHJcbiAgICAgIC8vIGdldCB0aGUgQ1NWIG91dHB1dCBmcm9tIHRoZSBncmlkIGRhdGFcclxuICAgICAgY29uc3QgZGF0YU91dHB1dCA9IHRoaXMuZ2V0RGF0YU91dHB1dCgpO1xyXG5cclxuICAgICAgLy8gdHJpZ2dlciBhIGRvd25sb2FkIGZpbGVcclxuICAgICAgLy8gd3JhcCBpdCBpbnRvIGEgc2V0VGltZW91dCBzbyB0aGF0IHRoZSBFdmVudEFnZ3JlZ2F0b3IgaGFzIGVub3VnaCB0aW1lIHRvIHN0YXJ0IGEgcHJlLXByb2Nlc3MgbGlrZSBzaG93aW5nIGEgc3Bpbm5lclxyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgZG93bmxvYWRPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBmaWxlbmFtZTogYCR7dGhpcy5fZXhwb3J0T3B0aW9ucy5maWxlbmFtZX0uJHt0aGlzLl9maWxlRm9ybWF0fWAsXHJcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5fZmlsZUZvcm1hdCxcclxuICAgICAgICAgICAgdXNlVXRmOFdpdGhCb206IHRoaXMuX2V4cG9ydE9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3VzZVV0ZjhXaXRoQm9tJykgPyB0aGlzLl9leHBvcnRPcHRpb25zLnVzZVV0ZjhXaXRoQm9tIDogdHJ1ZVxyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAvLyBzdGFydCBkb3dubG9hZGluZyBidXQgYWRkIHRoZSBjb250ZW50IHByb3BlcnR5IG9ubHkgb24gdGhlIHN0YXJ0IGRvd25sb2FkIG5vdCBvbiB0aGUgZXZlbnQgaXRzZWxmXHJcbiAgICAgICAgICB0aGlzLnN0YXJ0RG93bmxvYWRGaWxlKHsgLi4uZG93bmxvYWRPcHRpb25zLCBjb250ZW50OiBkYXRhT3V0cHV0IH0pOyAvLyBhZGQgY29udGVudCBwcm9wZXJ0eVxyXG4gICAgICAgICAgdGhpcy5vbkdyaWRBZnRlckV4cG9ydFRvRmlsZS5uZXh0KGRvd25sb2FkT3B0aW9ucyk7XHJcbiAgICAgICAgICByZXNvbHZlKHRydWUpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwgMCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyaWdnZXJzIGRvd25sb2FkIGZpbGUgd2l0aCBmaWxlIGZvcm1hdC5cclxuICAgKiBJRSg2LTEwKSBhcmUgbm90IHN1cHBvcnRlZFxyXG4gICAqIEFsbCBvdGhlciBicm93c2VycyB3aWxsIHVzZSBwbGFpbiBqYXZhc2NyaXB0IG9uIGNsaWVudCBzaWRlIHRvIHByb2R1Y2UgYSBmaWxlIGRvd25sb2FkLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICovXHJcbiAgc3RhcnREb3dubG9hZEZpbGUob3B0aW9uczogeyBmaWxlbmFtZTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcsIGZvcm1hdDogRmlsZVR5cGUgfCBzdHJpbmcsIHVzZVV0ZjhXaXRoQm9tOiBib29sZWFuIH0pIHtcclxuICAgIC8vIElFKDYtMTApIGRvbid0IHN1cHBvcnQgamF2YXNjcmlwdCBkb3dubG9hZCBhbmQgb3VyIHNlcnZpY2UgZG9lc24ndCBzdXBwb3J0IGVpdGhlciBzbyB0aHJvdyBhbiBlcnJvciwgd2UgaGF2ZSB0byBtYWtlIGEgcm91bmQgdHJpcCB0byB0aGUgV2ViIFNlcnZlciBmb3IgZXhwb3J0aW5nXHJcbiAgICBpZiAobmF2aWdhdG9yLmFwcE5hbWUgPT09ICdNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXInKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyIDYgdG8gMTAgZG8gbm90IHN1cHBvcnQgamF2YXNjcmlwdCBleHBvcnQgdG8gQ1NWLiBQbGVhc2UgdXBncmFkZSB5b3VyIGJyb3dzZXIuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2V0IHRoZSBjb3JyZWN0IE1JTUUgdHlwZVxyXG4gICAgY29uc3QgbWltZVR5cGUgPSAob3B0aW9ucy5mb3JtYXQgPT09IEZpbGVUeXBlLmNzdikgPyAndGV4dC9jc3YnIDogJ3RleHQvcGxhaW4nO1xyXG5cclxuICAgIC8vIG1ha2Ugc3VyZSBubyBodG1sIGVudGl0aWVzIGV4aXN0IGluIHRoZSBkYXRhXHJcbiAgICBjb25zdCBkYXRhQ29udGVudCA9IGh0bWxFbnRpdHlEZWNvZGUob3B0aW9ucy5jb250ZW50KTtcclxuXHJcbiAgICAvLyBkZWFsaW5nIHdpdGggRXhjZWwgQ1NWIGV4cG9ydCBhbmQgVVRGLTggaXMgYSBsaXR0bGUgdHJpY2t5Li4gV2Ugd2lsbCB1c2UgT3B0aW9uICMyIHRvIGNvdmVyIG9sZGVyIEV4Y2VsIHZlcnNpb25zXHJcbiAgICAvLyBPcHRpb24gIzE6IHdlIG5lZWQgdG8gbWFrZSBFeGNlbCBrbm93aW5nIHRoYXQgaXQncyBkZWFsaW5nIHdpdGggYW4gVVRGLTgsIEEgY29ycmVjdGx5IGZvcm1hdHRlZCBVVEY4IGZpbGUgY2FuIGhhdmUgYSBCeXRlIE9yZGVyIE1hcmsgYXMgaXRzIGZpcnN0IHRocmVlIG9jdGV0c1xyXG4gICAgLy8gcmVmZXJlbmNlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE1NTA5Ny9taWNyb3NvZnQtZXhjZWwtbWFuZ2xlcy1kaWFjcml0aWNzLWluLWNzdi1maWxlc1xyXG4gICAgLy8gT3B0aW9uIzI6IHVzZSBhIDNyZCBwYXJ0eSBleHRlbnNpb24gdG8gamF2YXNjcmlwdCBlbmNvZGUgaW50byBVVEYtMTZcclxuICAgIGxldCBvdXRwdXREYXRhOiBVaW50OEFycmF5IHwgc3RyaW5nO1xyXG4gICAgaWYgKG9wdGlvbnMuZm9ybWF0ID09PSBGaWxlVHlwZS5jc3YpIHtcclxuICAgICAgb3V0cHV0RGF0YSA9IG5ldyBUZXh0RW5jb2RlcigndXRmLTgnKS5lbmNvZGUoZGF0YUNvbnRlbnQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgb3V0cHV0RGF0YSA9IGRhdGFDb250ZW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNyZWF0ZSBhIEJsb2Igb2JqZWN0IGZvciB0aGUgZG93bmxvYWRcclxuICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbb3B0aW9ucy51c2VVdGY4V2l0aEJvbSA/ICdcXHVGRUZGJyA6ICcnLCBvdXRwdXREYXRhXSwge1xyXG4gICAgICB0eXBlOiBgJHttaW1lVHlwZX07Y2hhcnNldD11dGYtODtgXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyB3aGVuIHVzaW5nIElFL0VkZ2UsIHRoZW4gdXNlIGRpZmZlcmVudCBkb3dubG9hZCBjYWxsXHJcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIG5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKGJsb2IsIG9wdGlvbnMuZmlsZW5hbWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gdGhpcyB0cmljayB3aWxsIGdlbmVyYXRlIGEgdGVtcCA8YSAvPiB0YWdcclxuICAgICAgLy8gdGhlIGNvZGUgd2lsbCB0aGVuIHRyaWdnZXIgYSBoaWRkZW4gY2xpY2sgZm9yIGl0IHRvIHN0YXJ0IGRvd25sb2FkaW5nXHJcbiAgICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XHJcbiAgICAgIGNvbnN0IGNzdlVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcblxyXG4gICAgICBsaW5rLnRleHRDb250ZW50ID0gJ2Rvd25sb2FkJztcclxuICAgICAgbGluay5ocmVmID0gY3N2VXJsO1xyXG4gICAgICBsaW5rLnNldEF0dHJpYnV0ZSgnZG93bmxvYWQnLCBvcHRpb25zLmZpbGVuYW1lKTtcclxuXHJcbiAgICAgIC8vIHNldCB0aGUgdmlzaWJpbGl0eSB0byBoaWRkZW4gc28gdGhlcmUgaXMgbm8gZWZmZWN0IG9uIHlvdXIgd2ViLWxheW91dFxyXG4gICAgICBsaW5rLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuXHJcbiAgICAgIC8vIHRoaXMgcGFydCB3aWxsIGFwcGVuZCB0aGUgYW5jaG9yIHRhZywgdHJpZ2dlciBhIGNsaWNrIChmb3IgZG93bmxvYWQgdG8gc3RhcnQpIGFuZCBmaW5hbGx5IHJlbW92ZSB0aGUgdGFnIG9uY2UgY29tcGxldGVkXHJcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XHJcbiAgICAgIGxpbmsuY2xpY2soKTtcclxuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChsaW5rKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gUHJpdmF0ZSBmdW5jdGlvbnNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICBwcml2YXRlIGdldERhdGFPdXRwdXQoKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IGNvbHVtbnMgPSB0aGlzLl9ncmlkLmdldENvbHVtbnMoKSB8fCBbXTtcclxuXHJcbiAgICAvLyBHcm91cCBCeSB0ZXh0LCBpdCBjb3VsZCBiZSBzZXQgaW4gdGhlIGV4cG9ydCBvcHRpb25zIG9yIGZyb20gdHJhbnNsYXRpb24gb3IgaWYgbm90aGluZyBpcyBmb3VuZCB0aGVuIHVzZSB0aGUgRW5nbGlzaCBjb25zdGFudCB0ZXh0XHJcbiAgICBsZXQgZ3JvdXBCeUNvbHVtbkhlYWRlciA9IHRoaXMuX2V4cG9ydE9wdGlvbnMuZ3JvdXBpbmdDb2x1bW5IZWFkZXJUaXRsZTtcclxuICAgIGlmICghZ3JvdXBCeUNvbHVtbkhlYWRlciAmJiB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVUcmFuc2xhdGUgJiYgdGhpcy50cmFuc2xhdGUgJiYgdGhpcy50cmFuc2xhdGUuY3VycmVudExhbmcgJiYgdGhpcy50cmFuc2xhdGUuaW5zdGFudCkge1xyXG4gICAgICBncm91cEJ5Q29sdW1uSGVhZGVyID0gdGhpcy50cmFuc2xhdGUuaW5zdGFudCgnR1JPVVBfQlknKTtcclxuICAgIH0gZWxzZSBpZiAoIWdyb3VwQnlDb2x1bW5IZWFkZXIpIHtcclxuICAgICAgZ3JvdXBCeUNvbHVtbkhlYWRlciA9IHRoaXMuX2xvY2FsZXMgJiYgdGhpcy5fbG9jYWxlcy5URVhUX0dST1VQX0JZO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGEgQ1NWIG5lZWRzIGRvdWJsZSBxdW90ZXMgd3JhcHBlciwgdGhlIG90aGVyIHR5cGVzIGRvIG5vdCBuZWVkIGFueSB3cmFwcGVyXHJcbiAgICB0aGlzLl9leHBvcnRRdW90ZVdyYXBwZXIgPSAodGhpcy5fZmlsZUZvcm1hdCA9PT0gRmlsZVR5cGUuY3N2KSA/ICdcIicgOiAnJztcclxuXHJcbiAgICAvLyBkYXRhIHZhcmlhYmxlIHdoaWNoIHdpbGwgaG9sZCBhbGwgdGhlIGZpZWxkcyBkYXRhIG9mIGEgcm93XHJcbiAgICBsZXQgb3V0cHV0RGF0YVN0cmluZyA9ICcnO1xyXG5cclxuICAgIC8vIGdldCBncm91cGVkIGNvbHVtbiB0aXRsZXMgYW5kIGlmIGZvdW5kLCB3ZSB3aWxsIGFkZCBhIFwiR3JvdXAgYnlcIiBjb2x1bW4gYXQgdGhlIGZpcnN0IGNvbHVtbiBpbmRleFxyXG4gICAgLy8gaWYgaXQncyBhIENTViBmb3JtYXQsIHdlJ2xsIGVzY2FwZSB0aGUgdGV4dCBpbiBkb3VibGUgcXVvdGVzXHJcbiAgICBjb25zdCBncm91cGluZyA9IHRoaXMuX2RhdGFWaWV3LmdldEdyb3VwaW5nKCk7XHJcbiAgICBpZiAoZ3JvdXBpbmcgJiYgQXJyYXkuaXNBcnJheShncm91cGluZykgJiYgZ3JvdXBpbmcubGVuZ3RoID4gMCkge1xyXG4gICAgICB0aGlzLl9oYXNHcm91cGVkSXRlbXMgPSB0cnVlO1xyXG4gICAgICBvdXRwdXREYXRhU3RyaW5nICs9ICh0aGlzLl9maWxlRm9ybWF0ID09PSBGaWxlVHlwZS5jc3YpID8gYFwiJHtncm91cEJ5Q29sdW1uSGVhZGVyfVwiJHt0aGlzLl9kZWxpbWl0ZXJ9YCA6IGAke2dyb3VwQnlDb2x1bW5IZWFkZXJ9JHt0aGlzLl9kZWxpbWl0ZXJ9YDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX2hhc0dyb3VwZWRJdGVtcyA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGdldCBhbGwgY29sdW1uIGhlYWRlcnNcclxuICAgIHRoaXMuX2NvbHVtbkhlYWRlcnMgPSB0aGlzLmdldENvbHVtbkhlYWRlcnMoY29sdW1ucykgfHwgW107XHJcbiAgICBpZiAodGhpcy5fY29sdW1uSGVhZGVycyAmJiBBcnJheS5pc0FycmF5KHRoaXMuX2NvbHVtbkhlYWRlcnMpICYmIHRoaXMuX2NvbHVtbkhlYWRlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAvLyBhZGQgdGhlIGhlYWRlciByb3cgKyBhZGQgYSBuZXcgbGluZSBhdCB0aGUgZW5kIG9mIHRoZSByb3dcclxuICAgICAgY29uc3Qgb3V0cHV0SGVhZGVyVGl0bGVzID0gdGhpcy5fY29sdW1uSGVhZGVycy5tYXAoKGhlYWRlcikgPT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9leHBvcnRRdW90ZVdyYXBwZXIgKyBoZWFkZXIudGl0bGUgKyB0aGlzLl9leHBvcnRRdW90ZVdyYXBwZXI7XHJcbiAgICAgIH0pO1xyXG4gICAgICBvdXRwdXREYXRhU3RyaW5nICs9IChvdXRwdXRIZWFkZXJUaXRsZXMuam9pbih0aGlzLl9kZWxpbWl0ZXIpICsgdGhpcy5fbGluZUNhcnJpYWdlUmV0dXJuKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQb3B1bGF0ZSB0aGUgcmVzdCBvZiB0aGUgR3JpZCBEYXRhXHJcbiAgICBvdXRwdXREYXRhU3RyaW5nICs9IHRoaXMuZ2V0QWxsR3JpZFJvd0RhdGEoY29sdW1ucywgdGhpcy5fbGluZUNhcnJpYWdlUmV0dXJuKTtcclxuXHJcbiAgICByZXR1cm4gb3V0cHV0RGF0YVN0cmluZztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhbGwgdGhlIGdyaWQgcm93IGRhdGEgYW5kIHJldHVybiB0aGF0IGFzIGFuIG91dHB1dCBzdHJpbmdcclxuICAgKi9cclxuICBwcml2YXRlIGdldEFsbEdyaWRSb3dEYXRhKGNvbHVtbnM6IENvbHVtbltdLCBsaW5lQ2FycmlhZ2VSZXR1cm46IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICBjb25zdCBvdXRwdXREYXRhU3RyaW5ncyA9IFtdO1xyXG4gICAgY29uc3QgbGluZUNvdW50ID0gdGhpcy5fZGF0YVZpZXcuZ2V0TGVuZ3RoKCk7XHJcblxyXG4gICAgLy8gbG9vcCB0aHJvdWdoIGFsbCB0aGUgZ3JpZCByb3dzIG9mIGRhdGFcclxuICAgIGZvciAobGV0IHJvd051bWJlciA9IDA7IHJvd051bWJlciA8IGxpbmVDb3VudDsgcm93TnVtYmVyKyspIHtcclxuICAgICAgY29uc3QgaXRlbU9iaiA9IHRoaXMuX2RhdGFWaWV3LmdldEl0ZW0ocm93TnVtYmVyKTtcclxuICAgICAgaWYgKGl0ZW1PYmogIT0gbnVsbCkge1xyXG4gICAgICAgIC8vIE5vcm1hbCByb3cgKG5vdCBncm91cGVkIGJ5IGFueXRoaW5nKSB3b3VsZCBoYXZlIGFuIElEIHdoaWNoIHdhcyBwcmVkZWZpbmVkIGluIHRoZSBHcmlkIENvbHVtbnMgZGVmaW5pdGlvblxyXG4gICAgICAgIGlmIChpdGVtT2JqW3RoaXMuZGF0YXNldElkTmFtZV0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgLy8gZ2V0IHJlZ3VsYXIgcm93IGl0ZW0gZGF0YVxyXG4gICAgICAgICAgb3V0cHV0RGF0YVN0cmluZ3MucHVzaCh0aGlzLnJlYWRSZWd1bGFyUm93RGF0YShjb2x1bW5zLCByb3dOdW1iZXIsIGl0ZW1PYmopKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2hhc0dyb3VwZWRJdGVtcyAmJiBpdGVtT2JqLl9fZ3JvdXBUb3RhbHMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgLy8gZ2V0IHRoZSBncm91cCByb3dcclxuICAgICAgICAgIG91dHB1dERhdGFTdHJpbmdzLnB1c2godGhpcy5yZWFkR3JvdXBlZFRpdGxlUm93KGl0ZW1PYmopKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGl0ZW1PYmouX19ncm91cFRvdGFscykge1xyXG4gICAgICAgICAgLy8gZWxzZSBpZiB0aGUgcm93IGlzIGEgR3JvdXAgQnkgYW5kIHdlIGhhdmUgYWdyZWdnYXRvcnMsIHRoZW4gYSBwcm9wZXJ0eSBvZiAnX19ncm91cFRvdGFscycgd291bGQgZXhpc3QgdW5kZXIgdGhhdCBvYmplY3RcclxuICAgICAgICAgIG91dHB1dERhdGFTdHJpbmdzLnB1c2godGhpcy5yZWFkR3JvdXBlZFRvdGFsUm93KGNvbHVtbnMsIGl0ZW1PYmopKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0cHV0RGF0YVN0cmluZ3Muam9pbihsaW5lQ2FycmlhZ2VSZXR1cm4pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGFsbCBoZWFkZXIgdGl0bGVzIGFuZCB0aGVpciBrZXlzLCB0cmFuc2xhdGUgdGhlIHRpdGxlIHdoZW4gcmVxdWlyZWQuXHJcbiAgICogQHBhcmFtIGNvbHVtbnMgb2YgdGhlIGdyaWRcclxuICAgKi9cclxuICBwcml2YXRlIGdldENvbHVtbkhlYWRlcnMoY29sdW1uczogQ29sdW1uW10pOiBLZXlUaXRsZVBhaXJbXSB7XHJcbiAgICBpZiAoIWNvbHVtbnMgfHwgIUFycmF5LmlzQXJyYXkoY29sdW1ucykgfHwgY29sdW1ucy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb2x1bW5IZWFkZXJzID0gW107XHJcblxyXG4gICAgLy8gUG9wdWxhdGUgdGhlIENvbHVtbiBIZWFkZXIsIHB1bGwgdGhlIG5hbWUgZGVmaW5lZFxyXG4gICAgY29sdW1ucy5mb3JFYWNoKChjb2x1bW5EZWYpID0+IHtcclxuICAgICAgbGV0IGhlYWRlclRpdGxlID0gJyc7XHJcbiAgICAgIGlmICgoY29sdW1uRGVmLmhlYWRlcktleSB8fCBjb2x1bW5EZWYubmFtZUtleSkgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlVHJhbnNsYXRlICYmIHRoaXMudHJhbnNsYXRlICYmIHRoaXMudHJhbnNsYXRlLmN1cnJlbnRMYW5nICYmIHRoaXMudHJhbnNsYXRlLmluc3RhbnQpIHtcclxuICAgICAgICBoZWFkZXJUaXRsZSA9IHRoaXMudHJhbnNsYXRlLmluc3RhbnQoKGNvbHVtbkRlZi5oZWFkZXJLZXkgfHwgY29sdW1uRGVmLm5hbWVLZXkpKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBoZWFkZXJUaXRsZSA9IGNvbHVtbkRlZi5uYW1lIHx8IHRpdGxlQ2FzZShjb2x1bW5EZWYuZmllbGQpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHNraXBwZWRGaWVsZCA9IGNvbHVtbkRlZi5leGNsdWRlRnJvbUV4cG9ydCB8fCBmYWxzZTtcclxuXHJcbiAgICAgIC8vIGlmIGNvbHVtbiB3aWR0aCBpcyAwLCB0aGVuIHdlIGNvbnNpZGVyIHRoYXQgZmllbGQgYXMgYSBoaWRkZW4gZmllbGQgYW5kIHNob3VsZCBub3QgYmUgcGFydCBvZiB0aGUgZXhwb3J0XHJcbiAgICAgIGlmICgoY29sdW1uRGVmLndpZHRoID09PSB1bmRlZmluZWQgfHwgY29sdW1uRGVmLndpZHRoID4gMCkgJiYgIXNraXBwZWRGaWVsZCkge1xyXG4gICAgICAgIGNvbHVtbkhlYWRlcnMucHVzaCh7XHJcbiAgICAgICAgICBrZXk6IGNvbHVtbkRlZi5maWVsZCB8fCBjb2x1bW5EZWYuaWQsXHJcbiAgICAgICAgICB0aXRsZTogaGVhZGVyVGl0bGVcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGNvbHVtbkhlYWRlcnM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIGRhdGEgb2YgYSByZWd1bGFyIHJvdyAoYSByb3cgd2l0aG91dCBncm91cGluZylcclxuICAgKiBAcGFyYW0gcm93XHJcbiAgICogQHBhcmFtIGl0ZW1PYmpcclxuICAgKi9cclxuICBwcml2YXRlIHJlYWRSZWd1bGFyUm93RGF0YShjb2x1bW5zOiBDb2x1bW5bXSwgcm93OiBudW1iZXIsIGl0ZW1PYmo6IGFueSkge1xyXG4gICAgbGV0IGlkeCA9IDA7XHJcbiAgICBjb25zdCByb3dPdXRwdXRTdHJpbmdzID0gW107XHJcbiAgICBjb25zdCBleHBvcnRRdW90ZVdyYXBwZXIgPSB0aGlzLl9leHBvcnRRdW90ZVdyYXBwZXI7XHJcblxyXG4gICAgZm9yIChsZXQgY29sID0gMCwgbG4gPSBjb2x1bW5zLmxlbmd0aDsgY29sIDwgbG47IGNvbCsrKSB7XHJcbiAgICAgIGNvbnN0IGNvbHVtbkRlZiA9IGNvbHVtbnNbY29sXTtcclxuXHJcbiAgICAgIC8vIHNraXAgZXhjbHVkZWQgY29sdW1uXHJcbiAgICAgIGlmIChjb2x1bW5EZWYuZXhjbHVkZUZyb21FeHBvcnQpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gaWYgd2UgYXJlIGdyb3VwaW5nIGFuZCBhcmUgb24gMXN0IGNvbHVtbiBpbmRleCwgd2UgbmVlZCB0byBza2lwIHRoaXMgY29sdW1uIHNpbmNlIGl0IHdpbGwgYmUgdXNlZCBsYXRlciBieSB0aGUgZ3JvdXBpbmcgdGV4dDo6IEdyb3VwIGJ5IFtjb2x1bW5YXVxyXG4gICAgICBpZiAodGhpcy5faGFzR3JvdXBlZEl0ZW1zICYmIGlkeCA9PT0gMCkge1xyXG4gICAgICAgIGNvbnN0IGVtcHR5VmFsdWUgPSB0aGlzLl9maWxlRm9ybWF0ID09PSBGaWxlVHlwZS5jc3YgPyBgXCJcImAgOiAnJztcclxuICAgICAgICByb3dPdXRwdXRTdHJpbmdzLnB1c2goZW1wdHlWYWx1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGdldCB0aGUgb3V0cHV0IGJ5IGFuYWx5emluZyBpZiB3ZSdsbCBwdWxsIHRoZSB2YWx1ZSBmcm9tIHRoZSBjZWxsIG9yIGZyb20gYSBmb3JtYXR0ZXJcclxuICAgICAgbGV0IGl0ZW1EYXRhID0gZXhwb3J0V2l0aEZvcm1hdHRlcldoZW5EZWZpbmVkKHJvdywgY29sLCBpdGVtT2JqLCBjb2x1bW5EZWYsIHRoaXMuX2dyaWQsIHRoaXMuX2V4cG9ydE9wdGlvbnMpO1xyXG5cclxuICAgICAgLy8gZG9lcyB0aGUgdXNlciB3YW50IHRvIHNhbml0aXplIHRoZSBvdXRwdXQgZGF0YSAocmVtb3ZlIEhUTUwgdGFncyk/XHJcbiAgICAgIGlmIChjb2x1bW5EZWYuc2FuaXRpemVEYXRhRXhwb3J0IHx8IHRoaXMuX2V4cG9ydE9wdGlvbnMuc2FuaXRpemVEYXRhRXhwb3J0KSB7XHJcbiAgICAgICAgaXRlbURhdGEgPSBzYW5pdGl6ZUh0bWxUb1RleHQoaXRlbURhdGEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB3aGVuIENTViB3ZSBhbHNvIG5lZWQgdG8gZXNjYXBlIGRvdWJsZSBxdW90ZXMgdHdpY2UsIHNvIFwiIGJlY29tZXMgXCJcIlxyXG4gICAgICBpZiAodGhpcy5fZmlsZUZvcm1hdCA9PT0gRmlsZVR5cGUuY3N2ICYmIGl0ZW1EYXRhKSB7XHJcbiAgICAgICAgaXRlbURhdGEgPSBpdGVtRGF0YS50b1N0cmluZygpLnJlcGxhY2UoL1wiL2dpLCBgXCJcImApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBkbyB3ZSBoYXZlIGEgd3JhcHBlciB0byBrZWVwIGFzIGEgc3RyaW5nPyBpbiBjZXJ0YWluIGNhc2VzIGxpa2UgXCIxRTA2XCIsIHdlIGRvbid0IHdhbnQgZXhjZWwgdG8gdHJhbnNmb3JtIGl0IGludG8gZXhwb25lbnRpYWwgKDEuMEUwNilcclxuICAgICAgLy8gdG8gY2FuY2VsIHRoYXQgZWZmZWN0IHdlIGNhbiBoYWQgPSBpbiBmcm9udCwgZXg6ID1cIjFFMDZcIlxyXG4gICAgICBjb25zdCBrZWVwQXNTdHJpbmdXcmFwcGVyID0gKGNvbHVtbkRlZiAmJiBjb2x1bW5EZWYuZXhwb3J0Q3N2Rm9yY2VUb0tlZXBBc1N0cmluZykgPyAnPScgOiAnJztcclxuXHJcbiAgICAgIHJvd091dHB1dFN0cmluZ3MucHVzaChrZWVwQXNTdHJpbmdXcmFwcGVyICsgZXhwb3J0UXVvdGVXcmFwcGVyICsgaXRlbURhdGEgKyBleHBvcnRRdW90ZVdyYXBwZXIpO1xyXG4gICAgICBpZHgrKztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcm93T3V0cHV0U3RyaW5ncy5qb2luKHRoaXMuX2RlbGltaXRlcik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIGdyb3VwZWQgdGl0bGUocykgYW5kIGl0cyBncm91cCB0aXRsZSBmb3JtYXR0ZXIsIGZvciBleGFtcGxlIGlmIHdlIGdyb3VwZWQgYnkgc2FsZXNSZXAsIHRoZSByZXR1cm5lZCByZXN1bHQgd291bGQgYmU6OiAnU2FsZXMgUmVwOiBKb2huIERvdyAoMiBpdGVtcyknXHJcbiAgICogQHBhcmFtIGl0ZW1PYmpcclxuICAgKi9cclxuICBwcml2YXRlIHJlYWRHcm91cGVkVGl0bGVSb3coaXRlbU9iajogYW55KSB7XHJcbiAgICBsZXQgZ3JvdXBOYW1lID0gc2FuaXRpemVIdG1sVG9UZXh0KGl0ZW1PYmoudGl0bGUpO1xyXG4gICAgY29uc3QgZXhwb3J0UXVvdGVXcmFwcGVyID0gdGhpcy5fZXhwb3J0UXVvdGVXcmFwcGVyO1xyXG5cclxuICAgIGdyb3VwTmFtZSA9IGFkZFdoaXRlU3BhY2VzKDUgKiBpdGVtT2JqLmxldmVsKSArIGdyb3VwTmFtZTtcclxuXHJcbiAgICBpZiAodGhpcy5fZmlsZUZvcm1hdCA9PT0gRmlsZVR5cGUuY3N2KSB7XHJcbiAgICAgIC8vIHdoZW4gQ1NWIHdlIGFsc28gbmVlZCB0byBlc2NhcGUgZG91YmxlIHF1b3RlcyB0d2ljZSwgc28gXCIgYmVjb21lcyBcIlwiXHJcbiAgICAgIGdyb3VwTmFtZSA9IGdyb3VwTmFtZS50b1N0cmluZygpLnJlcGxhY2UoL1wiL2dpLCBgXCJcImApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV4cG9ydFF1b3RlV3JhcHBlciArIGdyb3VwTmFtZSArIGV4cG9ydFF1b3RlV3JhcHBlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZ3JvdXBlZCB0b3RhbHMgKGJlbG93IHRoZSByZWd1bGFyIHJvd3MpLCB0aGVzZSBhcmUgc2V0IGJ5IFNsaWNrIEFnZ3JlZ2F0b3JzLlxyXG4gICAqIEZvciBleGFtcGxlIGlmIHdlIGdyb3VwZWQgYnkgXCJzYWxlc1JlcFwiIGFuZCB3ZSBoYXZlIGEgU3VtIEFnZ3JlZ2F0b3Igb24gXCJzYWxlc1wiLCB0aGVuIHRoZSByZXR1cm5lZCBvdXRwdXQgd291bGQgYmU6OiBbXCJTdW0gMTIzJFwiXVxyXG4gICAqIEBwYXJhbSBpdGVtT2JqXHJcbiAgICovXHJcbiAgcHJpdmF0ZSByZWFkR3JvdXBlZFRvdGFsUm93KGNvbHVtbnM6IENvbHVtbltdLCBpdGVtT2JqOiBhbnkpIHtcclxuICAgIGNvbnN0IGRlbGltaXRlciA9IHRoaXMuX2V4cG9ydE9wdGlvbnMuZGVsaW1pdGVyO1xyXG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5fZXhwb3J0T3B0aW9ucy5mb3JtYXQ7XHJcbiAgICBjb25zdCBncm91cGluZ0FnZ3JlZ2F0b3JSb3dUZXh0ID0gdGhpcy5fZXhwb3J0T3B0aW9ucy5ncm91cGluZ0FnZ3JlZ2F0b3JSb3dUZXh0IHx8ICcnO1xyXG4gICAgY29uc3QgZXhwb3J0UXVvdGVXcmFwcGVyID0gdGhpcy5fZXhwb3J0UXVvdGVXcmFwcGVyO1xyXG4gICAgY29uc3Qgb3V0cHV0U3RyaW5ncyA9IFtgJHtleHBvcnRRdW90ZVdyYXBwZXJ9JHtncm91cGluZ0FnZ3JlZ2F0b3JSb3dUZXh0fSR7ZXhwb3J0UXVvdGVXcmFwcGVyfWBdO1xyXG5cclxuICAgIGNvbHVtbnMuZm9yRWFjaCgoY29sdW1uRGVmKSA9PiB7XHJcbiAgICAgIGxldCBpdGVtRGF0YSA9ICcnO1xyXG5cclxuICAgICAgY29uc3Qgc2tpcHBlZEZpZWxkID0gY29sdW1uRGVmLmV4Y2x1ZGVGcm9tRXhwb3J0IHx8IGZhbHNlO1xyXG5cclxuICAgICAgLy8gaWYgdGhlcmUncyBhIGdyb3VwVG90YWxzRm9ybWF0dGVyLCB3ZSB3aWxsIHJlLXJ1biBpdCB0byBnZXQgdGhlIGV4YWN0IHNhbWUgb3V0cHV0IGFzIHdoYXQgaXMgc2hvd24gaW4gVUlcclxuICAgICAgaWYgKGNvbHVtbkRlZi5ncm91cFRvdGFsc0Zvcm1hdHRlcikge1xyXG4gICAgICAgIGl0ZW1EYXRhID0gY29sdW1uRGVmLmdyb3VwVG90YWxzRm9ybWF0dGVyKGl0ZW1PYmosIGNvbHVtbkRlZik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGRvZXMgdGhlIHVzZXIgd2FudCB0byBzYW5pdGl6ZSB0aGUgb3V0cHV0IGRhdGEgKHJlbW92ZSBIVE1MIHRhZ3MpP1xyXG4gICAgICBpZiAoY29sdW1uRGVmLnNhbml0aXplRGF0YUV4cG9ydCB8fCB0aGlzLl9leHBvcnRPcHRpb25zLnNhbml0aXplRGF0YUV4cG9ydCkge1xyXG4gICAgICAgIGl0ZW1EYXRhID0gc2FuaXRpemVIdG1sVG9UZXh0KGl0ZW1EYXRhKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGZvcm1hdCA9PT0gRmlsZVR5cGUuY3N2KSB7XHJcbiAgICAgICAgLy8gd2hlbiBDU1Ygd2UgYWxzbyBuZWVkIHRvIGVzY2FwZSBkb3VibGUgcXVvdGVzIHR3aWNlLCBzbyBhIGRvdWJsZSBxdW90ZSBcIiBiZWNvbWVzIDJ4IGRvdWJsZSBxdW90ZXMgXCJcIlxyXG4gICAgICAgIGl0ZW1EYXRhID0gaXRlbURhdGEudG9TdHJpbmcoKS5yZXBsYWNlKC9cIi9naSwgYFwiXCJgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gYWRkIHRoZSBjb2x1bW4gKHVubGVzcyB1c2VyIHdhbnRzIHRvIHNraXAgaXQpXHJcbiAgICAgIGlmICgoY29sdW1uRGVmLndpZHRoID09PSB1bmRlZmluZWQgfHwgY29sdW1uRGVmLndpZHRoID4gMCkgJiYgIXNraXBwZWRGaWVsZCkge1xyXG4gICAgICAgIG91dHB1dFN0cmluZ3MucHVzaChleHBvcnRRdW90ZVdyYXBwZXIgKyBpdGVtRGF0YSArIGV4cG9ydFF1b3RlV3JhcHBlcik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBvdXRwdXRTdHJpbmdzLmpvaW4oZGVsaW1pdGVyKTtcclxuICB9XHJcbn1cclxuIl19