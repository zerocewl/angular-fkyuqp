import * as tslib_1 from "tslib";
import { Observable } from 'rxjs';
import { first } from 'rxjs/operators';
import * as moment_ from 'moment-mini';
var moment = moment_; // patch to fix rollup "moment has no default export" issue, document here https://github.com/rollup/rollup/issues/670
import { FieldType, OperatorType } from '../models/index';
/**
 * Add an item to an array only when the item does not exists, when the item is an object we will be using their "id" to compare
 * @param inputArray
 * @param inputItem
 */
export function addToArrayWhenNotExists(inputArray, inputItem) {
    var arrayRowIndex = -1;
    if (typeof inputItem === 'object' && inputItem.hasOwnProperty('id')) {
        arrayRowIndex = inputArray.findIndex(function (item) { return item.id === inputItem.id; });
    }
    else {
        arrayRowIndex = inputArray.findIndex(function (item) { return item === inputItem; });
    }
    if (arrayRowIndex < 0) {
        inputArray.push(inputItem);
    }
}
/**
 * Simple function to which will loop and create as demanded the number of white spaces,
 * this is used in the CSV export
 * @param int nbSpaces: number of white spaces to create
 */
export function addWhiteSpaces(nbSpaces) {
    var result = '';
    for (var i = 0; i < nbSpaces; i++) {
        result += ' ';
    }
    return result;
}
/**
 * HTML decode using jQuery with a <div>
 * Create a in-memory div, set it's inner text(which jQuery automatically encodes)
 * then grab the encoded contents back out.  The div never exists on the page.
*/
export function htmlDecode(encodedStr) {
    var parser = DOMParser && new DOMParser;
    if (parser && parser.parseFromString) {
        var dom = parser.parseFromString('<!doctype html><body>' + encodedStr, 'text/html');
        return dom && dom.body && dom.body.textContent;
    }
    else {
        // for some browsers that might not support DOMParser, use jQuery instead
        return $('<div/>').html(encodedStr).text();
    }
}
/**
 * HTML encode using jQuery with a <div>
 * Create a in-memory div, set it's inner text(which jQuery automatically encodes)
 * then grab the encoded contents back out.  The div never exists on the page.
*/
export function htmlEncode(inputValue) {
    var entityMap = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        '\'': '&#39;'
    };
    // all symbols::  /[&<>"'`=\/]/g
    return (inputValue || '').toString().replace(/[&<>"']/g, function (s) { return entityMap[s]; });
}
/**
 * Decode text into html entity
 * @param string text: input text
 * @param string text: output text
 */
export function htmlEntityDecode(input) {
    return input.replace(/&#(\d+);/g, function (match, dec) {
        return String.fromCharCode(dec);
    });
}
/**
 * Decode text into html entity
 * @param string text: input text
 * @param string text: output text
 */
export function htmlEntityEncode(input) {
    var buf = [];
    for (var i = input.length - 1; i >= 0; i--) {
        buf.unshift(['&#', input[i].charCodeAt(), ';'].join(''));
    }
    return buf.join('');
}
/**
 * Compares two arrays of characters to determine if all the items are equal
 * @param a first array
 * @param b second array to compare with a
 * @param [orderMatters=false] flag if the order matters, if not arrays will be sorted before comparison
 * @return boolean true if equal, else false
 */
export function charArraysEqual(a, b, orderMatters) {
    if (orderMatters === void 0) { orderMatters = false; }
    if (!a || !b || !Array.isArray(a) || !Array.isArray(a)) {
        return false;
    }
    if (a.length !== b.length) {
        return false;
    }
    if (!orderMatters) {
        a.sort();
        b.sort();
    }
    for (var i = 0; i < a.length; ++i) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
/**
 * Try casting an input of type Promise | Observable into a Promise type.
 * @param object which could be of type Promise or Observable
 * @param fromServiceName string representing the caller service name and will be used if we throw a casting problem error
 */
export function castToPromise(input, fromServiceName) {
    if (fromServiceName === void 0) { fromServiceName = ''; }
    var promise = input;
    if (input instanceof Promise) {
        // if it's already a Promise then return it
        return input;
    }
    else if (input instanceof Observable) {
        promise = input.pipe(first()).toPromise();
    }
    if (!(promise instanceof Promise)) {
        throw new Error("Something went wrong, Angular-Slickgrid " + fromServiceName + " is not able to convert the Observable into a Promise.\n      If you are using Angular HttpClient, you could try converting your http call to a Promise with \".toPromise()\"\n      for example::  this.http.post('graphql', { query: graphqlQuery }).toPromise()\n      ");
    }
    return promise;
}
/**
 * Uses the logic function to find an item in an array or returns the default
 * value provided (empty object by default)
 * @param any[] array the array to filter
 * @param function logic the logic to find the item
 * @param any [defaultVal={}] the default value to return
 * @return object the found object or default value
 */
export function findOrDefault(array, logic, defaultVal) {
    if (defaultVal === void 0) { defaultVal = {}; }
    return array.find(logic) || defaultVal;
}
/**
  * Take a number (or a string) and display it as a formatted decimal string with defined minimum and maximum decimals
  * @param input
  * @param minDecimal
  * @param maxDecimal
  */
export function decimalFormatted(input, minDecimal, maxDecimal, decimalSeparator, thousandSeparator) {
    if (decimalSeparator === void 0) { decimalSeparator = '.'; }
    if (thousandSeparator === void 0) { thousandSeparator = ''; }
    if (isNaN(+input)) {
        return input;
    }
    var minDec = (minDecimal === undefined) ? 2 : minDecimal;
    var maxDec = (maxDecimal === undefined) ? 2 : maxDecimal;
    var amount = String(Math.round(+input * Math.pow(10, maxDec)) / Math.pow(10, maxDec));
    if ((amount.indexOf('.') < 0) && (minDec > 0)) {
        amount += '.';
    }
    while ((amount.length - amount.indexOf('.')) <= minDec) {
        amount += '0';
    }
    // do we want to display our number with a custom separator in each thousand position
    if (thousandSeparator) {
        amount = thousandSeparatorFormatted(amount, thousandSeparator);
    }
    // when using a separator that is not a dot, replace it with the new separator
    if (decimalSeparator !== '.') {
        amount = amount.replace('.', decimalSeparator);
    }
    return amount;
}
/**
 * Format a number following options passed as arguments (decimals, separator, ...)
 * @param input
 * @param minDecimal
 * @param maxDecimal
 * @param displayNegativeNumberWithParentheses
 * @param symbolPrefix
 * @param symbolSuffix
 * @param decimalSeparator
 * @param thousandSeparator
 */
export function formatNumber(input, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, symbolPrefix, symbolSuffix, decimalSeparator, thousandSeparator) {
    if (symbolPrefix === void 0) { symbolPrefix = ''; }
    if (symbolSuffix === void 0) { symbolSuffix = ''; }
    if (decimalSeparator === void 0) { decimalSeparator = '.'; }
    if (thousandSeparator === void 0) { thousandSeparator = ''; }
    if (isNaN(+input)) {
        return input;
    }
    var calculatedValue = ((Math.round(parseFloat(input) * 1000000) / 1000000));
    if (calculatedValue < 0) {
        var absValue = Math.abs(calculatedValue);
        if (displayNegativeNumberWithParentheses) {
            if (!isNaN(minDecimal) || !isNaN(maxDecimal)) {
                return "(" + symbolPrefix + decimalFormatted(absValue, minDecimal, maxDecimal, decimalSeparator, thousandSeparator) + symbolSuffix + ")";
            }
            var formattedValue = thousandSeparatorFormatted("" + absValue, thousandSeparator);
            return "(" + symbolPrefix + formattedValue + symbolSuffix + ")";
        }
        else {
            if (!isNaN(minDecimal) || !isNaN(maxDecimal)) {
                return "-" + symbolPrefix + decimalFormatted(absValue, minDecimal, maxDecimal, decimalSeparator, thousandSeparator) + symbolSuffix;
            }
            var formattedValue = thousandSeparatorFormatted("" + absValue, thousandSeparator);
            return "-" + symbolPrefix + formattedValue + symbolSuffix;
        }
    }
    else {
        if (!isNaN(minDecimal) || !isNaN(maxDecimal)) {
            return "" + symbolPrefix + decimalFormatted(input, minDecimal, maxDecimal, decimalSeparator, thousandSeparator) + symbolSuffix;
        }
        var formattedValue = thousandSeparatorFormatted("" + input, thousandSeparator);
        return "" + symbolPrefix + formattedValue + symbolSuffix;
    }
}
/** From a dot (.) notation path, find and return a property within an object given a path */
export function getDescendantProperty(obj, path) {
    return path.split('.').reduce(function (acc, part) { return acc && acc[part]; }, obj);
}
/** Get the browser's scrollbar width, this is different to each browser */
export function getScrollBarWidth() {
    var $outer = $('<div>').css({ visibility: 'hidden', width: 100, overflow: 'scroll' }).appendTo('body');
    var widthWithScroll = $('<div>').css({ width: '100%' }).appendTo($outer).outerWidth();
    $outer.remove();
    return Math.ceil(100 - widthWithScroll);
}
/**
 * From a Date FieldType, return it's equivalent moment.js format
 * refer to moment.js for the format standard used: https://momentjs.com/docs/#/parsing/string-format/
 * @param fieldType
 */
export function mapMomentDateFormatWithFieldType(fieldType) {
    var map;
    switch (fieldType) {
        case FieldType.dateTime:
        case FieldType.dateTimeIso:
            map = 'YYYY-MM-DD HH:mm:ss';
            break;
        case FieldType.dateTimeShortIso:
            map = 'YYYY-MM-DD HH:mm';
            break;
        case FieldType.dateTimeIsoAmPm:
            map = 'YYYY-MM-DD hh:mm:ss a';
            break;
        case FieldType.dateTimeIsoAM_PM:
            map = 'YYYY-MM-DD hh:mm:ss A';
            break;
        // all Euro Formats (date/month/year)
        case FieldType.dateEuro:
            map = 'DD/MM/YYYY';
            break;
        case FieldType.dateEuroShort:
            map = 'D/M/YY';
            break;
        case FieldType.dateTimeEuro:
            map = 'DD/MM/YYYY HH:mm:ss';
            break;
        case FieldType.dateTimeShortEuro:
            map = 'DD/MM/YYYY HH:mm';
            break;
        case FieldType.dateTimeEuroAmPm:
            map = 'DD/MM/YYYY hh:mm:ss a';
            break;
        case FieldType.dateTimeEuroAM_PM:
            map = 'DD/MM/YYYY hh:mm:ss A';
            break;
        case FieldType.dateTimeEuroShort:
            map = 'D/M/YY H:m:s';
            break;
        case FieldType.dateTimeEuroShortAmPm:
            map = 'D/M/YY h:m:s a';
            break;
        // all US Formats (month/date/year)
        case FieldType.dateUs:
            map = 'MM/DD/YYYY';
            break;
        case FieldType.dateUsShort:
            map = 'M/D/YY';
            break;
        case FieldType.dateTimeUs:
            map = 'MM/DD/YYYY HH:mm:ss';
            break;
        case FieldType.dateTimeShortUs:
            map = 'MM/DD/YYYY HH:mm';
            break;
        case FieldType.dateTimeUsAmPm:
            map = 'MM/DD/YYYY hh:mm:ss a';
            break;
        case FieldType.dateTimeUsAM_PM:
            map = 'MM/DD/YYYY hh:mm:ss A';
            break;
        case FieldType.dateTimeUsShort:
            map = 'M/D/YY H:m:s';
            break;
        case FieldType.dateTimeUsShortAmPm:
            map = 'M/D/YY h:m:s a';
            break;
        case FieldType.dateUtc:
            map = 'YYYY-MM-DDTHH:mm:ss.SSSZ';
            break;
        case FieldType.date:
        case FieldType.dateIso:
        default:
            map = 'YYYY-MM-DD';
            break;
    }
    return map;
}
/**
 * From a Date FieldType, return it's equivalent Flatpickr format
 * refer to Flatpickr for the format standard used: https://chmln.github.io/flatpickr/formatting/#date-formatting-tokens
 * also note that they seem very similar to PHP format (except for am/pm): http://php.net/manual/en/function.date.php
 * @param fieldType
 */
export function mapFlatpickrDateFormatWithFieldType(fieldType) {
    /*
      d: Day of the month, 2 digits with leading zeros	01 to 31
      D: A textual representation of a day	Mon through Sun
      l: (lowercase 'L')	A full textual representation of the day of the week	Sunday through Saturday
      j: Day of the month without leading zeros	1 to 31
      J: Day of the month without leading zeros and ordinal suffix	1st, 2nd, to 31st
      w: Numeric representation of the day of the week	0 (for Sunday) through 6 (for Saturday)
      F: A full textual representation of a month	January through December
      m: Numeric representation of a month, with leading zero	01 through 12
      n: Numeric representation of a month, without leading zeros	1 through 12
      M: A short textual representation of a month	Jan through Dec
      U: The number of seconds since the Unix Epoch	1413704993
      y: A two digit representation of a year	99 or 03
      Y: A full numeric representation of a year, 4 digits	1999 or 2003
      H: Hours (24 hours)	00 to 23
      h: Hours	1 to 12
      i: Minutes	00 to 59
      S: Seconds, 2 digits	00 to 59
      s: Seconds	0, 1 to 59
      K: AM/PM	AM or PM
    */
    var map;
    switch (fieldType) {
        case FieldType.dateTime:
        case FieldType.dateTimeIso:
            map = 'Y-m-d H:i:S';
            break;
        case FieldType.dateTimeShortIso:
            map = 'Y-m-d H:i';
            break;
        case FieldType.dateTimeIsoAmPm:
        case FieldType.dateTimeIsoAM_PM:
            map = 'Y-m-d h:i:S K'; // there is no lowercase in Flatpickr :(
            break;
        // all Euro Formats (date/month/year)
        case FieldType.dateEuro:
            map = 'd/m/Y';
            break;
        case FieldType.dateEuroShort:
            map = 'd/m/y';
            break;
        case FieldType.dateTimeEuro:
            map = 'd/m/Y H:i:S';
            break;
        case FieldType.dateTimeShortEuro:
            map = 'd/m/y H:i';
            break;
        case FieldType.dateTimeEuroAmPm:
            map = 'd/m/Y h:i:S K'; // there is no lowercase in Flatpickr :(
            break;
        case FieldType.dateTimeEuroAM_PM:
            map = 'd/m/Y h:i:s K';
            break;
        case FieldType.dateTimeEuroShort:
            map = 'd/m/y H:i:s';
            break;
        case FieldType.dateTimeEuroShortAmPm:
            map = 'd/m/y h:i:s K'; // there is no lowercase in Flatpickr :(
            break;
        // all US Formats (month/date/year)
        case FieldType.dateUs:
            map = 'm/d/Y';
            break;
        case FieldType.dateUsShort:
            map = 'm/d/y';
            break;
        case FieldType.dateTimeUs:
            map = 'm/d/Y H:i:S';
            break;
        case FieldType.dateTimeShortUs:
            map = 'm/d/y H:i';
            break;
        case FieldType.dateTimeUsAmPm:
            map = 'm/d/Y h:i:S K'; // there is no lowercase in Flatpickr :(
            break;
        case FieldType.dateTimeUsAM_PM:
            map = 'm/d/Y h:i:s K';
            break;
        case FieldType.dateTimeUsShort:
            map = 'm/d/y H:i:s';
            break;
        case FieldType.dateTimeUsShortAmPm:
            map = 'm/d/y h:i:s K'; // there is no lowercase in Flatpickr :(
            break;
        case FieldType.dateUtc:
            map = 'Z';
            break;
        case FieldType.date:
        case FieldType.dateIso:
        default:
            map = 'Y-m-d';
            break;
    }
    return map;
}
/**
 * Mapper for query operators (ex.: <= is "le", > is "gt")
 * @param string operator
 * @returns string map
 */
export function mapOperatorType(operator) {
    var map;
    switch (operator) {
        case '<':
        case 'LT':
            map = OperatorType.lessThan;
            break;
        case '<=':
        case 'LE':
            map = OperatorType.lessThanOrEqual;
            break;
        case '>':
        case 'GT':
            map = OperatorType.greaterThan;
            break;
        case '>=':
        case 'GE':
            map = OperatorType.greaterThanOrEqual;
            break;
        case '<>':
        case '!=':
        case 'NE':
            map = OperatorType.notEqual;
            break;
        case '*':
        case 'a*':
        case 'StartsWith':
            map = OperatorType.startsWith;
            break;
        case '*z':
        case 'EndsWith':
            map = OperatorType.endsWith;
            break;
        case '=':
        case '==':
        case 'EQ':
            map = OperatorType.equal;
            break;
        case 'IN':
            map = OperatorType.in;
            break;
        case 'NIN':
        case 'NOT_IN':
            map = OperatorType.notIn;
            break;
        case 'Not_Contains':
        case 'NOT_CONTAINS':
            map = OperatorType.notContains;
            break;
        case 'Contains':
        case 'CONTAINS':
        default:
            map = OperatorType.contains;
            break;
    }
    return map;
}
/**
 * Find equivalent short designation of an Operator Type or Operator String.
 * When using a Compound Filter, we use the short designation and so we need the mapped value.
 * For example OperatorType.startsWith short designation is "a*", while OperatorType.greaterThanOrEqual is ">="
 */
export function mapOperatorToShorthandDesignation(operator) {
    var shortOperator = '';
    switch (operator) {
        case OperatorType.greaterThan:
        case '>':
            shortOperator = '>';
            break;
        case OperatorType.greaterThanOrEqual:
        case '>=':
            shortOperator = '>=';
            break;
        case OperatorType.lessThan:
        case '<':
            shortOperator = '<';
            break;
        case OperatorType.lessThanOrEqual:
        case '<=':
            shortOperator = '<=';
            break;
        case OperatorType.notEqual:
        case '<>':
            shortOperator = '<>';
            break;
        case OperatorType.equal:
        case '=':
        case '==':
        case 'EQ':
            shortOperator = '=';
            break;
        case OperatorType.startsWith:
        case 'a*':
        case '*':
            shortOperator = 'a*';
            break;
        case OperatorType.endsWith:
        case '*z':
            shortOperator = '*z';
            break;
        default:
            // any other operator will be considered as already a short expression, so we can return same input operator
            shortOperator = operator;
            break;
    }
    return shortOperator;
}
/**
 * Mapper for query operator by a Filter Type
 * For example a multiple-select typically uses 'IN' operator
 * @param operator
 * @returns string map
 */
export function mapOperatorByFieldType(fieldType) {
    var map;
    switch (fieldType) {
        case FieldType.string:
        case FieldType.unknown:
            map = OperatorType.contains;
            break;
        case FieldType.float:
        case FieldType.number:
        case FieldType.date:
        case FieldType.dateIso:
        case FieldType.dateUtc:
        case FieldType.dateTime:
        case FieldType.dateTimeIso:
        case FieldType.dateTimeIsoAmPm:
        case FieldType.dateTimeIsoAM_PM:
        case FieldType.dateEuro:
        case FieldType.dateEuroShort:
        case FieldType.dateTimeEuro:
        case FieldType.dateTimeEuroAmPm:
        case FieldType.dateTimeEuroAM_PM:
        case FieldType.dateTimeEuroShort:
        case FieldType.dateTimeEuroShortAmPm:
        case FieldType.dateTimeEuroShortAM_PM:
        case FieldType.dateUs:
        case FieldType.dateUsShort:
        case FieldType.dateTimeUs:
        case FieldType.dateTimeUsAmPm:
        case FieldType.dateTimeUsAM_PM:
        case FieldType.dateTimeUsShort:
        case FieldType.dateTimeUsShortAmPm:
        case FieldType.dateTimeUsShortAM_PM:
        default:
            map = OperatorType.equal;
            break;
    }
    return map;
}
/** Parse any input (bool, number, string) and return a boolean or False when not possible */
export function parseBoolean(input) {
    return /(true|1)/i.test(input + '');
}
/**
 * Parse a date passed as a string (Date only, without time) and return a Date object (if valid)
 * @param inputDateString
 * @returns string date formatted
 */
export function parseUtcDate(inputDateString, useUtc) {
    var date = null;
    if (/^[0-9\-\/]*$/.test(inputDateString)) {
        // get the UTC datetime with moment.js but we need to decode the value so that it's valid text
        var dateString = decodeURIComponent(inputDateString);
        var dateMoment = moment(new Date(dateString));
        if (dateMoment.isValid() && dateMoment.year().toString().length === 4) {
            date = (useUtc) ? dateMoment.utc().format() : dateMoment.format();
        }
    }
    return date;
}
/**
 * Sanitize, return only the text without HTML tags
 * @input htmlString
 * @return text
 */
export function sanitizeHtmlToText(htmlString) {
    var temp = document.createElement('div');
    temp.innerHTML = htmlString;
    return temp.textContent || temp.innerText || '';
}
/** Set the object value of deeper node from a given dot (.) notation path (e.g.: "user.firstName") */
export function setDeepValue(obj, path, value) {
    if (typeof path === 'string') {
        path = path.split('.');
    }
    if (path.length > 1) {
        var e = path.shift();
        setDeepValue(obj[e] = Object.prototype.toString.call(obj[e]) === '[object Object]' ? obj[e] : {}, path, value);
    }
    else {
        obj[path[0]] = value;
    }
}
/**
 * Format a number or a string into a string that is separated every thousand,
 * the default separator is a comma but user can optionally pass a different one
 * @param inputValue
 * @param separator default to comma ","
 * @returns string
 */
export function thousandSeparatorFormatted(inputValue, separator) {
    if (separator === void 0) { separator = ','; }
    if (inputValue !== null && inputValue !== undefined) {
        var stringValue = "" + inputValue;
        var decimalSplit = stringValue.split('.');
        if (decimalSplit.length === 2) {
            return decimalSplit[0].replace(/\B(?=(\d{3})+(?!\d))/g, separator) + "." + decimalSplit[1];
        }
        return stringValue.replace(/\B(?=(\d{3})+(?!\d))/g, separator);
    }
    return inputValue;
}
/**
 * Title case (or capitalize) first char of a string
 * Optionall title case the complete sentence (upper case first char of each word while changing everything else to lower case)
 * @param inputStr
 * @returns string
 */
export function titleCase(inputStr, caseEveryWords) {
    if (caseEveryWords === void 0) { caseEveryWords = false; }
    if (typeof inputStr === 'string') {
        if (caseEveryWords) {
            return inputStr.replace(/\w\S*/g, function (outputStr) {
                return outputStr.charAt(0).toUpperCase() + outputStr.substr(1).toLowerCase();
            });
        }
        return inputStr.charAt(0).toUpperCase() + inputStr.slice(1);
    }
    return inputStr;
}
/**
 * Converts a string to camel case (camelCase)
 * @param inputStr the string to convert
 * @return the string in camel case
 */
export function toCamelCase(inputStr) {
    if (typeof inputStr === 'string') {
        return inputStr.replace(/(?:^\w|[A-Z]|\b\w|[\s+\-_\/])/g, function (match, offset) {
            // remove white space or hypens or underscores
            if (/[\s+\-_\/]/.test(match)) {
                return '';
            }
            return offset === 0 ? match.toLowerCase() : match.toUpperCase();
        });
    }
    return inputStr;
}
/**
 * Converts a string to kebab (hypen) case
 * @param str the string to convert
 * @return the string in kebab case
 */
export function toKebabCase(inputStr) {
    if (typeof inputStr === 'string') {
        return toCamelCase(inputStr).replace(/([A-Z])/g, '-$1').toLowerCase();
    }
    return inputStr;
}
/**
 * Converts a string from camelCase to snake_case (underscore) case
 * @param str the string to convert
 * @return the string in kebab case
 */
export function toSnakeCase(inputStr) {
    if (typeof inputStr === 'string') {
        return toCamelCase(inputStr).replace(/([A-Z])/g, '_$1').toLowerCase();
    }
    return inputStr;
}
/**
 * Takes an input array and makes sure the array has unique values by removing duplicates
 * @param array input with possible duplicates
 * @param objectProperty optionally provide an object property to compare (example: 'id')
 * @return array output without duplicates
 */
export function uniqueArray(arr) {
    if (Array.isArray(arr) && arr.length > 0) {
        return arr.filter(function (item, index) {
            return arr.indexOf(item) >= index;
        });
    }
    return arr;
}
/**
 * Takes an input array of objects and makes sure the array has unique object values by removing duplicates
 * it will loop through the array using a property name (or "id" when is not provided) to compare uniqueness
 * @param array input with possible duplicates
 * @param propertyName defaults to "id"
 * @return array output without duplicates
 */
export function uniqueObjectArray(arr, propertyName) {
    if (propertyName === void 0) { propertyName = 'id'; }
    var e_1, _a;
    if (Array.isArray(arr) && arr.length > 0) {
        var result = [];
        var map = new Map();
        try {
            for (var arr_1 = tslib_1.__values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {
                var item = arr_1_1.value;
                if (!map.has(item[propertyName])) {
                    map.set(item[propertyName], true); // set any value to Map
                    result.push({
                        id: item[propertyName],
                        name: item.name
                    });
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (arr_1_1 && !arr_1_1.done && (_a = arr_1.return)) _a.call(arr_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return result;
    }
    return arr;
}
/**
 * Unsubscribe all Observables Subscriptions
 * It will return an empty array if it all went well
 * @param subscriptions
 */
export function unsubscribeAllObservables(subscriptions) {
    if (Array.isArray(subscriptions)) {
        subscriptions.forEach(function (subscription) {
            if (subscription && subscription.unsubscribe) {
                subscription.unsubscribe();
            }
        });
        subscriptions = [];
    }
    return subscriptions;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbGl0aWVzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1zbGlja2dyaWQvIiwic291cmNlcyI6WyJhcHAvbW9kdWxlcy9hbmd1bGFyLXNsaWNrZ3JpZC9zZXJ2aWNlcy91dGlsaXRpZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQWdCLE1BQU0sTUFBTSxDQUFDO0FBQ2hELE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN2QyxPQUFPLEtBQUssT0FBTyxNQUFNLGFBQWEsQ0FBQztBQUN2QyxJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsQ0FBQyxzSEFBc0g7QUFFOUksT0FBTyxFQUFFLFNBQVMsRUFBa0IsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFLMUU7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSx1QkFBdUIsQ0FBQyxVQUFpQixFQUFFLFNBQWM7SUFDdkUsSUFBSSxhQUFhLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDdkIsSUFBSSxPQUFPLFNBQVMsS0FBSyxRQUFRLElBQUksU0FBUyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUNuRSxhQUFhLEdBQUcsVUFBVSxDQUFDLFNBQVMsQ0FBQyxVQUFDLElBQUksSUFBSyxPQUFBLElBQUksQ0FBQyxFQUFFLEtBQUssU0FBUyxDQUFDLEVBQUUsRUFBeEIsQ0FBd0IsQ0FBQyxDQUFDO0tBQzFFO1NBQU07UUFDTCxhQUFhLEdBQUcsVUFBVSxDQUFDLFNBQVMsQ0FBQyxVQUFDLElBQUksSUFBSyxPQUFBLElBQUksS0FBSyxTQUFTLEVBQWxCLENBQWtCLENBQUMsQ0FBQztLQUNwRTtJQUVELElBQUksYUFBYSxHQUFHLENBQUMsRUFBRTtRQUNyQixVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0tBQzVCO0FBQ0gsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsY0FBYyxDQUFDLFFBQWdCO0lB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SUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxFQUFFO1FBQ2hDLGFBQWEsQ0FBQyxPQUFPLENBQUMsVUFBQyxZQUEwQjtZQUMvQyxJQUFJLFlBQVksSUFBSSxZQUFZLENBQUMsV0FBVyxFQUFFO2dCQUM1QyxZQUFZLENBQUMsV0FBVyxFQUFFLENBQUM7YUFDNUI7UUFDSCxDQUFDLENBQUMsQ0FBQztRQUNILGFBQWEsR0FBRyxFQUFFLENBQUM7S0FDcEI7SUFFRCxPQUFPLGFBQWEsQ0FBQztBQUN2QixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaXJzdCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCAqIGFzIG1vbWVudF8gZnJvbSAnbW9tZW50LW1pbmknO1xuY29uc3QgbW9tZW50ID0gbW9tZW50XzsgLy8gcGF0Y2ggdG8gZml4IHJvbGx1cCBcIm1vbWVudCBoYXMgbm8gZGVmYXVsdCBleHBvcnRcIiBpc3N1ZSwgZG9jdW1lbnQgaGVyZSBodHRwczovL2dpdGh1Yi5jb20vcm9sbHVwL3JvbGx1cC9pc3N1ZXMvNjcwXG5cbmltcG9ydCB7IEZpZWxkVHlwZSwgT3BlcmF0b3JTdHJpbmcsIE9wZXJhdG9yVHlwZSB9IGZyb20gJy4uL21vZGVscy9pbmRleCc7XG5cbi8vIHVzaW5nIGV4dGVybmFsIG5vbi10eXBlZCBqcyBsaWJyYXJpZXNcbmRlY2xhcmUgdmFyICQ6IGFueTtcblxuLyoqXG4gKiBBZGQgYW4gaXRlbSB0byBhbiBhcnJheSBvbmx5IHdoZW4gdGhlIGl0ZW0gZG9lcyBub3QgZXhpc3RzLCB3aGVuIHRoZSBpdGVtIGlzIGFuIG9iamVjdCB3ZSB3aWxsIGJlIHVzaW5nIHRoZWlyIFwiaWRcIiB0byBjb21wYXJlXG4gKiBAcGFyYW0gaW5wdXRBcnJheVxuICogQHBhcmFtIGlucHV0SXRlbVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkVG9BcnJheVdoZW5Ob3RFeGlzdHMoaW5wdXRBcnJheTogYW55W10sIGlucHV0SXRlbTogYW55KSB7XG4gIGxldCBhcnJheVJvd0luZGV4ID0gLTE7XG4gIGlmICh0eXBlb2YgaW5wdXRJdGVtID09PSAnb2JqZWN0JyAmJiBpbnB1dEl0ZW0uaGFzT3duUHJvcGVydHkoJ2lkJykpIHtcbiAgICBhcnJheVJvd0luZGV4ID0gaW5wdXRBcnJheS5maW5kSW5kZXgoKGl0ZW0pID0+IGl0ZW0uaWQgPT09IGlucHV0SXRlbS5pZCk7XG4gIH0gZWxzZSB7XG4gICAgYXJyYXlSb3dJbmRleCA9IGlucHV0QXJyYXkuZmluZEluZGV4KChpdGVtKSA9PiBpdGVtID09PSBpbnB1dEl0ZW0pO1xuICB9XG5cbiAgaWYgKGFycmF5Um93SW5kZXggPCAwKSB7XG4gICAgaW5wdXRBcnJheS5wdXNoKGlucHV0SXRlbSk7XG4gIH1cbn1cblxuLyoqXG4gKiBTaW1wbGUgZnVuY3Rpb24gdG8gd2hpY2ggd2lsbCBsb29wIGFuZCBjcmVhdGUgYXMgZGVtYW5kZWQgdGhlIG51bWJlciBvZiB3aGl0ZSBzcGFjZXMsXG4gKiB0aGlzIGlzIHVzZWQgaW4gdGhlIENTViBleHBvcnRcbiAqIEBwYXJhbSBpbnQgbmJTcGFjZXM6IG51bWJlciBvZiB3aGl0ZSBzcGFjZXMgdG8gY3JlYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRXaGl0ZVNwYWNlcyhuYlNwYWNlczogbnVtYmVyKTogc3RyaW5nIHtcbiAgbGV0IHJlc3VsdCA9ICcnO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmJTcGFjZXM7IGkrKykge1xuICAgIHJlc3VsdCArPSAnICc7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBIVE1MIGRlY29kZSB1c2luZyBqUXVlcnkgd2l0aCBhIDxkaXY+XG4gKiBDcmVhdGUgYSBpbi1tZW1vcnkgZGl2LCBzZXQgaXQncyBpbm5lciB0ZXh0KHdoaWNoIGpRdWVyeSBhdXRvbWF0aWNhbGx5IGVuY29kZXMpXG4gKiB0aGVuIGdyYWIgdGhlIGVuY29kZWQgY29udGVudHMgYmFjayBvdXQuICBUaGUgZGl2IG5ldmVyIGV4aXN0cyBvbiB0aGUgcGFnZS5cbiovXG5leHBvcnQgZnVuY3Rpb24gaHRtbERlY29kZShlbmNvZGVkU3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBwYXJzZXIgPSBET01QYXJzZXIgJiYgbmV3IERPTVBhcnNlcjtcbiAgaWYgKHBhcnNlciAmJiBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKSB7XG4gICAgY29uc3QgZG9tID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhcbiAgICAgICc8IWRvY3R5cGUgaHRtbD48Ym9keT4nICsgZW5jb2RlZFN0cixcbiAgICAgICd0ZXh0L2h0bWwnKTtcbiAgICByZXR1cm4gZG9tICYmIGRvbS5ib2R5ICYmIGRvbS5ib2R5LnRleHRDb250ZW50O1xuICB9IGVsc2Uge1xuICAgIC8vIGZvciBzb21lIGJyb3dzZXJzIHRoYXQgbWlnaHQgbm90IHN1cHBvcnQgRE9NUGFyc2VyLCB1c2UgalF1ZXJ5IGluc3RlYWRcbiAgICByZXR1cm4gJCgnPGRpdi8+JykuaHRtbChlbmNvZGVkU3RyKS50ZXh0KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBIVE1MIGVuY29kZSB1c2luZyBqUXVlcnkgd2l0aCBhIDxkaXY+XG4gKiBDcmVhdGUgYSBpbi1tZW1vcnkgZGl2LCBzZXQgaXQncyBpbm5lciB0ZXh0KHdoaWNoIGpRdWVyeSBhdXRvbWF0aWNhbGx5IGVuY29kZXMpXG4gKiB0aGVuIGdyYWIgdGhlIGVuY29kZWQgY29udGVudHMgYmFjayBvdXQuICBUaGUgZGl2IG5ldmVyIGV4aXN0cyBvbiB0aGUgcGFnZS5cbiovXG5leHBvcnQgZnVuY3Rpb24gaHRtbEVuY29kZShpbnB1dFZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBlbnRpdHlNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgICdcXCcnOiAnJiMzOTsnXG4gIH07XG4gIC8vIGFsbCBzeW1ib2xzOjogIC9bJjw+XCInYD1cXC9dL2dcbiAgcmV0dXJuIChpbnB1dFZhbHVlIHx8ICcnKS50b1N0cmluZygpLnJlcGxhY2UoL1smPD5cIiddL2csIChzKSA9PiBlbnRpdHlNYXBbc10pO1xufVxuXG4vKipcbiAqIERlY29kZSB0ZXh0IGludG8gaHRtbCBlbnRpdHlcbiAqIEBwYXJhbSBzdHJpbmcgdGV4dDogaW5wdXQgdGV4dFxuICogQHBhcmFtIHN0cmluZyB0ZXh0OiBvdXRwdXQgdGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaHRtbEVudGl0eURlY29kZShpbnB1dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGlucHV0LnJlcGxhY2UoLyYjKFxcZCspOy9nLCBmdW5jdGlvbiAobWF0Y2gsIGRlYykge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGRlYyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIERlY29kZSB0ZXh0IGludG8gaHRtbCBlbnRpdHlcbiAqIEBwYXJhbSBzdHJpbmcgdGV4dDogaW5wdXQgdGV4dFxuICogQHBhcmFtIHN0cmluZyB0ZXh0OiBvdXRwdXQgdGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaHRtbEVudGl0eUVuY29kZShpbnB1dDogYW55KTogc3RyaW5nIHtcbiAgY29uc3QgYnVmID0gW107XG4gIGZvciAobGV0IGkgPSBpbnB1dC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGJ1Zi51bnNoaWZ0KFsnJiMnLCBpbnB1dFtpXS5jaGFyQ29kZUF0KCksICc7J10uam9pbignJykpO1xuICB9XG4gIHJldHVybiBidWYuam9pbignJyk7XG59XG5cbi8qKlxuICogQ29tcGFyZXMgdHdvIGFycmF5cyBvZiBjaGFyYWN0ZXJzIHRvIGRldGVybWluZSBpZiBhbGwgdGhlIGl0ZW1zIGFyZSBlcXVhbFxuICogQHBhcmFtIGEgZmlyc3QgYXJyYXlcbiAqIEBwYXJhbSBiIHNlY29uZCBhcnJheSB0byBjb21wYXJlIHdpdGggYVxuICogQHBhcmFtIFtvcmRlck1hdHRlcnM9ZmFsc2VdIGZsYWcgaWYgdGhlIG9yZGVyIG1hdHRlcnMsIGlmIG5vdCBhcnJheXMgd2lsbCBiZSBzb3J0ZWQgYmVmb3JlIGNvbXBhcmlzb25cbiAqIEByZXR1cm4gYm9vbGVhbiB0cnVlIGlmIGVxdWFsLCBlbHNlIGZhbHNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGFyQXJyYXlzRXF1YWwoYTogYW55W10sIGI6IGFueVtdLCBvcmRlck1hdHRlcnM6IGJvb2xlYW4gPSBmYWxzZSk6IGJvb2xlYW4ge1xuICBpZiAoIWEgfHwgIWIgfHwgIUFycmF5LmlzQXJyYXkoYSkgfHwgIUFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFvcmRlck1hdHRlcnMpIHtcbiAgICBhLnNvcnQoKTtcbiAgICBiLnNvcnQoKTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogVHJ5IGNhc3RpbmcgYW4gaW5wdXQgb2YgdHlwZSBQcm9taXNlIHwgT2JzZXJ2YWJsZSBpbnRvIGEgUHJvbWlzZSB0eXBlLlxuICogQHBhcmFtIG9iamVjdCB3aGljaCBjb3VsZCBiZSBvZiB0eXBlIFByb21pc2Ugb3IgT2JzZXJ2YWJsZVxuICogQHBhcmFtIGZyb21TZXJ2aWNlTmFtZSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjYWxsZXIgc2VydmljZSBuYW1lIGFuZCB3aWxsIGJlIHVzZWQgaWYgd2UgdGhyb3cgYSBjYXN0aW5nIHByb2JsZW0gZXJyb3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhc3RUb1Byb21pc2U8VD4oaW5wdXQ6IFByb21pc2U8VD4gfCBPYnNlcnZhYmxlPFQ+LCBmcm9tU2VydmljZU5hbWU6IHN0cmluZyA9ICcnKTogUHJvbWlzZTxUPiB7XG4gIGxldCBwcm9taXNlOiBhbnkgPSBpbnB1dDtcblxuICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgLy8gaWYgaXQncyBhbHJlYWR5IGEgUHJvbWlzZSB0aGVuIHJldHVybiBpdFxuICAgIHJldHVybiBpbnB1dDtcbiAgfSBlbHNlIGlmIChpbnB1dCBpbnN0YW5jZW9mIE9ic2VydmFibGUpIHtcbiAgICBwcm9taXNlID0gaW5wdXQucGlwZShmaXJzdCgpKS50b1Byb21pc2UoKTtcbiAgfVxuXG4gIGlmICghKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBTb21ldGhpbmcgd2VudCB3cm9uZywgQW5ndWxhci1TbGlja2dyaWQgJHtmcm9tU2VydmljZU5hbWV9IGlzIG5vdCBhYmxlIHRvIGNvbnZlcnQgdGhlIE9ic2VydmFibGUgaW50byBhIFByb21pc2UuXG4gICAgICBJZiB5b3UgYXJlIHVzaW5nIEFuZ3VsYXIgSHR0cENsaWVudCwgeW91IGNvdWxkIHRyeSBjb252ZXJ0aW5nIHlvdXIgaHR0cCBjYWxsIHRvIGEgUHJvbWlzZSB3aXRoIFwiLnRvUHJvbWlzZSgpXCJcbiAgICAgIGZvciBleGFtcGxlOjogIHRoaXMuaHR0cC5wb3N0KCdncmFwaHFsJywgeyBxdWVyeTogZ3JhcGhxbFF1ZXJ5IH0pLnRvUHJvbWlzZSgpXG4gICAgICBgKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufVxuXG4vKipcbiAqIFVzZXMgdGhlIGxvZ2ljIGZ1bmN0aW9uIHRvIGZpbmQgYW4gaXRlbSBpbiBhbiBhcnJheSBvciByZXR1cm5zIHRoZSBkZWZhdWx0XG4gKiB2YWx1ZSBwcm92aWRlZCAoZW1wdHkgb2JqZWN0IGJ5IGRlZmF1bHQpXG4gKiBAcGFyYW0gYW55W10gYXJyYXkgdGhlIGFycmF5IHRvIGZpbHRlclxuICogQHBhcmFtIGZ1bmN0aW9uIGxvZ2ljIHRoZSBsb2dpYyB0byBmaW5kIHRoZSBpdGVtXG4gKiBAcGFyYW0gYW55IFtkZWZhdWx0VmFsPXt9XSB0aGUgZGVmYXVsdCB2YWx1ZSB0byByZXR1cm5cbiAqIEByZXR1cm4gb2JqZWN0IHRoZSBmb3VuZCBvYmplY3Qgb3IgZGVmYXVsdCB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZE9yRGVmYXVsdChhcnJheTogYW55W10sIGxvZ2ljOiAoaXRlbTogYW55KSA9PiBib29sZWFuLCBkZWZhdWx0VmFsID0ge30pOiBhbnkge1xuICByZXR1cm4gYXJyYXkuZmluZChsb2dpYykgfHwgZGVmYXVsdFZhbDtcbn1cblxuLyoqXG4gICogVGFrZSBhIG51bWJlciAob3IgYSBzdHJpbmcpIGFuZCBkaXNwbGF5IGl0IGFzIGEgZm9ybWF0dGVkIGRlY2ltYWwgc3RyaW5nIHdpdGggZGVmaW5lZCBtaW5pbXVtIGFuZCBtYXhpbXVtIGRlY2ltYWxzXG4gICogQHBhcmFtIGlucHV0XG4gICogQHBhcmFtIG1pbkRlY2ltYWxcbiAgKiBAcGFyYW0gbWF4RGVjaW1hbFxuICAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY2ltYWxGb3JtYXR0ZWQoaW5wdXQ6IG51bWJlciB8IHN0cmluZywgbWluRGVjaW1hbD86IG51bWJlciwgbWF4RGVjaW1hbD86IG51bWJlciwgZGVjaW1hbFNlcGFyYXRvcjogJy4nIHwgJywnID0gJy4nLCB0aG91c2FuZFNlcGFyYXRvcjogJywnIHwgJ18nIHwgJy4nIHwgJyAnIHwgJycgPSAnJyk6IHN0cmluZyB7XG4gIGlmIChpc05hTigraW5wdXQpKSB7XG4gICAgcmV0dXJuIGlucHV0IGFzIHN0cmluZztcbiAgfVxuXG4gIGNvbnN0IG1pbkRlYyA9IChtaW5EZWNpbWFsID09PSB1bmRlZmluZWQpID8gMiA6IG1pbkRlY2ltYWw7XG4gIGNvbnN0IG1heERlYyA9IChtYXhEZWNpbWFsID09PSB1bmRlZmluZWQpID8gMiA6IG1heERlY2ltYWw7XG4gIGxldCBhbW91bnQgPSBTdHJpbmcoTWF0aC5yb3VuZCgraW5wdXQgKiBNYXRoLnBvdygxMCwgbWF4RGVjKSkgLyBNYXRoLnBvdygxMCwgbWF4RGVjKSk7XG5cbiAgaWYgKChhbW91bnQuaW5kZXhPZignLicpIDwgMCkgJiYgKG1pbkRlYyA+IDApKSB7XG4gICAgYW1vdW50ICs9ICcuJztcbiAgfVxuICB3aGlsZSAoKGFtb3VudC5sZW5ndGggLSBhbW91bnQuaW5kZXhPZignLicpKSA8PSBtaW5EZWMpIHtcbiAgICBhbW91bnQgKz0gJzAnO1xuICB9XG5cbiAgLy8gZG8gd2Ugd2FudCB0byBkaXNwbGF5IG91ciBudW1iZXIgd2l0aCBhIGN1c3RvbSBzZXBhcmF0b3IgaW4gZWFjaCB0aG91c2FuZCBwb3NpdGlvblxuICBpZiAodGhvdXNhbmRTZXBhcmF0b3IpIHtcbiAgICBhbW91bnQgPSB0aG91c2FuZFNlcGFyYXRvckZvcm1hdHRlZChhbW91bnQsIHRob3VzYW5kU2VwYXJhdG9yKTtcbiAgfVxuXG4gIC8vIHdoZW4gdXNpbmcgYSBzZXBhcmF0b3IgdGhhdCBpcyBub3QgYSBkb3QsIHJlcGxhY2UgaXQgd2l0aCB0aGUgbmV3IHNlcGFyYXRvclxuICBpZiAoZGVjaW1hbFNlcGFyYXRvciAhPT0gJy4nKSB7XG4gICAgYW1vdW50ID0gYW1vdW50LnJlcGxhY2UoJy4nLCBkZWNpbWFsU2VwYXJhdG9yKTtcbiAgfVxuICByZXR1cm4gYW1vdW50O1xufVxuXG4vKipcbiAqIEZvcm1hdCBhIG51bWJlciBmb2xsb3dpbmcgb3B0aW9ucyBwYXNzZWQgYXMgYXJndW1lbnRzIChkZWNpbWFscywgc2VwYXJhdG9yLCAuLi4pXG4gKiBAcGFyYW0gaW5wdXRcbiAqIEBwYXJhbSBtaW5EZWNpbWFsXG4gKiBAcGFyYW0gbWF4RGVjaW1hbFxuICogQHBhcmFtIGRpc3BsYXlOZWdhdGl2ZU51bWJlcldpdGhQYXJlbnRoZXNlc1xuICogQHBhcmFtIHN5bWJvbFByZWZpeFxuICogQHBhcmFtIHN5bWJvbFN1ZmZpeFxuICogQHBhcmFtIGRlY2ltYWxTZXBhcmF0b3JcbiAqIEBwYXJhbSB0aG91c2FuZFNlcGFyYXRvclxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TnVtYmVyKGlucHV0OiBudW1iZXIgfCBzdHJpbmcsIG1pbkRlY2ltYWw/OiBudW1iZXIsIG1heERlY2ltYWw/OiBudW1iZXIsIGRpc3BsYXlOZWdhdGl2ZU51bWJlcldpdGhQYXJlbnRoZXNlcz86IGJvb2xlYW4sIHN5bWJvbFByZWZpeCA9ICcnLCBzeW1ib2xTdWZmaXggPSAnJywgZGVjaW1hbFNlcGFyYXRvcjogJy4nIHwgJywnID0gJy4nLCB0aG91c2FuZFNlcGFyYXRvcjogJywnIHwgJ18nIHwgJy4nIHwgJyAnIHwgJycgPSAnJyk6IHN0cmluZyB7XG4gIGlmIChpc05hTigraW5wdXQpKSB7XG4gICAgcmV0dXJuIGlucHV0IGFzIHN0cmluZztcbiAgfVxuXG4gIGNvbnN0IGNhbGN1bGF0ZWRWYWx1ZSA9ICgoTWF0aC5yb3VuZChwYXJzZUZsb2F0KGlucHV0IGFzIHN0cmluZykgKiAxMDAwMDAwKSAvIDEwMDAwMDApKTtcblxuICBpZiAoY2FsY3VsYXRlZFZhbHVlIDwgMCkge1xuICAgIGNvbnN0IGFic1ZhbHVlID0gTWF0aC5hYnMoY2FsY3VsYXRlZFZhbHVlKTtcbiAgICBpZiAoZGlzcGxheU5lZ2F0aXZlTnVtYmVyV2l0aFBhcmVudGhlc2VzKSB7XG4gICAgICBpZiAoIWlzTmFOKG1pbkRlY2ltYWwpIHx8ICFpc05hTihtYXhEZWNpbWFsKSkge1xuICAgICAgICByZXR1cm4gYCgke3N5bWJvbFByZWZpeH0ke2RlY2ltYWxGb3JtYXR0ZWQoYWJzVmFsdWUsIG1pbkRlY2ltYWwsIG1heERlY2ltYWwsIGRlY2ltYWxTZXBhcmF0b3IsIHRob3VzYW5kU2VwYXJhdG9yKX0ke3N5bWJvbFN1ZmZpeH0pYDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZvcm1hdHRlZFZhbHVlID0gdGhvdXNhbmRTZXBhcmF0b3JGb3JtYXR0ZWQoYCR7YWJzVmFsdWV9YCwgdGhvdXNhbmRTZXBhcmF0b3IpO1xuICAgICAgcmV0dXJuIGAoJHtzeW1ib2xQcmVmaXh9JHtmb3JtYXR0ZWRWYWx1ZX0ke3N5bWJvbFN1ZmZpeH0pYDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFpc05hTihtaW5EZWNpbWFsKSB8fCAhaXNOYU4obWF4RGVjaW1hbCkpIHtcbiAgICAgICAgcmV0dXJuIGAtJHtzeW1ib2xQcmVmaXh9JHtkZWNpbWFsRm9ybWF0dGVkKGFic1ZhbHVlLCBtaW5EZWNpbWFsLCBtYXhEZWNpbWFsLCBkZWNpbWFsU2VwYXJhdG9yLCB0aG91c2FuZFNlcGFyYXRvcil9JHtzeW1ib2xTdWZmaXh9YDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZvcm1hdHRlZFZhbHVlID0gdGhvdXNhbmRTZXBhcmF0b3JGb3JtYXR0ZWQoYCR7YWJzVmFsdWV9YCwgdGhvdXNhbmRTZXBhcmF0b3IpO1xuICAgICAgcmV0dXJuIGAtJHtzeW1ib2xQcmVmaXh9JHtmb3JtYXR0ZWRWYWx1ZX0ke3N5bWJvbFN1ZmZpeH1gO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoIWlzTmFOKG1pbkRlY2ltYWwpIHx8ICFpc05hTihtYXhEZWNpbWFsKSkge1xuICAgICAgcmV0dXJuIGAke3N5bWJvbFByZWZpeH0ke2RlY2ltYWxGb3JtYXR0ZWQoaW5wdXQsIG1pbkRlY2ltYWwsIG1heERlY2ltYWwsIGRlY2ltYWxTZXBhcmF0b3IsIHRob3VzYW5kU2VwYXJhdG9yKX0ke3N5bWJvbFN1ZmZpeH1gO1xuICAgIH1cbiAgICBjb25zdCBmb3JtYXR0ZWRWYWx1ZSA9IHRob3VzYW5kU2VwYXJhdG9yRm9ybWF0dGVkKGAke2lucHV0fWAsIHRob3VzYW5kU2VwYXJhdG9yKTtcbiAgICByZXR1cm4gYCR7c3ltYm9sUHJlZml4fSR7Zm9ybWF0dGVkVmFsdWV9JHtzeW1ib2xTdWZmaXh9YDtcbiAgfVxufVxuXG4vKiogRnJvbSBhIGRvdCAoLikgbm90YXRpb24gcGF0aCwgZmluZCBhbmQgcmV0dXJuIGEgcHJvcGVydHkgd2l0aGluIGFuIG9iamVjdCBnaXZlbiBhIHBhdGggKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREZXNjZW5kYW50UHJvcGVydHkob2JqOiBhbnksIHBhdGg6IHN0cmluZyk6IGFueSB7XG4gIHJldHVybiBwYXRoLnNwbGl0KCcuJykucmVkdWNlKChhY2MsIHBhcnQpID0+IGFjYyAmJiBhY2NbcGFydF0sIG9iaik7XG59XG5cbi8qKiBHZXQgdGhlIGJyb3dzZXIncyBzY3JvbGxiYXIgd2lkdGgsIHRoaXMgaXMgZGlmZmVyZW50IHRvIGVhY2ggYnJvd3NlciAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNjcm9sbEJhcldpZHRoKCk6IG51bWJlciB7XG4gIGNvbnN0ICRvdXRlciA9ICQoJzxkaXY+JykuY3NzKHsgdmlzaWJpbGl0eTogJ2hpZGRlbicsIHdpZHRoOiAxMDAsIG92ZXJmbG93OiAnc2Nyb2xsJyB9KS5hcHBlbmRUbygnYm9keScpO1xuICBjb25zdCB3aWR0aFdpdGhTY3JvbGwgPSAkKCc8ZGl2PicpLmNzcyh7IHdpZHRoOiAnMTAwJScgfSkuYXBwZW5kVG8oJG91dGVyKS5vdXRlcldpZHRoKCk7XG4gICRvdXRlci5yZW1vdmUoKTtcbiAgcmV0dXJuIE1hdGguY2VpbCgxMDAgLSB3aWR0aFdpdGhTY3JvbGwpO1xufVxuXG4vKipcbiAqIEZyb20gYSBEYXRlIEZpZWxkVHlwZSwgcmV0dXJuIGl0J3MgZXF1aXZhbGVudCBtb21lbnQuanMgZm9ybWF0XG4gKiByZWZlciB0byBtb21lbnQuanMgZm9yIHRoZSBmb3JtYXQgc3RhbmRhcmQgdXNlZDogaHR0cHM6Ly9tb21lbnRqcy5jb20vZG9jcy8jL3BhcnNpbmcvc3RyaW5nLWZvcm1hdC9cbiAqIEBwYXJhbSBmaWVsZFR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcE1vbWVudERhdGVGb3JtYXRXaXRoRmllbGRUeXBlKGZpZWxkVHlwZTogRmllbGRUeXBlKTogc3RyaW5nIHtcbiAgbGV0IG1hcDogc3RyaW5nO1xuICBzd2l0Y2ggKGZpZWxkVHlwZSkge1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lOlxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lSXNvOlxuICAgICAgbWFwID0gJ1lZWVktTU0tREQgSEg6bW06c3MnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVTaG9ydElzbzpcbiAgICAgIG1hcCA9ICdZWVlZLU1NLUREIEhIOm1tJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lSXNvQW1QbTpcbiAgICAgIG1hcCA9ICdZWVlZLU1NLUREIGhoOm1tOnNzIGEnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVJc29BTV9QTTpcbiAgICAgIG1hcCA9ICdZWVlZLU1NLUREIGhoOm1tOnNzIEEnO1xuICAgICAgYnJlYWs7XG4gICAgLy8gYWxsIEV1cm8gRm9ybWF0cyAoZGF0ZS9tb250aC95ZWFyKVxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVFdXJvOlxuICAgICAgbWFwID0gJ0REL01NL1lZWVknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZUV1cm9TaG9ydDpcbiAgICAgIG1hcCA9ICdEL00vWVknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVFdXJvOlxuICAgICAgbWFwID0gJ0REL01NL1lZWVkgSEg6bW06c3MnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVTaG9ydEV1cm86XG4gICAgICBtYXAgPSAnREQvTU0vWVlZWSBISDptbSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUV1cm9BbVBtOlxuICAgICAgbWFwID0gJ0REL01NL1lZWVkgaGg6bW06c3MgYSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUV1cm9BTV9QTTpcbiAgICAgIG1hcCA9ICdERC9NTS9ZWVlZIGhoOm1tOnNzIEEnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVFdXJvU2hvcnQ6XG4gICAgICBtYXAgPSAnRC9NL1lZIEg6bTpzJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lRXVyb1Nob3J0QW1QbTpcbiAgICAgIG1hcCA9ICdEL00vWVkgaDptOnMgYSc7XG4gICAgICBicmVhaztcbiAgICAvLyBhbGwgVVMgRm9ybWF0cyAobW9udGgvZGF0ZS95ZWFyKVxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVVczpcbiAgICAgIG1hcCA9ICdNTS9ERC9ZWVlZJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVVc1Nob3J0OlxuICAgICAgbWFwID0gJ00vRC9ZWSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVVzOlxuICAgICAgbWFwID0gJ01NL0REL1lZWVkgSEg6bW06c3MnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVTaG9ydFVzOlxuICAgICAgbWFwID0gJ01NL0REL1lZWVkgSEg6bW0nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVVc0FtUG06XG4gICAgICBtYXAgPSAnTU0vREQvWVlZWSBoaDptbTpzcyBhJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lVXNBTV9QTTpcbiAgICAgIG1hcCA9ICdNTS9ERC9ZWVlZIGhoOm1tOnNzIEEnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVVc1Nob3J0OlxuICAgICAgbWFwID0gJ00vRC9ZWSBIOm06cyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVVzU2hvcnRBbVBtOlxuICAgICAgbWFwID0gJ00vRC9ZWSBoOm06cyBhJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVVdGM6XG4gICAgICBtYXAgPSAnWVlZWS1NTS1ERFRISDptbTpzcy5TU1NaJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGU6XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZUlzbzpcbiAgICBkZWZhdWx0OlxuICAgICAgbWFwID0gJ1lZWVktTU0tREQnO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIG1hcDtcbn1cblxuLyoqXG4gKiBGcm9tIGEgRGF0ZSBGaWVsZFR5cGUsIHJldHVybiBpdCdzIGVxdWl2YWxlbnQgRmxhdHBpY2tyIGZvcm1hdFxuICogcmVmZXIgdG8gRmxhdHBpY2tyIGZvciB0aGUgZm9ybWF0IHN0YW5kYXJkIHVzZWQ6IGh0dHBzOi8vY2htbG4uZ2l0aHViLmlvL2ZsYXRwaWNrci9mb3JtYXR0aW5nLyNkYXRlLWZvcm1hdHRpbmctdG9rZW5zXG4gKiBhbHNvIG5vdGUgdGhhdCB0aGV5IHNlZW0gdmVyeSBzaW1pbGFyIHRvIFBIUCBmb3JtYXQgKGV4Y2VwdCBmb3IgYW0vcG0pOiBodHRwOi8vcGhwLm5ldC9tYW51YWwvZW4vZnVuY3Rpb24uZGF0ZS5waHBcbiAqIEBwYXJhbSBmaWVsZFR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcEZsYXRwaWNrckRhdGVGb3JtYXRXaXRoRmllbGRUeXBlKGZpZWxkVHlwZTogRmllbGRUeXBlKTogc3RyaW5nIHtcbiAgLypcbiAgICBkOiBEYXkgb2YgdGhlIG1vbnRoLCAyIGRpZ2l0cyB3aXRoIGxlYWRpbmcgemVyb3NcdDAxIHRvIDMxXG4gICAgRDogQSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIGEgZGF5XHRNb24gdGhyb3VnaCBTdW5cbiAgICBsOiAobG93ZXJjYXNlICdMJylcdEEgZnVsbCB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkYXkgb2YgdGhlIHdlZWtcdFN1bmRheSB0aHJvdWdoIFNhdHVyZGF5XG4gICAgajogRGF5IG9mIHRoZSBtb250aCB3aXRob3V0IGxlYWRpbmcgemVyb3NcdDEgdG8gMzFcbiAgICBKOiBEYXkgb2YgdGhlIG1vbnRoIHdpdGhvdXQgbGVhZGluZyB6ZXJvcyBhbmQgb3JkaW5hbCBzdWZmaXhcdDFzdCwgMm5kLCB0byAzMXN0XG4gICAgdzogTnVtZXJpYyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGF5IG9mIHRoZSB3ZWVrXHQwIChmb3IgU3VuZGF5KSB0aHJvdWdoIDYgKGZvciBTYXR1cmRheSlcbiAgICBGOiBBIGZ1bGwgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiBhIG1vbnRoXHRKYW51YXJ5IHRocm91Z2ggRGVjZW1iZXJcbiAgICBtOiBOdW1lcmljIHJlcHJlc2VudGF0aW9uIG9mIGEgbW9udGgsIHdpdGggbGVhZGluZyB6ZXJvXHQwMSB0aHJvdWdoIDEyXG4gICAgbjogTnVtZXJpYyByZXByZXNlbnRhdGlvbiBvZiBhIG1vbnRoLCB3aXRob3V0IGxlYWRpbmcgemVyb3NcdDEgdGhyb3VnaCAxMlxuICAgIE06IEEgc2hvcnQgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiBhIG1vbnRoXHRKYW4gdGhyb3VnaCBEZWNcbiAgICBVOiBUaGUgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgdGhlIFVuaXggRXBvY2hcdDE0MTM3MDQ5OTNcbiAgICB5OiBBIHR3byBkaWdpdCByZXByZXNlbnRhdGlvbiBvZiBhIHllYXJcdDk5IG9yIDAzXG4gICAgWTogQSBmdWxsIG51bWVyaWMgcmVwcmVzZW50YXRpb24gb2YgYSB5ZWFyLCA0IGRpZ2l0c1x0MTk5OSBvciAyMDAzXG4gICAgSDogSG91cnMgKDI0IGhvdXJzKVx0MDAgdG8gMjNcbiAgICBoOiBIb3Vyc1x0MSB0byAxMlxuICAgIGk6IE1pbnV0ZXNcdDAwIHRvIDU5XG4gICAgUzogU2Vjb25kcywgMiBkaWdpdHNcdDAwIHRvIDU5XG4gICAgczogU2Vjb25kc1x0MCwgMSB0byA1OVxuICAgIEs6IEFNL1BNXHRBTSBvciBQTVxuICAqL1xuICBsZXQgbWFwOiBzdHJpbmc7XG4gIHN3aXRjaCAoZmllbGRUeXBlKSB7XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWU6XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVJc286XG4gICAgICBtYXAgPSAnWS1tLWQgSDppOlMnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVTaG9ydElzbzpcbiAgICAgIG1hcCA9ICdZLW0tZCBIOmknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVJc29BbVBtOlxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lSXNvQU1fUE06XG4gICAgICBtYXAgPSAnWS1tLWQgaDppOlMgSyc7IC8vIHRoZXJlIGlzIG5vIGxvd2VyY2FzZSBpbiBGbGF0cGlja3IgOihcbiAgICAgIGJyZWFrO1xuICAgIC8vIGFsbCBFdXJvIEZvcm1hdHMgKGRhdGUvbW9udGgveWVhcilcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlRXVybzpcbiAgICAgIG1hcCA9ICdkL20vWSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlRXVyb1Nob3J0OlxuICAgICAgbWFwID0gJ2QvbS95JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lRXVybzpcbiAgICAgIG1hcCA9ICdkL20vWSBIOmk6Uyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVNob3J0RXVybzpcbiAgICAgIG1hcCA9ICdkL20veSBIOmknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVFdXJvQW1QbTpcbiAgICAgIG1hcCA9ICdkL20vWSBoOmk6UyBLJzsgLy8gdGhlcmUgaXMgbm8gbG93ZXJjYXNlIGluIEZsYXRwaWNrciA6KFxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVFdXJvQU1fUE06XG4gICAgICBtYXAgPSAnZC9tL1kgaDppOnMgSyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUV1cm9TaG9ydDpcbiAgICAgIG1hcCA9ICdkL20veSBIOmk6cyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUV1cm9TaG9ydEFtUG06XG4gICAgICBtYXAgPSAnZC9tL3kgaDppOnMgSyc7IC8vIHRoZXJlIGlzIG5vIGxvd2VyY2FzZSBpbiBGbGF0cGlja3IgOihcbiAgICAgIGJyZWFrO1xuICAgIC8vIGFsbCBVUyBGb3JtYXRzIChtb250aC9kYXRlL3llYXIpXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVVzOlxuICAgICAgbWFwID0gJ20vZC9ZJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVVc1Nob3J0OlxuICAgICAgbWFwID0gJ20vZC95JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lVXM6XG4gICAgICBtYXAgPSAnbS9kL1kgSDppOlMnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVTaG9ydFVzOlxuICAgICAgbWFwID0gJ20vZC95IEg6aSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVVzQW1QbTpcbiAgICAgIG1hcCA9ICdtL2QvWSBoOmk6UyBLJzsgLy8gdGhlcmUgaXMgbm8gbG93ZXJjYXNlIGluIEZsYXRwaWNrciA6KFxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVVc0FNX1BNOlxuICAgICAgbWFwID0gJ20vZC9ZIGg6aTpzIEsnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVVc1Nob3J0OlxuICAgICAgbWFwID0gJ20vZC95IEg6aTpzJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lVXNTaG9ydEFtUG06XG4gICAgICBtYXAgPSAnbS9kL3kgaDppOnMgSyc7IC8vIHRoZXJlIGlzIG5vIGxvd2VyY2FzZSBpbiBGbGF0cGlja3IgOihcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVVdGM6XG4gICAgICBtYXAgPSAnWic7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlOlxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVJc286XG4gICAgZGVmYXVsdDpcbiAgICAgIG1hcCA9ICdZLW0tZCc7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gbWFwO1xufVxuXG4vKipcbiAqIE1hcHBlciBmb3IgcXVlcnkgb3BlcmF0b3JzIChleC46IDw9IGlzIFwibGVcIiwgPiBpcyBcImd0XCIpXG4gKiBAcGFyYW0gc3RyaW5nIG9wZXJhdG9yXG4gKiBAcmV0dXJucyBzdHJpbmcgbWFwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBPcGVyYXRvclR5cGUob3BlcmF0b3I6IE9wZXJhdG9yVHlwZSB8IE9wZXJhdG9yU3RyaW5nKTogT3BlcmF0b3JUeXBlIHtcbiAgbGV0IG1hcDogT3BlcmF0b3JUeXBlO1xuXG4gIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICBjYXNlICc8JzpcbiAgICBjYXNlICdMVCc6XG4gICAgICBtYXAgPSBPcGVyYXRvclR5cGUubGVzc1RoYW47XG4gICAgICBicmVhaztcbiAgICBjYXNlICc8PSc6XG4gICAgY2FzZSAnTEUnOlxuICAgICAgbWFwID0gT3BlcmF0b3JUeXBlLmxlc3NUaGFuT3JFcXVhbDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJz4nOlxuICAgIGNhc2UgJ0dUJzpcbiAgICAgIG1hcCA9IE9wZXJhdG9yVHlwZS5ncmVhdGVyVGhhbjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJz49JzpcbiAgICBjYXNlICdHRSc6XG4gICAgICBtYXAgPSBPcGVyYXRvclR5cGUuZ3JlYXRlclRoYW5PckVxdWFsO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnPD4nOlxuICAgIGNhc2UgJyE9JzpcbiAgICBjYXNlICdORSc6XG4gICAgICBtYXAgPSBPcGVyYXRvclR5cGUubm90RXF1YWw7XG4gICAgICBicmVhaztcbiAgICBjYXNlICcqJzpcbiAgICBjYXNlICdhKic6XG4gICAgY2FzZSAnU3RhcnRzV2l0aCc6XG4gICAgICBtYXAgPSBPcGVyYXRvclR5cGUuc3RhcnRzV2l0aDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyp6JzpcbiAgICBjYXNlICdFbmRzV2l0aCc6XG4gICAgICBtYXAgPSBPcGVyYXRvclR5cGUuZW5kc1dpdGg7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc9JzpcbiAgICBjYXNlICc9PSc6XG4gICAgY2FzZSAnRVEnOlxuICAgICAgbWFwID0gT3BlcmF0b3JUeXBlLmVxdWFsO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnSU4nOlxuICAgICAgbWFwID0gT3BlcmF0b3JUeXBlLmluO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTklOJzpcbiAgICBjYXNlICdOT1RfSU4nOlxuICAgICAgbWFwID0gT3BlcmF0b3JUeXBlLm5vdEluO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTm90X0NvbnRhaW5zJzpcbiAgICBjYXNlICdOT1RfQ09OVEFJTlMnOlxuICAgICAgbWFwID0gT3BlcmF0b3JUeXBlLm5vdENvbnRhaW5zO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnQ29udGFpbnMnOlxuICAgIGNhc2UgJ0NPTlRBSU5TJzpcbiAgICBkZWZhdWx0OlxuICAgICAgbWFwID0gT3BlcmF0b3JUeXBlLmNvbnRhaW5zO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gbWFwO1xufVxuXG4vKipcbiAqIEZpbmQgZXF1aXZhbGVudCBzaG9ydCBkZXNpZ25hdGlvbiBvZiBhbiBPcGVyYXRvciBUeXBlIG9yIE9wZXJhdG9yIFN0cmluZy5cbiAqIFdoZW4gdXNpbmcgYSBDb21wb3VuZCBGaWx0ZXIsIHdlIHVzZSB0aGUgc2hvcnQgZGVzaWduYXRpb24gYW5kIHNvIHdlIG5lZWQgdGhlIG1hcHBlZCB2YWx1ZS5cbiAqIEZvciBleGFtcGxlIE9wZXJhdG9yVHlwZS5zdGFydHNXaXRoIHNob3J0IGRlc2lnbmF0aW9uIGlzIFwiYSpcIiwgd2hpbGUgT3BlcmF0b3JUeXBlLmdyZWF0ZXJUaGFuT3JFcXVhbCBpcyBcIj49XCJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcE9wZXJhdG9yVG9TaG9ydGhhbmREZXNpZ25hdGlvbihvcGVyYXRvcjogT3BlcmF0b3JUeXBlIHwgT3BlcmF0b3JTdHJpbmcpOiBPcGVyYXRvclN0cmluZyB7XG4gIGxldCBzaG9ydE9wZXJhdG9yOiBPcGVyYXRvclN0cmluZyA9ICcnO1xuXG4gIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICBjYXNlIE9wZXJhdG9yVHlwZS5ncmVhdGVyVGhhbjpcbiAgICBjYXNlICc+JzpcbiAgICAgIHNob3J0T3BlcmF0b3IgPSAnPic7XG4gICAgICBicmVhaztcbiAgICBjYXNlIE9wZXJhdG9yVHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw6XG4gICAgY2FzZSAnPj0nOlxuICAgICAgc2hvcnRPcGVyYXRvciA9ICc+PSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIE9wZXJhdG9yVHlwZS5sZXNzVGhhbjpcbiAgICBjYXNlICc8JzpcbiAgICAgIHNob3J0T3BlcmF0b3IgPSAnPCc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIE9wZXJhdG9yVHlwZS5sZXNzVGhhbk9yRXF1YWw6XG4gICAgY2FzZSAnPD0nOlxuICAgICAgc2hvcnRPcGVyYXRvciA9ICc8PSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIE9wZXJhdG9yVHlwZS5ub3RFcXVhbDpcbiAgICBjYXNlICc8Pic6XG4gICAgICBzaG9ydE9wZXJhdG9yID0gJzw+JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgT3BlcmF0b3JUeXBlLmVxdWFsOlxuICAgIGNhc2UgJz0nOlxuICAgIGNhc2UgJz09JzpcbiAgICBjYXNlICdFUSc6XG4gICAgICBzaG9ydE9wZXJhdG9yID0gJz0nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBPcGVyYXRvclR5cGUuc3RhcnRzV2l0aDpcbiAgICBjYXNlICdhKic6XG4gICAgY2FzZSAnKic6XG4gICAgICBzaG9ydE9wZXJhdG9yID0gJ2EqJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgT3BlcmF0b3JUeXBlLmVuZHNXaXRoOlxuICAgIGNhc2UgJyp6JzpcbiAgICAgIHNob3J0T3BlcmF0b3IgPSAnKnonO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGFueSBvdGhlciBvcGVyYXRvciB3aWxsIGJlIGNvbnNpZGVyZWQgYXMgYWxyZWFkeSBhIHNob3J0IGV4cHJlc3Npb24sIHNvIHdlIGNhbiByZXR1cm4gc2FtZSBpbnB1dCBvcGVyYXRvclxuICAgICAgc2hvcnRPcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gc2hvcnRPcGVyYXRvcjtcbn1cblxuLyoqXG4gKiBNYXBwZXIgZm9yIHF1ZXJ5IG9wZXJhdG9yIGJ5IGEgRmlsdGVyIFR5cGVcbiAqIEZvciBleGFtcGxlIGEgbXVsdGlwbGUtc2VsZWN0IHR5cGljYWxseSB1c2VzICdJTicgb3BlcmF0b3JcbiAqIEBwYXJhbSBvcGVyYXRvclxuICogQHJldHVybnMgc3RyaW5nIG1hcFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwT3BlcmF0b3JCeUZpZWxkVHlwZShmaWVsZFR5cGU6IEZpZWxkVHlwZSB8IHN0cmluZyk6IE9wZXJhdG9yVHlwZSB7XG4gIGxldCBtYXA6IE9wZXJhdG9yVHlwZTtcblxuICBzd2l0Y2ggKGZpZWxkVHlwZSkge1xuICAgIGNhc2UgRmllbGRUeXBlLnN0cmluZzpcbiAgICBjYXNlIEZpZWxkVHlwZS51bmtub3duOlxuICAgICAgbWFwID0gT3BlcmF0b3JUeXBlLmNvbnRhaW5zO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGaWVsZFR5cGUuZmxvYXQ6XG4gICAgY2FzZSBGaWVsZFR5cGUubnVtYmVyOlxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGU6XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZUlzbzpcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVXRjOlxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lOlxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lSXNvOlxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lSXNvQW1QbTpcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUlzb0FNX1BNOlxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVFdXJvOlxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVFdXJvU2hvcnQ6XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVFdXJvOlxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lRXVyb0FtUG06XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVFdXJvQU1fUE06XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVFdXJvU2hvcnQ6XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVFdXJvU2hvcnRBbVBtOlxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lRXVyb1Nob3J0QU1fUE06XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVVzOlxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVVc1Nob3J0OlxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lVXM6XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVVc0FtUG06XG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVVc0FNX1BNOlxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lVXNTaG9ydDpcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVVzU2hvcnRBbVBtOlxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lVXNTaG9ydEFNX1BNOlxuICAgIGRlZmF1bHQ6XG4gICAgICBtYXAgPSBPcGVyYXRvclR5cGUuZXF1YWw7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBtYXA7XG59XG5cbi8qKiBQYXJzZSBhbnkgaW5wdXQgKGJvb2wsIG51bWJlciwgc3RyaW5nKSBhbmQgcmV0dXJuIGEgYm9vbGVhbiBvciBGYWxzZSB3aGVuIG5vdCBwb3NzaWJsZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQm9vbGVhbihpbnB1dDogYW55KTogYm9vbGVhbiB7XG4gIHJldHVybiAvKHRydWV8MSkvaS50ZXN0KGlucHV0ICsgJycpO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgZGF0ZSBwYXNzZWQgYXMgYSBzdHJpbmcgKERhdGUgb25seSwgd2l0aG91dCB0aW1lKSBhbmQgcmV0dXJuIGEgRGF0ZSBvYmplY3QgKGlmIHZhbGlkKVxuICogQHBhcmFtIGlucHV0RGF0ZVN0cmluZ1xuICogQHJldHVybnMgc3RyaW5nIGRhdGUgZm9ybWF0dGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVV0Y0RhdGUoaW5wdXREYXRlU3RyaW5nOiBzdHJpbmcsIHVzZVV0Yz86IGJvb2xlYW4pOiBzdHJpbmcgfCBudWxsIHtcbiAgbGV0IGRhdGUgPSBudWxsO1xuXG4gIGlmICgvXlswLTlcXC1cXC9dKiQvLnRlc3QoaW5wdXREYXRlU3RyaW5nKSkge1xuICAgIC8vIGdldCB0aGUgVVRDIGRhdGV0aW1lIHdpdGggbW9tZW50LmpzIGJ1dCB3ZSBuZWVkIHRvIGRlY29kZSB0aGUgdmFsdWUgc28gdGhhdCBpdCdzIHZhbGlkIHRleHRcbiAgICBjb25zdCBkYXRlU3RyaW5nID0gZGVjb2RlVVJJQ29tcG9uZW50KGlucHV0RGF0ZVN0cmluZyk7XG4gICAgY29uc3QgZGF0ZU1vbWVudCA9IG1vbWVudChuZXcgRGF0ZShkYXRlU3RyaW5nKSk7XG4gICAgaWYgKGRhdGVNb21lbnQuaXNWYWxpZCgpICYmIGRhdGVNb21lbnQueWVhcigpLnRvU3RyaW5nKCkubGVuZ3RoID09PSA0KSB7XG4gICAgICBkYXRlID0gKHVzZVV0YykgPyBkYXRlTW9tZW50LnV0YygpLmZvcm1hdCgpIDogZGF0ZU1vbWVudC5mb3JtYXQoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGF0ZTtcbn1cblxuLyoqXG4gKiBTYW5pdGl6ZSwgcmV0dXJuIG9ubHkgdGhlIHRleHQgd2l0aG91dCBIVE1MIHRhZ3NcbiAqIEBpbnB1dCBodG1sU3RyaW5nXG4gKiBAcmV0dXJuIHRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhbml0aXplSHRtbFRvVGV4dChodG1sU3RyaW5nOiBzdHJpbmcpIHtcbiAgY29uc3QgdGVtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0ZW1wLmlubmVySFRNTCA9IGh0bWxTdHJpbmc7XG4gIHJldHVybiB0ZW1wLnRleHRDb250ZW50IHx8IHRlbXAuaW5uZXJUZXh0IHx8ICcnO1xufVxuXG4vKiogU2V0IHRoZSBvYmplY3QgdmFsdWUgb2YgZGVlcGVyIG5vZGUgZnJvbSBhIGdpdmVuIGRvdCAoLikgbm90YXRpb24gcGF0aCAoZS5nLjogXCJ1c2VyLmZpcnN0TmFtZVwiKSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldERlZXBWYWx1ZShvYmo6IGFueSwgcGF0aDogc3RyaW5nIHwgc3RyaW5nW10sIHZhbHVlOiBhbnkpIHtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgIHBhdGggPSBwYXRoLnNwbGl0KCcuJyk7XG4gIH1cblxuICBpZiAocGF0aC5sZW5ndGggPiAxKSB7XG4gICAgY29uc3QgZSA9IHBhdGguc2hpZnQoKTtcbiAgICBzZXREZWVwVmFsdWUoXG4gICAgICBvYmpbZV0gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqW2VdKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyBvYmpbZV0gOiB7fSxcbiAgICAgIHBhdGgsXG4gICAgICB2YWx1ZVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW3BhdGhbMF1dID0gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3JtYXQgYSBudW1iZXIgb3IgYSBzdHJpbmcgaW50byBhIHN0cmluZyB0aGF0IGlzIHNlcGFyYXRlZCBldmVyeSB0aG91c2FuZCxcbiAqIHRoZSBkZWZhdWx0IHNlcGFyYXRvciBpcyBhIGNvbW1hIGJ1dCB1c2VyIGNhbiBvcHRpb25hbGx5IHBhc3MgYSBkaWZmZXJlbnQgb25lXG4gKiBAcGFyYW0gaW5wdXRWYWx1ZVxuICogQHBhcmFtIHNlcGFyYXRvciBkZWZhdWx0IHRvIGNvbW1hIFwiLFwiXG4gKiBAcmV0dXJucyBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRob3VzYW5kU2VwYXJhdG9yRm9ybWF0dGVkKGlucHV0VmFsdWU6IHN0cmluZyB8IG51bWJlciB8IG51bGwsIHNlcGFyYXRvcjogJywnIHwgJ18nIHwgJy4nIHwgJyAnIHwgJycgPSAnLCcpOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKGlucHV0VmFsdWUgIT09IG51bGwgJiYgaW5wdXRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3Qgc3RyaW5nVmFsdWUgPSBgJHtpbnB1dFZhbHVlfWA7XG4gICAgY29uc3QgZGVjaW1hbFNwbGl0ID0gc3RyaW5nVmFsdWUuc3BsaXQoJy4nKTtcbiAgICBpZiAoZGVjaW1hbFNwbGl0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0dXJuIGAke2RlY2ltYWxTcGxpdFswXS5yZXBsYWNlKC9cXEIoPz0oXFxkezN9KSsoPyFcXGQpKS9nLCBzZXBhcmF0b3IpfS4ke2RlY2ltYWxTcGxpdFsxXX1gO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nVmFsdWUucmVwbGFjZSgvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgc2VwYXJhdG9yKTtcbiAgfVxuICByZXR1cm4gaW5wdXRWYWx1ZSBhcyBudWxsO1xufVxuXG4vKipcbiAqIFRpdGxlIGNhc2UgKG9yIGNhcGl0YWxpemUpIGZpcnN0IGNoYXIgb2YgYSBzdHJpbmdcbiAqIE9wdGlvbmFsbCB0aXRsZSBjYXNlIHRoZSBjb21wbGV0ZSBzZW50ZW5jZSAodXBwZXIgY2FzZSBmaXJzdCBjaGFyIG9mIGVhY2ggd29yZCB3aGlsZSBjaGFuZ2luZyBldmVyeXRoaW5nIGVsc2UgdG8gbG93ZXIgY2FzZSlcbiAqIEBwYXJhbSBpbnB1dFN0clxuICogQHJldHVybnMgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aXRsZUNhc2UoaW5wdXRTdHI6IHN0cmluZywgY2FzZUV2ZXJ5V29yZHMgPSBmYWxzZSk6IHN0cmluZyB7XG4gIGlmICh0eXBlb2YgaW5wdXRTdHIgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGNhc2VFdmVyeVdvcmRzKSB7XG4gICAgICByZXR1cm4gaW5wdXRTdHIucmVwbGFjZSgvXFx3XFxTKi9nLCAob3V0cHV0U3RyKSA9PiB7XG4gICAgICAgIHJldHVybiBvdXRwdXRTdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBvdXRwdXRTdHIuc3Vic3RyKDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0U3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgaW5wdXRTdHIuc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuIGlucHV0U3RyO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIHRvIGNhbWVsIGNhc2UgKGNhbWVsQ2FzZSlcbiAqIEBwYXJhbSBpbnB1dFN0ciB0aGUgc3RyaW5nIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4gdGhlIHN0cmluZyBpbiBjYW1lbCBjYXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0NhbWVsQ2FzZShpbnB1dFN0cjogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKHR5cGVvZiBpbnB1dFN0ciA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gaW5wdXRTdHIucmVwbGFjZSgvKD86Xlxcd3xbQS1aXXxcXGJcXHd8W1xccytcXC1fXFwvXSkvZywgKG1hdGNoOiBzdHJpbmcsIG9mZnNldDogbnVtYmVyKSA9PiB7XG4gICAgICAvLyByZW1vdmUgd2hpdGUgc3BhY2Ugb3IgaHlwZW5zIG9yIHVuZGVyc2NvcmVzXG4gICAgICBpZiAoL1tcXHMrXFwtX1xcL10vLnRlc3QobWF0Y2gpKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9mZnNldCA9PT0gMCA/IG1hdGNoLnRvTG93ZXJDYXNlKCkgOiBtYXRjaC50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBpbnB1dFN0cjtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyB0byBrZWJhYiAoaHlwZW4pIGNhc2VcbiAqIEBwYXJhbSBzdHIgdGhlIHN0cmluZyB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIHRoZSBzdHJpbmcgaW4ga2ViYWIgY2FzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9LZWJhYkNhc2UoaW5wdXRTdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmICh0eXBlb2YgaW5wdXRTdHIgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHRvQ2FtZWxDYXNlKGlucHV0U3RyKS5yZXBsYWNlKC8oW0EtWl0pL2csICctJDEnKS50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIHJldHVybiBpbnB1dFN0cjtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBmcm9tIGNhbWVsQ2FzZSB0byBzbmFrZV9jYXNlICh1bmRlcnNjb3JlKSBjYXNlXG4gKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgdG8gY29udmVydFxuICogQHJldHVybiB0aGUgc3RyaW5nIGluIGtlYmFiIGNhc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU25ha2VDYXNlKGlucHV0U3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAodHlwZW9mIGlucHV0U3RyID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0b0NhbWVsQ2FzZShpbnB1dFN0cikucmVwbGFjZSgvKFtBLVpdKS9nLCAnXyQxJykudG9Mb3dlckNhc2UoKTtcbiAgfVxuICByZXR1cm4gaW5wdXRTdHI7XG59XG5cbi8qKlxuICogVGFrZXMgYW4gaW5wdXQgYXJyYXkgYW5kIG1ha2VzIHN1cmUgdGhlIGFycmF5IGhhcyB1bmlxdWUgdmFsdWVzIGJ5IHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSBhcnJheSBpbnB1dCB3aXRoIHBvc3NpYmxlIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSBvYmplY3RQcm9wZXJ0eSBvcHRpb25hbGx5IHByb3ZpZGUgYW4gb2JqZWN0IHByb3BlcnR5IHRvIGNvbXBhcmUgKGV4YW1wbGU6ICdpZCcpXG4gKiBAcmV0dXJuIGFycmF5IG91dHB1dCB3aXRob3V0IGR1cGxpY2F0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuaXF1ZUFycmF5KGFycjogYW55W10pOiBhbnlbXSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikgJiYgYXJyLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gYXJyLmZpbHRlcigoaXRlbTogYW55LCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICByZXR1cm4gYXJyLmluZGV4T2YoaXRlbSkgPj0gaW5kZXg7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuLyoqXG4gKiBUYWtlcyBhbiBpbnB1dCBhcnJheSBvZiBvYmplY3RzIGFuZCBtYWtlcyBzdXJlIHRoZSBhcnJheSBoYXMgdW5pcXVlIG9iamVjdCB2YWx1ZXMgYnkgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogaXQgd2lsbCBsb29wIHRocm91Z2ggdGhlIGFycmF5IHVzaW5nIGEgcHJvcGVydHkgbmFtZSAob3IgXCJpZFwiIHdoZW4gaXMgbm90IHByb3ZpZGVkKSB0byBjb21wYXJlIHVuaXF1ZW5lc3NcbiAqIEBwYXJhbSBhcnJheSBpbnB1dCB3aXRoIHBvc3NpYmxlIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSBwcm9wZXJ0eU5hbWUgZGVmYXVsdHMgdG8gXCJpZFwiXG4gKiBAcmV0dXJuIGFycmF5IG91dHB1dCB3aXRob3V0IGR1cGxpY2F0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuaXF1ZU9iamVjdEFycmF5KGFycjogYW55W10sIHByb3BlcnR5TmFtZSA9ICdpZCcpOiBhbnlbXSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikgJiYgYXJyLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG5cbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSB7XG4gICAgICBpZiAoIW1hcC5oYXMoaXRlbVtwcm9wZXJ0eU5hbWVdKSkge1xuICAgICAgICBtYXAuc2V0KGl0ZW1bcHJvcGVydHlOYW1lXSwgdHJ1ZSk7ICAgIC8vIHNldCBhbnkgdmFsdWUgdG8gTWFwXG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICBpZDogaXRlbVtwcm9wZXJ0eU5hbWVdLFxuICAgICAgICAgIG5hbWU6IGl0ZW0ubmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG4vKipcbiAqIFVuc3Vic2NyaWJlIGFsbCBPYnNlcnZhYmxlcyBTdWJzY3JpcHRpb25zXG4gKiBJdCB3aWxsIHJldHVybiBhbiBlbXB0eSBhcnJheSBpZiBpdCBhbGwgd2VudCB3ZWxsXG4gKiBAcGFyYW0gc3Vic2NyaXB0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdW5zdWJzY3JpYmVBbGxPYnNlcnZhYmxlcyhzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSk6IFN1YnNjcmlwdGlvbltdIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3Vic2NyaXB0aW9ucykpIHtcbiAgICBzdWJzY3JpcHRpb25zLmZvckVhY2goKHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uKSA9PiB7XG4gICAgICBpZiAoc3Vic2NyaXB0aW9uICYmIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSkge1xuICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzdWJzY3JpcHRpb25zID0gW107XG4gIH1cblxuICByZXR1cm4gc3Vic2NyaXB0aW9ucztcbn1cbiJdfQ==