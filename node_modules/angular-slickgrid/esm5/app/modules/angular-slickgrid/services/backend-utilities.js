import { EMPTY, iif, isObservable } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { EmitterType } from '../models';
var main = {};
/** Execute the Backend Processes Callback, that could come from an Observable or a Promise callback */
main.executeBackendProcessesCallback = function exeBackendProcessesCallback(startTime, processResult, backendApi, totalItems) {
    var endTime = new Date();
    // define what our internal Post Process callback, only available for GraphQL Service for now
    // it will basically refresh the Dataset & Pagination removing the need for the user to always create his own PostProcess every time
    if (processResult && backendApi && backendApi.internalPostProcess) {
        backendApi.internalPostProcess(processResult);
    }
    // send the response process to the postProcess callback
    if (backendApi.postProcess) {
        if (processResult instanceof Object) {
            processResult.metrics = {
                startTime: startTime,
                endTime: endTime,
                executionTime: endTime.valueOf() - startTime.valueOf(),
                itemCount: totalItems,
                totalItemCount: totalItems
            };
            // @deprecated
            processResult.statistics = processResult.metrics;
        }
        backendApi.postProcess(processResult);
    }
};
/** On a backend service api error, we will run the "onError" if there is 1 provided or just throw back the error when nothing is provided */
main.onBackendError = function backendError(e, backendApi) {
    if (backendApi && backendApi.onError) {
        backendApi.onError(e);
    }
    else {
        throw e;
    }
};
/**
 * Execute the backend callback, which are mainly the "process" & "postProcess" methods.
 * Also note that "preProcess" was executed prior to this callback
 */
main.executeBackendCallback = function exeBackendCallback(backendServiceApi, query, args, startTime, totalItems, emitActionChangedCallback, httpCancelRequests$) {
    if (backendServiceApi) {
        // emit an onFilterChanged event when it's not called by a clear filter
        if (args && !args.clearFilterTriggered && !args.clearSortTriggered) {
            emitActionChangedCallback(EmitterType.remote);
        }
        // the processes can be Observables (like HttpClient) or Promises
        var process_1 = backendServiceApi.process(query);
        if (process_1 instanceof Promise && process_1.then) {
            process_1.then(function (processResult) { return main.executeBackendProcessesCallback(startTime, processResult, backendServiceApi, totalItems); })
                .catch(function (error) { return main.onBackendError(error, backendServiceApi); });
        }
        else if (isObservable(process_1)) {
            // this will abort any previous HTTP requests, that were previously hooked in the takeUntil, before sending a new request
            if (isObservable(httpCancelRequests$)) {
                httpCancelRequests$.next();
            }
            process_1
                // the following takeUntil, will potentially be used later to cancel any pending http request (takeUntil another rx, that would be httpCancelRequests$, completes)
                // but make sure the observable is actually defined with the iif condition check before piping it to the takeUntil
                .pipe(takeUntil(iif(function () { return isObservable(httpCancelRequests$); }, httpCancelRequests$, EMPTY)))
                .subscribe(function (processResult) { return main.executeBackendProcessesCallback(startTime, processResult, backendServiceApi, totalItems); }, function (error) { return main.onBackendError(error, backendServiceApi); });
        }
    }
};
/** Refresh the dataset through the Backend Service */
main.refreshBackendDataset = function refreshBackend(gridOptions) {
    var query = '';
    var backendApi = gridOptions && gridOptions.backendServiceApi;
    if (!backendApi || !backendApi.service || !backendApi.process) {
        throw new Error("BackendServiceApi requires at least a \"process\" function and a \"service\" defined");
    }
    if (backendApi.service) {
        query = backendApi.service.buildQuery();
    }
    if (query && query !== '') {
        // keep start time & end timestamps & return it after process execution
        var startTime = new Date();
        if (backendApi.preProcess) {
            backendApi.preProcess();
        }
        var totalItems = gridOptions && gridOptions.pagination && gridOptions.pagination.totalItems;
        main.executeBackendCallback(backendApi, query, null, startTime, totalItems);
    }
};
// export all methods & the main so that it works in all modules but also in Jest unit test
// export every method as independent constant so that it still works whenever this is used in other modules
export var executeBackendProcessesCallback = main.executeBackendProcessesCallback;
export var onBackendError = main.onBackendError;
export var executeBackendCallback = main.executeBackendCallback;
export var refreshBackendDataset = main.refreshBackendDataset;
export default main;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFja2VuZC11dGlsaXRpZXMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyLXNsaWNrZ3JpZC8iLCJzb3VyY2VzIjpbImFwcC9tb2R1bGVzL2FuZ3VsYXItc2xpY2tncmlkL3NlcnZpY2VzL2JhY2tlbmQtdXRpbGl0aWVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLFlBQVksRUFBVyxNQUFNLE1BQU0sQ0FBQztBQUN6RCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFM0MsT0FBTyxFQUFxQixXQUFXLEVBQXFELE1BQU0sV0FBVyxDQUFDO0FBRTlHLElBQU0sSUFBSSxHQUFRLEVBQUUsQ0FBQztBQUVyQix1R0FBdUc7QUFDdkcsSUFBSSxDQUFDLCtCQUErQixHQUFHLFNBQVMsMkJBQTJCLENBQUMsU0FBZSxFQUFFLGFBQTJELEVBQUUsVUFBNkIsRUFBRSxVQUFrQjtJQUN6TSxJQUFNLE9BQU8sR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDO0lBRTNCLDZGQUE2RjtJQUM3RixvSUFBb0k7SUFDcEksSUFBSSxhQUFhLElBQUksVUFBVSxJQUFJLFVBQVUsQ0FBQyxtQkFBbUIsRUFBRTtRQUNqRSxVQUFVLENBQUMsbUJBQW1CLENBQUMsYUFBYSxDQUFDLENBQUM7S0FDL0M7SUFFRCx3REFBd0Q7SUFDeEQsSUFBSSxVQUFVLENBQUMsV0FBVyxFQUFFO1FBQzFCLElBQUksYUFBYSxZQUFZLE1BQU0sRUFBRTtZQUNuQyxhQUFhLENBQUMsT0FBTyxHQUFHO2dCQUN0QixTQUFTLFdBQUE7Z0JBQ1QsT0FBTyxTQUFBO2dCQUNQLGFBQWEsRUFBRSxPQUFPLENBQUMsT0FBTyxFQUFFLEdBQUcsU0FBUyxDQUFDLE9BQU8sRUFBRTtnQkFDdEQsU0FBUyxFQUFFLFVBQVU7Z0JBQ3JCLGNBQWMsRUFBRSxVQUFVO2FBQzNCLENBQUM7WUFDRixjQUFjO1lBQ2QsYUFBYSxDQUFDLFVBQVUs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QUN6QztJQUVELElBQUksS0FBSyxJQUFJLEtBQUssS0FBSyxFQUFFLEVBQUU7UUFDekIsdUVBQXVFO1FBQ3ZFLElBQU0sU0FBUyxHQUFHLElBQUksSUFBSSxFQUFFLENBQUM7UUFFN0IsSUFBSSxVQUFVLENBQUMsVUFBVSxFQUFFO1lBQ3pCLFVBQVUsQ0FBQyxVQUFVLEVBQUUsQ0FBQztTQUN6QjtRQUVELElBQU0sVUFBVSxHQUFHLFdBQVcsSUFBSSxXQUFXLENBQUMsVUFBVSxJQUFJLFdBQVcsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDO1FBQzlGLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxVQUFVLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsVUFBVSxDQUFDLENBQUM7S0FDN0U7QUFDSCxDQUFDLENBQUM7QUFFRiwyRkFBMkY7QUFDM0YsNEdBQTRHO0FBQzVHLE1BQU0sQ0FBQyxJQUFNLCtCQUErQixHQUFHLElBQUksQ0FBQywrQkFBK0IsQ0FBQztBQUNwRixNQUFNLENBQUMsSUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQztBQUNsRCxNQUFNLENBQUMsSUFBTSxzQkFBc0IsR0FBRyxJQUFJLENBQUMsc0JBQXNCLENBQUM7QUFDbEUsTUFBTSxDQUFDLElBQU0scUJBQXFCLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixDQUFDO0FBRWhFLGVBQWUsSUFBSSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRU1QVFksIGlpZiwgaXNPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmltcG9ydCB7IEJhY2tlbmRTZXJ2aWNlQXBpLCBFbWl0dGVyVHlwZSwgR3JhcGhxbFJlc3VsdCwgR3JhcGhxbFBhZ2luYXRlZFJlc3VsdCwgR3JpZE9wdGlvbiB9IGZyb20gJy4uL21vZGVscyc7XHJcblxyXG5jb25zdCBtYWluOiBhbnkgPSB7fTtcclxuXHJcbi8qKiBFeGVjdXRlIHRoZSBCYWNrZW5kIFByb2Nlc3NlcyBDYWxsYmFjaywgdGhhdCBjb3VsZCBjb21lIGZyb20gYW4gT2JzZXJ2YWJsZSBvciBhIFByb21pc2UgY2FsbGJhY2sgKi9cclxubWFpbi5leGVjdXRlQmFja2VuZFByb2Nlc3Nlc0NhbGxiYWNrID0gZnVuY3Rpb24gZXhlQmFja2VuZFByb2Nlc3Nlc0NhbGxiYWNrKHN0YXJ0VGltZTogRGF0ZSwgcHJvY2Vzc1Jlc3VsdDogR3JhcGhxbFJlc3VsdCB8IEdyYXBocWxQYWdpbmF0ZWRSZXN1bHQgfCBhbnksIGJhY2tlbmRBcGk6IEJhY2tlbmRTZXJ2aWNlQXBpLCB0b3RhbEl0ZW1zOiBudW1iZXIpOiBHcmFwaHFsUmVzdWx0IHwgR3JhcGhxbFBhZ2luYXRlZFJlc3VsdCB8IGFueSB7XHJcbiAgY29uc3QgZW5kVGltZSA9IG5ldyBEYXRlKCk7XHJcblxyXG4gIC8vIGRlZmluZSB3aGF0IG91ciBpbnRlcm5hbCBQb3N0IFByb2Nlc3MgY2FsbGJhY2ssIG9ubHkgYXZhaWxhYmxlIGZvciBHcmFwaFFMIFNlcnZpY2UgZm9yIG5vd1xyXG4gIC8vIGl0IHdpbGwgYmFzaWNhbGx5IHJlZnJlc2ggdGhlIERhdGFzZXQgJiBQYWdpbmF0aW9uIHJlbW92aW5nIHRoZSBuZWVkIGZvciB0aGUgdXNlciB0byBhbHdheXMgY3JlYXRlIGhpcyBvd24gUG9zdFByb2Nlc3MgZXZlcnkgdGltZVxyXG4gIGlmIChwcm9jZXNzUmVzdWx0ICYmIGJhY2tlbmRBcGkgJiYgYmFja2VuZEFwaS5pbnRlcm5hbFBvc3RQcm9jZXNzKSB7XHJcbiAgICBiYWNrZW5kQXBpLmludGVybmFsUG9zdFByb2Nlc3MocHJvY2Vzc1Jlc3VsdCk7XHJcbiAgfVxyXG5cclxuICAvLyBzZW5kIHRoZSByZXNwb25zZSBwcm9jZXNzIHRvIHRoZSBwb3N0UHJvY2VzcyBjYWxsYmFja1xyXG4gIGlmIChiYWNrZW5kQXBpLnBvc3RQcm9jZXNzKSB7XHJcbiAgICBpZiAocHJvY2Vzc1Jlc3VsdCBpbnN0YW5jZW9mIE9iamVjdCkge1xyXG4gICAgICBwcm9jZXNzUmVzdWx0Lm1ldHJpY3MgPSB7XHJcbiAgICAgICAgc3RhcnRUaW1lLFxyXG4gICAgICAgIGVuZFRpbWUsXHJcbiAgICAgICAgZXhlY3V0aW9uVGltZTogZW5kVGltZS52YWx1ZU9mKCkgLSBzdGFydFRpbWUudmFsdWVPZigpLFxyXG4gICAgICAgIGl0ZW1Db3VudDogdG90YWxJdGVtcyxcclxuICAgICAgICB0b3RhbEl0ZW1Db3VudDogdG90YWxJdGVtc1xyXG4gICAgICB9O1xyXG4gICAgICAvLyBAZGVwcmVjYXRlZFxyXG4gICAgICBwcm9jZXNzUmVzdWx0LnN0YXRpc3RpY3MgPSBwcm9jZXNzUmVzdWx0Lm1ldHJpY3M7XHJcbiAgICB9XHJcbiAgICBiYWNrZW5kQXBpLnBvc3RQcm9jZXNzKHByb2Nlc3NSZXN1bHQpO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKiBPbiBhIGJhY2tlbmQgc2VydmljZSBhcGkgZXJyb3IsIHdlIHdpbGwgcnVuIHRoZSBcIm9uRXJyb3JcIiBpZiB0aGVyZSBpcyAxIHByb3ZpZGVkIG9yIGp1c3QgdGhyb3cgYmFjayB0aGUgZXJyb3Igd2hlbiBub3RoaW5nIGlzIHByb3ZpZGVkICovXHJcbm1haW4ub25CYWNrZW5kRXJyb3IgPSBmdW5jdGlvbiBiYWNrZW5kRXJyb3IoZTogYW55LCBiYWNrZW5kQXBpOiBCYWNrZW5kU2VydmljZUFwaSkge1xyXG4gIGlmIChiYWNrZW5kQXBpICYmIGJhY2tlbmRBcGkub25FcnJvcikge1xyXG4gICAgYmFja2VuZEFwaS5vbkVycm9yKGUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aHJvdyBlO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBFeGVjdXRlIHRoZSBiYWNrZW5kIGNhbGxiYWNrLCB3aGljaCBhcmUgbWFpbmx5IHRoZSBcInByb2Nlc3NcIiAmIFwicG9zdFByb2Nlc3NcIiBtZXRob2RzLlxyXG4gKiBBbHNvIG5vdGUgdGhhdCBcInByZVByb2Nlc3NcIiB3YXMgZXhlY3V0ZWQgcHJpb3IgdG8gdGhpcyBjYWxsYmFja1xyXG4gKi9cclxubWFpbi5leGVjdXRlQmFja2VuZENhbGxiYWNrID0gZnVuY3Rpb24gZXhlQmFja2VuZENhbGxiYWNrKGJhY2tlbmRTZXJ2aWNlQXBpOiBCYWNrZW5kU2VydmljZUFwaSwgcXVlcnk6IHN0cmluZywgYXJnczogYW55LCBzdGFydFRpbWU6IERhdGUsIHRvdGFsSXRlbXM6IG51bWJlciwgZW1pdEFjdGlvbkNoYW5nZWRDYWxsYmFjaz86ICh0eXBlOiBFbWl0dGVyVHlwZSkgPT4gdm9pZCwgaHR0cENhbmNlbFJlcXVlc3RzJD86IFN1YmplY3Q8dm9pZD4pIHtcclxuICBpZiAoYmFja2VuZFNlcnZpY2VBcGkpIHtcclxuICAgIC8vIGVtaXQgYW4gb25GaWx0ZXJDaGFuZ2VkIGV2ZW50IHdoZW4gaXQncyBub3QgY2FsbGVkIGJ5IGEgY2xlYXIgZmlsdGVyXHJcbiAgICBpZiAoYXJncyAmJiAhYXJncy5jbGVhckZpbHRlclRyaWdnZXJlZCAmJiAhYXJncy5jbGVhclNvcnRUcmlnZ2VyZWQpIHtcclxuICAgICAgZW1pdEFjdGlvbkNoYW5nZWRDYWxsYmFjayhFbWl0dGVyVHlwZS5yZW1vdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHRoZSBwcm9jZXNzZXMgY2FuIGJlIE9ic2VydmFibGVzIChsaWtlIEh0dHBDbGllbnQpIG9yIFByb21pc2VzXHJcbiAgICBjb25zdCBwcm9jZXNzID0gYmFja2VuZFNlcnZpY2VBcGkucHJvY2VzcyhxdWVyeSk7XHJcbiAgICBpZiAocHJvY2VzcyBpbnN0YW5jZW9mIFByb21pc2UgJiYgcHJvY2Vzcy50aGVuKSB7XHJcbiAgICAgIHByb2Nlc3MudGhlbigocHJvY2Vzc1Jlc3VsdDogR3JhcGhxbFJlc3VsdCB8IEdyYXBocWxQYWdpbmF0ZWRSZXN1bHQgfCBhbnkpID0+IG1haW4uZXhlY3V0ZUJhY2tlbmRQcm9jZXNzZXNDYWxsYmFjayhzdGFydFRpbWUsIHByb2Nlc3NSZXN1bHQsIGJhY2tlbmRTZXJ2aWNlQXBpLCB0b3RhbEl0ZW1zKSlcclxuICAgICAgICAuY2F0Y2goKGVycm9yOiBhbnkpID0+IG1haW4ub25CYWNrZW5kRXJyb3IoZXJyb3IsIGJhY2tlbmRTZXJ2aWNlQXBpKSk7XHJcbiAgICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZShwcm9jZXNzKSkge1xyXG4gICAgICAvLyB0aGlzIHdpbGwgYWJvcnQgYW55IHByZXZpb3VzIEhUVFAgcmVxdWVzdHMsIHRoYXQgd2VyZSBwcmV2aW91c2x5IGhvb2tlZCBpbiB0aGUgdGFrZVVudGlsLCBiZWZvcmUgc2VuZGluZyBhIG5ldyByZXF1ZXN0XHJcbiAgICAgIGlmIChpc09ic2VydmFibGUoaHR0cENhbmNlbFJlcXVlc3RzJCkpIHtcclxuICAgICAgICBodHRwQ2FuY2VsUmVxdWVzdHMkLm5leHQoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHJvY2Vzc1xyXG4gICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgdGFrZVVudGlsLCB3aWxsIHBvdGVudGlhbGx5IGJlIHVzZWQgbGF0ZXIgdG8gY2FuY2VsIGFueSBwZW5kaW5nIGh0dHAgcmVxdWVzdCAodGFrZVVudGlsIGFub3RoZXIgcngsIHRoYXQgd291bGQgYmUgaHR0cENhbmNlbFJlcXVlc3RzJCwgY29tcGxldGVzKVxyXG4gICAgICAgIC8vIGJ1dCBtYWtlIHN1cmUgdGhlIG9ic2VydmFibGUgaXMgYWN0dWFsbHkgZGVmaW5lZCB3aXRoIHRoZSBpaWYgY29uZGl0aW9uIGNoZWNrIGJlZm9yZSBwaXBpbmcgaXQgdG8gdGhlIHRha2VVbnRpbFxyXG4gICAgICAgIC5waXBlKHRha2VVbnRpbChpaWYoKCkgPT4gaXNPYnNlcnZhYmxlKGh0dHBDYW5jZWxSZXF1ZXN0cyQpLCBodHRwQ2FuY2VsUmVxdWVzdHMkLCBFTVBUWSkpKVxyXG4gICAgICAgIC5zdWJzY3JpYmUoXHJcbiAgICAgICAgICAocHJvY2Vzc1Jlc3VsdDogR3JhcGhxbFJlc3VsdCB8IEdyYXBocWxQYWdpbmF0ZWRSZXN1bHQgfCBhbnkpID0+IG1haW4uZXhlY3V0ZUJhY2tlbmRQcm9jZXNzZXNDYWxsYmFjayhzdGFydFRpbWUsIHByb2Nlc3NSZXN1bHQsIGJhY2tlbmRTZXJ2aWNlQXBpLCB0b3RhbEl0ZW1zKSxcclxuICAgICAgICAgIChlcnJvcjogYW55KSA9PiBtYWluLm9uQmFja2VuZEVycm9yKGVycm9yLCBiYWNrZW5kU2VydmljZUFwaSlcclxuICAgICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbi8qKiBSZWZyZXNoIHRoZSBkYXRhc2V0IHRocm91Z2ggdGhlIEJhY2tlbmQgU2VydmljZSAqL1xyXG5tYWluLnJlZnJlc2hCYWNrZW5kRGF0YXNldCA9IGZ1bmN0aW9uIHJlZnJlc2hCYWNrZW5kKGdyaWRPcHRpb25zOiBHcmlkT3B0aW9uKSB7XHJcbiAgbGV0IHF1ZXJ5ID0gJyc7XHJcbiAgY29uc3QgYmFja2VuZEFwaSA9IGdyaWRPcHRpb25zICYmIGdyaWRPcHRpb25zLmJhY2tlbmRTZXJ2aWNlQXBpO1xyXG5cclxuICBpZiAoIWJhY2tlbmRBcGkgfHwgIWJhY2tlbmRBcGkuc2VydmljZSB8fCAhYmFja2VuZEFwaS5wcm9jZXNzKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEJhY2tlbmRTZXJ2aWNlQXBpIHJlcXVpcmVzIGF0IGxlYXN0IGEgXCJwcm9jZXNzXCIgZnVuY3Rpb24gYW5kIGEgXCJzZXJ2aWNlXCIgZGVmaW5lZGApO1xyXG4gIH1cclxuXHJcbiAgaWYgKGJhY2tlbmRBcGkuc2VydmljZSkge1xyXG4gICAgcXVlcnkgPSBiYWNrZW5kQXBpLnNlcnZpY2UuYnVpbGRRdWVyeSgpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHF1ZXJ5ICYmIHF1ZXJ5ICE9PSAnJykge1xyXG4gICAgLy8ga2VlcCBzdGFydCB0aW1lICYgZW5kIHRpbWVzdGFtcHMgJiByZXR1cm4gaXQgYWZ0ZXIgcHJvY2VzcyBleGVjdXRpb25cclxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XHJcblxyXG4gICAgaWYgKGJhY2tlbmRBcGkucHJlUHJvY2Vzcykge1xyXG4gICAgICBiYWNrZW5kQXBpLnByZVByb2Nlc3MoKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0b3RhbEl0ZW1zID0gZ3JpZE9wdGlvbnMgJiYgZ3JpZE9wdGlvbnMucGFnaW5hdGlvbiAmJiBncmlkT3B0aW9ucy5wYWdpbmF0aW9uLnRvdGFsSXRlbXM7XHJcbiAgICBtYWluLmV4ZWN1dGVCYWNrZW5kQ2FsbGJhY2soYmFja2VuZEFwaSwgcXVlcnksIG51bGwsIHN0YXJ0VGltZSwgdG90YWxJdGVtcyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gZXhwb3J0IGFsbCBtZXRob2RzICYgdGhlIG1haW4gc28gdGhhdCBpdCB3b3JrcyBpbiBhbGwgbW9kdWxlcyBidXQgYWxzbyBpbiBKZXN0IHVuaXQgdGVzdFxyXG4vLyBleHBvcnQgZXZlcnkgbWV0aG9kIGFzIGluZGVwZW5kZW50IGNvbnN0YW50IHNvIHRoYXQgaXQgc3RpbGwgd29ya3Mgd2hlbmV2ZXIgdGhpcyBpcyB1c2VkIGluIG90aGVyIG1vZHVsZXNcclxuZXhwb3J0IGNvbnN0IGV4ZWN1dGVCYWNrZW5kUHJvY2Vzc2VzQ2FsbGJhY2sgPSBtYWluLmV4ZWN1dGVCYWNrZW5kUHJvY2Vzc2VzQ2FsbGJhY2s7XHJcbmV4cG9ydCBjb25zdCBvbkJhY2tlbmRFcnJvciA9IG1haW4ub25CYWNrZW5kRXJyb3I7XHJcbmV4cG9ydCBjb25zdCBleGVjdXRlQmFja2VuZENhbGxiYWNrID0gbWFpbi5leGVjdXRlQmFja2VuZENhbGxiYWNrO1xyXG5leHBvcnQgY29uc3QgcmVmcmVzaEJhY2tlbmREYXRhc2V0ID0gbWFpbi5yZWZyZXNoQmFja2VuZERhdGFzZXQ7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBtYWluO1xyXG4iXX0=