import * as tslib_1 from "tslib";
/**
 * This GraphqlQueryBuilder class is a lib that already exist
 * but was causing issues with TypeScript, RequireJS and other bundler/packagers
 * and so I rewrote it in pure TypeScript.
 *
 * The previous lib can be viewed here at this Github
 * https://github.com/codemeasandwich/graphql-query-builder
 */
var GraphqlQueryBuilder = /** @class */ (function () {
    /* Constructor, query/mutator you wish to use, and an alias or filter arguments. */
    function GraphqlQueryBuilder(queryFnName, aliasOrFilter) {
        this.queryFnName = queryFnName;
        this.head = [];
        if (typeof aliasOrFilter === 'string') {
            this.alias = aliasOrFilter;
        }
        else if (typeof aliasOrFilter === 'object') {
            this.filter(aliasOrFilter);
        }
        else if (aliasOrFilter === undefined && arguments.length === 2) {
            throw new TypeError("You have passed undefined as Second argument to \"Query\"");
        }
        else if (aliasOrFilter !== undefined) {
            throw new TypeError("Second argument to \"Query\" should be an alias name(String) or filter arguments(Object). What was passed is: " + aliasOrFilter);
        }
    }
    /**
     * The parameters to run the query against.
     * @param filters An object mapping attribute to values
     */
    GraphqlQueryBuilder.prototype.filter = function (filters) {
        var e_1, _a;
        try {
            for (var _b = tslib_1.__values(Object.keys(filters)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var prop = _c.value;
                if (typeof filters[prop] === 'function') {
                    continue;
                }
                var val = this.getGraphQLValue(filters[prop]);
                if (val === '{}') {
                    continue;
                }
                this.head.push(prop + ":" + val);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return this;
    };
    /**
     * Outlines the properties you wish to be returned from the query.
     * @param properties representing each attribute you want Returned
     */
    GraphqlQueryBuilder.prototype.find = function () {
        var searches = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            searches[_i] = arguments[_i];
        }
        if (!searches || !Array.isArray(searches) || searches.length === 0) {
            throw new TypeError("find value can not be >>falsy<<");
        }
        // if its a string.. it may have other values
        // else it sould be an Object or Array of maped values
        var searchKeys = (searches.length === 1 && Array.isArray(searches[0])) ? searches[0] : searches;
        this.body = this.parceFind(searchKeys);
        return this;
    };
    /**
     * set an alias for this result.
     * @param alias
     */
    GraphqlQueryBuilder.prototype.setAlias = function (alias) {
        this.alias = alias;
    };
    /**
     * Return to the formatted query string
     * @return
     */
    GraphqlQueryBuilder.prototype.toString = function () {
        if (this.body === undefined) {
            throw new ReferenceError("return properties are not defined. use the 'find' function to defined them");
        }
        return ((this.alias) ? (this.alias + ':') : '') + " " + this.queryFnName + " " + ((this.head.length > 0) ? '(' + this.head.join(',') + ')' : '') + "  { " + this.body + " }";
    };
    // --
    // PRIVATE FUNCTIONS
    // -----------------
    GraphqlQueryBuilder.prototype.parceFind = function (_levelA) {
        var propsA = _levelA.map(function (currentValue, index) {
            var itemX = _levelA[index];
            if (itemX instanceof GraphqlQueryBuilder) {
                return itemX.toString();
            }
            else if (!Array.isArray(itemX) && typeof itemX === 'object') {
                var propsAA = Object.keys(itemX);
                if (1 !== propsAA.length) {
                    throw new RangeError("Alias objects should only have one value. was passed: " + JSON.stringify(itemX));
                }
                var propS = propsAA[0];
                var item = itemX[propS];
                if (Array.isArray(item)) {
                    return new GraphqlQueryBuilder(propS).find(item);
                }
                return propS + " : " + item + " ";
            }
            else if (typeof itemX === 'string') {
                return itemX;
            }
            else {
                throw new RangeError("cannot handle Find value of " + itemX);
            }
        });
        return propsA.join(',');
    };
    GraphqlQueryBuilder.prototype.getGraphQLValue = function (value) {
        var _this = this;
        if (typeof value === 'string') {
            value = JSON.stringify(value);
        }
        else if (Array.isArray(value)) {
            value = value.map(function (item) {
                return _this.getGraphQLValue(item);
            }).join();
            value = "[" + value + "]";
        }
        else if (value instanceof Date) {
            value = JSON.stringify(value);
        }
        else if (value !== null && typeof value === 'object') {
            value = this.objectToString(value);
        }
        return value;
    };
    GraphqlQueryBuilder.prototype.objectToString = function (obj) {
        var e_2, _a;
        var sourceA = [];
        try {
            for (var _b = tslib_1.__values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var prop = _c.value;
                if (typeof obj[prop] === 'function') {
                    continue;
                }
                sourceA.push(prop + ":" + this.getGraphQLValue(obj[prop]));
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return "{" + sourceA.join() + "}";
    };
    return GraphqlQueryBuilder;
}());
export default GraphqlQueryBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JhcGhxbFF1ZXJ5QnVpbGRlci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItc2xpY2tncmlkLyIsInNvdXJjZXMiOlsiYXBwL21vZHVsZXMvYW5ndWxhci1zbGlja2dyaWQvc2VydmljZXMvZ3JhcGhxbFF1ZXJ5QnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7R0FPRztBQUNIO0lBS0UsbUZBQW1GO0lBQ25GLDZCQUFvQixXQUFtQixFQUFFLGFBQStCO1FBQXBELGdCQUFXLEdBQVgsV0FBVyxDQUFRO1FBSnZDLFNBQUksR0FBVSxFQUFFLENBQUM7UUFLZixJQUFJLE9BQU8sYUFBYSxLQUFLLFFBQVEsRUFBRTtZQUNyQyxJQUFJLENBQUMsS0FBSyxHQUFHLGFBQWEsQ0FBQztTQUM1QjthQUFNLElBQUksT0FBTyxhQUFhLEtBQUssUUFBUSxFQUFFO1lBQzVDLElBQUksQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUM7U0FDNUI7YUFBTSxJQUFJLGFBQWEsS0FBSyxTQUFTLElBQUksU0FBUyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDaEUsTUFBTSxJQUFJLFNBQVMsQ0FBQywyREFBeUQsQ0FBQyxDQUFDO1NBQ2hGO2FBQU0sSUFBSSxhQUFhLEtBQUssU0FBUyxFQUFFO1lBQ3RDLE1BQU0sSUFBSSxTQUFTLENBQUMsbUhBQStHLGFBQWUsQ0FBQyxDQUFDO1NBQ3JKO0lBQ0gsQ0FBQztJQUVEOzs7T0FHRztJQUNILG9DQUFNLEdBQU4sVUFBTyxPQUFZOzs7WUFDakIsS0FBbUIsSUFBQSxLQUFBLGlCQUFBLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUEsZ0JBQUEsNEJBQUU7Z0JBQXBDLElBQU0sSUFBSSxXQUFBO2dCQUNiLElBQUksT0FBTyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssVUFBVSxFQUFFO29CQUN2QyxTQUFTO2lCQUNWO2dCQUNELElBQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxl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Q0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDcEM7UUFDRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFTyw0Q0FBYyxHQUF0QixVQUF1QixHQUFROztRQUM3QixJQUFNLE9BQU8sR0FBRyxFQUFFLENBQUM7O1lBRW5CLEtBQW1CLElBQUEsS0FBQSxpQkFBQSxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFBLGdCQUFBLDRCQUFFO2dCQUFoQyxJQUFNLElBQUksV0FBQTtnQkFDYixJQUFJLE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLFVBQVUsRUFBRTtvQkFDbkMsU0FBUztpQkFDVjtnQkFDRCxPQUFPLENBQUMsSUFBSSxDQUFJLElBQUksU0FBSSxJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBRyxDQUFDLENBQUM7YUFDNUQ7Ozs7Ozs7OztRQUNELE9BQU8sTUFBSSxPQUFPLENBQUMsSUFBSSxFQUFFLE1BQUcsQ0FBQztJQUMvQixDQUFDO0lBQ0gsMEJBQUM7QUFBRCxDQUFDLEFBbElELElBa0lDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFRoaXMgR3JhcGhxbFF1ZXJ5QnVpbGRlciBjbGFzcyBpcyBhIGxpYiB0aGF0IGFscmVhZHkgZXhpc3RcclxuICogYnV0IHdhcyBjYXVzaW5nIGlzc3VlcyB3aXRoIFR5cGVTY3JpcHQsIFJlcXVpcmVKUyBhbmQgb3RoZXIgYnVuZGxlci9wYWNrYWdlcnNcclxuICogYW5kIHNvIEkgcmV3cm90ZSBpdCBpbiBwdXJlIFR5cGVTY3JpcHQuXHJcbiAqXHJcbiAqIFRoZSBwcmV2aW91cyBsaWIgY2FuIGJlIHZpZXdlZCBoZXJlIGF0IHRoaXMgR2l0aHViXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWVhc2FuZHdpY2gvZ3JhcGhxbC1xdWVyeS1idWlsZGVyXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmFwaHFsUXVlcnlCdWlsZGVyIHtcclxuICBhbGlhczogc3RyaW5nIHwgRnVuY3Rpb247XHJcbiAgaGVhZDogYW55W10gPSBbXTtcclxuICBib2R5OiBhbnk7XHJcblxyXG4gIC8qIENvbnN0cnVjdG9yLCBxdWVyeS9tdXRhdG9yIHlvdSB3aXNoIHRvIHVzZSwgYW5kIGFuIGFsaWFzIG9yIGZpbHRlciBhcmd1bWVudHMuICovXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBxdWVyeUZuTmFtZTogc3RyaW5nLCBhbGlhc09yRmlsdGVyPzogc3RyaW5nIHwgb2JqZWN0KSB7XHJcbiAgICBpZiAodHlwZW9mIGFsaWFzT3JGaWx0ZXIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHRoaXMuYWxpYXMgPSBhbGlhc09yRmlsdGVyO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYWxpYXNPckZpbHRlciA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgdGhpcy5maWx0ZXIoYWxpYXNPckZpbHRlcik7XHJcbiAgICB9IGVsc2UgaWYgKGFsaWFzT3JGaWx0ZXIgPT09IHVuZGVmaW5lZCAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFlvdSBoYXZlIHBhc3NlZCB1bmRlZmluZWQgYXMgU2Vjb25kIGFyZ3VtZW50IHRvIFwiUXVlcnlcImApO1xyXG4gICAgfSBlbHNlIGlmIChhbGlhc09yRmlsdGVyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgU2Vjb25kIGFyZ3VtZW50IHRvIFwiUXVlcnlcIiBzaG91bGQgYmUgYW4gYWxpYXMgbmFtZShTdHJpbmcpIG9yIGZpbHRlciBhcmd1bWVudHMoT2JqZWN0KS4gV2hhdCB3YXMgcGFzc2VkIGlzOiAke2FsaWFzT3JGaWx0ZXJ9YCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgcGFyYW1ldGVycyB0byBydW4gdGhlIHF1ZXJ5IGFnYWluc3QuXHJcbiAgICogQHBhcmFtIGZpbHRlcnMgQW4gb2JqZWN0IG1hcHBpbmcgYXR0cmlidXRlIHRvIHZhbHVlc1xyXG4gICAqL1xyXG4gIGZpbHRlcihmaWx0ZXJzOiBhbnkpIHtcclxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBPYmplY3Qua2V5cyhmaWx0ZXJzKSkge1xyXG4gICAgICBpZiAodHlwZW9mIGZpbHRlcnNbcHJvcF0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCB2YWwgPSB0aGlzLmdldEdyYXBoUUxWYWx1ZShmaWx0ZXJzW3Byb3BdKTtcclxuICAgICAgaWYgKHZhbCA9PT0gJ3t9Jykge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuaGVhZC5wdXNoKGAke3Byb3B9OiR7dmFsfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPdXRsaW5lcyB0aGUgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBiZSByZXR1cm5lZCBmcm9tIHRoZSBxdWVyeS5cclxuICAgKiBAcGFyYW0gcHJvcGVydGllcyByZXByZXNlbnRpbmcgZWFjaCBhdHRyaWJ1dGUgeW91IHdhbnQgUmV0dXJuZWRcclxuICAgKi9cclxuICBmaW5kKC4uLnNlYXJjaGVzOiBhbnlbXSkgeyAvLyBUSElTIE5FRUQgVE8gQkUgQSBcIkZVTkNUSU9OXCIgdG8gc2NvcGUgJ2FyZ3VtZW50cydcclxuICAgIGlmICghc2VhcmNoZXMgfHwgIUFycmF5LmlzQXJyYXkoc2VhcmNoZXMpIHx8IHNlYXJjaGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBmaW5kIHZhbHVlIGNhbiBub3QgYmUgPj5mYWxzeTw8YCk7XHJcbiAgICB9XHJcbiAgICAvLyBpZiBpdHMgYSBzdHJpbmcuLiBpdCBtYXkgaGF2ZSBvdGhlciB2YWx1ZXNcclxuICAgIC8vIGVsc2UgaXQgc291bGQgYmUgYW4gT2JqZWN0IG9yIEFycmF5IG9mIG1hcGVkIHZhbHVlc1xyXG4gICAgY29uc3Qgc2VhcmNoS2V5cyA9IChzZWFyY2hlcy5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShzZWFyY2hlc1swXSkpID8gc2VhcmNoZXNbMF0gOiBzZWFyY2hlcztcclxuICAgIHRoaXMuYm9keSA9IHRoaXMucGFyY2VGaW5kKHNlYXJjaEtleXMpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBzZXQgYW4gYWxpYXMgZm9yIHRoaXMgcmVzdWx0LlxyXG4gICAqIEBwYXJhbSBhbGlhc1xyXG4gICAqL1xyXG4gIHNldEFsaWFzKGFsaWFzOiBzdHJpbmcpIHtcclxuICAgIHRoaXMuYWxpYXMgPSBhbGlhcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiB0byB0aGUgZm9ybWF0dGVkIHF1ZXJ5IHN0cmluZ1xyXG4gICAqIEByZXR1cm5cclxuICAgKi9cclxuICB0b1N0cmluZygpIHtcclxuICAgIGlmICh0aGlzLmJvZHkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoYHJldHVybiBwcm9wZXJ0aWVzIGFyZSBub3QgZGVmaW5lZC4gdXNlIHRoZSAnZmluZCcgZnVuY3Rpb24gdG8gZGVmaW5lZCB0aGVtYCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGAkeyh0aGlzLmFsaWFzKSA/ICh0aGlzLmFsaWFzICsgJzonKSA6ICcnfSAke3RoaXMucXVlcnlGbk5hbWV9ICR7KHRoaXMuaGVhZC5sZW5ndGggPiAwKSA/ICcoJyArIHRoaXMuaGVhZC5qb2luKCcsJykgKyAnKScgOiAnJ30gIHsgJHt0aGlzLmJvZHl9IH1gO1xyXG4gIH1cclxuXHJcbiAgLy8gLS1cclxuICAvLyBQUklWQVRFIEZVTkNUSU9OU1xyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIHByaXZhdGUgcGFyY2VGaW5kKF9sZXZlbEE6IGFueVtdKSB7XHJcbiAgICBjb25zdCBwcm9wc0EgPSBfbGV2ZWxBLm1hcCgoY3VycmVudFZhbHVlLCBpbmRleCkgPT4ge1xyXG4gICAgICBjb25zdCBpdGVtWCA9IF9sZXZlbEFbaW5kZXhdO1xyXG5cclxuICAgICAgaWYgKGl0ZW1YIGluc3RhbmNlb2YgR3JhcGhxbFF1ZXJ5QnVpbGRlcikge1xyXG4gICAgICAgIHJldHVybiBpdGVtWC50b1N0cmluZygpO1xyXG4gICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1YKSAmJiB0eXBlb2YgaXRlbVggPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgY29uc3QgcHJvcHNBQSA9IE9iamVjdC5rZXlzKGl0ZW1YKTtcclxuICAgICAgICBpZiAoMSAhPT0gcHJvcHNBQS5sZW5ndGgpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBBbGlhcyBvYmplY3RzIHNob3VsZCBvbmx5IGhhdmUgb25lIHZhbHVlLiB3YXMgcGFzc2VkOiAke0pTT04uc3RyaW5naWZ5KGl0ZW1YKX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcHJvcFMgPSBwcm9wc0FBWzBdO1xyXG4gICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtWFtwcm9wU107XHJcblxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XHJcbiAgICAgICAgICByZXR1cm4gbmV3IEdyYXBocWxRdWVyeUJ1aWxkZXIocHJvcFMpLmZpbmQoaXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBgJHtwcm9wU30gOiAke2l0ZW19IGA7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW1YID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBpdGVtWDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgY2Fubm90IGhhbmRsZSBGaW5kIHZhbHVlIG9mICR7aXRlbVh9YCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBwcm9wc0Euam9pbignLCcpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBnZXRHcmFwaFFMVmFsdWUodmFsdWU6IGFueSkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XHJcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgIHZhbHVlID0gdmFsdWUubWFwKGl0ZW0gPT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEdyYXBoUUxWYWx1ZShpdGVtKTtcclxuICAgICAgfSkuam9pbigpO1xyXG4gICAgICB2YWx1ZSA9IGBbJHt2YWx1ZX1dYDtcclxuICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xyXG4gICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHZhbHVlID0gdGhpcy5vYmplY3RUb1N0cmluZyh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIG9iamVjdFRvU3RyaW5nKG9iajogYW55KSB7XHJcbiAgICBjb25zdCBzb3VyY2VBID0gW107XHJcblxyXG4gICAgZm9yIChjb25zdCBwcm9wIG9mIE9iamVjdC5rZXlzKG9iaikpIHtcclxuICAgICAgaWYgKHR5cGVvZiBvYmpbcHJvcF0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICBzb3VyY2VBLnB1c2goYCR7cHJvcH06JHt0aGlzLmdldEdyYXBoUUxWYWx1ZShvYmpbcHJvcF0pfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGB7JHtzb3VyY2VBLmpvaW4oKX19YDtcclxuICB9XHJcbn1cclxuIl19