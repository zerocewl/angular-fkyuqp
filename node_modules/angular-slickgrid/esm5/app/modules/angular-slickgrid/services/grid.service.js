import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { ExtensionService } from './extension.service';
import { FilterService } from './filter.service';
import { GridStateService } from './gridState.service';
import { SortService } from './sort.service';
import { Subject } from 'rxjs';
var highlightTimerEnd;
var GridServiceDeleteOptionDefaults = { triggerEvent: true };
var GridServiceInsertOptionDefaults = { highlightRow: true, position: 'top', resortGrid: false, selectRow: false, triggerEvent: true };
var GridServiceUpdateOptionDefaults = { highlightRow: true, selectRow: false, scrollRowIntoView: false, triggerEvent: true };
var GridService = /** @class */ (function () {
    function GridService(extensionService, filterService, gridStateService, sortService) {
        this.extensionService = extensionService;
        this.filterService = filterService;
        this.gridStateService = gridStateService;
        this.sortService = sortService;
        this.onItemAdded = new Subject();
        this.onItemDeleted = new Subject();
        this.onItemUpdated = new Subject();
        this.onItemUpserted = new Subject();
    }
    Object.defineProperty(GridService.prototype, "_gridOptions", {
        /** Getter for the Grid Options pulled through the Grid Object */
        get: function () {
            return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
        },
        enumerable: true,
        configurable: true
    });
    GridService.prototype.init = function (grid, dataView) {
        this._grid = grid;
        this._dataView = dataView;
    };
    /** Clear all Filters & Sorts */
    GridService.prototype.clearAllFiltersAndSorts = function () {
        // call both clear Filters & Sort but only trigger the last one to avoid sending multiple backend queries
        if (this.sortService && this.sortService.clearSorting) {
            this.sortService.clearSorting(false); // skip event trigger on this one
        }
        if (this.filterService && this.filterService.clearFilters) {
            this.filterService.clearFilters();
        }
    };
    /**
     * From a SlickGrid Event triggered get the Column Definition and Item Data Context
     *
     * For example the SlickGrid onClick will return cell arguments when subscribing to it.
     * From these cellArgs, we want to get the Column Definition and Item Data
     * @param cell event args
     * @return object with columnDef and dataContext
     */
    GridService.prototype.getColumnFromEventArguments = function (args) {
        if (!args || !args.grid || !args.grid.getColumns || !args.grid.getDataItem) {
            throw new Error('To get the column definition and data, we need to have these arguments passed as objects (row, cell, grid)');
        }
        return {
            row: args.row,
            cell: args.cell,
            columnDef: args.grid.getColumns()[args.cell],
            dataContext: args.grid.getDataItem(args.row),
            dataView: this._dataView,
            grid: this._grid
        };
    };
    /** Get data item by it's row index number */
    GridService.prototype.getDataItemByRowNumber = function (rowNumber) {
        if (!this._grid || typeof this._grid.getDataItem !== 'function') {
            throw new Error("We could not find SlickGrid Grid object or it's \"getDataItem\" method");
        }
        return this._grid.getDataItem(rowNumber);
    };
    /** Chain the item Metadata with our implementation of Metadata at given row index */
    GridService.prototype.getItemRowMetadataToHighlight = function (previousItemMetadata) {
        var _this = this;
        return function (rowNumber) {
            var item = _this._dataView.getItem(rowNumber);
            var meta = { cssClasses: '' };
            if (typeof previousItemMetadata === 'function') {
                meta = previousItemMetadata(rowNumber);
            }
            if (!meta) {
                meta = { cssClasses: '' };
            }
            if (item && item._dirty) {
                meta.cssClasses = (meta && meta.cssClasses || '') + ' dirty';
            }
            if (item && item.rowClass && meta) {
                meta.cssClasses += " " + item.rowClass;
                meta.cssClasses += " row" + rowNumber;
            }
            return meta;
        };
    };
    /**
     * Highlight then fade a row for x seconds.
     * The implementation follows this SO answer: https://stackoverflow.com/a/19985148/1212166
     * @param rowNumber
     * @param fadeDelay
     */
    GridService.prototype.highlightRow = function (rowNumber, fadeDelay, fadeOutDelay) {
        var _this = this;
        if (fadeDelay === void 0) { fadeDelay = 1500; }
        if (fadeOutDelay === void 0) { fadeOutDelay = 300; }
        // create a SelectionModel if there's not one yet
        if (!this._grid.getSelectionModel() && Slick && Slick.RowSelectionModel) {
            var rowSelectionPlugin = new Slick.RowSelectionModel(this._gridOptions.rowSelectionOptions || {});
            this._grid.setSelectionModel(rowSelectionPlugin);
        }
        if (Array.isArray(rowNumber)) {
            rowNumber.forEach(function (row) { return _this.highlightRowByMetadata(row, fadeDelay, fadeOutDelay); });
        }
        else {
            this.highlightRowByMetadata(rowNumber, fadeDelay, fadeOutDelay);
        }
    };
    GridService.prototype.highlightRowByMetadata = function (rowNumber, fadeDelay, fadeOutDelay) {
        var _this = this;
        if (fadeDelay === void 0) { fadeDelay = 1500; }
        if (fadeOutDelay === void 0) { fadeOutDelay = 300; }
        this._dataView.getItemMetadata = this.getItemRowMetadataToHighlight(this._dataView.getItemMetadata);
        var item = this._dataView.getItem(rowNumber);
        if (item && item.id) {
            item.rowClass = 'highlight';
            this._dataView.updateItem(item.id, item);
            this.renderGrid();
            // fade out
            clearTimeout(highlightTimerEnd);
            highlightTimerEnd = setTimeout(function () {
                item.rowClass = 'highlight-end';
                _this._dataView.updateItem(item.id, item);
                _this.renderGrid();
            }, fadeOutDelay);
            // delete the row's CSS highlight classes once the delay is passed
            setTimeout(function () {
                if (item && item.id) {
                    delete item.rowClass;
                    if (_this._dataView.getIdxById(item.id) !== undefined) {
                        _this._dataView.updateItem(item.id, item);
                        _this.renderGrid();
                    }
                }
            }, fadeDelay + fadeOutDelay);
        }
    };
    /** Get the Data Item from a grid row index */
    GridService.prototype.getDataItemByRowIndex = function (index) {
        if (!this._grid || typeof this._grid.getDataItem !== 'function') {
            throw new Error('We could not find SlickGrid Grid object and/or "getDataItem" method');
        }
        return this._grid.getDataItem(index);
    };
    /** Get the Data Item from an array of grid row indexes */
    GridService.prototype.getDataItemByRowIndexes = function (indexes) {
        var _this = this;
        if (!this._grid || typeof this._grid.getDataItem !== 'function') {
            throw new Error('We could not find SlickGrid Grid object and/or "getDataItem" method');
        }
        var dataItems = [];
        if (Array.isArray(indexes)) {
            indexes.forEach(function (idx) {
                dataItems.push(_this._grid.getDataItem(idx));
            });
        }
        return dataItems;
    };
    /** Get the currently selected row indexes */
    GridService.prototype.getSelectedRows = function () {
        if (!this._grid || typeof this._grid.getSelectedRows !== 'function') {
            throw new Error('We could not find SlickGrid Grid object and/or "getSelectedRows" method');
        }
        return this._grid.getSelectedRows();
    };
    /** Get the currently selected rows item data */
    GridService.prototype.getSelectedRowsDataItem = function () {
        if (!this._grid || typeof this._grid.getSelectedRows !== 'function') {
            throw new Error('We could not find SlickGrid Grid object and/or "getSelectedRows" method');
        }
        var selectedRowIndexes = this._grid.getSelectedRows();
        return this.getDataItemByRowIndexes(selectedRowIndexes);
    };
    /** Select the selected row by a row index */
    GridService.prototype.setSelectedRow = function (rowIndex) {
        if (this._grid && this._grid.setSelectedRows) {
            this._grid.setSelectedRows([rowIndex]);
        }
    };
    /** Set selected rows with provided array of row indexes */
    GridService.prototype.setSelectedRows = function (rowIndexes) {
        if (this._grid && this._grid.setSelectedRows) {
            this._grid.setSelectedRows(rowIndexes);
        }
    };
    /** Re-Render the Grid */
    GridService.prototype.renderGrid = function () {
        if (this._grid && typeof this._grid.invalidate === 'function') {
            this._grid.invalidate();
            this._grid.render();
        }
    };
    /**
     * Reset the grid to it's original state (clear any filters, sorting & pagination if exists) .
     * The column definitions could be passed as argument to reset (this can be used after a Grid State reset)
     * The reset will clear the Filters & Sort, then will reset the Columns to their original state
     */
    GridService.prototype.resetGrid = function (columnDefinitions) {
        // reset columns to original states & refresh the grid
        if (this._grid && this._dataView) {
            var originalColumns = this.extensionService.getAllColumns();
            if (Array.isArray(originalColumns) && originalColumns.length > 0) {
                // set the grid columns to it's original column definitions
                this._grid.setColumns(originalColumns);
                if (this._gridOptions && this._gridOptions.enableAutoSizeColumns) {
                    this._grid.autosizeColumns();
                }
                this.gridStateService.resetColumns(columnDefinitions);
            }
        }
        if (this.filterService && this.filterService.clearFilters) {
            this.filterService.clearFilters();
        }
        if (this.sortService && this.sortService.clearSorting) {
            this.sortService.clearSorting();
        }
    };
    /** @deprecated please use "addItem" method instead */
    GridService.prototype.addItemToDatagrid = function (item, shouldHighlightRow, shouldResortGrid, shouldTriggerEvent, shouldSelectRow) {
        if (shouldHighlightRow === void 0) { shouldHighlightRow = true; }
        if (shouldResortGrid === void 0) { shouldResortGrid = false; }
        if (shouldTriggerEvent === void 0) { shouldTriggerEvent = true; }
        if (shouldSelectRow === void 0) { shouldSelectRow = true; }
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "addItem" method since "addItemToDatagrid" will be deprecated in the future.');
        return this.addItem(item, { highlightRow: shouldHighlightRow, resortGrid: shouldResortGrid, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });
    };
    /** @deprecated please use "addItems" method instead */
    GridService.prototype.addItemsToDatagrid = function (items, shouldHighlightRow, shouldResortGrid, shouldTriggerEvent, shouldSelectRow) {
        if (shouldHighlightRow === void 0) { shouldHighlightRow = true; }
        if (shouldResortGrid === void 0) { shouldResortGrid = false; }
        if (shouldTriggerEvent === void 0) { shouldTriggerEvent = true; }
        if (shouldSelectRow === void 0) { shouldSelectRow = true; }
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "addItems" method since "addItemsToDatagrid" will be deprecated in the future.');
        return this.addItems(items, { highlightRow: shouldHighlightRow, resortGrid: shouldResortGrid, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });
    };
    /**
     * Add an item (data item) to the datagrid, by default it will highlight (flashing) the inserted row but we can disable it too
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
     * @return rowIndex: typically index 0 when adding to position "top" or a different number when adding to the "bottom"
     */
    GridService.prototype.addItem = function (item, options) {
        options = tslib_1.__assign({}, GridServiceInsertOptionDefaults, options);
        if (!this._grid || !this._gridOptions || !this._dataView) {
            throw new Error('We could not find SlickGrid Grid, DataView objects');
        }
        if (!item || !item.hasOwnProperty('id')) {
            throw new Error("Adding an item requires the item to include an \"id\" property");
        }
        // insert position top/bottom, defaults to top
        // when position is top we'll call insert at index 0, else call addItem which just push to the DataView array
        if (options && options.position === 'bottom') {
            this._dataView.addItem(item);
        }
        else {
            this._dataView.insertItem(0, item); // insert at index 0
        }
        // row number in the grid, by default it will be on first row (top is the default)
        var rowNumber = 0;
        // do we want the item to be sorted in the grid, when set to False it will insert on first row (defaults to false)
        if (options.resortGrid) {
            this._dataView.reSort();
            // find the row number in the grid and if user wanted to see highlighted row
            // we need to do it here after resort and get each row number because it possibly changes after the sort
            rowNumber = this._dataView.getRowById(item.id);
        }
        else {
            // scroll to row index 0 when inserting on top else scroll to the bottom where it got inserted
            rowNumber = (options && options.position === 'bottom') ? this._dataView.getRowById(item.id) : 0;
            this._grid.scrollRowIntoView(rowNumber);
        }
        // if highlight is enabled, we'll highlight the row we just added
        if (options.highlightRow) {
            this.highlightRow(rowNumber);
        }
        // if row selection (checkbox selector) is enabled, we'll select the row in the grid
        if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
            this.setSelectedRow(rowNumber);
        }
        // do we want to trigger an event after adding the item
        if (options.triggerEvent) {
            this.onItemAdded.next(item);
        }
        return rowNumber;
    };
    /**
     * Add item array (data item) to the datagrid, by default it will highlight (flashing) the inserted row but we can disable it too
     * @param item object arrays, which must contain unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
     */
    GridService.prototype.addItems = function (items, options) {
        var _this = this;
        options = tslib_1.__assign({}, GridServiceInsertOptionDefaults, options);
        var rowNumbers = [];
        // loop through all items to add
        if (!Array.isArray(items)) {
            return [this.addItem(items, options)];
        }
        else {
            items.forEach(function (item) { return _this.addItem(item, tslib_1.__assign({}, options, { highlightRow: false, resortGrid: false, triggerEvent: false, selectRow: false })); });
        }
        // do we want the item to be sorted in the grid, when set to False it will insert on first row (defaults to false)
        if (options.resortGrid) {
            this._dataView.reSort();
        }
        // scroll to row index 0 when inserting on top else scroll to the bottom where it got inserted
        (options && options.position === 'bottom') ? this._grid.navigateBottom() : this._grid.navigateTop();
        // get row numbers of all new inserted items
        // we need to do it after resort and get each row number because it possibly changed after the sort
        items.forEach(function (item) { return rowNumbers.push(_this._dataView.getRowById(item.id)); });
        // if user wanted to see highlighted row
        if (options.highlightRow) {
            this.highlightRow(rowNumbers);
        }
        // select the row in the grid
        if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
            this.setSelectedRows(rowNumbers);
        }
        // do we want to trigger an event after adding the item
        if (options.triggerEvent) {
            this.onItemAdded.next(items);
        }
        return rowNumbers;
    };
    /** @deprecated please use "deleteItem" method instead */
    GridService.prototype.deleteDataGridItem = function (item, shouldTriggerEvent) {
        if (shouldTriggerEvent === void 0) { shouldTriggerEvent = true; }
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "deleteItem" method since "deleteDataGridItem" will be deprecated in the future.');
        this.deleteItem(item, { triggerEvent: shouldTriggerEvent });
    };
    /** @deprecated please use "deleteItems" method instead */
    GridService.prototype.deleteDataGridItems = function (items, shouldTriggerEvent) {
        if (shouldTriggerEvent === void 0) { shouldTriggerEvent = true; }
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "deleteItems" method since "deleteDataGridItems" will be deprecated in the future.');
        this.deleteItems(items, { triggerEvent: shouldTriggerEvent });
    };
    /** @deprecated please use "deleteItemById" method instead */
    GridService.prototype.deleteDataGridItemById = function (itemId, shouldTriggerEvent) {
        if (shouldTriggerEvent === void 0) { shouldTriggerEvent = true; }
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "deleteItemById" method since "deleteDataGridItemById" will be deprecated in the future.');
        this.deleteItemById(itemId, { triggerEvent: shouldTriggerEvent });
    };
    /** @deprecated please use "deleteItemByIds" method instead */
    GridService.prototype.deleteDataGridItemByIds = function (itemIds, shouldTriggerEvent) {
        if (shouldTriggerEvent === void 0) { shouldTriggerEvent = true; }
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "deleteItemByIds" method since "deleteDataGridItemByIds" will be deprecated in the future.');
        this.deleteItemByIds(itemIds, { triggerEvent: shouldTriggerEvent });
    };
    /**
     * Delete an existing item from the datagrid (dataView)
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (triggerEvent)
     * @return item id deleted
     */
    GridService.prototype.deleteItem = function (item, options) {
        options = tslib_1.__assign({}, GridServiceDeleteOptionDefaults, options);
        if (!item || !item.hasOwnProperty('id')) {
            throw new Error("Deleting an item requires the item to include an \"id\" property");
        }
        return this.deleteItemById(item.id, options);
    };
    /**
     * Delete an array of existing items from the datagrid
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (triggerEvent)
     * @return item id deleted
     */
    GridService.prototype.deleteItems = function (items, options) {
        var _this = this;
        options = tslib_1.__assign({}, GridServiceDeleteOptionDefaults, options);
        // when it's not an array, we can call directly the single item delete
        if (!Array.isArray(items)) {
            this.deleteItem(items, options);
            return [items.id];
        }
        var itemIds = [];
        items.forEach(function (item) {
            if (item && item.id !== undefined) {
                itemIds.push(item.id);
            }
            _this.deleteItem(item, tslib_1.__assign({}, options, { triggerEvent: false }));
        });
        // do we want to trigger an event after deleting the item
        if (options.triggerEvent) {
            this.onItemDeleted.next(items);
        }
        return itemIds;
    };
    /**
     * Delete an existing item from the datagrid (dataView) by it's id
     * @param itemId: item unique id
     * @param options: provide the possibility to do certain actions after or during the upsert (triggerEvent)
     * @return item id deleted
     */
    GridService.prototype.deleteItemById = function (itemId, options) {
        options = tslib_1.__assign({}, GridServiceDeleteOptionDefaults, options);
        if (itemId === null || itemId === undefined) {
            throw new Error("Cannot delete a row without a valid \"id\"");
        }
        // when user has row selection enabled, we should clear any selection to avoid confusion after a delete
        var isSyncGridSelectionEnabled = this.gridStateService && this.gridStateService.needToPreserveRowSelection() || false;
        if (!isSyncGridSelectionEnabled && this._grid && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
            this.setSelectedRows([]);
        }
        // delete the item from the dataView
        this._dataView.deleteItem(itemId);
        // do we want to trigger an event after deleting the item
        if (options.triggerEvent) {
            this.onItemDeleted.next(itemId);
        }
        return itemId;
    };
    /**
     * Delete an array of existing items from the datagrid
     * @param itemIds array of item unique IDs
     * @param options: provide the possibility to do certain actions after or during the upsert (triggerEvent)
     */
    GridService.prototype.deleteItemByIds = function (itemIds, options) {
        options = tslib_1.__assign({}, GridServiceDeleteOptionDefaults, options);
        // when it's not an array, we can call directly the single item delete
        if (Array.isArray(itemIds)) {
            for (var i = 0; i < itemIds.length; i++) {
                if (itemIds[i] !== null) {
                    this.deleteItemById(itemIds[i], { triggerEvent: false });
                }
            }
            // do we want to trigger an event after deleting the item
            if (options.triggerEvent) {
                this.onItemDeleted.next(itemIds);
            }
            return itemIds;
        }
        return [];
    };
    /** @deprecated please use "updateItem" method instead */
    GridService.prototype.updateDataGridItem = function (item, shouldHighlightRow, shouldTriggerEvent, shouldSelectRow) {
        if (shouldHighlightRow === void 0) { shouldHighlightRow = true; }
        if (shouldTriggerEvent === void 0) { shouldTriggerEvent = true; }
        if (shouldSelectRow === void 0) { shouldSelectRow = true; }
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "updateItem" method since "updateDataGridItem" will be deprecated in the future.');
        return this.updateItem(item, { highlightRow: shouldHighlightRow, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });
    };
    /** @deprecated please use "updateItems" method instead */
    GridService.prototype.updateDataGridItems = function (items, shouldHighlightRow, shouldTriggerEvent, shouldSelectRow) {
        if (shouldHighlightRow === void 0) { shouldHighlightRow = true; }
        if (shouldTriggerEvent === void 0) { shouldTriggerEvent = true; }
        if (shouldSelectRow === void 0) { shouldSelectRow = true; }
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "updateItems" method since "updateDataGridItems" will be deprecated in the future.');
        return this.updateItems(items, { highlightRow: shouldHighlightRow, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });
    };
    /** @deprecated please use "updateItemById" method instead */
    GridService.prototype.updateDataGridItemById = function (itemId, item, shouldHighlightRow, shouldTriggerEvent, shouldSelectRow) {
        if (shouldHighlightRow === void 0) { shouldHighlightRow = true; }
        if (shouldTriggerEvent === void 0) { shouldTriggerEvent = true; }
        if (shouldSelectRow === void 0) { shouldSelectRow = true; }
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "updateItemById" method since "updateDataGridItemById" will be deprecated in the future.');
        return this.updateItemById(itemId, item, { highlightRow: shouldHighlightRow, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });
    };
    /**
     * Update an existing item with new properties inside the datagrid
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, selectRow, triggerEvent)
     * @return grid row index
     */
    GridService.prototype.updateItem = function (item, options) {
        options = tslib_1.__assign({}, GridServiceUpdateOptionDefaults, options);
        var itemId = (!item || !item.hasOwnProperty('id')) ? undefined : item.id;
        if (itemId === undefined) {
            throw new Error("Calling Update of an item requires the item to include an \"id\" property");
        }
        return this.updateItemById(itemId, item, options);
    };
    /**
     * Update an array of existing items with new properties inside the datagrid
     * @param item object arrays, which must contain unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, selectRow, triggerEvent)
     * @return grid row indexes
     */
    GridService.prototype.updateItems = function (items, options) {
        var _this = this;
        options = tslib_1.__assign({}, GridServiceUpdateOptionDefaults, options);
        // when it's not an array, we can call directly the single item update
        if (!Array.isArray(items)) {
            return [this.updateItem(items, options)];
        }
        var gridRowNumbers = [];
        items.forEach(function (item) {
            gridRowNumbers.push(_this.updateItem(item, tslib_1.__assign({}, options, { highlightRow: false, selectRow: false, triggerEvent: false })));
        });
        // only highlight at the end, all at once
        // we have to do this because doing highlight 1 by 1 would only re-select the last highlighted row which is wrong behavior
        if (options.highlightRow) {
            this.highlightRow(gridRowNumbers);
        }
        // select the row in the grid
        if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
            this.setSelectedRows(gridRowNumbers);
        }
        // do we want to trigger an event after updating the item
        if (options.triggerEvent) {
            this.onItemUpdated.next(items);
        }
        return gridRowNumbers;
    };
    /**
     * Update an existing item in the datagrid by it's id and new properties
     * @param itemId: item unique id
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, selectRow, triggerEvent)
     * @return grid row number
     */
    GridService.prototype.updateItemById = function (itemId, item, options) {
        options = tslib_1.__assign({}, GridServiceUpdateOptionDefaults, options);
        if (itemId === undefined) {
            throw new Error("Cannot update a row without a valid \"id\"");
        }
        var rowNumber = this._dataView.getRowById(itemId);
        if (!item || rowNumber === undefined) {
            throw new Error("The item to update in the grid was not found with id: " + itemId);
        }
        if (this._dataView.getIdxById(itemId) !== undefined) {
            // Update the item itself inside the dataView
            this._dataView.updateItem(itemId, item);
            this._grid.updateRow(rowNumber);
            // do we want to scroll to the row so that it shows in the Viewport (UI)
            if (options.scrollRowIntoView) {
                this._grid.scrollRowIntoView(rowNumber);
            }
            // highlight the row we just updated, if defined
            if (options.highlightRow) {
                this.highlightRow(rowNumber);
            }
            // select the row in the grid
            if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
                this.setSelectedRow(rowNumber);
            }
            // do we want to trigger an event after updating the item
            if (options.triggerEvent) {
                this.onItemUpdated.next(item);
            }
        }
        return rowNumber;
    };
    /**
     * Insert a row into the grid if it doesn't already exist or update if it does.
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
     */
    GridService.prototype.upsertItem = function (item, options) {
        options = tslib_1.__assign({}, GridServiceInsertOptionDefaults, options);
        var itemId = (!item || !item.hasOwnProperty('id')) ? undefined : item.id;
        if (itemId === undefined) {
            throw new Error("Calling Upsert of an item requires the item to include an \"id\" property");
        }
        return this.upsertItemById(itemId, item, options);
    };
    /**
     * Update an array of existing items with new properties inside the datagrid
     * @param item object arrays, which must contain unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
     * @return row numbers in the grid
     */
    GridService.prototype.upsertItems = function (items, options) {
        var _this = this;
        options = tslib_1.__assign({}, GridServiceInsertOptionDefaults, options);
        // when it's not an array, we can call directly the single item update
        if (!Array.isArray(items)) {
            return [this.upsertItem(items, options)];
        }
        var upsertedRows = [];
        items.forEach(function (item) {
            upsertedRows.push(_this.upsertItem(item, tslib_1.__assign({}, options, { highlightRow: false, resortGrid: false, selectRow: false, triggerEvent: false })));
        });
        var rowNumbers = upsertedRows.map(function (upsertRow) { return upsertRow.added !== undefined ? upsertRow.added : upsertRow.updated; });
        // only highlight at the end, all at once
        // we have to do this because doing highlight 1 by 1 would only re-select the last highlighted row which is wrong behavior
        if (options.highlightRow) {
            this.highlightRow(rowNumbers);
        }
        // select the row in the grid
        if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
            this.setSelectedRows(rowNumbers);
        }
        // do we want to trigger an event after updating the item
        if (options.triggerEvent) {
            this.onItemUpserted.next(items);
            var addedItems = upsertedRows.filter(function (upsertRow) { return upsertRow.added !== undefined; });
            if (Array.isArray(addedItems) && addedItems.length > 0) {
                this.onItemAdded.next(addedItems);
            }
            var updatedItems = upsertedRows.filter(function (upsertRow) { return upsertRow.updated !== undefined; });
            if (Array.isArray(updatedItems) && updatedItems.length > 0) {
                this.onItemUpdated.next(updatedItems);
            }
        }
        return upsertedRows;
    };
    /**
     * Update an existing item in the datagrid by it's id and new properties
     * @param itemId: item unique id
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
     * @return grid row number in the grid
     */
    GridService.prototype.upsertItemById = function (itemId, item, options) {
        var isItemAdded = false;
        options = tslib_1.__assign({}, GridServiceInsertOptionDefaults, options);
        if (itemId === undefined) {
            throw new Error("Calling Upsert of an item requires the item to include a valid and unique \"id\" property");
        }
        var rowNumberAdded;
        var rowNumberUpdated;
        if (this._dataView.getRowById(itemId) === undefined) {
            rowNumberAdded = this.addItem(item, options);
            isItemAdded = true;
        }
        else {
            rowNumberUpdated = this.updateItem(item, { highlightRow: options.highlightRow, selectRow: options.selectRow, triggerEvent: options.triggerEvent });
            isItemAdded = false;
        }
        // do we want to trigger an event after updating the item
        if (options.triggerEvent) {
            this.onItemUpserted.next(item);
            isItemAdded ? this.onItemAdded.next(item) : this.onItemUpdated.next(item);
        }
        return { added: rowNumberAdded, updated: rowNumberUpdated };
    };
    GridService = tslib_1.__decorate([
        Injectable(),
        tslib_1.__metadata("design:paramtypes", [ExtensionService,
            FilterService,
            GridStateService,
            SortService])
    ], GridService);
    return GridService;
}());
export { GridService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1zbGlja2dyaWQvIiwic291cmNlcyI6WyJhcHAvbW9kdWxlcy9hbmd1bGFyLXNsaWNrZ3JpZC9zZXJ2aWNlcy9ncmlkLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFVM0MsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDdkQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ2pELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM3QyxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBSS9CLElBQUksaUJBQXNCLENBQUM7QUFDM0IsSUFBTSwrQkFBK0IsR0FBNEIsRUFBRSxZQUFZLEVBQUUsSUFBSSxFQUFFLENBQUM7QUFDeEYsSUFBTSwrQkFBK0IsR0FBNEIsRUFBRSxZQUFZLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUNsSyxJQUFNLCtCQUErQixHQUE0QixFQUFFLFlBQVksRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxpQkFBaUIsRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRSxDQUFDO0FBR3hKO0lBUUUscUJBQ1UsZ0JBQWtDLEVBQ2xDLGFBQTRCLEVBQzVCLGdCQUFrQyxFQUNsQyxXQUF3QjtRQUh4QixxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO1FBQ2xDLGtCQUFhLEdBQWIsYUFBYSxDQUFlO1FBQzVCLHFCQUFnQixHQUFoQixnQkFBZ0Is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T0FBTyxFQUFFLEtBQUssRUFBRSxjQUFjLEVBQUUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLENBQUM7SUFDOUQsQ0FBQztJQTNxQlUsV0FBVztRQUR2QixVQUFVLEVBQUU7aURBVWlCLGdCQUFnQjtZQUNuQixhQUFhO1lBQ1YsZ0JBQWdCO1lBQ3JCLFdBQVc7T0FadkIsV0FBVyxDQTRxQnZCO0lBQUQsa0JBQUM7Q0FBQSxBQTVxQkQsSUE0cUJDO1NBNXFCWSxXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge1xyXG4gIENlbGxBcmdzLFxyXG4gIENvbHVtbixcclxuICBHcmlkT3B0aW9uLFxyXG4gIEdyaWRTZXJ2aWNlRGVsZXRlT3B0aW9uLFxyXG4gIEdyaWRTZXJ2aWNlSW5zZXJ0T3B0aW9uLFxyXG4gIEdyaWRTZXJ2aWNlVXBkYXRlT3B0aW9uLFxyXG4gIE9uRXZlbnRBcmdzXHJcbn0gZnJvbSAnLi8uLi9tb2RlbHMvaW5kZXgnO1xyXG5pbXBvcnQgeyBFeHRlbnNpb25TZXJ2aWNlIH0gZnJvbSAnLi9leHRlbnNpb24uc2VydmljZSc7XHJcbmltcG9ydCB7IEZpbHRlclNlcnZpY2UgfSBmcm9tICcuL2ZpbHRlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgR3JpZFN0YXRlU2VydmljZSB9IGZyb20gJy4vZ3JpZFN0YXRlLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBTb3J0U2VydmljZSB9IGZyb20gJy4vc29ydC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xyXG5cclxuLy8gdXNpbmcgZXh0ZXJuYWwgbm9uLXR5cGVkIGpzIGxpYnJhcmllc1xyXG5kZWNsYXJlIHZhciBTbGljazogYW55O1xyXG5sZXQgaGlnaGxpZ2h0VGltZXJFbmQ6IGFueTtcclxuY29uc3QgR3JpZFNlcnZpY2VEZWxldGVPcHRpb25EZWZhdWx0czogR3JpZFNlcnZpY2VEZWxldGVPcHRpb24gPSB7IHRyaWdnZXJFdmVudDogdHJ1ZSB9O1xyXG5jb25zdCBHcmlkU2VydmljZUluc2VydE9wdGlvbkRlZmF1bHRzOiBHcmlkU2VydmljZUluc2VydE9wdGlvbiA9IHsgaGlnaGxpZ2h0Um93OiB0cnVlLCBwb3NpdGlvbjogJ3RvcCcsIHJlc29ydEdyaWQ6IGZhbHNlLCBzZWxlY3RSb3c6IGZhbHNlLCB0cmlnZ2VyRXZlbnQ6IHRydWUgfTtcclxuY29uc3QgR3JpZFNlcnZpY2VVcGRhdGVPcHRpb25EZWZhdWx0czogR3JpZFNlcnZpY2VVcGRhdGVPcHRpb24gPSB7IGhpZ2hsaWdodFJvdzogdHJ1ZSwgc2VsZWN0Um93OiBmYWxzZSwgc2Nyb2xsUm93SW50b1ZpZXc6IGZhbHNlLCB0cmlnZ2VyRXZlbnQ6IHRydWUgfTtcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEdyaWRTZXJ2aWNlIHtcclxuICBwcml2YXRlIF9ncmlkOiBhbnk7XHJcbiAgcHJpdmF0ZSBfZGF0YVZpZXc6IGFueTtcclxuICBvbkl0ZW1BZGRlZCA9IG5ldyBTdWJqZWN0PGFueSB8IGFueVtdPigpO1xyXG4gIG9uSXRlbURlbGV0ZWQgPSBuZXcgU3ViamVjdDxhbnkgfCBhbnlbXT4oKTtcclxuICBvbkl0ZW1VcGRhdGVkID0gbmV3IFN1YmplY3Q8YW55IHwgYW55W10+KCk7XHJcbiAgb25JdGVtVXBzZXJ0ZWQgPSBuZXcgU3ViamVjdDxhbnkgfCBhbnlbXT4oKTtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIGV4dGVuc2lvblNlcnZpY2U6IEV4dGVuc2lvblNlcnZpY2UsXHJcbiAgICBwcml2YXRlIGZpbHRlclNlcnZpY2U6IEZpbHRlclNlcnZpY2UsXHJcbiAgICBwcml2YXRlIGdyaWRTdGF0ZVNlcnZpY2U6IEdyaWRTdGF0ZVNlcnZpY2UsXHJcbiAgICBwcml2YXRlIHNvcnRTZXJ2aWNlOiBTb3J0U2VydmljZVxyXG4gICkgeyB9XHJcblxyXG4gIC8qKiBHZXR0ZXIgZm9yIHRoZSBHcmlkIE9wdGlvbnMgcHVsbGVkIHRocm91Z2ggdGhlIEdyaWQgT2JqZWN0ICovXHJcbiAgcHJpdmF0ZSBnZXQgX2dyaWRPcHRpb25zKCk6IEdyaWRPcHRpb24ge1xyXG4gICAgcmV0dXJuICh0aGlzLl9ncmlkICYmIHRoaXMuX2dyaWQuZ2V0T3B0aW9ucykgPyB0aGlzLl9ncmlkLmdldE9wdGlvbnMoKSA6IHt9O1xyXG4gIH1cclxuXHJcbiAgaW5pdChncmlkOiBhbnksIGRhdGFWaWV3OiBhbnkpOiB2b2lkIHtcclxuICAgIHRoaXMuX2dyaWQgPSBncmlkO1xyXG4gICAgdGhpcy5fZGF0YVZpZXcgPSBkYXRhVmlldztcclxuICB9XHJcblxyXG4gIC8qKiBDbGVhciBhbGwgRmlsdGVycyAmIFNvcnRzICovXHJcbiAgY2xlYXJBbGxGaWx0ZXJzQW5kU29ydHMoKSB7XHJcbiAgICAvLyBjYWxsIGJvdGggY2xlYXIgRmlsdGVycyAmIFNvcnQgYnV0IG9ubHkgdHJpZ2dlciB0aGUgbGFzdCBvbmUgdG8gYXZvaWQgc2VuZGluZyBtdWx0aXBsZSBiYWNrZW5kIHF1ZXJpZXNcclxuICAgIGlmICh0aGlzLnNvcnRTZXJ2aWNlICYmIHRoaXMuc29ydFNlcnZpY2UuY2xlYXJTb3J0aW5nKSB7XHJcbiAgICAgIHRoaXMuc29ydFNlcnZpY2UuY2xlYXJTb3J0aW5nKGZhbHNlKTsgLy8gc2tpcCBldmVudCB0cmlnZ2VyIG9uIHRoaXMgb25lXHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5maWx0ZXJTZXJ2aWNlICYmIHRoaXMuZmlsdGVyU2VydmljZS5jbGVhckZpbHRlcnMpIHtcclxuICAgICAgdGhpcy5maWx0ZXJTZXJ2aWNlLmNsZWFyRmlsdGVycygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRnJvbSBhIFNsaWNrR3JpZCBFdmVudCB0cmlnZ2VyZWQgZ2V0IHRoZSBDb2x1bW4gRGVmaW5pdGlvbiBhbmQgSXRlbSBEYXRhIENvbnRleHRcclxuICAgKlxyXG4gICAqIEZvciBleGFtcGxlIHRoZSBTbGlja0dyaWQgb25DbGljayB3aWxsIHJldHVybiBjZWxsIGFyZ3VtZW50cyB3aGVuIHN1YnNjcmliaW5nIHRvIGl0LlxyXG4gICAqIEZyb20gdGhlc2UgY2VsbEFyZ3MsIHdlIHdhbnQgdG8gZ2V0IHRoZSBDb2x1bW4gRGVmaW5pdGlvbiBhbmQgSXRlbSBEYXRhXHJcbiAgICogQHBhcmFtIGNlbGwgZXZlbnQgYXJnc1xyXG4gICAqIEByZXR1cm4gb2JqZWN0IHdpdGggY29sdW1uRGVmIGFuZCBkYXRhQ29udGV4dFxyXG4gICAqL1xyXG4gIGdldENvbHVtbkZyb21FdmVudEFyZ3VtZW50cyhhcmdzOiBDZWxsQXJncyk6IE9uRXZlbnRBcmdzIHtcclxuICAgIGlmICghYXJncyB8fCAhYXJncy5ncmlkIHx8ICFhcmdzLmdyaWQuZ2V0Q29sdW1ucyB8fCAhYXJncy5ncmlkLmdldERhdGFJdGVtKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignVG8gZ2V0IHRoZSBjb2x1bW4gZGVmaW5pdGlvbiBhbmQgZGF0YSwgd2UgbmVlZCB0byBoYXZlIHRoZXNlIGFyZ3VtZW50cyBwYXNzZWQgYXMgb2JqZWN0cyAocm93LCBjZWxsLCBncmlkKScpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHJvdzogYXJncy5yb3csXHJcbiAgICAgIGNlbGw6IGFyZ3MuY2VsbCxcclxuICAgICAgY29sdW1uRGVmOiBhcmdzLmdyaWQuZ2V0Q29sdW1ucygpW2FyZ3MuY2VsbF0sXHJcbiAgICAgIGRhdGFDb250ZXh0OiBhcmdzLmdyaWQuZ2V0RGF0YUl0ZW0oYXJncy5yb3cpLFxyXG4gICAgICBkYXRhVmlldzogdGhpcy5fZGF0YVZpZXcsXHJcbiAgICAgIGdyaWQ6IHRoaXMuX2dyaWRcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKiogR2V0IGRhdGEgaXRlbSBieSBpdCdzIHJvdyBpbmRleCBudW1iZXIgKi9cclxuICBnZXREYXRhSXRlbUJ5Um93TnVtYmVyKHJvd051bWJlcjogbnVtYmVyKSB7XHJcbiAgICBpZiAoIXRoaXMuX2dyaWQgfHwgdHlwZW9mIHRoaXMuX2dyaWQuZ2V0RGF0YUl0ZW0gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBXZSBjb3VsZCBub3QgZmluZCBTbGlja0dyaWQgR3JpZCBvYmplY3Qgb3IgaXQncyBcImdldERhdGFJdGVtXCIgbWV0aG9kYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5fZ3JpZC5nZXREYXRhSXRlbShyb3dOdW1iZXIpO1xyXG4gIH1cclxuXHJcbiAgLyoqIENoYWluIHRoZSBpdGVtIE1ldGFkYXRhIHdpdGggb3VyIGltcGxlbWVudGF0aW9uIG9mIE1ldGFkYXRhIGF0IGdpdmVuIHJvdyBpbmRleCAqL1xyXG4gIGdldEl0ZW1Sb3dNZXRhZGF0YVRvSGlnaGxpZ2h0KHByZXZpb3VzSXRlbU1ldGFkYXRhOiBhbnkpIHtcclxuICAgIHJldHVybiAocm93TnVtYmVyOiBudW1iZXIpID0+IHtcclxuICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX2RhdGFWaWV3LmdldEl0ZW0ocm93TnVtYmVyKTtcclxuICAgICAgbGV0IG1ldGEgPSB7IGNzc0NsYXNzZXM6ICcnIH07XHJcbiAgICAgIGlmICh0eXBlb2YgcHJldmlvdXNJdGVtTWV0YWRhdGEgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBtZXRhID0gcHJldmlvdXNJdGVtTWV0YWRhdGEocm93TnVtYmVyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFtZXRhKSB7XHJcbiAgICAgICAgbWV0YSA9IHsgY3NzQ2xhc3NlczogJycgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5fZGlydHkpIHtcclxuICAgICAgICBtZXRhLmNzc0NsYXNzZXMgPSAobWV0YSAmJiBtZXRhLmNzc0NsYXNzZXMgfHwgJycpICsgJyBkaXJ0eSc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpdGVtICYmIGl0ZW0ucm93Q2xhc3MgJiYgbWV0YSkge1xyXG4gICAgICAgIG1ldGEuY3NzQ2xhc3NlcyArPSBgICR7aXRlbS5yb3dDbGFzc31gO1xyXG4gICAgICAgIG1ldGEuY3NzQ2xhc3NlcyArPSBgIHJvdyR7cm93TnVtYmVyfWA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtZXRhO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhpZ2hsaWdodCB0aGVuIGZhZGUgYSByb3cgZm9yIHggc2Vjb25kcy5cclxuICAgKiBUaGUgaW1wbGVtZW50YXRpb24gZm9sbG93cyB0aGlzIFNPIGFuc3dlcjogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE5OTg1MTQ4LzEyMTIxNjZcclxuICAgKiBAcGFyYW0gcm93TnVtYmVyXHJcbiAgICogQHBhcmFtIGZhZGVEZWxheVxyXG4gICAqL1xyXG4gIGhpZ2hsaWdodFJvdyhyb3dOdW1iZXI6IG51bWJlciB8IG51bWJlcltdLCBmYWRlRGVsYXkgPSAxNTAwLCBmYWRlT3V0RGVsYXkgPSAzMDApIHtcclxuICAgIC8vIGNyZWF0ZSBhIFNlbGVjdGlvbk1vZGVsIGlmIHRoZXJlJ3Mgbm90IG9uZSB5ZXRcclxuICAgIGlmICghdGhpcy5fZ3JpZC5nZXRTZWxlY3Rpb25Nb2RlbCgpICYmIFNsaWNrICYmIFNsaWNrLlJvd1NlbGVjdGlvbk1vZGVsKSB7XHJcbiAgICAgIGNvbnN0IHJvd1NlbGVjdGlvblBsdWdpbiA9IG5ldyBTbGljay5Sb3dTZWxlY3Rpb25Nb2RlbCh0aGlzLl9ncmlkT3B0aW9ucy5yb3dTZWxlY3Rpb25PcHRpb25zIHx8IHt9KTtcclxuICAgICAgdGhpcy5fZ3JpZC5zZXRTZWxlY3Rpb25Nb2RlbChyb3dTZWxlY3Rpb25QbHVnaW4pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHJvd051bWJlcikpIHtcclxuICAgICAgcm93TnVtYmVyLmZvckVhY2gocm93ID0+IHRoaXMuaGlnaGxpZ2h0Um93QnlNZXRhZGF0YShyb3csIGZhZGVEZWxheSwgZmFkZU91dERlbGF5KSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmhpZ2hsaWdodFJvd0J5TWV0YWRhdGEocm93TnVtYmVyLCBmYWRlRGVsYXksIGZhZGVPdXREZWxheSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBoaWdobGlnaHRSb3dCeU1ldGFkYXRhKHJvd051bWJlcjogbnVtYmVyLCBmYWRlRGVsYXkgPSAxNTAwLCBmYWRlT3V0RGVsYXkgPSAzMDApIHtcclxuICAgIHRoaXMuX2RhdGFWaWV3LmdldEl0ZW1NZXRhZGF0YSA9IHRoaXMuZ2V0SXRlbVJvd01ldGFkYXRhVG9IaWdobGlnaHQodGhpcy5fZGF0YVZpZXcuZ2V0SXRlbU1ldGFkYXRhKTtcclxuXHJcbiAgICBjb25zdCBpdGVtID0gdGhpcy5fZGF0YVZpZXcuZ2V0SXRlbShyb3dOdW1iZXIpO1xyXG4gICAgaWYgKGl0ZW0gJiYgaXRlbS5pZCkge1xyXG4gICAgICBpdGVtLnJvd0NsYXNzID0gJ2hpZ2hsaWdodCc7XHJcbiAgICAgIHRoaXMuX2RhdGFWaWV3LnVwZGF0ZUl0ZW0oaXRlbS5pZCwgaXRlbSk7XHJcbiAgICAgIHRoaXMucmVuZGVyR3JpZCgpO1xyXG5cclxuICAgICAgLy8gZmFkZSBvdXRcclxuICAgICAgY2xlYXJUaW1lb3V0KGhpZ2hsaWdodFRpbWVyRW5kKTtcclxuICAgICAgaGlnaGxpZ2h0VGltZXJFbmQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBpdGVtLnJvd0NsYXNzID0gJ2hpZ2hsaWdodC1lbmQnO1xyXG4gICAgICAgIHRoaXMuX2RhdGFWaWV3LnVwZGF0ZUl0ZW0oaXRlbS5pZCwgaXRlbSk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJHcmlkKCk7XHJcbiAgICAgIH0sIGZhZGVPdXREZWxheSk7XHJcblxyXG4gICAgICAvLyBkZWxldGUgdGhlIHJvdydzIENTUyBoaWdobGlnaHQgY2xhc3NlcyBvbmNlIHRoZSBkZWxheSBpcyBwYXNzZWRcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5pZCkge1xyXG4gICAgICAgICAgZGVsZXRlIGl0ZW0ucm93Q2xhc3M7XHJcbiAgICAgICAgICBpZiAodGhpcy5fZGF0YVZpZXcuZ2V0SWR4QnlJZChpdGVtLmlkKSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGFWaWV3LnVwZGF0ZUl0ZW0oaXRlbS5pZCwgaXRlbSk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyR3JpZCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSwgZmFkZURlbGF5ICsgZmFkZU91dERlbGF5KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBHZXQgdGhlIERhdGEgSXRlbSBmcm9tIGEgZ3JpZCByb3cgaW5kZXggKi9cclxuICBnZXREYXRhSXRlbUJ5Um93SW5kZXgoaW5kZXg6IG51bWJlcik6IGFueSB7XHJcbiAgICBpZiAoIXRoaXMuX2dyaWQgfHwgdHlwZW9mIHRoaXMuX2dyaWQuZ2V0RGF0YUl0ZW0gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZSBjb3VsZCBub3QgZmluZCBTbGlja0dyaWQgR3JpZCBvYmplY3QgYW5kL29yIFwiZ2V0RGF0YUl0ZW1cIiBtZXRob2QnKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5fZ3JpZC5nZXREYXRhSXRlbShpbmRleCk7XHJcbiAgfVxyXG5cclxuICAvKiogR2V0IHRoZSBEYXRhIEl0ZW0gZnJvbSBhbiBhcnJheSBvZiBncmlkIHJvdyBpbmRleGVzICovXHJcbiAgZ2V0RGF0YUl0ZW1CeVJvd0luZGV4ZXMoaW5kZXhlczogbnVtYmVyW10pOiBhbnlbXSB7XHJcbiAgICBpZiAoIXRoaXMuX2dyaWQgfHwgdHlwZW9mIHRoaXMuX2dyaWQuZ2V0RGF0YUl0ZW0gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZSBjb3VsZCBub3QgZmluZCBTbGlja0dyaWQgR3JpZCBvYmplY3QgYW5kL29yIFwiZ2V0RGF0YUl0ZW1cIiBtZXRob2QnKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkYXRhSXRlbXMgPSBbXTtcclxuXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbmRleGVzKSkge1xyXG4gICAgICBpbmRleGVzLmZvckVhY2goKGlkeCkgPT4ge1xyXG4gICAgICAgIGRhdGFJdGVtcy5wdXNoKHRoaXMuX2dyaWQuZ2V0RGF0YUl0ZW0oaWR4KSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkYXRhSXRlbXM7XHJcbiAgfVxyXG5cclxuICAvKiogR2V0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgcm93IGluZGV4ZXMgKi9cclxuICBnZXRTZWxlY3RlZFJvd3MoKTogbnVtYmVyW10ge1xyXG4gICAgaWYgKCF0aGlzLl9ncmlkIHx8IHR5cGVvZiB0aGlzLl9ncmlkLmdldFNlbGVjdGVkUm93cyAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlIGNvdWxkIG5vdCBmaW5kIFNsaWNrR3JpZCBHcmlkIG9iamVjdCBhbmQvb3IgXCJnZXRTZWxlY3RlZFJvd3NcIiBtZXRob2QnKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl9ncmlkLmdldFNlbGVjdGVkUm93cygpO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHJvd3MgaXRlbSBkYXRhICovXHJcbiAgZ2V0U2VsZWN0ZWRSb3dzRGF0YUl0ZW0oKTogYW55W10ge1xyXG4gICAgaWYgKCF0aGlzLl9ncmlkIHx8IHR5cGVvZiB0aGlzLl9ncmlkLmdldFNlbGVjdGVkUm93cyAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlIGNvdWxkIG5vdCBmaW5kIFNsaWNrR3JpZCBHcmlkIG9iamVjdCBhbmQvb3IgXCJnZXRTZWxlY3RlZFJvd3NcIiBtZXRob2QnKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzZWxlY3RlZFJvd0luZGV4ZXMgPSB0aGlzLl9ncmlkLmdldFNlbGVjdGVkUm93cygpO1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0RGF0YUl0ZW1CeVJvd0luZGV4ZXMoc2VsZWN0ZWRSb3dJbmRleGVzKTtcclxuICB9XHJcblxyXG4gIC8qKiBTZWxlY3QgdGhlIHNlbGVjdGVkIHJvdyBieSBhIHJvdyBpbmRleCAqL1xyXG4gIHNldFNlbGVjdGVkUm93KHJvd0luZGV4OiBudW1iZXIpIHtcclxuICAgIGlmICh0aGlzLl9ncmlkICYmIHRoaXMuX2dyaWQuc2V0U2VsZWN0ZWRSb3dzKSB7XHJcbiAgICAgIHRoaXMuX2dyaWQuc2V0U2VsZWN0ZWRSb3dzKFtyb3dJbmRleF0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIFNldCBzZWxlY3RlZCByb3dzIHdpdGggcHJvdmlkZWQgYXJyYXkgb2Ygcm93IGluZGV4ZXMgKi9cclxuICBzZXRTZWxlY3RlZFJvd3Mocm93SW5kZXhlczogbnVtYmVyW10pIHtcclxuICAgIGlmICh0aGlzLl9ncmlkICYmIHRoaXMuX2dyaWQuc2V0U2VsZWN0ZWRSb3dzKSB7XHJcbiAgICAgIHRoaXMuX2dyaWQuc2V0U2VsZWN0ZWRSb3dzKHJvd0luZGV4ZXMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIFJlLVJlbmRlciB0aGUgR3JpZCAqL1xyXG4gIHJlbmRlckdyaWQoKSB7XHJcbiAgICBpZiAodGhpcy5fZ3JpZCAmJiB0eXBlb2YgdGhpcy5fZ3JpZC5pbnZhbGlkYXRlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRoaXMuX2dyaWQuaW52YWxpZGF0ZSgpO1xyXG4gICAgICB0aGlzLl9ncmlkLnJlbmRlcigpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgdGhlIGdyaWQgdG8gaXQncyBvcmlnaW5hbCBzdGF0ZSAoY2xlYXIgYW55IGZpbHRlcnMsIHNvcnRpbmcgJiBwYWdpbmF0aW9uIGlmIGV4aXN0cykgLlxyXG4gICAqIFRoZSBjb2x1bW4gZGVmaW5pdGlvbnMgY291bGQgYmUgcGFzc2VkIGFzIGFyZ3VtZW50IHRvIHJlc2V0ICh0aGlzIGNhbiBiZSB1c2VkIGFmdGVyIGEgR3JpZCBTdGF0ZSByZXNldClcclxuICAgKiBUaGUgcmVzZXQgd2lsbCBjbGVhciB0aGUgRmlsdGVycyAmIFNvcnQsIHRoZW4gd2lsbCByZXNldCB0aGUgQ29sdW1ucyB0byB0aGVpciBvcmlnaW5hbCBzdGF0ZVxyXG4gICAqL1xyXG4gIHJlc2V0R3JpZChjb2x1bW5EZWZpbml0aW9ucz86IENvbHVtbltdKSB7XHJcbiAgICAvLyByZXNldCBjb2x1bW5zIHRvIG9yaWdpbmFsIHN0YXRlcyAmIHJlZnJlc2ggdGhlIGdyaWRcclxuICAgIGlmICh0aGlzLl9ncmlkICYmIHRoaXMuX2RhdGFWaWV3KSB7XHJcbiAgICAgIGNvbnN0IG9yaWdpbmFsQ29sdW1ucyA9IHRoaXMuZXh0ZW5zaW9uU2VydmljZS5nZXRBbGxDb2x1bW5zKCk7XHJcblxyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvcmlnaW5hbENvbHVtbnMpICYmIG9yaWdpbmFsQ29sdW1ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgLy8gc2V0IHRoZSBncmlkIGNvbHVtbnMgdG8gaXQncyBvcmlnaW5hbCBjb2x1bW4gZGVmaW5pdGlvbnNcclxuICAgICAgICB0aGlzLl9ncmlkLnNldENvbHVtbnMob3JpZ2luYWxDb2x1bW5zKTtcclxuICAgICAgICBpZiAodGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlQXV0b1NpemVDb2x1bW5zKSB7XHJcbiAgICAgICAgICB0aGlzLl9ncmlkLmF1dG9zaXplQ29sdW1ucygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmdyaWRTdGF0ZVNlcnZpY2UucmVzZXRDb2x1bW5zKGNvbHVtbkRlZmluaXRpb25zKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmZpbHRlclNlcnZpY2UgJiYgdGhpcy5maWx0ZXJTZXJ2aWNlLmNsZWFyRmlsdGVycykge1xyXG4gICAgICB0aGlzLmZpbHRlclNlcnZpY2UuY2xlYXJGaWx0ZXJzKCk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5zb3J0U2VydmljZSAmJiB0aGlzLnNvcnRTZXJ2aWNlLmNsZWFyU29ydGluZykge1xyXG4gICAgICB0aGlzLnNvcnRTZXJ2aWNlLmNsZWFyU29ydGluZygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIEBkZXByZWNhdGVkIHBsZWFzZSB1c2UgXCJhZGRJdGVtXCIgbWV0aG9kIGluc3RlYWQgKi9cclxuICBhZGRJdGVtVG9EYXRhZ3JpZChpdGVtOiBhbnksIHNob3VsZEhpZ2hsaWdodFJvdyA9IHRydWUsIHNob3VsZFJlc29ydEdyaWQgPSBmYWxzZSwgc2hvdWxkVHJpZ2dlckV2ZW50ID0gdHJ1ZSwgc2hvdWxkU2VsZWN0Um93ID0gdHJ1ZSk6IG51bWJlciB7XHJcbiAgICBjb25zb2xlLndhcm4oJ1tBbmd1bGFyLVNsaWNrZ3JpZCAtIEdyaWRTZXJ2aWNlXSBwbGVhc2UgY29uc2lkZXIgdXNpbmcgdGhlIG5ldyBcImFkZEl0ZW1cIiBtZXRob2Qgc2luY2UgXCJhZGRJdGVtVG9EYXRhZ3JpZFwiIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB0aGUgZnV0dXJlLicpO1xyXG4gICAgcmV0dXJuIHRoaXMuYWRkSXRlbShpdGVtLCB7IGhpZ2hsaWdodFJvdzogc2hvdWxkSGlnaGxpZ2h0Um93LCByZXNvcnRHcmlkOiBzaG91bGRSZXNvcnRHcmlkLCB0cmlnZ2VyRXZlbnQ6IHNob3VsZFRyaWdnZXJFdmVudCwgc2VsZWN0Um93OiBzaG91bGRTZWxlY3RSb3cgfSk7XHJcbiAgfVxyXG5cclxuICAvKiogQGRlcHJlY2F0ZWQgcGxlYXNlIHVzZSBcImFkZEl0ZW1zXCIgbWV0aG9kIGluc3RlYWQgKi9cclxuICBhZGRJdGVtc1RvRGF0YWdyaWQoaXRlbXM6IGFueVtdLCBzaG91bGRIaWdobGlnaHRSb3cgPSB0cnVlLCBzaG91bGRSZXNvcnRHcmlkID0gZmFsc2UsIHNob3VsZFRyaWdnZXJFdmVudCA9IHRydWUsIHNob3VsZFNlbGVjdFJvdyA9IHRydWUpOiBudW1iZXJbXSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ1tBbmd1bGFyLVNsaWNrZ3JpZCAtIEdyaWRTZXJ2aWNlXSBwbGVhc2UgY29uc2lkZXIgdXNpbmcgdGhlIG5ldyBcImFkZEl0ZW1zXCIgbWV0aG9kIHNpbmNlIFwiYWRkSXRlbXNUb0RhdGFncmlkXCIgd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUuJyk7XHJcbiAgICByZXR1cm4gdGhpcy5hZGRJdGVtcyhpdGVtcywgeyBoaWdobGlnaHRSb3c6IHNob3VsZEhpZ2hsaWdodFJvdywgcmVzb3J0R3JpZDogc2hvdWxkUmVzb3J0R3JpZCwgdHJpZ2dlckV2ZW50OiBzaG91bGRUcmlnZ2VyRXZlbnQsIHNlbGVjdFJvdzogc2hvdWxkU2VsZWN0Um93IH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGFuIGl0ZW0gKGRhdGEgaXRlbSkgdG8gdGhlIGRhdGFncmlkLCBieSBkZWZhdWx0IGl0IHdpbGwgaGlnaGxpZ2h0IChmbGFzaGluZykgdGhlIGluc2VydGVkIHJvdyBidXQgd2UgY2FuIGRpc2FibGUgaXQgdG9vXHJcbiAgICogQHBhcmFtIGl0ZW0gb2JqZWN0IHdoaWNoIG11c3QgY29udGFpbiBhIHVuaXF1ZSBcImlkXCIgcHJvcGVydHkgYW5kIGFueSBvdGhlciBzdWl0YWJsZSBwcm9wZXJ0aWVzXHJcbiAgICogQHBhcmFtIG9wdGlvbnM6IHByb3ZpZGUgdGhlIHBvc3NpYmlsaXR5IHRvIGRvIGNlcnRhaW4gYWN0aW9ucyBhZnRlciBvciBkdXJpbmcgdGhlIHVwc2VydCAoaGlnaGxpZ2h0Um93LCByZXNvcnRHcmlkLCBzZWxlY3RSb3csIHRyaWdnZXJFdmVudClcclxuICAgKiBAcmV0dXJuIHJvd0luZGV4OiB0eXBpY2FsbHkgaW5kZXggMCB3aGVuIGFkZGluZyB0byBwb3NpdGlvbiBcInRvcFwiIG9yIGEgZGlmZmVyZW50IG51bWJlciB3aGVuIGFkZGluZyB0byB0aGUgXCJib3R0b21cIlxyXG4gICAqL1xyXG4gIGFkZEl0ZW0oaXRlbTogYW55LCBvcHRpb25zPzogR3JpZFNlcnZpY2VJbnNlcnRPcHRpb24pOiBudW1iZXIge1xyXG4gICAgb3B0aW9ucyA9IHsgLi4uR3JpZFNlcnZpY2VJbnNlcnRPcHRpb25EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xyXG5cclxuICAgIGlmICghdGhpcy5fZ3JpZCB8fCAhdGhpcy5fZ3JpZE9wdGlvbnMgfHwgIXRoaXMuX2RhdGFWaWV3KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2UgY291bGQgbm90IGZpbmQgU2xpY2tHcmlkIEdyaWQsIERhdGFWaWV3IG9iamVjdHMnKTtcclxuICAgIH1cclxuICAgIGlmICghaXRlbSB8fCAhaXRlbS5oYXNPd25Qcm9wZXJ0eSgnaWQnKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFkZGluZyBhbiBpdGVtIHJlcXVpcmVzIHRoZSBpdGVtIHRvIGluY2x1ZGUgYW4gXCJpZFwiIHByb3BlcnR5YCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaW5zZXJ0IHBvc2l0aW9uIHRvcC9ib3R0b20sIGRlZmF1bHRzIHRvIHRvcFxyXG4gICAgLy8gd2hlbiBwb3NpdGlvbiBpcyB0b3Agd2UnbGwgY2FsbCBpbnNlcnQgYXQgaW5kZXggMCwgZWxzZSBjYWxsIGFkZEl0ZW0gd2hpY2gganVzdCBwdXNoIHRvIHRoZSBEYXRhVmlldyBhcnJheVxyXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcclxuICAgICAgdGhpcy5fZGF0YVZpZXcuYWRkSXRlbShpdGVtKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX2RhdGFWaWV3Lmluc2VydEl0ZW0oMCwgaXRlbSk7IC8vIGluc2VydCBhdCBpbmRleCAwXHJcbiAgICB9XHJcblxyXG4gICAgLy8gcm93IG51bWJlciBpbiB0aGUgZ3JpZCwgYnkgZGVmYXVsdCBpdCB3aWxsIGJlIG9uIGZpcnN0IHJvdyAodG9wIGlzIHRoZSBkZWZhdWx0KVxyXG4gICAgbGV0IHJvd051bWJlciA9IDA7XHJcblxyXG4gICAgLy8gZG8gd2Ugd2FudCB0aGUgaXRlbSB0byBiZSBzb3J0ZWQgaW4gdGhlIGdyaWQsIHdoZW4gc2V0IHRvIEZhbHNlIGl0IHdpbGwgaW5zZXJ0IG9uIGZpcnN0IHJvdyAoZGVmYXVsdHMgdG8gZmFsc2UpXHJcbiAgICBpZiAob3B0aW9ucy5yZXNvcnRHcmlkKSB7XHJcbiAgICAgIHRoaXMuX2RhdGFWaWV3LnJlU29ydCgpO1xyXG5cclxuICAgICAgLy8gZmluZCB0aGUgcm93IG51bWJlciBpbiB0aGUgZ3JpZCBhbmQgaWYgdXNlciB3YW50ZWQgdG8gc2VlIGhpZ2hsaWdodGVkIHJvd1xyXG4gICAgICAvLyB3ZSBuZWVkIHRvIGRvIGl0IGhlcmUgYWZ0ZXIgcmVzb3J0IGFuZCBnZXQgZWFjaCByb3cgbnVtYmVyIGJlY2F1c2UgaXQgcG9zc2libHkgY2hhbmdlcyBhZnRlciB0aGUgc29ydFxyXG4gICAgICByb3dOdW1iZXIgPSB0aGlzLl9kYXRhVmlldy5nZXRSb3dCeUlkKGl0ZW0uaWQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gc2Nyb2xsIHRvIHJvdyBpbmRleCAwIHdoZW4gaW5zZXJ0aW5nIG9uIHRvcCBlbHNlIHNjcm9sbCB0byB0aGUgYm90dG9tIHdoZXJlIGl0IGdvdCBpbnNlcnRlZFxyXG4gICAgICByb3dOdW1iZXIgPSAob3B0aW9ucyAmJiBvcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJykgPyB0aGlzLl9kYXRhVmlldy5nZXRSb3dCeUlkKGl0ZW0uaWQpIDogMDtcclxuICAgICAgdGhpcy5fZ3JpZC5zY3JvbGxSb3dJbnRvVmlldyhyb3dOdW1iZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIGhpZ2hsaWdodCBpcyBlbmFibGVkLCB3ZSdsbCBoaWdobGlnaHQgdGhlIHJvdyB3ZSBqdXN0IGFkZGVkXHJcbiAgICBpZiAob3B0aW9ucy5oaWdobGlnaHRSb3cpIHtcclxuICAgICAgdGhpcy5oaWdobGlnaHRSb3cocm93TnVtYmVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpZiByb3cgc2VsZWN0aW9uIChjaGVja2JveCBzZWxlY3RvcikgaXMgZW5hYmxlZCwgd2UnbGwgc2VsZWN0IHRoZSByb3cgaW4gdGhlIGdyaWRcclxuICAgIGlmIChvcHRpb25zLnNlbGVjdFJvdyAmJiB0aGlzLl9ncmlkT3B0aW9ucyAmJiAodGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlQ2hlY2tib3hTZWxlY3RvciB8fCB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVSb3dTZWxlY3Rpb24pKSB7XHJcbiAgICAgIHRoaXMuc2V0U2VsZWN0ZWRSb3cocm93TnVtYmVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBkbyB3ZSB3YW50IHRvIHRyaWdnZXIgYW4gZXZlbnQgYWZ0ZXIgYWRkaW5nIHRoZSBpdGVtXHJcbiAgICBpZiAob3B0aW9ucy50cmlnZ2VyRXZlbnQpIHtcclxuICAgICAgdGhpcy5vbkl0ZW1BZGRlZC5uZXh0KGl0ZW0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByb3dOdW1iZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGQgaXRlbSBhcnJheSAoZGF0YSBpdGVtKSB0byB0aGUgZGF0YWdyaWQsIGJ5IGRlZmF1bHQgaXQgd2lsbCBoaWdobGlnaHQgKGZsYXNoaW5nKSB0aGUgaW5zZXJ0ZWQgcm93IGJ1dCB3ZSBjYW4gZGlzYWJsZSBpdCB0b29cclxuICAgKiBAcGFyYW0gaXRlbSBvYmplY3QgYXJyYXlzLCB3aGljaCBtdXN0IGNvbnRhaW4gdW5pcXVlIFwiaWRcIiBwcm9wZXJ0eSBhbmQgYW55IG90aGVyIHN1aXRhYmxlIHByb3BlcnRpZXNcclxuICAgKiBAcGFyYW0gb3B0aW9uczogcHJvdmlkZSB0aGUgcG9zc2liaWxpdHkgdG8gZG8gY2VydGFpbiBhY3Rpb25zIGFmdGVyIG9yIGR1cmluZyB0aGUgdXBzZXJ0IChoaWdobGlnaHRSb3csIHJlc29ydEdyaWQsIHNlbGVjdFJvdywgdHJpZ2dlckV2ZW50KVxyXG4gICAqL1xyXG4gIGFkZEl0ZW1zKGl0ZW1zOiBhbnkgfCBhbnlbXSwgb3B0aW9ucz86IEdyaWRTZXJ2aWNlSW5zZXJ0T3B0aW9uKTogbnVtYmVyW10ge1xyXG4gICAgb3B0aW9ucyA9IHsgLi4uR3JpZFNlcnZpY2VJbnNlcnRPcHRpb25EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xyXG4gICAgY29uc3Qgcm93TnVtYmVyczogbnVtYmVyW10gPSBbXTtcclxuXHJcbiAgICAvLyBsb29wIHRocm91Z2ggYWxsIGl0ZW1zIHRvIGFkZFxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xyXG4gICAgICByZXR1cm4gW3RoaXMuYWRkSXRlbShpdGVtcywgb3B0aW9ucyldO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbTogYW55KSA9PiB0aGlzLmFkZEl0ZW0oaXRlbSwgeyAuLi5vcHRpb25zLCBoaWdobGlnaHRSb3c6IGZhbHNlLCByZXNvcnRHcmlkOiBmYWxzZSwgdHJpZ2dlckV2ZW50OiBmYWxzZSwgc2VsZWN0Um93OiBmYWxzZSB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZG8gd2Ugd2FudCB0aGUgaXRlbSB0byBiZSBzb3J0ZWQgaW4gdGhlIGdyaWQsIHdoZW4gc2V0IHRvIEZhbHNlIGl0IHdpbGwgaW5zZXJ0IG9uIGZpcnN0IHJvdyAoZGVmYXVsdHMgdG8gZmFsc2UpXHJcbiAgICBpZiAob3B0aW9ucy5yZXNvcnRHcmlkKSB7XHJcbiAgICAgIHRoaXMuX2RhdGFWaWV3LnJlU29ydCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNjcm9sbCB0byByb3cgaW5kZXggMCB3aGVuIGluc2VydGluZyBvbiB0b3AgZWxzZSBzY3JvbGwgdG8gdGhlIGJvdHRvbSB3aGVyZSBpdCBnb3QgaW5zZXJ0ZWRcclxuICAgIChvcHRpb25zICYmIG9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nKSA/IHRoaXMuX2dyaWQubmF2aWdhdGVCb3R0b20oKSA6IHRoaXMuX2dyaWQubmF2aWdhdGVUb3AoKTtcclxuXHJcbiAgICAvLyBnZXQgcm93IG51bWJlcnMgb2YgYWxsIG5ldyBpbnNlcnRlZCBpdGVtc1xyXG4gICAgLy8gd2UgbmVlZCB0byBkbyBpdCBhZnRlciByZXNvcnQgYW5kIGdldCBlYWNoIHJvdyBudW1iZXIgYmVjYXVzZSBpdCBwb3NzaWJseSBjaGFuZ2VkIGFmdGVyIHRoZSBzb3J0XHJcbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtOiBhbnkpID0+IHJvd051bWJlcnMucHVzaCh0aGlzLl9kYXRhVmlldy5nZXRSb3dCeUlkKGl0ZW0uaWQpKSk7XHJcblxyXG4gICAgLy8gaWYgdXNlciB3YW50ZWQgdG8gc2VlIGhpZ2hsaWdodGVkIHJvd1xyXG4gICAgaWYgKG9wdGlvbnMuaGlnaGxpZ2h0Um93KSB7XHJcbiAgICAgIHRoaXMuaGlnaGxpZ2h0Um93KHJvd051bWJlcnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNlbGVjdCB0aGUgcm93IGluIHRoZSBncmlkXHJcbiAgICBpZiAob3B0aW9ucy5zZWxlY3RSb3cgJiYgdGhpcy5fZ3JpZE9wdGlvbnMgJiYgKHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZUNoZWNrYm94U2VsZWN0b3IgfHwgdGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlUm93U2VsZWN0aW9uKSkge1xyXG4gICAgICB0aGlzLnNldFNlbGVjdGVkUm93cyhyb3dOdW1iZXJzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBkbyB3ZSB3YW50IHRvIHRyaWdnZXIgYW4gZXZlbnQgYWZ0ZXIgYWRkaW5nIHRoZSBpdGVtXHJcbiAgICBpZiAob3B0aW9ucy50cmlnZ2VyRXZlbnQpIHtcclxuICAgICAgdGhpcy5vbkl0ZW1BZGRlZC5uZXh0KGl0ZW1zKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcm93TnVtYmVycztcclxuICB9XHJcblxyXG4gIC8qKiBAZGVwcmVjYXRlZCBwbGVhc2UgdXNlIFwiZGVsZXRlSXRlbVwiIG1ldGhvZCBpbnN0ZWFkICovXHJcbiAgZGVsZXRlRGF0YUdyaWRJdGVtKGl0ZW06IGFueSwgc2hvdWxkVHJpZ2dlckV2ZW50ID0gdHJ1ZSkge1xyXG4gICAgY29uc29sZS53YXJuKCdbQW5ndWxhci1TbGlja2dyaWQgLSBHcmlkU2VydmljZV0gcGxlYXNlIGNvbnNpZGVyIHVzaW5nIHRoZSBuZXcgXCJkZWxldGVJdGVtXCIgbWV0aG9kIHNpbmNlIFwiZGVsZXRlRGF0YUdyaWRJdGVtXCIgd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUuJyk7XHJcbiAgICB0aGlzLmRlbGV0ZUl0ZW0oaXRlbSwgeyB0cmlnZ2VyRXZlbnQ6IHNob3VsZFRyaWdnZXJFdmVudCB9KTtcclxuICB9XHJcblxyXG4gIC8qKiBAZGVwcmVjYXRlZCBwbGVhc2UgdXNlIFwiZGVsZXRlSXRlbXNcIiBtZXRob2QgaW5zdGVhZCAqL1xyXG4gIGRlbGV0ZURhdGFHcmlkSXRlbXMoaXRlbXM6IGFueVtdLCBzaG91bGRUcmlnZ2VyRXZlbnQgPSB0cnVlKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ1tBbmd1bGFyLVNsaWNrZ3JpZCAtIEdyaWRTZXJ2aWNlXSBwbGVhc2UgY29uc2lkZXIgdXNpbmcgdGhlIG5ldyBcImRlbGV0ZUl0ZW1zXCIgbWV0aG9kIHNpbmNlIFwiZGVsZXRlRGF0YUdyaWRJdGVtc1wiIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB0aGUgZnV0dXJlLicpO1xyXG4gICAgdGhpcy5kZWxldGVJdGVtcyhpdGVtcywgeyB0cmlnZ2VyRXZlbnQ6IHNob3VsZFRyaWdnZXJFdmVudCB9KTtcclxuICB9XHJcblxyXG4gIC8qKiBAZGVwcmVjYXRlZCBwbGVhc2UgdXNlIFwiZGVsZXRlSXRlbUJ5SWRcIiBtZXRob2QgaW5zdGVhZCAqL1xyXG4gIGRlbGV0ZURhdGFHcmlkSXRlbUJ5SWQoaXRlbUlkOiBzdHJpbmcgfCBudW1iZXIsIHNob3VsZFRyaWdnZXJFdmVudCA9IHRydWUpIHtcclxuICAgIGNvbnNvbGUud2FybignW0FuZ3VsYXItU2xpY2tncmlkIC0gR3JpZFNlcnZpY2VdIHBsZWFzZSBjb25zaWRlciB1c2luZyB0aGUgbmV3IFwiZGVsZXRlSXRlbUJ5SWRcIiBtZXRob2Qgc2luY2UgXCJkZWxldGVEYXRhR3JpZEl0ZW1CeUlkXCIgd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUuJyk7XHJcbiAgICB0aGlzLmRlbGV0ZUl0ZW1CeUlkKGl0ZW1JZCwgeyB0cmlnZ2VyRXZlbnQ6IHNob3VsZFRyaWdnZXJFdmVudCB9KTtcclxuICB9XHJcblxyXG4gIC8qKiBAZGVwcmVjYXRlZCBwbGVhc2UgdXNlIFwiZGVsZXRlSXRlbUJ5SWRzXCIgbWV0aG9kIGluc3RlYWQgKi9cclxuICBkZWxldGVEYXRhR3JpZEl0ZW1CeUlkcyhpdGVtSWRzOiBudW1iZXJbXSB8IHN0cmluZ1tdLCBzaG91bGRUcmlnZ2VyRXZlbnQgPSB0cnVlKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ1tBbmd1bGFyLVNsaWNrZ3JpZCAtIEdyaWRTZXJ2aWNlXSBwbGVhc2UgY29uc2lkZXIgdXNpbmcgdGhlIG5ldyBcImRlbGV0ZUl0ZW1CeUlkc1wiIG1ldGhvZCBzaW5jZSBcImRlbGV0ZURhdGFHcmlkSXRlbUJ5SWRzXCIgd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUuJyk7XHJcbiAgICB0aGlzLmRlbGV0ZUl0ZW1CeUlkcyhpdGVtSWRzLCB7IHRyaWdnZXJFdmVudDogc2hvdWxkVHJpZ2dlckV2ZW50IH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVsZXRlIGFuIGV4aXN0aW5nIGl0ZW0gZnJvbSB0aGUgZGF0YWdyaWQgKGRhdGFWaWV3KVxyXG4gICAqIEBwYXJhbSBpdGVtIG9iamVjdCB3aGljaCBtdXN0IGNvbnRhaW4gYSB1bmlxdWUgXCJpZFwiIHByb3BlcnR5IGFuZCBhbnkgb3RoZXIgc3VpdGFibGUgcHJvcGVydGllc1xyXG4gICAqIEBwYXJhbSBvcHRpb25zOiBwcm92aWRlIHRoZSBwb3NzaWJpbGl0eSB0byBkbyBjZXJ0YWluIGFjdGlvbnMgYWZ0ZXIgb3IgZHVyaW5nIHRoZSB1cHNlcnQgKHRyaWdnZXJFdmVudClcclxuICAgKiBAcmV0dXJuIGl0ZW0gaWQgZGVsZXRlZFxyXG4gICAqL1xyXG4gIGRlbGV0ZUl0ZW0oaXRlbTogYW55LCBvcHRpb25zPzogR3JpZFNlcnZpY2VEZWxldGVPcHRpb24pOiBudW1iZXIgfCBzdHJpbmcge1xyXG4gICAgb3B0aW9ucyA9IHsgLi4uR3JpZFNlcnZpY2VEZWxldGVPcHRpb25EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xyXG5cclxuICAgIGlmICghaXRlbSB8fCAhaXRlbS5oYXNPd25Qcm9wZXJ0eSgnaWQnKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYERlbGV0aW5nIGFuIGl0ZW0gcmVxdWlyZXMgdGhlIGl0ZW0gdG8gaW5jbHVkZSBhbiBcImlkXCIgcHJvcGVydHlgKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmRlbGV0ZUl0ZW1CeUlkKGl0ZW0uaWQsIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVsZXRlIGFuIGFycmF5IG9mIGV4aXN0aW5nIGl0ZW1zIGZyb20gdGhlIGRhdGFncmlkXHJcbiAgICogQHBhcmFtIGl0ZW0gb2JqZWN0IHdoaWNoIG11c3QgY29udGFpbiBhIHVuaXF1ZSBcImlkXCIgcHJvcGVydHkgYW5kIGFueSBvdGhlciBzdWl0YWJsZSBwcm9wZXJ0aWVzXHJcbiAgICogQHBhcmFtIG9wdGlvbnM6IHByb3ZpZGUgdGhlIHBvc3NpYmlsaXR5IHRvIGRvIGNlcnRhaW4gYWN0aW9ucyBhZnRlciBvciBkdXJpbmcgdGhlIHVwc2VydCAodHJpZ2dlckV2ZW50KVxyXG4gICAqIEByZXR1cm4gaXRlbSBpZCBkZWxldGVkXHJcbiAgICovXHJcbiAgZGVsZXRlSXRlbXMoaXRlbXM6IGFueSB8IGFueVtdLCBvcHRpb25zPzogR3JpZFNlcnZpY2VEZWxldGVPcHRpb24pOiBudW1iZXJbXSB8IHN0cmluZ1tdIHtcclxuICAgIG9wdGlvbnMgPSB7IC4uLkdyaWRTZXJ2aWNlRGVsZXRlT3B0aW9uRGVmYXVsdHMsIC4uLm9wdGlvbnMgfTtcclxuXHJcbiAgICAvLyB3aGVuIGl0J3Mgbm90IGFuIGFycmF5LCB3ZSBjYW4gY2FsbCBkaXJlY3RseSB0aGUgc2luZ2xlIGl0ZW0gZGVsZXRlXHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XHJcbiAgICAgIHRoaXMuZGVsZXRlSXRlbShpdGVtcywgb3B0aW9ucyk7XHJcbiAgICAgIHJldHVybiBbaXRlbXMuaWRdO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaXRlbUlkcyA9IFtdO1xyXG4gICAgaXRlbXMuZm9yRWFjaCgoaXRlbTogYW55KSA9PiB7XHJcbiAgICAgIGlmIChpdGVtICYmIGl0ZW0uaWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGl0ZW1JZHMucHVzaChpdGVtLmlkKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmRlbGV0ZUl0ZW0oaXRlbSwgeyAuLi5vcHRpb25zLCB0cmlnZ2VyRXZlbnQ6IGZhbHNlIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gZG8gd2Ugd2FudCB0byB0cmlnZ2VyIGFuIGV2ZW50IGFmdGVyIGRlbGV0aW5nIHRoZSBpdGVtXHJcbiAgICBpZiAob3B0aW9ucy50cmlnZ2VyRXZlbnQpIHtcclxuICAgICAgdGhpcy5vbkl0ZW1EZWxldGVkLm5leHQoaXRlbXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGl0ZW1JZHM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZWxldGUgYW4gZXhpc3RpbmcgaXRlbSBmcm9tIHRoZSBkYXRhZ3JpZCAoZGF0YVZpZXcpIGJ5IGl0J3MgaWRcclxuICAgKiBAcGFyYW0gaXRlbUlkOiBpdGVtIHVuaXF1ZSBpZFxyXG4gICAqIEBwYXJhbSBvcHRpb25zOiBwcm92aWRlIHRoZSBwb3NzaWJpbGl0eSB0byBkbyBjZXJ0YWluIGFjdGlvbnMgYWZ0ZXIgb3IgZHVyaW5nIHRoZSB1cHNlcnQgKHRyaWdnZXJFdmVudClcclxuICAgKiBAcmV0dXJuIGl0ZW0gaWQgZGVsZXRlZFxyXG4gICAqL1xyXG4gIGRlbGV0ZUl0ZW1CeUlkKGl0ZW1JZDogc3RyaW5nIHwgbnVtYmVyLCBvcHRpb25zPzogR3JpZFNlcnZpY2VEZWxldGVPcHRpb24pOiBudW1iZXIgfCBzdHJpbmcge1xyXG4gICAgb3B0aW9ucyA9IHsgLi4uR3JpZFNlcnZpY2VEZWxldGVPcHRpb25EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xyXG5cclxuICAgIGlmIChpdGVtSWQgPT09IG51bGwgfHwgaXRlbUlkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZGVsZXRlIGEgcm93IHdpdGhvdXQgYSB2YWxpZCBcImlkXCJgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB3aGVuIHVzZXIgaGFzIHJvdyBzZWxlY3Rpb24gZW5hYmxlZCwgd2Ugc2hvdWxkIGNsZWFyIGFueSBzZWxlY3Rpb24gdG8gYXZvaWQgY29uZnVzaW9uIGFmdGVyIGEgZGVsZXRlXHJcbiAgICBjb25zdCBpc1N5bmNHcmlkU2VsZWN0aW9uRW5hYmxlZCA9IHRoaXMuZ3JpZFN0YXRlU2VydmljZSAmJiB0aGlzLmdyaWRTdGF0ZVNlcnZpY2UubmVlZFRvUHJlc2VydmVSb3dTZWxlY3Rpb24oKSB8fCBmYWxzZTtcclxuICAgIGlmICghaXNTeW5jR3JpZFNlbGVjdGlvbkVuYWJsZWQgJiYgdGhpcy5fZ3JpZCAmJiB0aGlzLl9ncmlkT3B0aW9ucyAmJiAodGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlQ2hlY2tib3hTZWxlY3RvciB8fCB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVSb3dTZWxlY3Rpb24pKSB7XHJcbiAgICAgIHRoaXMuc2V0U2VsZWN0ZWRSb3dzKFtdKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBkZWxldGUgdGhlIGl0ZW0gZnJvbSB0aGUgZGF0YVZpZXdcclxuICAgIHRoaXMuX2RhdGFWaWV3LmRlbGV0ZUl0ZW0oaXRlbUlkKTtcclxuXHJcbiAgICAvLyBkbyB3ZSB3YW50IHRvIHRyaWdnZXIgYW4gZXZlbnQgYWZ0ZXIgZGVsZXRpbmcgdGhlIGl0ZW1cclxuICAgIGlmIChvcHRpb25zLnRyaWdnZXJFdmVudCkge1xyXG4gICAgICB0aGlzLm9uSXRlbURlbGV0ZWQubmV4dChpdGVtSWQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGl0ZW1JZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlbGV0ZSBhbiBhcnJheSBvZiBleGlzdGluZyBpdGVtcyBmcm9tIHRoZSBkYXRhZ3JpZFxyXG4gICAqIEBwYXJhbSBpdGVtSWRzIGFycmF5IG9mIGl0ZW0gdW5pcXVlIElEc1xyXG4gICAqIEBwYXJhbSBvcHRpb25zOiBwcm92aWRlIHRoZSBwb3NzaWJpbGl0eSB0byBkbyBjZXJ0YWluIGFjdGlvbnMgYWZ0ZXIgb3IgZHVyaW5nIHRoZSB1cHNlcnQgKHRyaWdnZXJFdmVudClcclxuICAgKi9cclxuICBkZWxldGVJdGVtQnlJZHMoaXRlbUlkczogbnVtYmVyW10gfCBzdHJpbmdbXSwgb3B0aW9ucz86IEdyaWRTZXJ2aWNlRGVsZXRlT3B0aW9uKTogbnVtYmVyW10gfCBzdHJpbmdbXSB7XHJcbiAgICBvcHRpb25zID0geyAuLi5HcmlkU2VydmljZURlbGV0ZU9wdGlvbkRlZmF1bHRzLCAuLi5vcHRpb25zIH07XHJcblxyXG4gICAgLy8gd2hlbiBpdCdzIG5vdCBhbiBhcnJheSwgd2UgY2FuIGNhbGwgZGlyZWN0bHkgdGhlIHNpbmdsZSBpdGVtIGRlbGV0ZVxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbUlkcykpIHtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtSWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGl0ZW1JZHNbaV0gIT09IG51bGwpIHtcclxuICAgICAgICAgIHRoaXMuZGVsZXRlSXRlbUJ5SWQoaXRlbUlkc1tpXSwgeyB0cmlnZ2VyRXZlbnQ6IGZhbHNlIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZG8gd2Ugd2FudCB0byB0cmlnZ2VyIGFuIGV2ZW50IGFmdGVyIGRlbGV0aW5nIHRoZSBpdGVtXHJcbiAgICAgIGlmIChvcHRpb25zLnRyaWdnZXJFdmVudCkge1xyXG4gICAgICAgIHRoaXMub25JdGVtRGVsZXRlZC5uZXh0KGl0ZW1JZHMpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBpdGVtSWRzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBkZXByZWNhdGVkIHBsZWFzZSB1c2UgXCJ1cGRhdGVJdGVtXCIgbWV0aG9kIGluc3RlYWQgKi9cclxuICB1cGRhdGVEYXRhR3JpZEl0ZW0oaXRlbTogYW55LCBzaG91bGRIaWdobGlnaHRSb3cgPSB0cnVlLCBzaG91bGRUcmlnZ2VyRXZlbnQgPSB0cnVlLCBzaG91bGRTZWxlY3RSb3cgPSB0cnVlKTogbnVtYmVyIHtcclxuICAgIGNvbnNvbGUud2FybignW0FuZ3VsYXItU2xpY2tncmlkIC0gR3JpZFNlcnZpY2VdIHBsZWFzZSBjb25zaWRlciB1c2luZyB0aGUgbmV3IFwidXBkYXRlSXRlbVwiIG1ldGhvZCBzaW5jZSBcInVwZGF0ZURhdGFHcmlkSXRlbVwiIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB0aGUgZnV0dXJlLicpO1xyXG4gICAgcmV0dXJuIHRoaXMudXBkYXRlSXRlbShpdGVtLCB7IGhpZ2hsaWdodFJvdzogc2hvdWxkSGlnaGxpZ2h0Um93LCB0cmlnZ2VyRXZlbnQ6IHNob3VsZFRyaWdnZXJFdmVudCwgc2VsZWN0Um93OiBzaG91bGRTZWxlY3RSb3cgfSk7XHJcbiAgfVxyXG5cclxuICAvKiogQGRlcHJlY2F0ZWQgcGxlYXNlIHVzZSBcInVwZGF0ZUl0ZW1zXCIgbWV0aG9kIGluc3RlYWQgKi9cclxuICB1cGRhdGVEYXRhR3JpZEl0ZW1zKGl0ZW1zOiBhbnkgfCBhbnlbXSwgc2hvdWxkSGlnaGxpZ2h0Um93ID0gdHJ1ZSwgc2hvdWxkVHJpZ2dlckV2ZW50ID0gdHJ1ZSwgc2hvdWxkU2VsZWN0Um93ID0gdHJ1ZSk6IG51bWJlcltdIHtcclxuICAgIGNvbnNvbGUud2FybignW0FuZ3VsYXItU2xpY2tncmlkIC0gR3JpZFNlcnZpY2VdIHBsZWFzZSBjb25zaWRlciB1c2luZyB0aGUgbmV3IFwidXBkYXRlSXRlbXNcIiBtZXRob2Qgc2luY2UgXCJ1cGRhdGVEYXRhR3JpZEl0ZW1zXCIgd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUuJyk7XHJcbiAgICByZXR1cm4gdGhpcy51cGRhdGVJdGVtcyhpdGVtcywgeyBoaWdobGlnaHRSb3c6IHNob3VsZEhpZ2hsaWdodFJvdywgdHJpZ2dlckV2ZW50OiBzaG91bGRUcmlnZ2VyRXZlbnQsIHNlbGVjdFJvdzogc2hvdWxkU2VsZWN0Um93IH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBkZXByZWNhdGVkIHBsZWFzZSB1c2UgXCJ1cGRhdGVJdGVtQnlJZFwiIG1ldGhvZCBpbnN0ZWFkICovXHJcbiAgdXBkYXRlRGF0YUdyaWRJdGVtQnlJZChpdGVtSWQ6IG51bWJlciB8IHN0cmluZywgaXRlbTogYW55LCBzaG91bGRIaWdobGlnaHRSb3cgPSB0cnVlLCBzaG91bGRUcmlnZ2VyRXZlbnQgPSB0cnVlLCBzaG91bGRTZWxlY3RSb3cgPSB0cnVlKTogbnVtYmVyIHtcclxuICAgIGNvbnNvbGUud2FybignW0FuZ3VsYXItU2xpY2tncmlkIC0gR3JpZFNlcnZpY2VdIHBsZWFzZSBjb25zaWRlciB1c2luZyB0aGUgbmV3IFwidXBkYXRlSXRlbUJ5SWRcIiBtZXRob2Qgc2luY2UgXCJ1cGRhdGVEYXRhR3JpZEl0ZW1CeUlkXCIgd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUuJyk7XHJcbiAgICByZXR1cm4gdGhpcy51cGRhdGVJdGVtQnlJZChpdGVtSWQsIGl0ZW0sIHsgaGlnaGxpZ2h0Um93OiBzaG91bGRIaWdobGlnaHRSb3csIHRyaWdnZXJFdmVudDogc2hvdWxkVHJpZ2dlckV2ZW50LCBzZWxlY3RSb3c6IHNob3VsZFNlbGVjdFJvdyB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBhbiBleGlzdGluZyBpdGVtIHdpdGggbmV3IHByb3BlcnRpZXMgaW5zaWRlIHRoZSBkYXRhZ3JpZFxyXG4gICAqIEBwYXJhbSBpdGVtIG9iamVjdCB3aGljaCBtdXN0IGNvbnRhaW4gYSB1bmlxdWUgXCJpZFwiIHByb3BlcnR5IGFuZCBhbnkgb3RoZXIgc3VpdGFibGUgcHJvcGVydGllc1xyXG4gICAqIEBwYXJhbSBvcHRpb25zOiBwcm92aWRlIHRoZSBwb3NzaWJpbGl0eSB0byBkbyBjZXJ0YWluIGFjdGlvbnMgYWZ0ZXIgb3IgZHVyaW5nIHRoZSB1cHNlcnQgKGhpZ2hsaWdodFJvdywgc2VsZWN0Um93LCB0cmlnZ2VyRXZlbnQpXHJcbiAgICogQHJldHVybiBncmlkIHJvdyBpbmRleFxyXG4gICAqL1xyXG4gIHVwZGF0ZUl0ZW0oaXRlbTogYW55LCBvcHRpb25zPzogR3JpZFNlcnZpY2VVcGRhdGVPcHRpb24pOiBudW1iZXIge1xyXG4gICAgb3B0aW9ucyA9IHsgLi4uR3JpZFNlcnZpY2VVcGRhdGVPcHRpb25EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xyXG4gICAgY29uc3QgaXRlbUlkID0gKCFpdGVtIHx8ICFpdGVtLmhhc093blByb3BlcnR5KCdpZCcpKSA/IHVuZGVmaW5lZCA6IGl0ZW0uaWQ7XHJcblxyXG4gICAgaWYgKGl0ZW1JZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FsbGluZyBVcGRhdGUgb2YgYW4gaXRlbSByZXF1aXJlcyB0aGUgaXRlbSB0byBpbmNsdWRlIGFuIFwiaWRcIiBwcm9wZXJ0eWApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLnVwZGF0ZUl0ZW1CeUlkKGl0ZW1JZCwgaXRlbSwgb3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgYW4gYXJyYXkgb2YgZXhpc3RpbmcgaXRlbXMgd2l0aCBuZXcgcHJvcGVydGllcyBpbnNpZGUgdGhlIGRhdGFncmlkXHJcbiAgICogQHBhcmFtIGl0ZW0gb2JqZWN0IGFycmF5cywgd2hpY2ggbXVzdCBjb250YWluIHVuaXF1ZSBcImlkXCIgcHJvcGVydHkgYW5kIGFueSBvdGhlciBzdWl0YWJsZSBwcm9wZXJ0aWVzXHJcbiAgICogQHBhcmFtIG9wdGlvbnM6IHByb3ZpZGUgdGhlIHBvc3NpYmlsaXR5IHRvIGRvIGNlcnRhaW4gYWN0aW9ucyBhZnRlciBvciBkdXJpbmcgdGhlIHVwc2VydCAoaGlnaGxpZ2h0Um93LCBzZWxlY3RSb3csIHRyaWdnZXJFdmVudClcclxuICAgKiBAcmV0dXJuIGdyaWQgcm93IGluZGV4ZXNcclxuICAgKi9cclxuICB1cGRhdGVJdGVtcyhpdGVtczogYW55IHwgYW55W10sIG9wdGlvbnM/OiBHcmlkU2VydmljZVVwZGF0ZU9wdGlvbik6IG51bWJlcltdIHtcclxuICAgIG9wdGlvbnMgPSB7IC4uLkdyaWRTZXJ2aWNlVXBkYXRlT3B0aW9uRGVmYXVsdHMsIC4uLm9wdGlvbnMgfTtcclxuXHJcbiAgICAvLyB3aGVuIGl0J3Mgbm90IGFuIGFycmF5LCB3ZSBjYW4gY2FsbCBkaXJlY3RseSB0aGUgc2luZ2xlIGl0ZW0gdXBkYXRlXHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XHJcbiAgICAgIHJldHVybiBbdGhpcy51cGRhdGVJdGVtKGl0ZW1zLCBvcHRpb25zKV07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZ3JpZFJvd051bWJlcnM6IG51bWJlcltdID0gW107XHJcbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtOiBhbnkpID0+IHtcclxuICAgICAgZ3JpZFJvd051bWJlcnMucHVzaCh0aGlzLnVwZGF0ZUl0ZW0oaXRlbSwgeyAuLi5vcHRpb25zLCBoaWdobGlnaHRSb3c6IGZhbHNlLCBzZWxlY3RSb3c6IGZhbHNlLCB0cmlnZ2VyRXZlbnQ6IGZhbHNlIH0pKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIG9ubHkgaGlnaGxpZ2h0IGF0IHRoZSBlbmQsIGFsbCBhdCBvbmNlXHJcbiAgICAvLyB3ZSBoYXZlIHRvIGRvIHRoaXMgYmVjYXVzZSBkb2luZyBoaWdobGlnaHQgMSBieSAxIHdvdWxkIG9ubHkgcmUtc2VsZWN0IHRoZSBsYXN0IGhpZ2hsaWdodGVkIHJvdyB3aGljaCBpcyB3cm9uZyBiZWhhdmlvclxyXG4gICAgaWYgKG9wdGlvbnMuaGlnaGxpZ2h0Um93KSB7XHJcbiAgICAgIHRoaXMuaGlnaGxpZ2h0Um93KGdyaWRSb3dOdW1iZXJzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBzZWxlY3QgdGhlIHJvdyBpbiB0aGUgZ3JpZFxyXG4gICAgaWYgKG9wdGlvbnMuc2VsZWN0Um93ICYmIHRoaXMuX2dyaWRPcHRpb25zICYmICh0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVDaGVja2JveFNlbGVjdG9yIHx8IHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZVJvd1NlbGVjdGlvbikpIHtcclxuICAgICAgdGhpcy5zZXRTZWxlY3RlZFJvd3MoZ3JpZFJvd051bWJlcnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGRvIHdlIHdhbnQgdG8gdHJpZ2dlciBhbiBldmVudCBhZnRlciB1cGRhdGluZyB0aGUgaXRlbVxyXG4gICAgaWYgKG9wdGlvbnMudHJpZ2dlckV2ZW50KSB7XHJcbiAgICAgIHRoaXMub25JdGVtVXBkYXRlZC5uZXh0KGl0ZW1zKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZ3JpZFJvd051bWJlcnM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgYW4gZXhpc3RpbmcgaXRlbSBpbiB0aGUgZGF0YWdyaWQgYnkgaXQncyBpZCBhbmQgbmV3IHByb3BlcnRpZXNcclxuICAgKiBAcGFyYW0gaXRlbUlkOiBpdGVtIHVuaXF1ZSBpZFxyXG4gICAqIEBwYXJhbSBpdGVtIG9iamVjdCB3aGljaCBtdXN0IGNvbnRhaW4gYSB1bmlxdWUgXCJpZFwiIHByb3BlcnR5IGFuZCBhbnkgb3RoZXIgc3VpdGFibGUgcHJvcGVydGllc1xyXG4gICAqIEBwYXJhbSBvcHRpb25zOiBwcm92aWRlIHRoZSBwb3NzaWJpbGl0eSB0byBkbyBjZXJ0YWluIGFjdGlvbnMgYWZ0ZXIgb3IgZHVyaW5nIHRoZSB1cHNlcnQgKGhpZ2hsaWdodFJvdywgc2VsZWN0Um93LCB0cmlnZ2VyRXZlbnQpXHJcbiAgICogQHJldHVybiBncmlkIHJvdyBudW1iZXJcclxuICAgKi9cclxuICB1cGRhdGVJdGVtQnlJZChpdGVtSWQ6IG51bWJlciB8IHN0cmluZywgaXRlbTogYW55LCBvcHRpb25zPzogR3JpZFNlcnZpY2VVcGRhdGVPcHRpb24pOiBudW1iZXIge1xyXG4gICAgb3B0aW9ucyA9IHsgLi4uR3JpZFNlcnZpY2VVcGRhdGVPcHRpb25EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xyXG4gICAgaWYgKGl0ZW1JZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHVwZGF0ZSBhIHJvdyB3aXRob3V0IGEgdmFsaWQgXCJpZFwiYCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCByb3dOdW1iZXIgPSB0aGlzLl9kYXRhVmlldy5nZXRSb3dCeUlkKGl0ZW1JZCk7XHJcblxyXG4gICAgaWYgKCFpdGVtIHx8IHJvd051bWJlciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGl0ZW0gdG8gdXBkYXRlIGluIHRoZSBncmlkIHdhcyBub3QgZm91bmQgd2l0aCBpZDogJHtpdGVtSWR9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX2RhdGFWaWV3LmdldElkeEJ5SWQoaXRlbUlkKSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIC8vIFVwZGF0ZSB0aGUgaXRlbSBpdHNlbGYgaW5zaWRlIHRoZSBkYXRhVmlld1xyXG4gICAgICB0aGlzLl9kYXRhVmlldy51cGRhdGVJdGVtKGl0ZW1JZCwgaXRlbSk7XHJcbiAgICAgIHRoaXMuX2dyaWQudXBkYXRlUm93KHJvd051bWJlcik7XHJcblxyXG4gICAgICAvLyBkbyB3ZSB3YW50IHRvIHNjcm9sbCB0byB0aGUgcm93IHNvIHRoYXQgaXQgc2hvd3MgaW4gdGhlIFZpZXdwb3J0IChVSSlcclxuICAgICAgaWYgKG9wdGlvbnMuc2Nyb2xsUm93SW50b1ZpZXcpIHtcclxuICAgICAgICB0aGlzLl9ncmlkLnNjcm9sbFJvd0ludG9WaWV3KHJvd051bWJlcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGhpZ2hsaWdodCB0aGUgcm93IHdlIGp1c3QgdXBkYXRlZCwgaWYgZGVmaW5lZFxyXG4gICAgICBpZiAob3B0aW9ucy5oaWdobGlnaHRSb3cpIHtcclxuICAgICAgICB0aGlzLmhpZ2hsaWdodFJvdyhyb3dOdW1iZXIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBzZWxlY3QgdGhlIHJvdyBpbiB0aGUgZ3JpZFxyXG4gICAgICBpZiAob3B0aW9ucy5zZWxlY3RSb3cgJiYgdGhpcy5fZ3JpZE9wdGlvbnMgJiYgKHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZUNoZWNrYm94U2VsZWN0b3IgfHwgdGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlUm93U2VsZWN0aW9uKSkge1xyXG4gICAgICAgIHRoaXMuc2V0U2VsZWN0ZWRSb3cocm93TnVtYmVyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZG8gd2Ugd2FudCB0byB0cmlnZ2VyIGFuIGV2ZW50IGFmdGVyIHVwZGF0aW5nIHRoZSBpdGVtXHJcbiAgICAgIGlmIChvcHRpb25zLnRyaWdnZXJFdmVudCkge1xyXG4gICAgICAgIHRoaXMub25JdGVtVXBkYXRlZC5uZXh0KGl0ZW0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcm93TnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5zZXJ0IGEgcm93IGludG8gdGhlIGdyaWQgaWYgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0IG9yIHVwZGF0ZSBpZiBpdCBkb2VzLlxyXG4gICAqIEBwYXJhbSBpdGVtIG9iamVjdCB3aGljaCBtdXN0IGNvbnRhaW4gYSB1bmlxdWUgXCJpZFwiIHByb3BlcnR5IGFuZCBhbnkgb3RoZXIgc3VpdGFibGUgcHJvcGVydGllc1xyXG4gICAqIEBwYXJhbSBvcHRpb25zOiBwcm92aWRlIHRoZSBwb3NzaWJpbGl0eSB0byBkbyBjZXJ0YWluIGFjdGlvbnMgYWZ0ZXIgb3IgZHVyaW5nIHRoZSB1cHNlcnQgKGhpZ2hsaWdodFJvdywgcmVzb3J0R3JpZCwgc2VsZWN0Um93LCB0cmlnZ2VyRXZlbnQpXHJcbiAgICovXHJcbiAgdXBzZXJ0SXRlbShpdGVtOiBhbnksIG9wdGlvbnM/OiBHcmlkU2VydmljZUluc2VydE9wdGlvbik6IHsgYWRkZWQ6IG51bWJlciwgdXBkYXRlZDogbnVtYmVyIH0ge1xyXG4gICAgb3B0aW9ucyA9IHsgLi4uR3JpZFNlcnZpY2VJbnNlcnRPcHRpb25EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xyXG4gICAgY29uc3QgaXRlbUlkID0gKCFpdGVtIHx8ICFpdGVtLmhhc093blByb3BlcnR5KCdpZCcpKSA/IHVuZGVmaW5lZCA6IGl0ZW0uaWQ7XHJcblxyXG4gICAgaWYgKGl0ZW1JZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FsbGluZyBVcHNlcnQgb2YgYW4gaXRlbSByZXF1aXJlcyB0aGUgaXRlbSB0byBpbmNsdWRlIGFuIFwiaWRcIiBwcm9wZXJ0eWApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLnVwc2VydEl0ZW1CeUlkKGl0ZW1JZCwgaXRlbSwgb3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgYW4gYXJyYXkgb2YgZXhpc3RpbmcgaXRlbXMgd2l0aCBuZXcgcHJvcGVydGllcyBpbnNpZGUgdGhlIGRhdGFncmlkXHJcbiAgICogQHBhcmFtIGl0ZW0gb2JqZWN0IGFycmF5cywgd2hpY2ggbXVzdCBjb250YWluIHVuaXF1ZSBcImlkXCIgcHJvcGVydHkgYW5kIGFueSBvdGhlciBzdWl0YWJsZSBwcm9wZXJ0aWVzXHJcbiAgICogQHBhcmFtIG9wdGlvbnM6IHByb3ZpZGUgdGhlIHBvc3NpYmlsaXR5IHRvIGRvIGNlcnRhaW4gYWN0aW9ucyBhZnRlciBvciBkdXJpbmcgdGhlIHVwc2VydCAoaGlnaGxpZ2h0Um93LCByZXNvcnRHcmlkLCBzZWxlY3RSb3csIHRyaWdnZXJFdmVudClcclxuICAgKiBAcmV0dXJuIHJvdyBudW1iZXJzIGluIHRoZSBncmlkXHJcbiAgICovXHJcbiAgdXBzZXJ0SXRlbXMoaXRlbXM6IGFueSB8IGFueVtdLCBvcHRpb25zPzogR3JpZFNlcnZpY2VJbnNlcnRPcHRpb24pOiB7IGFkZGVkOiBudW1iZXIsIHVwZGF0ZWQ6IG51bWJlciB9W10ge1xyXG4gICAgb3B0aW9ucyA9IHsgLi4uR3JpZFNlcnZpY2VJbnNlcnRPcHRpb25EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xyXG4gICAgLy8gd2hlbiBpdCdzIG5vdCBhbiBhcnJheSwgd2UgY2FuIGNhbGwgZGlyZWN0bHkgdGhlIHNpbmdsZSBpdGVtIHVwZGF0ZVxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xyXG4gICAgICByZXR1cm4gW3RoaXMudXBzZXJ0SXRlbShpdGVtcywgb3B0aW9ucyldO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdXBzZXJ0ZWRSb3dzOiB7IGFkZGVkOiBudW1iZXIsIHVwZGF0ZWQ6IG51bWJlciB9W10gPSBbXTtcclxuICAgIGl0ZW1zLmZvckVhY2goKGl0ZW06IGFueSkgPT4ge1xyXG4gICAgICB1cHNlcnRlZFJvd3MucHVzaCh0aGlzLnVwc2VydEl0ZW0oaXRlbSwgeyAuLi5vcHRpb25zLCBoaWdobGlnaHRSb3c6IGZhbHNlLCByZXNvcnRHcmlkOiBmYWxzZSwgc2VsZWN0Um93OiBmYWxzZSwgdHJpZ2dlckV2ZW50OiBmYWxzZSB9KSk7XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHJvd051bWJlcnMgPSB1cHNlcnRlZFJvd3MubWFwKCh1cHNlcnRSb3cpID0+IHVwc2VydFJvdy5hZGRlZCAhPT0gdW5kZWZpbmVkID8gdXBzZXJ0Um93LmFkZGVkIDogdXBzZXJ0Um93LnVwZGF0ZWQpO1xyXG4gICAgLy8gb25seSBoaWdobGlnaHQgYXQgdGhlIGVuZCwgYWxsIGF0IG9uY2VcclxuICAgIC8vIHdlIGhhdmUgdG8gZG8gdGhpcyBiZWNhdXNlIGRvaW5nIGhpZ2hsaWdodCAxIGJ5IDEgd291bGQgb25seSByZS1zZWxlY3QgdGhlIGxhc3QgaGlnaGxpZ2h0ZWQgcm93IHdoaWNoIGlzIHdyb25nIGJlaGF2aW9yXHJcbiAgICBpZiAob3B0aW9ucy5oaWdobGlnaHRSb3cpIHtcclxuICAgICAgdGhpcy5oaWdobGlnaHRSb3cocm93TnVtYmVycyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2VsZWN0IHRoZSByb3cgaW4gdGhlIGdyaWRcclxuICAgIGlmIChvcHRpb25zLnNlbGVjdFJvdyAmJiB0aGlzLl9ncmlkT3B0aW9ucyAmJiAodGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlQ2hlY2tib3hTZWxlY3RvciB8fCB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVSb3dTZWxlY3Rpb24pKSB7XHJcbiAgICAgIHRoaXMuc2V0U2VsZWN0ZWRSb3dzKHJvd051bWJlcnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGRvIHdlIHdhbnQgdG8gdHJpZ2dlciBhbiBldmVudCBhZnRlciB1cGRhdGluZyB0aGUgaXRlbVxyXG4gICAgaWYgKG9wdGlvbnMudHJpZ2dlckV2ZW50KSB7XHJcbiAgICAgIHRoaXMub25JdGVtVXBzZXJ0ZWQubmV4dChpdGVtcyk7XHJcbiAgICAgIGNvbnN0IGFkZGVkSXRlbXMgPSB1cHNlcnRlZFJvd3MuZmlsdGVyKCh1cHNlcnRSb3cpID0+IHVwc2VydFJvdy5hZGRlZCAhPT0gdW5kZWZpbmVkKTtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYWRkZWRJdGVtcykgJiYgYWRkZWRJdGVtcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdGhpcy5vbkl0ZW1BZGRlZC5uZXh0KGFkZGVkSXRlbXMpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHVwZGF0ZWRJdGVtcyA9IHVwc2VydGVkUm93cy5maWx0ZXIoKHVwc2VydFJvdykgPT4gdXBzZXJ0Um93LnVwZGF0ZWQgIT09IHVuZGVmaW5lZCk7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHVwZGF0ZWRJdGVtcykgJiYgdXBkYXRlZEl0ZW1zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB0aGlzLm9uSXRlbVVwZGF0ZWQubmV4dCh1cGRhdGVkSXRlbXMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdXBzZXJ0ZWRSb3dzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIGFuIGV4aXN0aW5nIGl0ZW0gaW4gdGhlIGRhdGFncmlkIGJ5IGl0J3MgaWQgYW5kIG5ldyBwcm9wZXJ0aWVzXHJcbiAgICogQHBhcmFtIGl0ZW1JZDogaXRlbSB1bmlxdWUgaWRcclxuICAgKiBAcGFyYW0gaXRlbSBvYmplY3Qgd2hpY2ggbXVzdCBjb250YWluIGEgdW5pcXVlIFwiaWRcIiBwcm9wZXJ0eSBhbmQgYW55IG90aGVyIHN1aXRhYmxlIHByb3BlcnRpZXNcclxuICAgKiBAcGFyYW0gb3B0aW9uczogcHJvdmlkZSB0aGUgcG9zc2liaWxpdHkgdG8gZG8gY2VydGFpbiBhY3Rpb25zIGFmdGVyIG9yIGR1cmluZyB0aGUgdXBzZXJ0IChoaWdobGlnaHRSb3csIHJlc29ydEdyaWQsIHNlbGVjdFJvdywgdHJpZ2dlckV2ZW50KVxyXG4gICAqIEByZXR1cm4gZ3JpZCByb3cgbnVtYmVyIGluIHRoZSBncmlkXHJcbiAgICovXHJcbiAgdXBzZXJ0SXRlbUJ5SWQoaXRlbUlkOiBudW1iZXIgfCBzdHJpbmcsIGl0ZW06IGFueSwgb3B0aW9ucz86IEdyaWRTZXJ2aWNlSW5zZXJ0T3B0aW9uKTogeyBhZGRlZDogbnVtYmVyLCB1cGRhdGVkOiBudW1iZXIgfSB7XHJcbiAgICBsZXQgaXNJdGVtQWRkZWQgPSBmYWxzZTtcclxuICAgIG9wdGlvbnMgPSB7IC4uLkdyaWRTZXJ2aWNlSW5zZXJ0T3B0aW9uRGVmYXVsdHMsIC4uLm9wdGlvbnMgfTtcclxuICAgIGlmIChpdGVtSWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbGxpbmcgVXBzZXJ0IG9mIGFuIGl0ZW0gcmVxdWlyZXMgdGhlIGl0ZW0gdG8gaW5jbHVkZSBhIHZhbGlkIGFuZCB1bmlxdWUgXCJpZFwiIHByb3BlcnR5YCk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHJvd051bWJlckFkZGVkOiBudW1iZXI7XHJcbiAgICBsZXQgcm93TnVtYmVyVXBkYXRlZDogbnVtYmVyO1xyXG4gICAgaWYgKHRoaXMuX2RhdGFWaWV3LmdldFJvd0J5SWQoaXRlbUlkKSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJvd051bWJlckFkZGVkID0gdGhpcy5hZGRJdGVtKGl0ZW0sIG9wdGlvbnMpO1xyXG4gICAgICBpc0l0ZW1BZGRlZCA9IHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByb3dOdW1iZXJVcGRhdGVkID0gdGhpcy51cGRhdGVJdGVtKGl0ZW0sIHsgaGlnaGxpZ2h0Um93OiBvcHRpb25zLmhpZ2hsaWdodFJvdywgc2VsZWN0Um93OiBvcHRpb25zLnNlbGVjdFJvdywgdHJpZ2dlckV2ZW50OiBvcHRpb25zLnRyaWdnZXJFdmVudCB9KTtcclxuICAgICAgaXNJdGVtQWRkZWQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBkbyB3ZSB3YW50IHRvIHRyaWdnZXIgYW4gZXZlbnQgYWZ0ZXIgdXBkYXRpbmcgdGhlIGl0ZW1cclxuICAgIGlmIChvcHRpb25zLnRyaWdnZXJFdmVudCkge1xyXG4gICAgICB0aGlzLm9uSXRlbVVwc2VydGVkLm5leHQoaXRlbSk7XHJcbiAgICAgIGlzSXRlbUFkZGVkID8gdGhpcy5vbkl0ZW1BZGRlZC5uZXh0KGl0ZW0pIDogdGhpcy5vbkl0ZW1VcGRhdGVkLm5leHQoaXRlbSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBhZGRlZDogcm93TnVtYmVyQWRkZWQsIHVwZGF0ZWQ6IHJvd051bWJlclVwZGF0ZWQgfTtcclxuICB9XHJcbn1cclxuIl19