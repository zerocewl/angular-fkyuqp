import { Subject } from 'rxjs';
import { ColumnSort, CurrentSorter, EmitterType, SlickEventHandler } from './../models/index';
import * as ɵngcc0 from '@angular/core';
export declare class SortService {
    private _currentLocalSorters;
    private _eventHandler;
    private _dataView;
    private _grid;
    private _isBackendGrid;
    private httpCancelRequests$;
    onSortChanged: Subject<CurrentSorter[]>;
    onSortCleared: Subject<boolean>;
    constructor();
    /** Getter of the SlickGrid Event Handler */
    readonly eventHandler: SlickEventHandler;
    /** Getter for the Grid Options pulled through the Grid Object */
    private readonly _gridOptions;
    /** Getter for the Column Definitions pulled through the Grid Object */
    private readonly _columnDefinitions;
    /**
     * Bind a backend sort (single/multi) hook to the grid
     * @param grid SlickGrid Grid object
     * @param dataView SlickGrid DataView object
     */
    bindBackendOnSort(grid: any, dataView: any): void;
    /**
     * Bind a local sort (single/multi) hook to the grid
     * @param grid SlickGrid Grid object
     * @param gridOptions Grid Options object
     * @param dataView
     */
    bindLocalOnSort(grid: any, dataView: any): void;
    clearSorting(triggerQueryEvent?: boolean): void;
    dispose(): void;
    /**
     * A simple function that is binded to the subscriber and emit a change when the sort is called.
     * Other services, like Pagination, can then subscribe to it.
     * @param sender
     */
    emitSortChanged(sender: EmitterType, currentLocalSorters?: CurrentSorter[]): void;
    getCurrentLocalSorters(): CurrentSorter[];
    /**
     * Get current column sorts,
     * If a column is passed as an argument, that will be exclusion so we won't add this column to our output array since it is already in the array.
     * The usage of this method is that we want to know the sort prior to calling the next sorting command
     */
    getCurrentColumnSorts(excludedColumnId?: string): any;
    /** Load defined Sorting (sorters) into the grid */
    loadGridSorters(sorters: CurrentSorter[]): ColumnSort[];
    onBackendSortChanged(event: Event, args: {
        multiColumnSort?: boolean;
        grid: any;
        sortCols: ColumnSort[];
        clearSortTriggered?: boolean;
    }): void;
    onLocalSortChanged(grid: any, dataView: any, sortColumns: ColumnSort[], forceReSort?: boolean): void;
    sortComparer(sortColumns: ColumnSort[], dataRow1: any, dataRow2: any): number;
    /**
     * Update Sorting (sorters) dynamically just by providing an array of sorter(s).
     * You can also choose emit (default) a Sort Changed event that will be picked by the Grid State Service.
     *
     * Also for backend service only, you can choose to trigger a backend query (default) or not if you wish to do it later,
     * this could be useful when using updateFilters & updateSorting and you wish to only send the backend query once.
     * @param sorters array
     * @param triggerEvent defaults to True, do we want to emit a sort changed event?
     * @param triggerBackendQuery defaults to True, which will query the backend.
     */
    updateSorting(sorters: CurrentSorter[], emitChangedEvent?: boolean, triggerBackendQuery?: boolean): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<SortService>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<SortService>;
}

//# sourceMappingURL=sort.service.d.ts.map