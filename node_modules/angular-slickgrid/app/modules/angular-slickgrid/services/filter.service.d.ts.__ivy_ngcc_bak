import { Subject } from 'rxjs';
import { Column, ColumnFilters, CurrentFilter, EmitterType, SlickEvent, SlickEventHandler } from './../models/index';
import { FilterFactory } from '../filters/filterFactory';
import { SharedService } from './shared.service';
export declare class FilterService {
    private filterFactory;
    private sharedService;
    private _eventHandler;
    private _isFilterFirstRender;
    private _firstColumnIdRendered;
    private _filtersMetadata;
    private _columnFilters;
    private _dataView;
    private _grid;
    private _onSearchChange;
    private httpCancelRequests$;
    onFilterChanged: Subject<CurrentFilter[]>;
    onFilterCleared: Subject<boolean>;
    constructor(filterFactory: FilterFactory, sharedService: SharedService);
    /** Getter of the SlickGrid Event Handler */
    readonly eventHandler: SlickEventHandler;
    /** Getter to know if the filter was already rendered or if it was its first time render */
    readonly isFilterFirstRender: boolean;
    /** Getter of the SlickGrid Event Handler */
    readonly onSearchChange: SlickEvent;
    /** Getter for the Grid Options pulled through the Grid Object */
    private readonly _gridOptions;
    /** Getter for the Column Definitions pulled through the Grid Object */
    private readonly _columnDefinitions;
    init(grid: any): void;
    dispose(): void;
    /**
     * Dispose of the filters, since it's a singleton, we don't want to affect other grids with same columns
     */
    disposeColumnFilters(): void;
    /**
     * Bind a backend filter hook to the grid
     * @param grid SlickGrid Grid object
     */
    bindBackendOnFilter(grid: any, dataView: any): void;
    /**
     * Bind a local filter hook to the grid
     * @param grid SlickGrid Grid object
     * @param dataView
     */
    bindLocalOnFilter(grid: any, dataView: any): void;
    clearFilterByColumnId(event: Event, columnId: number | string): void;
    /** Clear the search filters (below the column titles) */
    clearFilters(triggerChange?: boolean): void;
    customLocalFilter(item: any, args: any): boolean;
    getColumnFilters(): ColumnFilters;
    getFiltersMetadata(): any[];
    getCurrentLocalFilters(): CurrentFilter[];
    /**
     * A simple function that is binded to the subscriber and emit a change when the filter is called.
     * Other services, like Pagination, can then subscribe to it.
     * @param caller
     */
    emitFilterChanged(caller: EmitterType): void;
    onBackendFilterChange(event: KeyboardEvent, args: any): Promise<void>;
    /**
     * When user passes an array of preset filters, we need to pre-populate each column filter searchTerm(s)
     * The process is to loop through the preset filters array, find the associated column from columnDefinitions and fill in the filter object searchTerm(s)
     * This is basically the same as if we would manually add searchTerm(s) to a column filter object in the column definition, but we do it programmatically.
     * At the end of the day, when creating the Filter (DOM Element), it will use these searchTerm(s) so we can take advantage of that without recoding each Filter type (DOM element)
     */
    populateColumnFilterSearchTermPresets(filters: CurrentFilter[]): Column[];
    /**
     * Set the sort icons in the UI (ONLY the icons, it does not do any sorting)
     * The column sort icons are not necessarily inter-connected to the sorting functionality itself,
     * you can change the sorting icons separately by passing an array of columnId/sortAsc and that will change ONLY the icons
     * @param sortColumns
     */
    setSortColumnIcons(sortColumns: {
        columnId: string;
        sortAsc: boolean;
    }[]): void;
    /**
     * Update Filters dynamically just by providing an array of filter(s).
     * You can also choose emit (default) a Filter Changed event that will be picked by the Grid State Service.
     *
     * Also for backend service only, you can choose to trigger a backend query (default) or not if you wish to do it later,
     * this could be useful when using updateFilters & updateSorting and you wish to only send the backend query once.
     * @param filters array
     * @param triggerEvent defaults to True, do we want to emit a filter changed event?
     * @param triggerBackendQuery defaults to True, which will query the backend.
     */
    updateFilters(filters: CurrentFilter[], emitChangedEvent?: boolean, triggerBackendQuery?: boolean): void;
    /** Add all created filters (from their template) to the header row section area */
    private addFilterTemplateToHeaderRow;
    /**
     * Callback method that is called and executed by the individual Filter (DOM element),
     * for example when user type in a word to search (which uses InputFilter), this Filter will execute the callback from a keyup event.
     */
    private callbackSearchEvent;
    private updateColumnFilters;
}
